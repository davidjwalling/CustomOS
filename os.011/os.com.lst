     1                                  ;=======================================================================================================================
     2                                  ;
     3                                  ;       File:           os.asm
     4                                  ;
     5                                  ;       Project:        os.011
     6                                  ;
     7                                  ;       Description:    In this sample program, logic is added to allocate and free memory blocks at the kernel level.
     8                                  ;
     9                                  ;       Revised:        2 September 2019
    10                                  ;
    11                                  ;       Assembly:       nasm os.asm -f bin -o os.dat     -l os.dat.lst     -DBUILDBOOT
    12                                  ;                       nasm os.asm -f bin -o os.dsk     -l os.dsk.lst     -DBUILDDISK
    13                                  ;                       nasm os.asm -f bin -o os.com     -l os.com.lst     -DBUILDCOM
    14                                  ;                       nasm os.asm -f bin -o osprep.com -l osprep.com.lst -DBUILDPREP
    15                                  ;
    16                                  ;       Assembler:      Netwide Assembler (NASM) 2.14.02, 26 Dec 2018
    17                                  ;
    18                                  ;       Notice:         Copyright (C) 2010-2019 David J. Walling
    19                                  ;
    20                                  ;=======================================================================================================================
    21                                  ;-----------------------------------------------------------------------------------------------------------------------
    22                                  ;
    23                                  ;       Assembly Directives
    24                                  ;
    25                                  ;       Use one of the following as an assembly directive (-D) with NASM.
    26                                  ;
    27                                  ;       BUILDBOOT       Creates os.dat, a 512-byte boot sector as a standalone file.
    28                                  ;       BUILDDISK       Creates os.dsk, a 1.44MB (3.5") floppy disk image file.
    29                                  ;       BUILDCOM        Creates os.com, the OS loader and kernel as a standalone DOS program.
    30                                  ;       BUILDPREP       Creates osprep.com, a DOS program that prepares a floppy disk to boot the OS.
    31                                  ;
    32                                  ;-----------------------------------------------------------------------------------------------------------------------
    33                                  %ifdef BUILDDISK                                                                ;if we are building a disk image ...
    34                                  %define BUILDBOOT                                                               ;... also build the boot sector
    35                                  %define BUILDCOM                                                                ;... and the OS kernel
    36                                  %endif
    37                                  %ifdef BUILDPREP                                                                ;if creating the disk prep program ...
    38                                  %define BUILDBOOT                                                               ;... also build the boot sector
    39                                  %endif
    40                                  ;-----------------------------------------------------------------------------------------------------------------------
    41                                  ;
    42                                  ;       Conventions
    43                                  ;
    44                                  ;       Alignment:      In this document, columns are numbered beginning with 1. Logical tabs are set after every
    45                                  ;                       eight columns. Tabs are simulated using SPACE characters. Comments that span an entire line
    46                                  ;                       have a semicolon in line 1 and text begins in column 9. Assembly instructions (mnemonics)
    47                                  ;                       begin in column 25. Assembly operands begin in column 33. Inline comments begin in column 81.
    48                                  ;                       Lines should not extend beyond column 120.
    49                                  ;
    50                                  ;       Arguments:      Arguments are passed as registers and generally follow this order: EAX, ECX, EDX, EBX. ECX
    51                                  ;                       may be used as the sole parameter if a test for zero is required. EBX and EBP may be used as
    52                                  ;                       parameters if the routine is considered a "method" of an "object". In this case, EBX or EBP
    53                                  ;                       will address the object storage. If the routine is a general-purpose string or byte-array
    54                                  ;                       manipulator, ESI and EDI may be used as parameters to address input and/or ouput buffers.
    55                                  ;
    56                                  ;       Code Order:     Routines should appear in the order of their first likely use. Negative relative call or jump
    57                                  ;                       addresses usually, therefore, indicate reuse.
    58                                  ;
    59                                  ;       Comments:       A comment that spans the entire line begins with a semicolon in column 1. A comment that
    60                                  ;                       accompanies code on a line begins with a semicolon in column 81. Register names in comments
    61                                  ;                       are in upper case (EAX, EDI). Hexadecimal values in comments are in lower case (01fh, 0dah).
    62                                  ;                       Routines are preceded with a comment box that includes the routine name, description, and
    63                                  ;                       register contents on entry and exit, if applicable.
    64                                  ;
    65                                  ;       Constants:      Symbolic constants (equates) are named in all-caps beginning with 'E' (EDATAPORT). Constant
    66                                  ;                       stored values are named in camel case, starting with 'c' (cbMaxLines). The 2nd letter of the
    67                                  ;                       constant label indicates the storage type.
    68                                  ;
    69                                  ;                       cq......        constant quad-word (dq)
    70                                  ;                       cd......        constant double-word (dd)
    71                                  ;                       cw......        constant word (dw)
    72                                  ;                       cb......        constant byte (db)
    73                                  ;                       cz......        constant ASCIIZ (null-terminated) string
    74                                  ;                       cs......        constant non-terminated string (sequence of characters)
    75                                  ;
    76                                  ;       Instructions:   32-bit instructions are generally favored. 8-bit instructions and data are preferred for
    77                                  ;                       flags and status fields, etc. 16-bit instructions are avoided wherever possible to limit
    78                                  ;                       the generation of prefix bytes.
    79                                  ;
    80                                  ;       Labels:         Labels within a routine are numeric and begin with a period (.10, .20). Labels within a
    81                                  ;                       routine begin at ".10" and increment by 10.
    82                                  ;
    83                                  ;       Literals:       Literal values defined by external standards should be defined as symbolic constants
    84                                  ;                       (equates). Hexadecimal literals in code are in upper case with a leading '0' and trailing
    85                                  ;                       'h' (01Fh). Binary literal values in source code are encoded with a final 'b' (1010b).
    86                                  ;                       Decimal literal values in source code are strictly numerals (2048). Octal literal values
    87                                  ;                       are avoided. String literals are enclosed in double quotes, e.g. "Loading OS". Single
    88                                  ;                       character literals are enclosed in single quotes, e.g. 'A'.
    89                                  ;
    90                                  ;       Macros:         Macro names are in camel case, beginning with a lower-case letter (getDateString). Macro
    91                                  ;                       names describe an action and begin with a verb.
    92                                  ;
    93                                  ;       Memory Use:     Operating system memory allocation is avoided. Buffers are kept to as small a size as
    94                                  ;                       practicable. Data and code intermingling is avoided.
    95                                  ;
    96                                  ;       Registers:      Register names in comments are in upper case (EAX, EDX). Register names in source code are
    97                                  ;                       in lower case (eax, edx).
    98                                  ;
    99                                  ;       Return Values:  Routines return result values in EAX or ECX or both. Routines should indicate failure by
   100                                  ;                       setting the carry flag to 1. Routines may prefer the use of ECX as a return value if the
   101                                  ;                       value is to be tested for null upon return (using the jecxz instruction).
   102                                  ;
   103                                  ;       Routines:       Routine names are in mixed case and capitalized (GetYear, ReadRealTimeClock). Routine names
   104                                  ;                       begin with a verb (Get, Read, Load). Routines should have a single entry address and a single
   105                                  ;                       exit instruction (ret, iretd, etc.). Routines that serve as wrappers for library functions
   106                                  ;                       carry the same name as the library function but begin with a leading underscore (_) character.
   107                                  ;
   108                                  ;       Structures:     Structure names are in all-caps (DATETIME). Structure names describe a "thing" and so do NOT
   109                                  ;                       begin with a verb.
   110                                  ;
   111                                  ;       Usage:          Registers EBX, ECX, EBP, SS, CS, DS and ES are preserved by routines. Registers ESI and EDI
   112                                  ;                       are preserved unless they are input parameters. Registers EAX and ECX are preferred for
   113                                  ;                       returning response/result values. Registers EBX and EBP are preferred for context (structure)
   114                                  ;                       address parameters. Registers EAX, ECX, EDX and EBX are preferred for integral parameters.
   115                                  ;
   116                                  ;       Variables:      Variables are named in camel case, starting with 'w'. The 2nd letter of the variable label
   117                                  ;                       indicates the storage type.
   118                                  ;
   119                                  ;                       wq......        variable quad-word (resq)
   120                                  ;                       wd......        variable double-word (resd)
   121                                  ;                       ww......        variable word (resw)
   122                                  ;                       wb......        variable byte (resb)
   123                                  ;                       ws......        writable structure
   124                                  ;
   125                                  ;-----------------------------------------------------------------------------------------------------------------------
   126                                  ;=======================================================================================================================
   127                                  ;
   128                                  ;       Equates
   129                                  ;
   130                                  ;       The equate (equ) statement defines a symbolic name for a fixed value so that such a value can be defined and
   131                                  ;       verified once and then used throughout the code. Using symbolic names simplifies searching for where logical
   132                                  ;       values are used. Equate names are in all-caps and begin with the letter 'E'. Equates are grouped into related
   133                                  ;       sets. Equates in this sample program are defined in the following groupings:
   134                                  ;
   135                                  ;       Hardware-Defined Values
   136                                  ;
   137                                  ;       ECRT...         6845 Cathode Ray Tube (CRT) Controller values
   138                                  ;       EFDC...         NEC 765 Floppy Disk Controller (FDC) values
   139                                  ;       EKEYB...        8042 or "PS/2 Controller" (Keyboard Controller) values
   140                                  ;       EPIC...         8259 Programmable Interrupt Controller (PIC) values
   141                                  ;       EPIT...         8253 Programmable Interval Timer (PIT) values
   142                                  ;       EX86...         Intel x86 CPU architecture values
   143                                  ;
   144                                  ;       Firmware-Defined Values
   145                                  ;
   146                                  ;       EBIOS...        Basic Input/Output System (BIOS) values
   147                                  ;
   148                                  ;       Standards-Based Values
   149                                  ;
   150                                  ;       EASCII...       American Standard Code for Information Interchange (ASCII) values
   151                                  ;
   152                                  ;       Operating System Values
   153                                  ;
   154                                  ;       EBOOT...        Boot sector and loader values
   155                                  ;       ECON...         Console values (dimensions and attributes)
   156                                  ;       EGDT...         Global Descriptor Table (GDT) selector values
   157                                  ;       EKEYF...        Keyboard status flags
   158                                  ;       EKRN...         Kernel values (fixed locations and sizes)
   159                                  ;       ELDT...         Local Descriptor Table (LDT) selector values
   160                                  ;       EMEM...         Memory Management values
   161                                  ;       EMSG...         Message identifiers
   162                                  ;
   163                                  ;=======================================================================================================================
   164                                  ;-----------------------------------------------------------------------------------------------------------------------
   165                                  ;
   166                                  ;       Hardware-Defined Values
   167                                  ;
   168                                  ;-----------------------------------------------------------------------------------------------------------------------
   169                                  ;-----------------------------------------------------------------------------------------------------------------------
   170                                  ;
   171                                  ;       6845 Cathode Ray Tube (CRT) Controller                                  ECRT...
   172                                  ;
   173                                  ;       The Motorola 6845 CRT Controller (CRTC) is a programmable controller
   174                                  ;       for CGA, EGA, VGA and compatible video modes.
   175                                  ;
   176                                  ;-----------------------------------------------------------------------------------------------------------------------
   177                                  ECRTPORTHI              equ     003h                                            ;controller port hi
   178                                  ECRTPORTLO              equ     0D4h                                            ;controller port lo
   179                                  ECRTCURLOCHI            equ     00Eh                                            ;cursor loc reg hi
   180                                  ECRTCURLOCLO            equ     00Fh                                            ;cursor loc reg lo
   181                                  ;-----------------------------------------------------------------------------------------------------------------------
   182                                  ;
   183                                  ;       NEC 765 Floppy Disk Controller (FDC)                                    EFDC...
   184                                  ;
   185                                  ;       The NEC 765 FDC is a programmable controller for floppy disk drives.
   186                                  ;
   187                                  ;-----------------------------------------------------------------------------------------------------------------------
   188                                  EFDCPORTHI              equ     003h                                            ;controller port hi
   189                                  EFDCPORTLOOUT           equ     0F2h                                            ;digital output register lo
   190                                  EFDCPORTLOSTAT          equ     0F4h                                            ;main status register lo
   191                                  EFDCSTATBUSY            equ     010h                                            ;main status is busy
   192                                  EFDCMOTOROFF            equ     00Ch                                            ;motor off / enable / DMA
   193                                  ;-----------------------------------------------------------------------------------------------------------------------
   194                                  ;
   195                                  ;       8042 Keyboard Controller                                                EKEYB...
   196                                  ;
   197                                  ;       The 8042 Keyboard Controller (8042) is a programmable controller that accepts input signals from the keyboard
   198                                  ;       device. It also signals a hardware interrupt to the CPU when the low-order bit of I/O port 64h is set to zero.
   199                                  ;
   200                                  ;-----------------------------------------------------------------------------------------------------------------------
   201                                  EKEYBPORTDATA           equ     060h                                            ;data port
   202                                  EKEYBPORTSTAT           equ     064h                                            ;status port
   203                                  EKEYBCMDRESET           equ     0FEh                                            ;reset bit 0 to restart system
   204                                  EKEYBBITOUT             equ     001h                                            ;output buffer status bit
   205                                  EKEYBBITIN              equ     002h                                            ;input buffer status bit
   206                                  EKEYBCMDLAMPS           equ     0EDh                                            ;set/reset lamps command
   207                                  EKEYBWAITLOOP           equ     010000h                                         ;wait loop
   208                                                                                                                  ;---------------------------------------
   209                                                                                                                  ;       Keyboard Scan Codes
   210                                                                                                                  ;---------------------------------------
   211                                  EKEYBBACKSPACE          equ     00Eh                                            ;backspace down
   212                                  EKEYBTABDOWN            equ     00Fh                                            ;tab down
   213                                  EKEYBENTERDOWN          equ     01Ch                                            ;enter down
   214                                  EKEYBCTRLLDOWN          equ     01Dh                                            ;control down
   215                                  EKEYBSHIFTLDOWN         equ     02Ah                                            ;left shift down
   216                                  EKEYBSHIFTRDOWN         equ     036h                                            ;right shift down
   217                                  EKEYBALTLDOWN           equ     038h                                            ;alt down
   218                                  EKEYBCAPSDOWN           equ     03Ah                                            ;caps-lock down
   219                                  EKEYBNUMDOWN            equ     045h                                            ;num-lock down
   220                                  EKEYBSCROLLDOWN         equ     046h                                            ;scroll-lock down
   221                                  EKEYBPAD7DOWN           equ     047h                                            ;keypad-7 down
   222                                  EKEYBPADINSERTDOWN      equ     052h                                            ;keypad-insert down
   223                                  EKEYBPADDELETEDOWN      equ     053h                                            ;keypad-delete down
   224                                  EKEYBWINLDOWN           equ     05Bh                                            ;left windows (R) down
   225                                  EKEYBWINRDOWN           equ     05Ch                                            ;right windows (R) down
   226                                  EKEYBUPARROWDOWN        equ     068h                                            ;up-arrow down (e0 48)
   227                                  EKEYBLEFTARROWDOWN      equ     06Bh                                            ;left-arrow down (e0 4b)
   228                                  EKEYBRIGHTARROWDOWN     equ     06Dh                                            ;right-arrow down (e0 4d)
   229                                  EKEYBDOWNARROWDOWN      equ     070h                                            ;down-arrow down (e0 50)
   230                                  EKEYBINSERTDOWN         equ     072h                                            ;insert down (e0 52)
   231                                  EKEYBDELETEDOWN         equ     073h                                            ;delete down (e0 53)
   232                                  EKEYBPADSLASHDOWN       equ     075h                                            ;keypad slash down
   233                                  EKEYBALTRDOWN           equ     078h                                            ;right-alt down
   234                                  EKEYBPADENTERDOWN       equ     07Ch                                            ;keypad-enter down
   235                                  EKEYBCTRLRDOWN          equ     07Dh                                            ;right-control key down
   236                                  EKEYBMAKECODEMASK       equ     07Fh                                            ;make code mask
   237                                  EKEYBUP                 equ     080h                                            ;up
   238                                  EKEYBCTRLLUP            equ     09Dh                                            ;control key up
   239                                  EKEYBSHIFTLUP           equ     0AAh                                            ;left shift key up
   240                                  EKEYBSHIFTRUP           equ     0B6h                                            ;right shift key up
   241                                  EKEYBPADASTERISKUP      equ     0B7h                                            ;keypad asterisk up
   242                                  EKEYBALTLUP             equ     0B8h                                            ;left alt key up
   243                                  EKEYBWINLUP             equ     0DBh                                            ;left windows (R) up
   244                                  EKEYBWINRUP             equ     0DCh                                            ;right windows (R) up
   245                                  EKEYBCODEEXT0           equ     0E0h                                            ;extended scan code 0
   246                                  EKEYBCODEEXT1           equ     0E1h                                            ;extended scan code 1
   247                                  EKEYBALTRUP             equ     0F8h                                            ;right-alt up
   248                                  EKEYBCTRLRUP            equ     0FDh                                            ;left-control up
   249                                  ;-----------------------------------------------------------------------------------------------------------------------
   250                                  ;
   251                                  ;       8259 Peripheral Interrupt Controller                                    EPIC...
   252                                  ;
   253                                  ;       The 8259 Peripheral Interrupt Controller (PIC) is a programmable controller that accepts interrupt signals from
   254                                  ;       external devices and signals a hardware interrupt to the CPU.
   255                                  ;
   256                                  ;-----------------------------------------------------------------------------------------------------------------------
   257                                  EPICPORTPRI             equ     020h                                            ;primary control port 0
   258                                  EPICPORTPRI1            equ     021h                                            ;primary control port 1
   259                                  EPICPORTSEC             equ     0A0h                                            ;secondary control port 0
   260                                  EPICPORTSEC1            equ     0A1h                                            ;secondary control port 1
   261                                  EPICEOI                 equ     020h                                            ;non-specific EOI code
   262                                  ;-----------------------------------------------------------------------------------------------------------------------
   263                                  ;
   264                                  ;       8253 Programmable Interval Timer                                        EPIT...
   265                                  ;
   266                                  ;       The Intel 8253 Programmable Interval Timer (PIT) is a chip that produces a hardware interrupt (IRQ0)
   267                                  ;       approximately 18.2 times per second.
   268                                  ;
   269                                  ;-----------------------------------------------------------------------------------------------------------------------
   270                                  EPITDAYTICKS            equ     01800B0h                                        ;ticks per day
   271                                  ;-----------------------------------------------------------------------------------------------------------------------
   272                                  ;
   273                                  ;       x86 CPU Architecture                                                    ;EX86...
   274                                  ;
   275                                  ;-----------------------------------------------------------------------------------------------------------------------
   276                                  EX86DESCLEN             equ     8                                               ;size of a protected mode descriptor
   277                                  ;-----------------------------------------------------------------------------------------------------------------------
   278                                  ;
   279                                  ;       x86 Descriptor Access Codes                                             EX86ACC...
   280                                  ;
   281                                  ;       The x86 architecture supports the classification of memory areas or segments. Segment attributes are defined by
   282                                  ;       structures known as descriptors. Within a descriptor are access type codes that define the type of the segment.
   283                                  ;
   284                                  ;       0.......        Segment is not present in memory (triggers int 11)
   285                                  ;       1.......        Segment is present in memory
   286                                  ;       .LL.....        Segment is of privilege level LL (0,1,2,3)
   287                                  ;       ...0....        Segment is a system segment
   288                                  ;       ...00010                Local Descriptor Table
   289                                  ;       ...00101                Task Gate
   290                                  ;       ...010B1                Task State Segment (B:0=Available,1=Busy)
   291                                  ;       ...01100                Call Gate (386)
   292                                  ;       ...01110                Interrupt Gate (386)
   293                                  ;       ...01111                Trap Gate (386)
   294                                  ;       ...1...A        Segment is a code or data (A:1=Accesssed)
   295                                  ;       ...10DW.                Data (D:1=Expand Down,W:1=Writable)
   296                                  ;       ...11CR.                Code (C:1=Conforming,R:1=Readable)
   297                                  ;
   298                                  ;-----------------------------------------------------------------------------------------------------------------------
   299                                  EX86ACCINT              equ     10001110b                                       ;interrupt gate
   300                                  EX86ACCTRAP             equ     10001111b                                       ;trap gate
   301                                  ;-----------------------------------------------------------------------------------------------------------------------
   302                                  ;
   303                                  ;       Firmware-Defined Values
   304                                  ;
   305                                  ;-----------------------------------------------------------------------------------------------------------------------
   306                                  ;-----------------------------------------------------------------------------------------------------------------------
   307                                  ;
   308                                  ;       BIOS Interrupts and Functions                                           EBIOS...
   309                                  ;
   310                                  ;       Basic Input/Output System (BIOS) functions are grouped and accessed by issuing an interrupt call. Each
   311                                  ;       BIOS interrupt supports several functions. The function code is typically passed in the AH register.
   312                                  ;
   313                                  ;-----------------------------------------------------------------------------------------------------------------------
   314                                  EBIOSINTVIDEO           equ     010h                                            ;video services interrupt
   315                                  EBIOSFNSETVMODE         equ     000h                                            ;video set mode function
   316                                  EBIOSMODETEXT80         equ     003h                                            ;video mode 80x25 text
   317                                  EBIOSFNTTYOUTPUT        equ     00Eh                                            ;video TTY output function
   318                                  EBIOSINTDISKETTE        equ     013h                                            ;diskette services interrupt
   319                                  EBIOSFNREADSECTOR       equ     002h                                            ;diskette read sector function
   320                                  EBIOSFNWRITESECTOR      equ     003h                                            ;diskette write sector function
   321                                  EBIOSINTMISC            equ     015h                                            ;miscellaneous services interrupt
   322                                  EBIOSFNINITPROTMODE     equ     089h                                            ;initialize protected mode fn
   323                                  EBIOSINTKEYBOARD        equ     016h                                            ;keyboard services interrupt
   324                                  EBIOSFNKEYSTATUS        equ     001h                                            ;keyboard status function
   325                                  ;-----------------------------------------------------------------------------------------------------------------------
   326                                  ;
   327                                  ;       Standards-Based Values
   328                                  ;
   329                                  ;-----------------------------------------------------------------------------------------------------------------------
   330                                  ;-----------------------------------------------------------------------------------------------------------------------
   331                                  ;
   332                                  ;       ASCII                                                                   EASCII...
   333                                  ;
   334                                  ;-----------------------------------------------------------------------------------------------------------------------
   335                                  EASCIIRETURN            equ     00Dh                                            ;carriage return
   336                                  EASCIIESCAPE            equ     01Bh                                            ;escape
   337                                  EASCIISPACE             equ     020h                                            ;space
   338                                  EASCIISLASH             equ     02Fh                                            ;slash
   339                                  EASCIIZERO              equ     030h                                            ;zero
   340                                  EASCIININE              equ     039h                                            ;nine
   341                                  EASCIIUPPERA            equ     041h                                            ;'A'
   342                                  EASCIIUPPERZ            equ     05Ah                                            ;'Z'
   343                                  EASCIICARET             equ     05Eh                                            ;'^'
   344                                  EASCIIUNDERSCORE        equ     05Fh                                            ;'_'
   345                                  EASCIILOWERA            equ     061h                                            ;'a'
   346                                  EASCIILOWERZ            equ     07Ah                                            ;'z'
   347                                  EASCIITILDE             equ     07Eh                                            ;'~'
   348                                  EASCIIDELETE            equ     07Fh                                            ;del
   349                                  EASCIIBORDSGLVERT       equ     0B3h                                            ;vertical single border
   350                                  EASCIIBORDSGLUPRRGT     equ     0BFh                                            ;upper-right single border
   351                                  EASCIIBORDSGLLWRLFT     equ     0C0h                                            ;lower-left single border
   352                                  EASCIIBORDSGLHORZ       equ     0C4h                                            ;horizontal single border
   353                                  EASCIIBORDSGLLWRRGT     equ     0D9h                                            ;lower-right single border
   354                                  EASCIIBORDSGLUPRLFT     equ     0DAh                                            ;upper-left single border
   355                                  EASCIICASEMASK          equ     11011111b                                       ;case mask
   356                                  ;-----------------------------------------------------------------------------------------------------------------------
   357                                  ;
   358                                  ;       Operating System Values
   359                                  ;
   360                                  ;-----------------------------------------------------------------------------------------------------------------------
   361                                  ;-----------------------------------------------------------------------------------------------------------------------
   362                                  ;
   363                                  ;       Boot Sector and Loader Constants                                        EBOOT...
   364                                  ;
   365                                  ;       Equates in this section support the boot sector and the 16-bit operating system loader, which will be
   366                                  ;       responsible for placing the CPU into protected mode and calling the initial operating system task.
   367                                  ;
   368                                  ;-----------------------------------------------------------------------------------------------------------------------
   369                                  EBOOTSTACKTOP           equ     0100h                                           ;boot sector stack top relative to DS
   370                                  EBOOTSECTORBYTES        equ     512                                             ;bytes per sector
   371                                  EBOOTDIRENTRIES         equ     224                                             ;directory entries (1.44MB 3.5" FD)
   372                                  EBOOTDISKSECTORS        equ     2880                                            ;sectors per disk (1.44MB 3.5" FD)
   373                                  EBOOTDISKBYTES          equ     (EBOOTSECTORBYTES*EBOOTDISKSECTORS)             ;bytes per disk
   374                                  EBOOTFATBASE            equ     (EBOOTSTACKTOP+EBOOTSECTORBYTES)                ;offset of FAT I/O buffer rel to DS
   375                                  EBOOTMAXTRIES           equ     5                                               ;max read retries
   376                                  ;-----------------------------------------------------------------------------------------------------------------------
   377                                  ;       Console Constants                                                       ECON...
   378                                  ;-----------------------------------------------------------------------------------------------------------------------
   379                                  ECONCOLS                equ     80                                              ;columns per row
   380                                  ECONROWS                equ     24                                              ;console rows
   381                                  ECONOIAROW              equ     24                                              ;operator information area row
   382                                  ECONCOLBYTES            equ     2                                               ;bytes per column
   383                                  ECONROWBYTES            equ     (ECONCOLS*ECONCOLBYTES)                         ;bytes per row
   384                                  ECONROWDWORDS           equ     (ECONROWBYTES/4)                                ;double-words per row
   385                                  ECONCLEARDWORD          equ     007200720h                                      ;attribute and ASCII space
   386                                  ECONOIADWORD            equ     070207020h                                      ;attribute and ASCII space
   387                                  ;-----------------------------------------------------------------------------------------------------------------------
   388                                  ;       Global Descriptor Table (GDT) Selectors                                 EGDT...
   389                                  ;-----------------------------------------------------------------------------------------------------------------------
   390                                  EGDTOSDATA              equ     018h                                            ;kernel data selector
   391                                  EGDTCGA                 equ     020h                                            ;cga video selector
   392                                  EGDTLOADERCODE          equ     030h                                            ;loader code selector
   393                                  EGDTOSCODE              equ     048h                                            ;os kernel code selector
   394                                  EGDTLOADERLDT           equ     050h                                            ;loader local descriptor table selector
   395                                  EGDTLOADERTSS           equ     058h                                            ;loader task state segment selector
   396                                  EGDTCONSOLELDT          equ     060h                                            ;console local descriptor table selector
   397                                  EGDTCONSOLETSS          equ     068h                                            ;console task state segment selector
   398                                  ;-----------------------------------------------------------------------------------------------------------------------
   399                                  ;       Keyboard Flags                                                          EKEYF...
   400                                  ;-----------------------------------------------------------------------------------------------------------------------
   401                                  EKEYFCTRLLEFT           equ     00000001b                                       ;left control
   402                                  EKEYFSHIFTLEFT          equ     00000010b                                       ;left shift
   403                                  EKEYFALTLEFT            equ     00000100b                                       ;left alt
   404                                  EKEYFCTRLRIGHT          equ     00001000b                                       ;right control
   405                                  EKEYFSHIFTRIGHT         equ     00010000b                                       ;right shift
   406                                  EKEYFSHIFT              equ     00010010b                                       ;left or right shift
   407                                  EKEYFALTRIGHT           equ     00100000b                                       ;right alt
   408                                  EKEYFWINLEFT            equ     01000000b                                       ;left windows(R)
   409                                  EKEYFWINRIGHT           equ     10000000b                                       ;right windows (R)
   410                                  EKEYFLOCKSCROLL         equ     00000001b                                       ;scroll-lock flag
   411                                  EKEYFLOCKNUM            equ     00000010b                                       ;num-lock flag
   412                                  EKEYFLOCKCAPS           equ     00000100b                                       ;cap-lock flag
   413                                  EKEYFLOCKINSERT         equ     00001000b                                       ;insert-lock flag
   414                                  EKEYFTIMEOUT            equ     10000000b                                       ;controller timeout
   415                                  ;-----------------------------------------------------------------------------------------------------------------------
   416                                  ;       Kernel Constants                                                        EKRN...
   417                                  ;-----------------------------------------------------------------------------------------------------------------------
   418                                  EKRNCODEBASE            equ     01000h                                          ;kernel base address (0000:1000)
   419                                  EKRNCODESEG             equ     (EKRNCODEBASE >> 4)                             ;kernel code segment (0100:0000)
   420                                  EKRNCODELEN             equ     05000h                                          ;kernel code size (1000h to 6000h)
   421                                  EKRNCODESRCADR          equ     0500h                                           ;kernel code offset to loader DS:
   422                                  ;-----------------------------------------------------------------------------------------------------------------------
   423                                  ;       Local Descriptor Table (LDT) Selectors                                  ELDT...
   424                                  ;-----------------------------------------------------------------------------------------------------------------------
   425                                  ELDTMQ                  equ     02Ch                                            ;console task message queue
   426                                  ;-----------------------------------------------------------------------------------------------------------------------
   427                                  ;       Memory Management Constants                                             EMEM...
   428                                  ;-----------------------------------------------------------------------------------------------------------------------
   429                                  EMEMMINSIZE             equ     256                                             ;minimum heap block size (incl. hdr)
   430                                  EMEMFREECODE            equ     "FREE"                                          ;free memory signature
   431                                  EMEMUSERCODE            equ     "USER"                                          ;user memory signature
   432                                  EMEMWIPEBYTE            equ     000h                                            ;byte value to wipe storage
   433                                  ;-----------------------------------------------------------------------------------------------------------------------
   434                                  ;       Message Identifiers                                                     EMSG...
   435                                  ;-----------------------------------------------------------------------------------------------------------------------
   436                                  EMSGKEYDOWN             equ     041000000h                                      ;key-down
   437                                  EMSGKEYUP               equ     041010000h                                      ;key-up
   438                                  EMSGKEYCHAR             equ     041020000h                                      ;character
   439                                  ;=======================================================================================================================
   440                                  ;
   441                                  ;       Structures
   442                                  ;
   443                                  ;=======================================================================================================================
   444                                  ;-----------------------------------------------------------------------------------------------------------------------
   445                                  ;
   446                                  ;       KEYBDATA
   447                                  ;
   448                                  ;       The KEYBDATA structure holds variables used to handle keyboard events.
   449                                  ;
   450                                  ;-----------------------------------------------------------------------------------------------------------------------
   451                                  struc                   KEYBDATA
   452 00000000 <res 00000001>          .scan0                  resb    1                                               ;1st scan code
   453 00000001 <res 00000001>          .scan1                  resb    1                                               ;2nd scan code
   454 00000002 <res 00000001>          .scan2                  resb    1                                               ;3rd scan code
   455 00000003 <res 00000001>          .scan3                  resb    1                                               ;4th scan code
   456 00000004 <res 00000001>          .scan                   resb    1                                               ;active scan code
   457 00000005 <res 00000001>          .char                   resb    1                                               ;ASCII character
   458 00000006 <res 00000001>          .last                   resb    1                                               ;previous scan code
   459 00000007 <res 00000001>          .shift                  resb    1                                               ;shift flags (shift, ctrl, alt, win)
   460 00000008 <res 00000001>          .lock                   resb    1                                               ;lock flags (caps, num, scroll, insert)
   461 00000009 <res 00000001>          .status                 resb    1                                               ;status (timeout)
   462                                  EKEYBDATAL              equ     ($-.scan0)                                      ;structure length
   463                                  endstruc
   464                                  ;-----------------------------------------------------------------------------------------------------------------------
   465                                  ;
   466                                  ;       MEMBLOCK
   467                                  ;
   468                                  ;       The MEMBLOCK structure defines a memory block.
   469                                  ;
   470                                  ;-----------------------------------------------------------------------------------------------------------------------
   471                                  struc                   MEMBLOCK
   472 00000000 <res 00000004>          .signature              resd    1                                               ;starting signature
   473 00000004 <res 00000004>          .bytes                  resd    1                                               ;block size in bytes
   474 00000008 <res 00000004>          .owner                  resd    1                                               ;owning task
   475 0000000C <res 00000004>          .reserved               resd    1                                               ;reserved
   476 00000010 <res 00000004>          .nextcontig             resd    1                                               ;next contiguous block
   477 00000014 <res 00000004>          .previouscontig         resd    1                                               ;previous contiguous block
   478 00000018 <res 00000004>          .nextblock              resd    1                                               ;next free/task block
   479 0000001C <res 00000004>          .previousblock          resd    1                                               ;previous free/task block
   480                                  EMEMBLOCKLEN            equ     ($-.signature)
   481                                  endstruc
   482                                  ;-----------------------------------------------------------------------------------------------------------------------
   483                                  ;
   484                                  ;       MEMROOT
   485                                  ;
   486                                  ;       The MEMROOT structure defines starting and ending addresses of memory block chains.
   487                                  ;
   488                                  ;-----------------------------------------------------------------------------------------------------------------------
   489                                  struc                   MEMROOT
   490 00000000 <res 00000004>          .firstcontig            resd    1                                               ;first contiguous block
   491 00000004 <res 00000004>          .lastcontig             resd    1                                               ;last contiguous block
   492 00000008 <res 00000004>          .firstfree              resd    1                                               ;first free block
   493 0000000C <res 00000004>          .lastfree               resd    1                                               ;last free block
   494 00000010 <res 00000004>          .firsttask              resd    1                                               ;first task block
   495 00000014 <res 00000004>          .lasttask               resd    1                                               ;last task block
   496                                  EMEMROOTLEN             equ     ($-.firstcontig)
   497                                  endstruc
   498                                  ;-----------------------------------------------------------------------------------------------------------------------
   499                                  ;
   500                                  ;       MQUEUE
   501                                  ;
   502                                  ;       The MQUEUE structure maps memory used for a message queue.
   503                                  ;
   504                                  ;-----------------------------------------------------------------------------------------------------------------------
   505                                  struc                   MQUEUE
   506 00000000 <res 00000004>          MQHead                  resd    1                                               ;000 head ptr
   507 00000004 <res 00000004>          MQTail                  resd    1                                               ;004 tail ptr
   508 00000008 <res 000003F8>          MQData                  resd    254                                             ;message queue
   509                                  endstruc
   510                                  ;-----------------------------------------------------------------------------------------------------------------------
   511                                  ;
   512                                  ;       OSDATA
   513                                  ;
   514                                  ;       The OSDATA structure maps low-memory addresses used by the BIOS and the OS. Areas that may be in use by DOS or
   515                                  ;       other host operating systems that may be running when this OS is launched are avoided.
   516                                  ;
   517                                  ;-----------------------------------------------------------------------------------------------------------------------
   518                                  struc                   OSDATA
   519 00000000 <res 00000400>                                  resb    0400h                                           ;000 real mode interrupt vectors
   520 00000400 <res 00000002>                                  resw    1                                               ;400 COM1 port address
   521 00000402 <res 00000002>                                  resw    1                                               ;402 COM2 port address
   522 00000404 <res 00000002>                                  resw    1                                               ;404 COM3 port address
   523 00000406 <res 00000002>                                  resw    1                                               ;406 COM4 port address
   524 00000408 <res 00000002>                                  resw    1                                               ;408 LPT1 port address
   525 0000040A <res 00000002>                                  resw    1                                               ;40a LPT2 port address
   526 0000040C <res 00000002>                                  resw    1                                               ;40c LPT3 port address
   527 0000040E <res 00000002>                                  resw    1                                               ;40e LPT4 port address
   528 00000410 <res 00000002>                                  resb    2                                               ;410 equipment list flags
   529 00000412 <res 00000001>                                  resb    1                                               ;412 errors in PCjr infrared keybd link
   530 00000413 <res 00000002>                                  resw    1                                               ;413 memory size (kb) INT 12h
   531 00000415 <res 00000001>                                  resb    1                                               ;415 mfr error test scratchpad
   532 00000416 <res 00000001>                                  resb    1                                               ;416 PS/2 BIOS control flags
   533 00000417 <res 00000001>                                  resb    1                                               ;417 keyboard flag byte 0
   534 00000418 <res 00000001>                                  resb    1                                               ;418 keyboard flag byte 1
   535 00000419 <res 00000001>                                  resb    1                                               ;419 alternate keypad entry
   536 0000041A <res 00000002>                                  resw    1                                               ;41a keyboard buffer head offset
   537 0000041C <res 00000002>                                  resw    1                                               ;41c keyboard buffer tail offset
   538 0000041E <res 00000020>                                  resb    32                                              ;41e keyboard buffer
   539 0000043E <res 00000001>          wbFDCStatus             resb    1                                               ;43e drive recalibration status
   540 0000043F <res 00000001>          wbFDCControl            resb    1                                               ;43f FDC motor status/control byte
   541 00000440 <res 00000001>          wbFDCMotor              resb    1                                               ;440 FDC motor timeout byte
   542 00000441 <res 00000001>                                  resb    1                                               ;441 status of last diskette operation
   543 00000442 <res 00000007>                                  resb    7                                               ;442 NEC diskette controller status
   544 00000449 <res 00000001>                                  resb    1                                               ;449 current video mode
   545 0000044A <res 00000002>                                  resw    1                                               ;44a screen columns
   546 0000044C <res 00000002>                                  resw    1                                               ;44c video regen buffer size
   547 0000044E <res 00000002>                                  resw    1                                               ;44e current video page offset
   548 00000450 <res 00000010>                                  resw    8                                               ;450 cursor postions of pages 1-8
   549 00000460 <res 00000001>                                  resb    1                                               ;460 cursor ending scanline
   550 00000461 <res 00000001>                                  resb    1                                               ;461 cursor start scanline
   551 00000462 <res 00000001>                                  resb    1                                               ;462 active display page number
   552 00000463 <res 00000002>                                  resw    1                                               ;463 CRTC base port address
   553 00000465 <res 00000001>                                  resb    1                                               ;465 CRT mode control register value
   554 00000466 <res 00000001>                                  resb    1                                               ;466 CGA current color palette mask
   555 00000467 <res 00000002>                                  resw    1                                               ;467 CS:IP for 286 return from PROT MODE
   556 00000469 <res 00000003>                                  resb    3                                               ;469 vague
   557 0000046C <res 00000004>          wdClockTicks            resd    1                                               ;46c clock ticks
   558 00000470 <res 00000001>          wbClockDays             resb    1                                               ;470 clock days
   559 00000471 <res 00000001>                                  resb    1                                               ;471 bios break flag
   560 00000472 <res 00000002>                                  resw    1                                               ;472 soft reset
   561 00000474 <res 00000001>                                  resb    1                                               ;474 last hard disk operation status
   562 00000475 <res 00000001>                                  resb    1                                               ;475 hard disks attached
   563 00000476 <res 00000001>                                  resb    1                                               ;476 XT fised disk drive control byte
   564 00000477 <res 00000001>                                  resb    1                                               ;477 port offset to current fixed disk adapter
   565 00000478 <res 00000004>                                  resb    4                                               ;478 LPT timeout values
   566 0000047C <res 00000004>                                  resb    4                                               ;47c COM timeout values
   567 00000480 <res 00000002>                                  resw    1                                               ;480 keyboard buffer start offset
   568 00000482 <res 00000002>                                  resw    1                                               ;482 keyboard buffer end offset
   569 00000484 <res 00000001>                                  resb    1                                               ;484 Rows on screen less 1 (EGA+)
   570 00000485 <res 00000001>                                  resb    1                                               ;485 point height of character matrix (EGA+)
   571 00000486 <res 00000001>                                  resb    1                                               ;486 PC Jr initial keybd delay
   572 00000487 <res 00000001>                                  resb    1                                               ;487 EGA+ video mode ops
   573 00000488 <res 00000001>                                  resb    1                                               ;488 EGA feature bit switches
   574 00000489 <res 00000001>                                  resb    1                                               ;489 VGA video display data area
   575 0000048A <res 00000001>                                  resb    1                                               ;48a EGA+ display combination code
   576 0000048B <res 00000001>                                  resb    1                                               ;48b last diskette data rate selected
   577 0000048C <res 00000001>                                  resb    1                                               ;48c hard disk status from controller
   578 0000048D <res 00000001>                                  resb    1                                               ;48d hard disk error from controller
   579 0000048E <res 00000001>                                  resb    1                                               ;48e hard disk interrupt control flag
   580 0000048F <res 00000001>                                  resb    1                                               ;48f combination hard/floppy disk card
   581 00000490 <res 00000004>                                  resb    4                                               ;490 drive 0,1,2,3 media state
   582 00000494 <res 00000001>                                  resb    1                                               ;494 track currently seeked to on drive 0
   583 00000495 <res 00000001>                                  resb    1                                               ;495 track currently seeked to on drive 1
   584 00000496 <res 00000001>                                  resb    1                                               ;496 keyboard mode/type
   585 00000497 <res 00000001>                                  resb    1                                               ;497 keyboard LED flags
   586 00000498 <res 00000004>                                  resd    1                                               ;498 pointer to user wait complete flag
   587 0000049C <res 00000004>                                  resd    1                                               ;49c user wait time-out value in microseconds
   588 000004A0 <res 00000001>                                  resb    1                                               ;4a0 RTC wait function flag
   589 000004A1 <res 00000001>                                  resb    1                                               ;4a1 LANA DMA channel flags
   590 000004A2 <res 00000002>                                  resb    2                                               ;4a2 status of LANA 0,1
   591 000004A4 <res 00000004>                                  resd    1                                               ;4a4 saved hard disk interrupt vector
   592 000004A8 <res 00000004>                                  resd    1                                               ;4a8 BIOS video save/override pointer table addr
   593 000004AC <res 00000008>                                  resb    8                                               ;4ac reserved
   594 000004B4 <res 00000001>                                  resb    1                                               ;4b4 keyboard NMI control flags
   595 000004B5 <res 00000004>                                  resd    1                                               ;4b5 keyboard break pending flags
   596 000004B9 <res 00000001>                                  resb    1                                               ;4b9 Port 60 single byte queue
   597 000004BA <res 00000001>                                  resb    1                                               ;4ba scan code of last key
   598 000004BB <res 00000001>                                  resb    1                                               ;4bb NMI buffer head pointer
   599 000004BC <res 00000001>                                  resb    1                                               ;4bc NMI buffer tail pointer
   600 000004BD <res 00000010>                                  resb    16                                              ;4bd NMI scan code buffer
   601 000004CD <res 00000001>                                  resb    1                                               ;4cd unknown
   602 000004CE <res 00000002>                                  resw    1                                               ;4de day counter
   603 000004D0 <res 00000020>                                  resb    32                                              ;4d0 unknown
   604 000004F0 <res 00000010>                                  resb    16                                              ;4f0 intra-app comm area
   605 00000500 <res 00000001>                                  resb    1                                               ;500 print-screen status byte
   606 00000501 <res 00000003>                                  resb    3                                               ;501 used by BASIC
   607 00000504 <res 00000001>                                  resb    1                                               ;504 DOS single diskette mode
   608 00000505 <res 0000000A>                                  resb    10                                              ;505 POST work area
   609 0000050F <res 00000001>                                  resb    1                                               ;50f BASIC shell flag
   610 00000510 <res 00000002>                                  resw    1                                               ;510 BASIC default DS (DEF SEG)
   611 00000512 <res 00000004>                                  resd    1                                               ;512 BASIC INT 1C interrupt handler
   612 00000516 <res 00000004>                                  resd    1                                               ;516 BASIC INT 23 interrupt handler
   613 0000051A <res 00000004>                                  resd    1                                               ;51a BASIC INT 24 interrupt handler
   614 0000051E <res 00000002>                                  resw    1                                               ;51e unknown
   615 00000520 <res 00000002>                                  resw    1                                               ;520 DOS dynamic storage
   616 00000522 <res 0000000E>                                  resb    14                                              ;522 DOS diskette initialization table (INT 1e)
   617 00000530 <res 00000004>                                  resb    4                                               ;530 MODE command
   618 00000534 <res 000001CC>                                  resb    460                                             ;534 unused
   619 00000700 <res 00000100>                                  resb    256                                             ;700 i/o drivers from io.sys/ibmbio.com
   620                                  ;-----------------------------------------------------------------------------------------------------------------------
   621                                  ;
   622                                  ;       Kernel Variables                                                        @disk: N/A      @mem: 000800
   623                                  ;
   624                                  ;       Kernel variables may be accessed by interrupts or by the initial task (Console).
   625                                  ;
   626                                  ;-----------------------------------------------------------------------------------------------------------------------
   627                                  ECONDATA                equ     ($)
   628                                                                                                                  ;---------------------------------------
   629                                                                                                                  ;  panel handling
   630                                                                                                                  ;---------------------------------------
   631 00000800 <res 00000004>          wdConsoleHandler        resd    1                                               ;handler function
   632 00000804 <res 00000004>          wdConsolePanel          resd    1                                               ;panel definition addr
   633 00000808 <res 00000004>          wdConsoleField          resd    1                                               ;active field definition addr
   634 0000080C <res 00000004>          wdConsoleMemBase        resd    1                                               ;console memory address
   635 00000810 <res 00000050>          wzConsoleInBuffer       resb    80                                              ;command input buffer
   636 00000860 <res 00000050>          wzConsoleToken          resb    80                                              ;token buffer
   637 000008B0 <res 00000050>          wzConsoleOutBuffer      resb    80                                              ;output buffer
   638                                                                                                                  ;---------------------------------------
   639                                                                                                                  ;  memory panel fields
   640                                                                                                                  ;---------------------------------------
   641 00000900 <res 0000004C>          wzConsoleMemBuf0        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   642 0000094C <res 0000004C>          wzConsoleMemBuf1        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   643 00000998 <res 0000004C>          wzConsoleMemBuf2        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   644 000009E4 <res 0000004C>          wzConsoleMemBuf3        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   645 00000A30 <res 0000004C>          wzConsoleMemBuf4        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   646 00000A7C <res 0000004C>          wzConsoleMemBuf5        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   647 00000AC8 <res 0000004C>          wzConsoleMemBuf6        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   648 00000B14 <res 0000004C>          wzConsoleMemBuf7        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   649 00000B60 <res 0000004C>          wzConsoleMemBuf8        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   650 00000BAC <res 0000004C>          wzConsoleMemBuf9        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   651 00000BF8 <res 0000004C>          wzConsoleMemBufA        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   652 00000C44 <res 0000004C>          wzConsoleMemBufB        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   653 00000C90 <res 0000004C>          wzConsoleMemBufC        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   654 00000CDC <res 0000004C>          wzConsoleMemBufD        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   655 00000D28 <res 0000004C>          wzConsoleMemBufE        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   656 00000D74 <res 0000004C>          wzConsoleMemBufF        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   657 00000DC0 <res 0000004C>          wzConsoleMemBuf10       resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   658 00000E0C <res 0000004C>          wzConsoleMemBuf11       resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   659 00000E58 <res 0000004C>          wzConsoleMemBuf12       resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   660 00000EA4 <res 0000004C>          wzConsoleMemBuf13       resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   661                                                                                                                  ;---------------------------------------
   662                                                                                                                  ;  reusable menu option input
   663                                                                                                                  ;---------------------------------------
   664 00000EF0 <res 00000002>          wzFldMenuOptn0          resb    2                                               ;menu option 0  _\0
   665 00000EF2 <res 00000002>          wzFldMenuOptn1          resb    2                                               ;menu option 1
   666 00000EF4 <res 00000002>          wzFldMenuOptn2          resb    2                                               ;menu option 2
   667 00000EF6 <res 00000002>          wzFldMenuOptn3          resb    2                                               ;menu option 3
   668 00000EF8 <res 00000002>          wzFldMenuOptn4          resb    2                                               ;menu option 4
   669 00000EFA <res 00000002>          wzFldMenuOptn5          resb    2                                               ;menu option 5
   670 00000EFC <res 00000002>          wzFldMenuOptn6          resb    2                                               ;menu option 6
   671 00000EFE <res 00000002>          wzFldMenuOptn7          resb    2                                               ;menu option 7
   672 00000F00 <res 00000002>          wzFldMenuOptn8          resb    2                                               ;menu option 8
   673 00000F02 <res 00000002>          wzFldMenuOptn9          resb    2                                               ;menu option 9
   674 00000F04 <res 00000002>          wzFldMenuOptnA          resb    2                                               ;menu option A
   675 00000F06 <res 00000002>          wzFldMenuOptnB          resb    2                                               ;menu option B
   676 00000F08 <res 00000002>          wzFldMenuOptnC          resb    2                                               ;menu option C
   677 00000F0A <res 00000002>          wzFldMenuOptnD          resb    2                                               ;menu option D
   678 00000F0C <res 00000002>          wzFldMenuOptnE          resb    2                                               ;menu option E
   679 00000F0E <res 00000002>          wzFldMenuOptnF          resb    2                                               ;menu option F
   680 00000F10 <res 00000002>          wzFldMenuOptn10         resb    2                                               ;menu option 10
   681 00000F12 <res 00000002>          wzFldMenuOptn11         resb    2                                               ;menu option 11
   682 00000F14 <res 00000002>          wzFldMenuOptn12         resb    2                                               ;menu option 12
   683 00000F16 <res 00000002>          wzFldMenuOptn13         resb    2                                               ;menu option 13
   684                                                                                                                  ;---------------------------------------
   685                                                                                                                  ;  cursor placement
   686                                                                                                                  ;---------------------------------------
   687 00000F18 <res 00000001>          wbConsoleColumn         resb    1                                               ;console column
   688 00000F19 <res 00000001>          wbConsoleRow            resb    1                                               ;console row
   689                                                                                                                  ;---------------------------------------
   690                                                                                                                  ;  set by keyboard interrupt
   691                                                                                                                  ;---------------------------------------
   692 00000F1A <res 0000000A>          wsKeybData              resb    EKEYBDATAL                                      ;keyboard data
   693                                                                                                                  ;---------------------------------------
   694                                                                                                                  ;  memory management
   695                                                                                                                  ;---------------------------------------
   696 00000F24 <res 00000018>          wsConsoleMemRoot        resb    EMEMROOTLEN                                     ;memory root structure
   697                                  ECONDATALEN             equ     ($-ECONDATA)                                    ;size of console data area
   698                                  ;-----------------------------------------------------------------------------------------------------------------------
   699                                  ;
   700                                  ;       End of OS Variables
   701                                  ;
   702                                  ;-----------------------------------------------------------------------------------------------------------------------
   703                                  endstruc
   704                                  ;-----------------------------------------------------------------------------------------------------------------------
   705                                  ;
   706                                  ;       Macros
   707                                  ;
   708                                  ;       These macros are used to assist in defining descriptor tables and interrupt table offsets.
   709                                  ;
   710                                  ;-----------------------------------------------------------------------------------------------------------------------
   711                                  %macro                  mint    1
   712                                  _%1                     equ     ($-$$) / EX86DESCLEN
   713                                                          dq      ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
   714                                  %endmacro
   715                                  %macro                  mtrap   1
   716                                  _%1                     equ     ($-$$) / EX86DESCLEN
   717                                                          dq      ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
   718                                  %endmacro
   719                                  %macro                  menter  1
   720                                  ?%1                     equ     ($-$$)
   721                                  %endmacro
   722                                  %macro                  tsvce   1
   723                                  e%1                     equ     ($-tsvc)/4
   724                                                          dd      %1
   725                                  %endmacro
   726                                  %ifdef BUILDBOOT
   727                                  ;=======================================================================================================================
   728                                  ;
   729                                  ;       Boot Sector                                                             @disk: 000000   @mem: 007c00
   730                                  ;
   731                                  ;       The first sector of the diskette is the boot sector. The BIOS will load the boot sector into memory and pass
   732                                  ;       control to the code at the start of the sector. The boot sector code is responsible for loading the operating
   733                                  ;       system into memory. The boot sector contains a disk parameter table describing the geometry and allocation
   734                                  ;       of the diskette. Following the disk parameter table is code to load the operating system kernel into memory.
   735                                  ;
   736                                  ;       The "cpu" directive limits emitted code to those instructions supported by the most primitive processor
   737                                  ;       we expect to ever execute our code. The "vstart" parameter indicates addressability of symbols so as to
   738                                  ;       emulate the DOS .COM program model. Although the BIOS is expected to load the boot sector at address 7c00,
   739                                  ;       we do not make that assumption. The CPU starts in 16-bit addressing mode. A three-byte jump instruction is
   740                                  ;       immediately followed by the disk parameter table.
   741                                  ;
   742                                  ;=======================================================================================================================
   743                                                          cpu     8086                                            ;assume minimal CPU
   744                                  section                 boot    vstart=0100h                                    ;emulate .COM (CS,DS,ES=PSP) addressing
   745                                                          bits    16                                              ;16-bit code at power-up
   746                                  %ifdef BUILDPREP
   747                                  Boot                    jmp     word Prep                                       ;jump to preparation code
   748                                  %else
   749                                  Boot                    jmp     word Boot.10                                    ;jump over parameter table
   750                                  %endif
   751                                  ;-----------------------------------------------------------------------------------------------------------------------
   752                                  ;
   753                                  ;       Disk Parameter Table
   754                                  ;
   755                                  ;       The disk parameter table informs the BIOS of the floppy disk architecture. Here, we use parameters for the
   756                                  ;       3.5" 1.44MB floppy disk since this format is widely supported by virtual machine hypervisors.
   757                                  ;
   758                                  ;-----------------------------------------------------------------------------------------------------------------------
   759                                                          db      "OS      "                                      ;eight-byte label
   760                                  cwSectorBytes           dw      EBOOTSECTORBYTES                                ;bytes per sector
   761                                  cbClusterSectors        db      1                                               ;sectors per cluster
   762                                  cwReservedSectors       dw      1                                               ;reserved sectors
   763                                  cbFatCount              db      2                                               ;file allocation table copies
   764                                  cwDirEntries            dw      EBOOTDIRENTRIES                                 ;max directory entries
   765                                  cwDiskSectors           dw      EBOOTDISKSECTORS                                ;sectors per disk
   766                                  cbDiskType              db      0F0h                                            ;1.44MB
   767                                  cwFatSectors            dw      9                                               ;sectors per FAT copy
   768                                  cbTrackSectors          equ     $                                               ;sectors per track (as byte)
   769                                  cwTrackSectors          dw      18                                              ;sectors per track (as word)
   770                                  cwDiskSides             dw      2                                               ;sides per disk
   771                                  cwSpecialSectors        dw      0                                               ;special sectors
   772                                  ;
   773                                  ;       BIOS typically loads the boot sector at absolute address 7c00 and sets the stack pointer at 512 bytes past
   774                                  ;       the end of the boot sector. But, since BIOS code varies, we don't make any assumptions as to where our boot
   775                                  ;       sector is loaded. For example, the initial CS:IP could be 0:7c00, 700:c00, 7c0:0, etc. To avoid assumptions,
   776                                  ;       we first normalize CS:IP to get the absolute segment address in BX. The comments below show the effect of this
   777                                  ;       code given several possible starting values for CS:IP.
   778                                  ;
   779                                                                                                                  ;CS:IP   0:7c00 700:c00 7c0:0
   780                                  Boot.10                 call    word .20                                        ;[ESP] =   7c21     c21    21
   781                                  .@20                    equ     $-$$                                            ;.@20 = 021h
   782                                  .20                     pop     ax                                              ;AX =      7c21     c21    21
   783                                                          sub     ax,.@20                                         ;AX =      7c00     c00     0
   784                                                          mov     cl,4                                            ;shift count
   785                                                          shr     ax,cl                                           ;AX =       7c0      c0     0
   786                                                          mov     bx,cs                                           ;BX =         0     700   7c0
   787                                                          add     bx,ax                                           ;BX =       7c0     7c0   7c0
   788                                  ;
   789                                  ;       Now, since we are assembling our boot code to emulate the addressing of a .COM file, we want the DS and ES
   790                                  ;       registers to be set to where a Program Segment Prefix (PSP) would be, exactly 100h (256) bytes prior to
   791                                  ;       the start of our code. This will correspond to our assembled data address offsets. Note that we instructed
   792                                  ;       the assembler to produce addresses for our symbols that are offset from our code by 100h. See the "vstart"
   793                                  ;       parameter for the "section" directive above. We also set SS to the PSP and SP to the address of our i/o
   794                                  ;       buffer. This leaves 256 bytes of usable stack from 7b0:0 to 7b0:100.
   795                                  ;
   796                                  ;       Note that when a value is loaded into the stack segment register (SS) interrupts are disabled until the
   797                                  ;       completion of the following instruction.
   798                                  ;
   799                                                          sub     bx,16                                           ;BX = 07b0
   800                                                          mov     ds,bx                                           ;DS = 07b0 = psp
   801                                                          mov     es,bx                                           ;ES = 07b0 = psp
   802                                                          mov     ss,bx                                           ;SS = 07b0 = psp (ints disabled)
   803                                                          mov     sp,EBOOTSTACKTOP                                ;SP = 0100       (ints enabled)
   804                                  ;
   805                                  ;       Our boot addressability is now set up according to the following diagram.
   806                                  ;
   807                                  ;       DS,ES,SS -----> 007b00  +-----------------------------------------------+ DS:0000
   808                                  ;                               |  Boot Stack & Boot PSP (Unused)               |
   809                                  ;                               |  256 = 100h bytes                             |
   810                                  ;       SS:SP --------> 007c00  +-----------------------------------------------+ DS:0100  07b0:0100
   811                                  ;                               |  Boot Sector (vstart=0100h)                   |
   812                                  ;                               |  1 sector = 512 = 200h bytes                  |
   813                                  ;                       007e00  +-----------------------------------------------+ DS:0300
   814                                  ;                               |  File Allocation Table (FAT) I/O Buffer       |
   815                                  ;                               |  9x512-byte sectors = 4,608 = 1200h bytes     |
   816                                  ;                       009000  +-----------------------------------------------+ DS:1500  08f0:0100
   817                                  ;                               |  Directory Sector Buffer & Kernel Load Area   |
   818                                  ;                               |  2 sectors = 1024 = 400h bytes
   819                                  ;                       009400  +-----------------------------------------------+ DS:1900
   820                                  ;
   821                                  ;       On entry, DL indicates the drive being booted from.
   822                                  ;
   823                                                          mov     [wbDrive],dl                                    ;[wbDrive] = drive being booted from
   824                                  ;
   825                                  ;       Compute directory i/o buffer address.
   826                                  ;
   827                                                          mov     ax,[cwFatSectors]                               ;AX = 0009 = FAT sectors
   828                                                          mul     word [cwSectorBytes]                            ;DX:AX = 0000:1200 = FAT bytes
   829                                                          add     ax,EBOOTFATBASE                                 ;AX = 1500 = end of FAT buffer
   830                                                          mov     [wwDirBuffer],ax                                ;[wwDirBuffer] = 1500
   831                                  ;
   832                                  ;       Compute segment where os.com will be loaded.
   833                                  ;
   834                                                          shr     ax,cl                                           ;AX = 0150
   835                                                          add     ax,bx                                           ;AX = 0150 + 07b0 = 0900
   836                                                          sub     ax,16                                           ;AX = 08f0
   837                                                          mov     [wwLoadSegment],ax                              ;[wwLoadSegment] = 08f0
   838                                  ;
   839                                  ;       Set the video mode to 80 column, 25 row, text.
   840                                  ;
   841                                                          mov     ax,EBIOSFNSETVMODE<<8|EBIOSMODETEXT80           ;set mode function, 80x25 text mode
   842                                                          int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
   843                                  ;
   844                                  ;       Write a message to the console so we know we have our addressability established.
   845                                  ;
   846                                                          mov     si,czLoadMsg                                    ;loading message
   847                                                          call    BootPrint                                       ;display loader message
   848                                  ;
   849                                  ;       Initialize the number of directory sectors to search.
   850                                  ;
   851                                                          mov     ax,[cwDirEntries]                               ;AX = 224 = max dir entries
   852                                                          mov     [wwEntriesLeft],ax                              ;[wwEntriesLeft] = 224
   853                                  ;
   854                                  ;       Compute number of directory sectors and initialize overhead count.
   855                                  ;
   856                                                          mov     cx,ax                                           ;CX = 00e0 = 224 entries
   857                                                          mul     word [cwEntryLen]                               ;DX:AX = 224 * 32 = 7168
   858                                                          div     word [cwSectorBytes]                            ;AX = 7168 / 512 = 14 = dir sectors
   859                                                          mov     [wwOverhead],ax                                 ;[wwOverhead] = 000e
   860                                  ;
   861                                  ;       Compute directory entries per sector.
   862                                  ;
   863                                                          xchg    ax,cx                                           ;DX:AX = 0:00e0, CX = 0000e
   864                                                          div     cx                                              ;AX = 0010 = entries per dir sector
   865                                                          mov     [wwSectorEntries],ax                            ;[wwSectorEntries] = 0010
   866                                  ;
   867                                  ;       Compute first logical directory sector and update overhead count.
   868                                  ;
   869                                                          mov     ax,[cwFatSectors]                               ;AX = 0009 = FAT sectors per copy
   870                                                          mul     byte [cbFatCount]                               ;AX = 0012 = FAT sectors
   871                                                          add     ax,[cwReservedSectors]                          ;AX = 0013 = FAT plus reserved
   872                                                          add     ax,[cwSpecialSectors]                           ;AX = 0013 = FAT + reserved + special
   873                                                          mov     [wwLogicalSector],ax                            ;[wwLogicalSector] = 0013
   874                                                          add     [wwOverhead],ax                                 ;[wwOverhead] = 0021 = res+spec+FAT+dir
   875                                  ;
   876                                  ;       Read directory sector.
   877                                  ;
   878                                  .30                     mov     al,1                                            ;sector count
   879                                                          mov     [wbReadCount],al                                ;[wbReadCount] = 01
   880                                                          mov     bx,[wwDirBuffer]                                ;BX = 1500
   881                                                          call    ReadSector                                      ;read sector into es:bx
   882                                  ;
   883                                  ;       Setup variables to search this directory sector.
   884                                  ;
   885                                                          mov     ax,[wwEntriesLeft]                              ;directory entries to search
   886                                                          cmp     ax,[wwSectorEntries]                            ;need to search more sectors?
   887                                                          jna     .40                                             ;no, continue
   888                                                          mov     ax,[wwSectorEntries]                            ;yes, limit search to sector
   889                                  .40                     sub     [wwEntriesLeft],ax                              ;update entries left to searh
   890                                                          mov     si,cbKernelProgram                              ;program name
   891                                                          mov     di,[wwDirBuffer]                                ;DI = 1500
   892                                  ;
   893                                  ;       Loop through directory sectors searching for kernel program.
   894                                  ;
   895                                  .50                     push    si                                              ;save kernel name address
   896                                                          push    di                                              ;save dir i/o buffer address
   897                                                          mov     cx,11                                           ;length of 8+3 name
   898                                                          cld                                                     ;forward strings
   899                                                          repe    cmpsb                                           ;compare entry name
   900                                                          pop     di                                              ;restore dir i/o buffer address
   901                                                          pop     si                                              ;restore kernel name address
   902                                                          je      .60                                             ;exit loop if found
   903                                                          add     di,[cwEntryLen]                                 ;point to next dir entry
   904                                                          dec     ax                                              ;decrement remaining entries
   905                                                          jnz     .50                                             ;next entry
   906                                  ;
   907                                  ;       Repeat search if we are not at the end of the directory.
   908                                  ;
   909                                                          inc     word [wwLogicalSector]                          ;increment logical sector
   910                                                          cmp     word [wwEntriesLeft],0                          ;done with directory?
   911                                                          jne     .30                                             ;no, get next sector
   912                                                          mov     si,czNoKernel                                   ;missing kernel message
   913                                                          jmp     BootExit                                        ;display message and exit
   914                                  ;
   915                                  ;       If we find the kernel program in the directory, read the FAT.
   916                                  ;
   917                                  .60                     mov     ax,[cwReservedSectors]                          ;AX = 0001
   918                                                          mov     [wwLogicalSector],ax                            ;start past boot sector
   919                                                          mov     ax,[cwFatSectors]                               ;AX = 0009
   920                                                          mov     [wbReadCount],al                                ;[wbReadCount] = 09
   921                                                          mov     bx,EBOOTFATBASE                                 ;BX = 0300
   922                                                          call    ReadSector                                      ;read FAT into buffer
   923                                  ;
   924                                  ;       Get the starting cluster of the kernel program and target address.
   925                                  ;
   926                                                          mov     ax,[di+26]                                      ;AX = starting cluster of file
   927                                                          les     bx,[wwLoadOffset]                               ;ES:BX = kernel load add (08f0:0100)
   928                                  ;
   929                                  ;       Read each program cluster into RAM.
   930                                  ;
   931                                  .70                     push    ax                                              ;save cluster nbr
   932                                                          sub     ax,2                                            ;AX = cluster nbr base 0
   933                                                          mov     cl,[cbClusterSectors]                           ;CL = sectors per cluster
   934                                                          mov     [wbReadCount],cl                                ;save sectors to read
   935                                                          xor     ch,ch                                           ;CX = sectors per cluster
   936                                                          mul     cx                                              ;DX:AX = logical cluster sector
   937                                                          add     ax,[wwOverhead]                                 ;AX = kernel sector nbr
   938                                                          mov     [wwLogicalSector],ax                            ;save logical sector nbr
   939                                                          call    ReadSector                                      ;read sectors into ES:BX
   940                                  ;
   941                                  ;       Update buffer pointer for next cluster.
   942                                  ;
   943                                                          mov     al,[cbClusterSectors]                           ;AL = sectors per cluster
   944                                                          xor     ah,ah                                           ;AX = sectors per cluster
   945                                                          mul     word [cwSectorBytes]                            ;DX:AX = cluster bytes
   946                                                          add     bx,ax                                           ;BX = next cluster target address
   947                                                          pop     ax                                              ;AX = restore cluster nbr
   948                                  ;
   949                                  ;       Compute next cluster number.
   950                                  ;
   951                                                          mov     cx,ax                                           ;CX = cluster nbr
   952                                                          mov     di,ax                                           ;DI = cluster nbr
   953                                                          shr     ax,1                                            ;AX = cluster/2
   954                                                          mov     dx,ax                                           ;DX = cluster/2
   955                                                          add     ax,dx                                           ;AX = 2*(cluster/2)
   956                                                          add     ax,dx                                           ;AX = 3*(cluster/2)
   957                                                          and     di,1                                            ;get low bit
   958                                                          add     di,ax                                           ;add one if cluster is odd
   959                                                          add     di,EBOOTFATBASE                                 ;add FAT buffer address
   960                                                          mov     ax,[di]                                         ;get cluster bytes
   961                                  ;
   962                                  ;       Adjust cluster nbr by 4 bits if cluster is odd; test for end of chain.
   963                                  ;
   964                                                          test    cl,1                                            ;is cluster odd?
   965                                                          jz      .80                                             ;no, skip ahead
   966                                                          mov     cl,4                                            ;shift count
   967                                                          shr     ax,cl                                           ;shift nybble low
   968                                  .80                     and     ax,0FFFh                                        ;mask for 24 bits; next cluster nbr
   969                                                          cmp     ax,0FFFh                                        ;end of chain?
   970                                                          jne     .70                                             ;no, continue
   971                                  ;
   972                                  ;       Transfer control to the operating system program.
   973                                  ;
   974                                                          db      0EAh                                            ;jmp seg:offset
   975                                  wwLoadOffset            dw      0100h                                           ;kernel entry offset
   976                                  wwLoadSegment           dw      08F0h                                           ;kernel entry segment (computed)
   977                                  ;
   978                                  ;       Read [wbReadCount] disk sectors from [wwLogicalSector] into ES:BX.
   979                                  ;
   980                                  ReadSector              mov     ax,[cwTrackSectors]                             ;AX = sectors per track
   981                                                          mul     word [cwDiskSides]                              ;DX:AX = sectors per cylinder
   982                                                          mov     cx,ax                                           ;CX = sectors per cylinder
   983                                                          mov     ax,[wwLogicalSector]                            ;DX:AX = logical sector
   984                                                          div     cx                                              ;AX = cylinder; DX = cyl sector
   985                                                          mov     [wbTrack],al                                    ;[wbTrack] = cylinder
   986                                                          mov     ax,dx                                           ;AX = cyl sector
   987                                                          div     byte [cbTrackSectors]                           ;AH = sector, AL = head
   988                                                          inc     ah                                              ;AH = sector (1,2,3,...)
   989                                                          mov     [wbHead],ax                                     ;[wbHead]= head, [wwSectorTrack]= sector
   990                                  ;
   991                                  ;       Try maxtries times to read sector.
   992                                  ;
   993                                                          mov     cx,EBOOTMAXTRIES                                ;CX = 0005
   994                                  .10                     push    bx                                              ;save buffer address
   995                                                          push    cx                                              ;save retry count
   996                                                          mov     dx,[wwDriveHead]                                ;DH = head, DL = drive
   997                                                          mov     cx,[wwSectorTrack]                              ;CH = track, CL = sector
   998                                                          mov     ax,[wwReadCountCommand]                         ;AH = fn., AL = sector count
   999                                                          int     EBIOSINTDISKETTE                                ;read sector
  1000                                                          pop     cx                                              ;restore retry count
  1001                                                          pop     bx                                              ;restore buffer address
  1002                                                          jnc     BootReturn                                      ;skip ahead if done
  1003                                                          loop    .10                                             ;retry
  1004                                  ;
  1005                                  ;       Handle disk error: convert to ASCII and store in error string.
  1006                                  ;
  1007                                                          mov     al,ah                                           ;AL = bios error code
  1008                                                          xor     ah,ah                                           ;AX = bios error code
  1009                                                          mov     dl,16                                           ;divisor for base 16
  1010                                                          div     dl                                              ;AL = hi order, AH = lo order
  1011                                                          or      ax,03030h                                       ;apply ASCII zone bits
  1012                                                          cmp     ah,03Ah                                         ;range test ASCII numeral
  1013                                                          jb      .20                                             ;continue if numeral
  1014                                                          add     ah,7                                            ;adjust for ASCII 'A'-'F'
  1015                                  .20                     cmp     al,03Ah                                         ;range test ASCII numeral
  1016                                                          jb      .30                                             ;continue if numeral
  1017                                                          add     ah,7                                            ;adjust for ASCII 'A'-'F'
  1018                                  .30                     mov     [wzErrorCode],ax                                ;store ASCII error code
  1019                                                          mov     si,czErrorMsg                                   ;error message address
  1020                                  BootExit                call    BootPrint                                       ;display messge to console
  1021                                  ;
  1022                                  ;       Wait for a key press.
  1023                                  ;
  1024                                  .10                     mov     ah,EBIOSFNKEYSTATUS                             ;BIOS keyboard status function
  1025                                                          int     EBIOSINTKEYBOARD                                ;get keyboard status
  1026                                                          jnz     .20                                             ;continue if key pressed
  1027                                                          sti                                                     ;enable maskable interrupts
  1028                                                          hlt                                                     ;wait for interrupt
  1029                                                          jmp     .10                                             ;repeat
  1030                                  ;
  1031                                  ;       Reset the system.
  1032                                  ;
  1033                                  .20                     mov     al,EKEYBCMDRESET                                ;8042 pulse output port pin
  1034                                                          out     EKEYBPORTSTAT,al                                ;drive B0 low to restart
  1035                                  .30                     sti                                                     ;enable maskable interrupts
  1036                                                          hlt                                                     ;stop until reset, int, nmi
  1037                                                          jmp     .30                                             ;loop until restart kicks in
  1038                                  ;
  1039                                  ;       Display text message.
  1040                                  ;
  1041                                  BootPrint               cld                                                     ;forward strings
  1042                                  .10                     lodsb                                                   ;load next byte at DS:SI in AL
  1043                                                          test    al,al                                           ;end of string?
  1044                                                          jz      BootReturn                                      ;... yes, exit our loop
  1045                                                          mov     ah,EBIOSFNTTYOUTPUT                             ;BIOS teletype function
  1046                                                          int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
  1047                                                          jmp     .10                                             ;repeat until done
  1048                                  BootReturn              ret                                                     ;return
  1049                                  ;-----------------------------------------------------------------------------------------------------------------------
  1050                                  ;
  1051                                  ;       Constants
  1052                                  ;
  1053                                  ;-----------------------------------------------------------------------------------------------------------------------
  1054                                                          align   2
  1055                                  cwEntryLen              dw      32                                              ;length of directory entry
  1056                                  cbKernelProgram         db      "OS      COM"                                   ;kernel program name
  1057                                  czLoadMsg               db      "Loading OS",13,10,0                            ;loading message
  1058                                  czErrorMsg              db      "Disk error "                                   ;error message
  1059                                  wzErrorCode             db      020h,020h,0                                     ;error code and null terminator
  1060                                  czNoKernel              db      "OS missing",0                                  ;missing kernel message
  1061                                  ;-----------------------------------------------------------------------------------------------------------------------
  1062                                  ;
  1063                                  ;       Work Areas
  1064                                  ;
  1065                                  ;-----------------------------------------------------------------------------------------------------------------------
  1066                                                          align   2
  1067                                  wwDirBuffer             dw      0                                               ;directory i/o buffer address
  1068                                  wwEntriesLeft           dw      0                                               ;directory entries to search
  1069                                  wwOverhead              dw      0                                               ;overhead sectors
  1070                                  wwSectorEntries         dw      0                                               ;directory entries per sector
  1071                                  wwLogicalSector         dw      0                                               ;current logical sector
  1072                                  wwReadCountCommand      equ     $                                               ;read count and command
  1073                                  wbReadCount             db      0                                               ;sectors to read
  1074                                  cbReadCommand           db      EBIOSFNREADSECTOR                               ;BIOS read disk fn code
  1075                                  wwDriveHead             equ     $                                               ;drive, head (word)
  1076                                  wbDrive                 db      0                                               ;drive
  1077                                  wbHead                  db      0                                               ;head
  1078                                  wwSectorTrack           equ     $                                               ;sector, track (word)
  1079                                                          db      0                                               ;sector
  1080                                  wbTrack                 db      0                                               ;track
  1081                                                          times   510-($-$$) db 0h                                ;zero fill to end of sector
  1082                                                          db      055h,0AAh                                       ;end of sector signature
  1083                                  %endif
  1084                                  %ifdef BUILDPREP
  1085                                  ;=======================================================================================================================
  1086                                  ;
  1087                                  ;       Diskette Preparation Code
  1088                                  ;
  1089                                  ;       This routine writes the OS boot sector code to a formatted floppy diskette. The diskette parameter table,
  1090                                  ;       which is located in the first 30 bytes of the boot sector is first read from the diskette and overlayed onto
  1091                                  ;       the OS bootstrap code so that the diskette format parameters are preserved.
  1092                                  ;
  1093                                  ;=======================================================================================================================
  1094                                  ;
  1095                                  ;       Query the user to insert a flopppy diskette and press enter or cancel.
  1096                                  ;
  1097                                  Prep                    mov     si,czPrepMsg10                                  ;starting message address
  1098                                                          call    BootPrint                                       ;display message
  1099                                  ;
  1100                                  ;       Exit if the Escape key is pressed or loop until Enter is pressed.
  1101                                  ;
  1102                                  .10                     mov     ah,EBIOSFNKEYSTATUS                             ;BIOS keyboard status function
  1103                                                          int     EBIOSINTKEYBOARD                                ;get keyboard status
  1104                                                          jnz     .20                                             ;continue if key pressed
  1105                                                          sti                                                     ;enable interrupts
  1106                                                          hlt                                                     ;wait for interrupt
  1107                                                          jmp     .10                                             ;repeat
  1108                                  .20                     cmp     al,EASCIIRETURN                                 ;Enter key pressed?
  1109                                                          je      .30                                             ;yes, branch
  1110                                                          cmp     al,EASCIIESCAPE                                 ;Escape key pressed?
  1111                                                          jne     .10                                             ;no, repeat
  1112                                                          jmp     .120                                            ;yes, exit program
  1113                                  ;
  1114                                  ;       Display writing-sector message and patch the JMP instruction.
  1115                                  ;
  1116                                  .30                     mov     si,czPrepMsg12                                  ;writing-sector message address
  1117                                                          call    BootPrint                                       ;display message
  1118                                                          mov     bx,Boot+1                                       ;address of JMP instruction operand
  1119                                                          mov     ax,01Bh                                         ;address past disk parameter table
  1120                                                          mov     [bx],ax                                         ;update the JMP instruction
  1121                                  ;
  1122                                  ;       Try to read the boot sector.
  1123                                  ;
  1124                                                          mov     cx,EBOOTMAXTRIES                                ;try up to five times
  1125                                  .40                     push    cx                                              ;save remaining tries
  1126                                                          mov     bx,wcPrepInBuf                                  ;input buffer address
  1127                                                          mov     dx,0                                            ;head zero, drive zero
  1128                                                          mov     cx,1                                            ;track zero, sector one
  1129                                                          mov     al,1                                            ;one sector
  1130                                                          mov     ah,EBIOSFNREADSECTOR                            ;read function
  1131                                                          int     EBIOSINTDISKETTE                                ;attempt the read
  1132                                                          pop     cx                                              ;restore remaining retries
  1133                                                          jnc     .50                                             ;skip ahead if successful
  1134                                                          loop    .40                                             ;try again
  1135                                                          mov     si,czPrepMsg20                                  ;read-error message address
  1136                                                          jmp     .70                                             ;branch to error routine
  1137                                  ;
  1138                                  ;       Copy diskette parms from input buffer to output buffer.
  1139                                  ;
  1140                                  .50                     mov     si,wcPrepInBuf                                  ;input buffer address
  1141                                                          add     si,11                                           ;skip over JMP and system ID
  1142                                                          mov     di,Boot                                         ;output buffer address
  1143                                                          add     di,11                                           ;skip over JMP and system ID
  1144                                                          mov     cx,19                                           ;length of diskette parameters
  1145                                                          cld                                                     ;forward string copies
  1146                                                          rep     movsb                                           ;copy diskette parameters
  1147                                  ;
  1148                                  ;       Try to write boot sector to diskette.
  1149                                  ;
  1150                                                          mov     cx,EBOOTMAXTRIES                                ;try up to five times
  1151                                  .60                     push    cx                                              ;save remaining tries
  1152                                                          mov     bx,Boot                                         ;output buffer address
  1153                                                          mov     dx,0                                            ;head zero, drive zero
  1154                                                          mov     cx,1                                            ;track zero, sector one
  1155                                                          mov     al,1                                            ;one sector
  1156                                                          mov     ah,EBIOSFNWRITESECTOR                           ;write function
  1157                                                          int     EBIOSINTDISKETTE                                ;attempt the write
  1158                                                          pop     cx                                              ;restore remaining retries
  1159                                                          jnc     .100                                            ;skip ahead if successful
  1160                                                          loop    .60                                             ;try again
  1161                                                          mov     si,czPrepMsg30                                  ;write-error message address
  1162                                  ;
  1163                                  ;       Convert the error code to ASCII and display the error message.
  1164                                  ;
  1165                                  .70                     push    ax                                              ;save error code
  1166                                                          mov     al,ah                                           ;copy error code
  1167                                                          mov     ah,0                                            ;AX = error code
  1168                                                          mov     dl,10h                                          ;hexadecimal divisor
  1169                                                          idiv    dl                                              ;AL = hi-order, AH = lo-order
  1170                                                          or      ax,03030h                                       ;add ASCII zone digits
  1171                                                          cmp     ah,03Ah                                         ;AH ASCII numeral?
  1172                                                          jb      .80                                             ;yes, continue
  1173                                                          add     ah,7                                            ;no, make ASCII 'A'-'F'
  1174                                  .80                     cmp     al,03Ah                                         ;ASCII numeral?
  1175                                                          jb      .90                                             ;yes, continue
  1176                                                          add     al,7                                            ;no, make ASCII
  1177                                  .90                     mov     [si+17],ax                                      ;put ASCII error code in message
  1178                                                          call    BootPrint                                       ;write error message
  1179                                                          pop     ax                                              ;restore error code
  1180                                  ;
  1181                                  ;       Display the completion message.
  1182                                  ;
  1183                                  .100                    mov     si,czPrepMsgOK                                  ;assume successful completion
  1184                                                          mov     al,ah                                           ;BIOS return code
  1185                                                          cmp     al,0                                            ;success?
  1186                                                          je      .110                                            ;yes, continue
  1187                                                          mov     si,czPrepMsgErr1                                ;disk parameter error message
  1188                                                          cmp     al,1                                            ;disk parameter error?
  1189                                                          je      .110                                            ;yes, continue
  1190                                                          mov     si,czPrepMsgErr2                                ;address mark not found message
  1191                                                          cmp     al,2                                            ;address mark not found?
  1192                                                          je      .110                                            ;yes, continue
  1193                                                          mov     si,czPrepMsgErr3                                ;protected disk message
  1194                                                          cmp     al,3                                            ;protected disk?
  1195                                                          je      .110                                            ;yes, continue
  1196                                                          mov     si,czPrepMsgErr6                                ;diskette removed message
  1197                                                          cmp     al,6                                            ;diskette removed?
  1198                                                          je      .110                                            ;yes, continue
  1199                                                          mov     si,czPrepMsgErr80                               ;drive timed out message
  1200                                                          cmp     al,80h                                          ;drive timed out?
  1201                                                          je      .110                                            ;yes, continue
  1202                                                          mov     si,czPrepMsgErrXX                               ;unknown error message
  1203                                  .110                    call    BootPrint                                       ;display result message
  1204                                  .120                    mov     ax,04C00H                                       ;terminate with zero result code
  1205                                                          int     021h                                            ;terminate DOS program
  1206                                                          ret                                                     ;return (should not execute)
  1207                                  ;-----------------------------------------------------------------------------------------------------------------------
  1208                                  ;
  1209                                  ;       Diskette Preparation Messages
  1210                                  ;
  1211                                  ;-----------------------------------------------------------------------------------------------------------------------
  1212                                  czPrepMsg10             db      13,10,"OS Boot-Diskette Preparation Program"
  1213                                                          db      13,10,"Copyright (C) 2010-2019 David J. Walling"
  1214                                                          db      13,10
  1215                                                          db      13,10,"This program overwrites the boot sector of a diskette with startup code that"
  1216                                                          db      13,10,"will load the operating system into memory when the computer is restarted."
  1217                                                          db      13,10,"To proceed, place a formatted diskette into drive A: and press the Enter key."
  1218                                                          db      13,10,"To exit this program without preparing a diskette, press the Escape key."
  1219                                                          db      13,10,0
  1220                                  czPrepMsg12             db      13,10,"Writing the boot sector to the diskette ..."
  1221                                                          db      13,10,0
  1222                                  czPrepMsg20             db      13,10,"The error-code .. was returned from the BIOS while reading from the disk."
  1223                                                          db      13,10,0
  1224                                  czPrepMsg30             db      13,10,"The error-code .. was returned from the BIOS while writing to the disk."
  1225                                                          db      13,10,0
  1226                                  czPrepMsgOK             db      13,10,"The boot-sector was written to the diskette. Before booting your computer with"
  1227                                                          db      13,10,"this diskette, make sure that the file OS.COM is copied onto the diskette."
  1228                                                          db      13,10,0
  1229                                  czPrepMsgErr1           db      13,10,"(01) Invalid Disk Parameter"
  1230                                                          db      13,10,"This is an internal error caused by an invalid value being passed to a system"
  1231                                                          db      13,10,"function. The OSBOOT.COM file may be corrupt. Copy or download the file again"
  1232                                                          db      13,10,"and retry."
  1233                                                          db      13,10,0
  1234                                  czPrepMsgErr2           db      13,10,"(02) Address Mark Not Found"
  1235                                                          db      13,10,"This error indicates a physical problem with the floppy diskette. Please retry"
  1236                                                          db      13,10,"using another diskette."
  1237                                                          db      13,10,0
  1238                                  czPrepMsgErr3           db      13,10,"(03) Protected Disk"
  1239                                                          db      13,10,"This error is usually caused by attempting to write to a write-protected disk."
  1240                                                          db      13,10,"Check the 'write-protect' setting on the disk or retry using using another disk."
  1241                                                          db      13,10,0
  1242                                  czPrepMsgErr6           db      13,10,"(06) Diskette Removed"
  1243                                                          db      13,10,"This error may indicate that the floppy diskette has been removed from the"
  1244                                                          db      13,10,"diskette drive. On some systems, this code may also occur if the diskette is"
  1245                                                          db      13,10,"'write protected.' Please verify that the diskette is not write-protected and"
  1246                                                          db      13,10,"is properly inserted in the diskette drive."
  1247                                                          db      13,10,0
  1248                                  czPrepMsgErr80          db      13,10,"(80) Drive Timed Out"
  1249                                                          db      13,10,"This error usually indicates that no diskette is in the diskette drive. Please"
  1250                                                          db      13,10,"make sure that the diskette is properly seated in the drive and retry."
  1251                                                          db      13,10,0
  1252                                  czPrepMsgErrXX          db      13,10,"(??) Unknown Error"
  1253                                                          db      13,10,"The error-code returned by the BIOS is not a recognized error. Please consult"
  1254                                                          db      13,10,"your computer's technical reference for a description of this error code."
  1255                                                          db      13,10,0
  1256                                  wcPrepInBuf             equ     $
  1257                                  %endif
  1258                                  %ifdef BUILDDISK
  1259                                  ;=======================================================================================================================
  1260                                  ;
  1261                                  ;       File Allocation Tables
  1262                                  ;
  1263                                  ;       The disk contains two copies of the File Allocation Table (FAT). On our disk, each FAT copy is 1200h bytes in
  1264                                  ;       length. Each FAT entry contains the logical number of the next cluster. The first two entries are reserved. Our
  1265                                  ;       OS.COM file here is 5400h bytes in length. The first 400h bytes are the 16-bit loader code. The remaining 5000h
  1266                                  ;       bytes are the 32-bit kernel code. Our disk parameter table defines a cluster as containing one sector and each
  1267                                  ;       sector having 200h bytes. Therefore, our FAT table must reserve 42 clusters for OS.COM. The clusters used by
  1268                                  ;       OS.COM, then, will be cluster 2 through 43. The entry for cluster 43 is set to "0fffh" to indicate that it is
  1269                                  ;       the last cluster in the chain.
  1270                                  ;
  1271                                  ;       Every three bytes encode two FAT entries as follows:
  1272                                  ;
  1273                                  ;       db      0abh,0cdh,0efh  ;even cluster: 0dabh, odd cluster: 0efch
  1274                                  ;
  1275                                  ;=======================================================================================================================
  1276                                  ;-----------------------------------------------------------------------------------------------------------------------
  1277                                  ;
  1278                                  ;       FAT copy 1                                                              @disk: 000200   @mem: n/a
  1279                                  ;
  1280                                  ;-----------------------------------------------------------------------------------------------------------------------
  1281                                  section                 fat1                                                    ;first copy of FAT
  1282                                                          db      0F0h,0FFh,0FFh, 003h,040h,000h
  1283                                                          db      005h,060h,000h, 007h,080h,000h
  1284                                                          db      009h,0A0h,000h, 00Bh,0C0h,000h
  1285                                                          db      00Dh,0E0h,000h, 00Fh,000h,001h
  1286                                                          db      011h,020h,001h, 013h,040h,001h
  1287                                                          db      015h,060h,001h, 017h,080h,001h
  1288                                                          db      019h,0A0h,001h, 01Bh,0C0h,001h
  1289                                                          db      01Dh,0E0h,001h, 01Fh,000h,002h
  1290                                                          db      021h,020h,002h, 023h,040h,002h
  1291                                                          db      025h,060h,002h, 027h,080h,002h
  1292                                                          db      029h,0A0h,002h, 02Bh,0F0h,0FFh
  1293                                                          times   (9*512)-($-$$) db 0                             ;zero fill to end of section
  1294                                  ;-----------------------------------------------------------------------------------------------------------------------
  1295                                  ;
  1296                                  ;       FAT copy 2                                                              @disk: 001400   @mem: n/a
  1297                                  ;
  1298                                  ;-----------------------------------------------------------------------------------------------------------------------
  1299                                  section                 fat2                                                    ;second copy of FAT
  1300                                                          db      0F0h,0FFh,0FFh, 003h,040h,000h
  1301                                                          db      005h,060h,000h, 007h,080h,000h
  1302                                                          db      009h,0A0h,000h, 00Bh,0C0h,000h
  1303                                                          db      00Dh,0E0h,000h, 00Fh,000h,001h
  1304                                                          db      011h,020h,001h, 013h,040h,001h
  1305                                                          db      015h,060h,001h, 017h,080h,001h
  1306                                                          db      019h,0A0h,001h, 01Bh,0C0h,001h
  1307                                                          db      01Dh,0E0h,001h, 01Fh,000h,002h
  1308                                                          db      021h,020h,002h, 023h,040h,002h
  1309                                                          db      025h,060h,002h, 027h,080h,002h
  1310                                                          db      029h,0A0h,002h, 02Bh,0F0h,0FFh
  1311                                                          times   (9*512)-($-$$) db 0                             ;zero fill to end of section
  1312                                  ;-----------------------------------------------------------------------------------------------------------------------
  1313                                  ;
  1314                                  ;       Diskette Directory                                                      @disk: 002600   @mem: n/a
  1315                                  ;
  1316                                  ;       The disk contains one copy of the diskette directory. Each directory entry is 32 bytes long. Our directory
  1317                                  ;       contains only one entry. Unused entries are set to all nulls. The directory immediately follows the second FAT
  1318                                  ;       copy.
  1319                                  ;
  1320                                  ;-----------------------------------------------------------------------------------------------------------------------
  1321                                  section                 dir                                                     ;diskette directory
  1322                                                          db      "OS      COM"                                   ;file name (must contain spaces)
  1323                                                          db      020h                                            ;attribute (archive bit set)
  1324                                                          times   10 db 0                                         ;unused
  1325                                                          dw      0h                                              ;time
  1326                                                          db      01000001b                                       ;mmm = 10 MOD 8 = 2; ddddd = 1
  1327                                                          db      01001001b                                       ;yyyyyyy = 2016-1980 = 36 = 24h; m/8 = 1
  1328                                                          dw      2                                               ;first cluster
  1329                                                          dd      05400h                                          ;file size
  1330                                                          times   (EBOOTDIRENTRIES*32)-($-$$) db 0h               ;zero fill to end of section
  1331                                  %endif
  1332                                  %ifdef BUILDCOM
  1333                                  ;=======================================================================================================================
  1334                                  ;
  1335                                  ;       OS.COM
  1336                                  ;
  1337                                  ;       The operating system file is assembled at the start of the data area of the floppy disk image, which
  1338                                  ;       immediately follows the directory. This corresponds to logical cluster 2, even though the physical address of
  1339                                  ;       this sector on the disk varies depending on the disk type. The os.com file consists of two parts, the OS loader
  1340                                  ;       and the OS kernel. The Loader is 16-bit code that receives control directly from the boot sector code after the
  1341                                  ;       OS.COM file is loaded into memory. The kernel is 32-bit code that receives control after the Loader has
  1342                                  ;       initialized protected-mode tables and 32-bit interrupt handlers and switched the CPU into protected mode.
  1343                                  ;
  1344                                  ;       Our loader addressability is set up according to the following diagram.
  1345                                  ;
  1346                                  ;       SS -----------> 007b00  +-----------------------------------------------+ SS:0000
  1347                                  ;                               |  Boot Stack & Boot PSP (Unused)               |
  1348                                  ;                               |  256 = 100h bytes                             |
  1349                                  ;       SS:SP --------> 007c00  +-----------------------------------------------+ SS:0100  07b0:0100
  1350                                  ;                               |  Boot Sector (vstart=0100h)                   |
  1351                                  ;                               |  1 sector = 512 = 200h bytes                  |
  1352                                  ;                       007e00  +-----------------------------------------------+
  1353                                  ;                               |  File Allocation Table (FAT) I/O Buffer       |
  1354                                  ;                               |  9 x 512-byte sectors = 4,608 = 1200h bytes   |
  1355                                  ;                               |                                               |
  1356                                  ;       CS,DS,ES -----> 008f00  |  Loader PSP (Unused)                          | DS:0000
  1357                                  ;                               |                                               |
  1358                                  ;       CS:IP --------> 009000  +-----------------------------------------------+ DS:0100  08f0:0100
  1359                                  ;                               |  Loader Code                                  |
  1360                                  ;                               |  2 sectors = 1024 = 400h bytes                |
  1361                                  ;                       009400  +-----------------------------------------------+ DS:0500
  1362                                  ;
  1363                                  ;=======================================================================================================================
  1364                                  ;-----------------------------------------------------------------------------------------------------------------------
  1365                                  ;
  1366                                  ;       OS Loader                                                               @disk: 004200   @mem: 009000
  1367                                  ;
  1368                                  ;       This code is the operating system loader. It resides on the boot disk at the start of the data area, following
  1369                                  ;       the directory. The loader occupies several clusters that are mapped in the file allocation tables above.
  1370                                  ;       The loader executes 16-bit instructions in real mode. It performs several initialization functions such as
  1371                                  ;       determining whether the CPU and other resources are sufficient to run the operating system. If all minimum
  1372                                  ;       resources are present, the loader initializes protected mode tables, places the CPU into protected mode and
  1373                                  ;       starts the console task. Since the loader was called either from the bootstrap or as a .com file on the boot
  1374                                  ;       disk, we can assume that the initial IP is 0x100 and not perform any absolute address fix-ups on our segment
  1375                                  ;       registers.
  1376                                  ;
  1377                                  ;-----------------------------------------------------------------------------------------------------------------------
  1378                                                          cpu     8086                                            ;assume minimal CPU
  1379                                  section                 loader  vstart=0100h                                    ;use .COM compatible addressing
  1380                                                          bits    16                                              ;this is 16-bit code
  1381 00000000 0E                      Loader                  push    cs                                              ;use the code segment
  1382 00000001 1F                                              pop     ds                                              ;...as our data segment
  1383 00000002 0E                                              push    cs                                              ;use the code segment
  1384 00000003 07                                              pop     es                                              ;...as our extra segment
  1385                                  ;
  1386                                  ;       Write a message to the console so we know we have our addressability established.
  1387                                  ;
  1388 00000004 BE[5B01]                                        mov     si,czStartingMsg                                ;starting message
  1389 00000007 E8A600                                          call    PutTTYString                                    ;display loader message
  1390                                  ;
  1391                                  ;       Determine the CPU type, generally. Exit if the CPU is not at least an 80386.
  1392                                  ;
  1393 0000000A E88300                                          call    GetCPUType                                      ;AL = cpu type
  1394 0000000D BE[C800]                                        mov     si,czCPUErrorMsg                                ;loader error message
  1395 00000010 3C03                                            cmp     al,3                                            ;80386+?
  1396 00000012 7267                                            jb      LoaderExit                                      ;no, exit with error message
  1397                                                          cpu     386                                             ;allow 80386 instructions
  1398 00000014 BE[3301]                                        mov     si,czCPUOKMsg                                   ;cpu ok message
  1399 00000017 E89600                                          call    PutTTYString                                    ;display message
  1400                                  ;
  1401                                  ;       Fixup the GDT descriptor for the current (loader) code segment.
  1402                                  ;
  1403 0000001A BE0005                                          mov     si,EKRNCODESRCADR                               ;GDT offset
  1404 0000001D 8CC8                                            mov     ax,cs                                           ;AX:SI = gdt source
  1405 0000001F C1C004                                          rol     ax,4                                            ;AX = phys addr bits 11-0,15-12
  1406 00000022 88C1                                            mov     cl,al                                           ;CL = phys addr bits 3-0,15-12
  1407 00000024 24F0                                            and     al,0F0h                                         ;AL = phys addr bits 11-0
  1408 00000026 80E10F                                          and     cl,00Fh                                         ;CL = phys addr bits 15-12
  1409 00000029 894432                                          mov     word [si+EGDTLOADERCODE+2],ax                   ;lo-order loader code (0-15)
  1410 0000002C 884C34                                          mov     byte [si+EGDTLOADERCODE+4],cl                   ;lo-order loader code (16-23)
  1411 0000002F BE[3C01]                                        mov     si,czGDTOKMsg                                   ;GDT prepared message
  1412 00000032 E87B00                                          call    PutTTYString                                    ;display message
  1413                                  ;
  1414                                  ;       Move the 32-bit kernel to its appropriate memory location.
  1415                                  ;
  1416 00000035 680001                                          push    EKRNCODESEG                                     ;use kernel code segment ...
  1417 00000038 07                                              pop     es                                              ;... as target segment
  1418 00000039 31FF                                            xor     di,di                                           ;ES:DI = target address
  1419 0000003B BE0005                                          mov     si,EKRNCODESRCADR                               ;DS:SI = source address
  1420 0000003E B90050                                          mov     cx,EKRNCODELEN                                  ;CX = kernel size
  1421 00000041 FC                                              cld                                                     ;forward strings
  1422 00000042 F3A4                                            rep     movsb                                           ;copy kernel image
  1423 00000044 BE[4B01]                                        mov     si,czKernelLoadedMsg                            ;kernel moved message
  1424 00000047 E86600                                          call    PutTTYString                                    ;display message
  1425                                  ;
  1426                                  ;       Switch to protected mode.
  1427                                  ;
  1428 0000004A 31F6                                            xor     si,si                                           ;ES:SI = gdt addr
  1429 0000004C 8ED6                                            mov     ss,si                                           ;protected mode ss
  1430 0000004E BC0010                                          mov     sp,EKRNCODEBASE                                 ;initial stack immediate before code
  1431 00000051 B489                                            mov     ah,EBIOSFNINITPROTMODE                          ;initialize protected mode fn.
  1432 00000053 BB2820                                          mov     bx,02028h                                       ;BH,BL = IRQ int bases
  1433 00000056 BA1F00                                          mov     dx,001Fh                                        ;outer delay loop count
  1434 00000059 B9FFFF                  .10                     mov     cx,0FFFFh                                       ;inner delay loop count
  1435 0000005C E2FE                                            loop    $                                               ;wait out pending interrupts
  1436 0000005E 4A                                              dec     dx                                              ;restore outer loop count
  1437 0000005F 75F8                                            jnz     .10                                             ;continue outer loop
  1438 00000061 CD15                                            int     EBIOSINTMISC                                    ;call BIOS to set protected mode
  1439                                  ;
  1440                                  ;       Enable hardware and maskable interrupts.
  1441                                  ;
  1442 00000063 30C0                                            xor     al,al                                           ;enable all registers code
  1443 00000065 E621                                            out     EPICPORTPRI1,al                                 ;enable all primary 8259A ints
  1444 00000067 E6A1                                            out     EPICPORTSEC1,al                                 ;enable all secondary 8259A ints
  1445 00000069 FB                                              sti                                                     ;enable maskable interrupts
  1446                                  ;
  1447                                  ;       Load the Task State Segment (TSS) and Local Descriptor Table (LDT) registers and jump to the initial task.
  1448                                  ;
  1449 0000006A 2E0F001E[C000]                                  ltr     [cs:cwLoaderTSS]                                ;load task register
  1450 00000070 2E0F0016[BE00]                                  lldt    [cs:cwLoaderLDT]                                ;load local descriptor table register
  1451 00000076 EA00006800                                      jmp     EGDTCONSOLETSS:0                                ;jump to task state segment selector
  1452                                  ;-----------------------------------------------------------------------------------------------------------------------
  1453                                  ;
  1454                                  ;       Routine:        LoaderExit
  1455                                  ;
  1456                                  ;       Description:    This routine displays the message at DS:SI, waits for a keypress and resets the system.
  1457                                  ;
  1458                                  ;       In:             DS:SI   string address
  1459                                  ;
  1460                                  ;-----------------------------------------------------------------------------------------------------------------------
  1461 0000007B E83200                  LoaderExit              call    PutTTYString                                    ;display error message
  1462                                  ;
  1463                                  ;       Now we want to wait for a keypress. We can use a keyboard interrupt function for this (INT 16h, AH=0).
  1464                                  ;       However, some hypervisor BIOS implementations have been seen to implement the "wait" as simply a fast
  1465                                  ;       iteration of the keyboard status function call (INT 16h, AH=1), causing a max CPU condition. So, instead,
  1466                                  ;       we will use the keyboard status call and iterate over a halt (HLT) instruction until a key is pressed.
  1467                                  ;       The STI instruction enables maskable interrupts, including the keyboard. The CPU assures that the
  1468                                  ;       instruction immediately following STI will be executed before any interrupt is serviced.
  1469                                  ;
  1470 0000007E B401                    .30                     mov     ah,EBIOSFNKEYSTATUS                             ;keyboard status function
  1471 00000080 CD16                                            int     EBIOSINTKEYBOARD                                ;call BIOS keyboard interrupt
  1472 00000082 7504                                            jnz     .40                                             ;exit if key pressed
  1473 00000084 FB                                              sti                                                     ;enable maskable interrupts
  1474 00000085 F4                                              hlt                                                     ;wait for interrupt
  1475 00000086 EBF6                                            jmp     .30                                             ;repeat until keypress
  1476                                  ;
  1477                                  ;       Now that a key has been pressed, we signal the system to restart by driving the B0 line on the 8042
  1478                                  ;       keyboard controller low (OUT 64h,0feh). The restart may take some microseconds to kick in, so we issue
  1479                                  ;       HLT until the system resets.
  1480                                  ;
  1481 00000088 B0FE                    .40                     mov     al,EKEYBCMDRESET                                ;8042 pulse output port pin
  1482 0000008A E664                                            out     EKEYBPORTSTAT,al                                ;drive B0 low to restart
  1483 0000008C FB                      .50                     sti                                                     ;enable maskable interrupts
  1484 0000008D F4                                              hlt                                                     ;stop until reset, int, nmi
  1485 0000008E EBFC                                            jmp     .50                                             ;loop until restart kicks in
  1486                                  ;-----------------------------------------------------------------------------------------------------------------------
  1487                                  ;
  1488                                  ;       Routine:        GetCPUType
  1489                                  ;
  1490                                  ;       Description:    The loader needs only to determine that the cpu is at least an 80386 or an equivalent. Note that
  1491                                  ;                       the CPUID instruction was not introduced until the SL-enhanced 80486 and Pentium processors, so
  1492                                  ;                       to distinguish whether we have at least an 80386, other means must be used.
  1493                                  ;
  1494                                  ;       Out:            AX      0 = 808x, v20, etc.
  1495                                  ;                               1 = 80186
  1496                                  ;                               2 = 80286
  1497                                  ;                               3 = 80386
  1498                                  ;
  1499                                  ;-----------------------------------------------------------------------------------------------------------------------
  1500 00000090 B001                    GetCPUType              mov     al,1                                            ;AL = 1
  1501 00000092 B120                                            mov     cl,32                                           ;shift count
  1502 00000094 D2E8                                            shr     al,cl                                           ;try a 32-bit shift
  1503 00000096 08C0                                            or      al,al                                           ;did the shift happen?
  1504 00000098 7415                                            jz      .10                                             ;yes, cpu is 808x, v20, etc.
  1505                                                          cpu     186
  1506 0000009A 54                                              push    sp                                              ;save stack pointer
  1507 0000009B 59                                              pop     cx                                              ;...into cx
  1508 0000009C 39E1                                            cmp     cx,sp                                           ;did sp decrement before push?
  1509 0000009E 750F                                            jne     .10                                             ;yes, cpu is 80186
  1510                                                          cpu     286
  1511 000000A0 40                                              inc     ax                                              ;AX = 2
  1512 000000A1 0F0106[C200]                                    sgdt    [cbLoaderGDT]                                   ;store gdt reg in work area
  1513 000000A6 8A0E[C700]                                      mov     cl,[cbLoaderGDTHiByte]                          ;CL = hi-order byte
  1514 000000AA FEC1                                            inc     cl                                              ;was hi-byte of GDTR 0xff?
  1515 000000AC 7401                                            jz      .10                                             ;yes, cpu is 80286
  1516 000000AE 40                                              inc     ax                                              ;AX = 3
  1517 000000AF C3                      .10                     ret                                                     ;return
  1518                                  ;-----------------------------------------------------------------------------------------------------------------------
  1519                                  ;
  1520                                  ;       Routine:        PutTTYString
  1521                                  ;
  1522                                  ;       Description:    This routine sends a NUL-terminated string of characters to the TTY output device. We use the
  1523                                  ;                       TTY output function of the BIOS video interrupt, passing the address of the string in DS:SI
  1524                                  ;                       and the BIOS teletype function code in AH. After a return from the BIOS interrupt, we repeat
  1525                                  ;                       for the next string character until a NUL is found. Note that we clear the direction flag (DF)
  1526                                  ;                       with CLD before the first LODSB. The direction flag is not guaranteed to be preserved between
  1527                                  ;                       calls within the OS. However, the "int" instruction does store the EFLAGS register on the
  1528                                  ;                       stack and restores it on return. Therefore, clearing the direction flag before subsequent calls
  1529                                  ;                       to LODSB is not needed.
  1530                                  ;
  1531                                  ;       In:             DS:SI   address of string
  1532                                  ;
  1533                                  ;       Out:            DF      0
  1534                                  ;                       ZF      1
  1535                                  ;                       AL      0
  1536                                  ;
  1537                                  ;-----------------------------------------------------------------------------------------------------------------------
  1538 000000B0 FC                      PutTTYString            cld                                                     ;forward strings
  1539 000000B1 AC                      .10                     lodsb                                                   ;load next byte at DS:SI in AL
  1540 000000B2 84C0                                            test    al,al                                           ;end of string?
  1541 000000B4 7406                                            jz      .20                                             ;... yes, exit our loop
  1542 000000B6 B40E                                            mov     ah,EBIOSFNTTYOUTPUT                             ;BIOS teletype function
  1543 000000B8 CD10                                            int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
  1544 000000BA EBF5                                            jmp     .10                                             ;repeat until done
  1545 000000BC C3                      .20                     ret                                                     ;return
  1546                                  ;-----------------------------------------------------------------------------------------------------------------------
  1547                                  ;
  1548                                  ;       Loader Data
  1549                                  ;
  1550                                  ;       The loader data is updated to include constants defining the initial (Loader) TSS and LDT selectors in the
  1551                                  ;       GDT, a work area to build the GDTR, and additional text messages.
  1552                                  ;
  1553                                  ;-----------------------------------------------------------------------------------------------------------------------
  1554 000000BD 90                                              align   2
  1555 000000BE 5000                    cwLoaderLDT             dw      EGDTLOADERLDT                                   ;loader local descriptor table selector
  1556 000000C0 5800                    cwLoaderTSS             dw      EGDTLOADERTSS                                   ;loader task state segment selector
  1557 000000C2 00<rept>                cbLoaderGDT             times   5 db 0                                          ;6-byte GDTR work area
  1558 000000C7 00                      cbLoaderGDTHiByte       db      0                                               ;hi-order byte
  1559 000000C8 546865206F70657261-     czCPUErrorMsg           db      "The operating system requires an i386 or later processor.",13,10
  1559 000000D1 74696E672073797374-
  1559 000000DA 656D20726571756972-
  1559 000000E3 657320616E20693338-
  1559 000000EC 36206F72206C617465-
  1559 000000F5 722070726F63657373-
  1559 000000FE 6F722E0D0A         
  1560 00000103 506C65617365207072-                             db      "Please press any key to restart the computer.",13,10,0
  1560 0000010C 65737320616E79206B-
  1560 00000115 657920746F20726573-
  1560 0000011E 746172742074686520-
  1560 00000127 636F6D70757465722E-
  1560 00000130 0D0A00             
  1561 00000133 435055204F4B0D0A00      czCPUOKMsg              db      "CPU OK",13,10,0                                ;CPU level ok message
  1562 0000013C 474454207072657061-     czGDTOKMsg              db      "GDT prepared",13,10,0                          ;global descriptor table ok message
  1562 00000145 7265640D0A00       
  1563 0000014B 4B65726E656C206C6F-     czKernelLoadedMsg       db      "Kernel loaded",13,10,0                         ;kernel loaded message
  1563 00000154 616465640D0A00     
  1564 0000015B 5374617274696E6720-     czStartingMsg           db      "Starting OS",13,10,0                           ;starting message
  1564 00000164 4F530D0A00         
  1565 00000169 00<rept>                                        times   1024-($-$$) db 0h                               ;zero fill to end of sector
  1566                                  ;=======================================================================================================================
  1567                                  ;
  1568                                  ;       OS Kernel                                                               @disk: 004600   @mem: 001000
  1569                                  ;
  1570                                  ;       This code is the operating system kernel. It resides on the boot disk image as part of the OS.COM file,
  1571                                  ;       following the 16-bit loader code above. The Kernel executes only 32-bit code in protected mode and contains one
  1572                                  ;       task, the Console, which performs a loop accepting user input from external devices (keyboard, etc.), processes
  1573                                  ;       commands and displays ouput to video memory. The Kernel also includes a library of system functions accessible
  1574                                  ;       through software interrupt 58 (30h). Finally, the Kernel provides CPU and hardware interrupt handlers.
  1575                                  ;
  1576                                  ;=======================================================================================================================
  1577                                  ;=======================================================================================================================
  1578                                  ;
  1579                                  ;       Kernel Tables
  1580                                  ;
  1581                                  ;=======================================================================================================================
  1582                                  ;-----------------------------------------------------------------------------------------------------------------------
  1583                                  ;
  1584                                  ;       Global Descriptor Table                                                 @disk: 004600   @mem: 001000
  1585                                  ;
  1586                                  ;       The Global Descriptor Table (GDT) consists of eight-byte descriptors that define reserved memory areas. The
  1587                                  ;       first descriptor must be all nulls.
  1588                                  ;
  1589                                  ;       6   5         4         3         2         1         0
  1590                                  ;       3210987654321098765432109876543210987654321098765432109876543210
  1591                                  ;       ----------------------------------------------------------------
  1592                                  ;       h......hffffmmmma......ab......................bn..............n
  1593                                  ;
  1594                                  ;       h......h                                                                hi-order base address (bits 24-31)
  1595                                  ;               ffff                                                            flags
  1596                                  ;                   mmmm                                                        hi-order limit (bits 16-19)
  1597                                  ;                       a......a                                                access
  1598                                  ;                               b......................b                        lo-order base address (bits 0-23)
  1599                                  ;                                                       n..............n        lo-order limit (bits 0-15)
  1600                                  ;
  1601                                  ;       00000000                                                                all areas have base addresses below 2^24
  1602                                  ;               0...                                                            single-byte size granularity
  1603                                  ;               1...                                                            4-kilobyte size granularity
  1604                                  ;               .0..                                                            16-bit default for code segments
  1605                                  ;               .1..                                                            32-bit default for code segments
  1606                                  ;               ..0.                                                            intel-reserved; should be zero
  1607                                  ;               ...0                                                            available for operating system use
  1608                                  ;                   0000                                                        segment is less than 2^16 in size
  1609                                  ;                   1111                                                        segment is greater than 2^24-2 in size
  1610                                  ;                       1.......                                                segment is present in memory
  1611                                  ;                       .00.....                                                segment is of privilege level 0
  1612                                  ;                       ...0....                                                segment is of system or gate type
  1613                                  ;                       ...00010                                                local decriptor table (LDT)
  1614                                  ;                       ...01001                                                task state segment (TSS) available
  1615                                  ;                       ...01011                                                task state segment (TSS) busy
  1616                                  ;                       ...10...                                                data segment
  1617                                  ;                       ...10011                                                writable data (accessed)
  1618                                  ;                       ...11...                                                code segment
  1619                                  ;                       ...11011                                                readable non-conforming code (accessed)
  1620                                  ;
  1621                                  ;-----------------------------------------------------------------------------------------------------------------------
  1622                                  section                 gdt                                                     ;global descriptor table
  1623 00000000 0000000000000000                                dq      0000000000000000h                               ;00 required null selector
  1624 00000008 FF07001000934000                                dq      00409300100007FFh                               ;08 2KB  writable data  (GDT alias)
  1625 00000010 FF07001800934000                                dq      00409300180007FFh                               ;10 2KB  writable data  (IDT alias)
  1626 00000018 FFFF00000093CF00                                dq      00CF93000000FFFFh                               ;18 4GB  writable data  (kernel)     DS:
  1627 00000020 FF0F00800B934000                                dq      0040930B80000FFFh                               ;20 4KB  writable data  (CGA)        ES:
  1628 00000028 FF0F000000934000                                dq      0040930000000FFFh                               ;28 4KB  writable stack (Loader)     SS:
  1629 00000030 FFFF0000009B0000                                dq      00009B000000FFFFh                               ;30 64KB readable code  (loader)     CS:
  1630 00000038 FFFF0000FF9B0000                                dq      00009BFF0000FFFFh                               ;38 64KB readable code  (BIOS)
  1631 00000040 FFFF000400934000                                dq      004093000400FFFFh                               ;40 64KB writable data  (BIOS)
  1632 00000048 FF1F0020009B4000                                dq      00409B0020001FFFh                               ;48 8KB  readable code  (kernel)
  1633 00000050 7F00000F00824000                                dq      004082000F00007Fh                               ;50 80B  writable LDT   (loader)
  1634 00000058 7F00800F00894000                                dq      004089000F80007Fh                               ;58 80B  writable TSS   (loader)
  1635 00000060 7F00004700824000                                dq      004082004700007Fh                               ;60 80B  writable LDT   (console)
  1636 00000068 7F00804700894000                                dq      004089004780007Fh                               ;88 80B  writable TSS   (console)
  1637 00000070 00<rept>                                        times   2048-($-$$) db 0h                               ;zero fill to end of section
  1638                                  ;-----------------------------------------------------------------------------------------------------------------------
  1639                                  ;
  1640                                  ;       Interrupt Descriptor Table                                              @disk: 004e00   @mem: 001800
  1641                                  ;
  1642                                  ;       The Interrupt Descriptor Table (IDT) consists of one eight-byte entry (descriptor) for each interrupt. The
  1643                                  ;       descriptors here are of two kinds, interrupt gates and trap gates. The "mint" and "mtrap" macros define the
  1644                                  ;       descriptors, taking only the name of the entry point for the code handling the interrupt.
  1645                                  ;
  1646                                  ;       6   5         4         3         2         1         0
  1647                                  ;       3210987654321098765432109876543210987654321098765432109876543210
  1648                                  ;       ----------------------------------------------------------------
  1649                                  ;       h..............hPzzStttt00000000S..............Sl..............l
  1650                                  ;
  1651                                  ;       h...h   high-order offset (bits 16-31)
  1652                                  ;       P       present (0=unused interrupt)
  1653                                  ;       zz      descriptor privilege level
  1654                                  ;       S       storage segment (must be zero for IDT)
  1655                                  ;       tttt    type: 0101=task, 1110=int, 1111=trap
  1656                                  ;       S...S   handling code selector in GDT
  1657                                  ;       l...l   lo-order offset (bits 0-15)
  1658                                  ;
  1659                                  ;-----------------------------------------------------------------------------------------------------------------------
  1660                                  section                 idt                                                     ;interrupt descriptor table
  1661                                                          mtrap   dividebyzero                                    ;00 divide by zero
  1661                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1661 00000000 00004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1662                                                          mtrap   singlestep                                      ;01 single step
  1662                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1662 00000008 0C004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1663                                                          mtrap   nmi                                             ;02 non-maskable
  1663                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1663 00000010 18004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1664                                                          mtrap   break                                           ;03 break
  1664                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1664 00000018 24004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1665                                                          mtrap   into                                            ;04 into
  1665                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1665 00000020 30004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1666                                                          mtrap   bounds                                          ;05 bounds
  1666                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1666 00000028 3C004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1667                                                          mtrap   badopcode                                       ;06 bad op code
  1667                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1667 00000030 48004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1668                                                          mtrap   nocoproc                                        ;07 no coprocessor
  1668                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1668 00000038 54004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1669                                                          mtrap   doublefault                                     ;08 double-fault
  1669                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1669 00000040 60004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1670                                                          mtrap   operand                                         ;09 operand
  1670                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1670 00000048 6C004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1671                                                          mtrap   badtss                                          ;0a bad TSS
  1671                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1671 00000050 78004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1672                                                          mtrap   notpresent                                      ;0b not-present
  1672                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1672 00000058 84004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1673                                                          mtrap   stacklimit                                      ;0c stack limit
  1673                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1673 00000060 90004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1674                                                          mtrap   protection                                      ;0d general protection fault
  1674                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1674 00000068 9C004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1675                                                          mtrap   int14                                           ;0e (reserved)
  1675                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1675 00000070 A8004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1676                                                          mtrap   int15                                           ;0f (reserved)
  1676                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1676 00000078 B4004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1677                                                          mtrap   coproccalc                                      ;10 (reserved)
  1677                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1677 00000080 C0004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1678                                                          mtrap   int17                                           ;11 (reserved)
  1678                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1678 00000088 CC004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1679                                                          mtrap   int18                                           ;12 (reserved)
  1679                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1679 00000090 D5004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1680                                                          mtrap   int19                                           ;13 (reserved)
  1680                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1680 00000098 DE004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1681                                                          mtrap   int20                                           ;14 (reserved)
  1681                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1681 000000A0 E7004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1682                                                          mtrap   int21                                           ;15 (reserved)
  1682                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1682 000000A8 F0004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1683                                                          mtrap   int22                                           ;16 (reserved)
  1683                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1683 000000B0 F9004800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1684                                                          mtrap   int23                                           ;17 (reserved)
  1684                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1684 000000B8 02014800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1685                                                          mtrap   int24                                           ;18 (reserved)
  1685                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1685 000000C0 0B014800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1686                                                          mtrap   int25                                           ;19 (reserved)
  1686                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1686 000000C8 14014800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1687                                                          mtrap   int26                                           ;1a (reserved)
  1687                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1687 000000D0 1D014800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1688                                                          mtrap   int27                                           ;1b (reserved)
  1688                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1688 000000D8 26014800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1689                                                          mtrap   int28                                           ;1c (reserved)
  1689                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1689 000000E0 2F014800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1690                                                          mtrap   int29                                           ;1d (reserved)
  1690                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1690 000000E8 38014800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1691                                                          mtrap   int30                                           ;1e (reserved)
  1691                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1691 000000F0 41014800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1692                                                          mtrap   int31                                           ;1f (reserved)
  1692                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1692 000000F8 4A014800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1693                                                          mint    clocktick                                       ;20 IRQ0 clock tick
  1693                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1693 00000100 31054800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1694                                                          mint    keyboard                                        ;21 IRQ1 keyboard
  1694                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1694 00000108 82054800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1695                                                          mint    iochannel                                       ;22 IRQ2 second 8259A cascade
  1695                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1695 00000110 D1094800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1696                                                          mint    com2                                            ;23 IRQ3 com2
  1696                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1696 00000118 D4094800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1697                                                          mint    com1                                            ;24 IRQ4 com1
  1697                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1697 00000120 D7094800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1698                                                          mint    lpt2                                            ;25 IRQ5 lpt2
  1698                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1698 00000128 DA094800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1699                                                          mint    diskette                                        ;26 IRQ6 diskette
  1699                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1699 00000130 DD094800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1700                                                          mint    lpt1                                            ;27 IRQ7 lpt1
  1700                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1700 00000138 F7094800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1701                                                          mint    rtclock                                         ;28 IRQ8 real-time clock
  1701                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1701 00000140 FA094800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1702                                                          mint    retrace                                         ;29 IRQ9 CGA vertical retrace
  1702                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1702 00000148 FD094800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1703                                                          mint    irq10                                           ;2a IRQA (reserved)
  1703                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1703 00000150 000A4800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1704                                                          mint    irq11                                           ;2b IRQB (reserved)
  1704                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1704 00000158 030A4800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1705                                                          mint    ps2mouse                                        ;2c IRQC ps/2 mouse
  1705                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1705 00000160 060A4800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1706                                                          mint    coprocessor                                     ;2d IRQD coprocessor
  1706                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1706 00000168 090A4800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1707                                                          mint    fixeddisk                                       ;2e IRQE fixed disk
  1707                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1707 00000170 0C0A4800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1708                                                          mint    irq15                                           ;2f IRQF (reserved)
  1708                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1708 00000178 0F0A4800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1709                                                          mtrap   svc                                             ;30 OS services
  1709                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1709 00000180 210A4800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1710 00000188 00<rept>                                        times   2048-($-$$) db 0h                               ;zero fill to end of section
  1711                                  ;=======================================================================================================================
  1712                                  ;
  1713                                  ;       Interrupt Handlers                                                      @disk: 005600   @mem:  002000
  1714                                  ;
  1715                                  ;       Interrupt handlers are 32-bit routines that receive control either in response to events or by direct
  1716                                  ;       invocation from other kernel code. The interrupt handlers are of three basic types. CPU interrupts occur when a
  1717                                  ;       CPU exception is detected. Hardware interrupts occur when an external device (timer, keyboard, disk, etc.)
  1718                                  ;       signals the CPU on an interrupt request line (IRQ). Software interrupts occur when directly called by other code
  1719                                  ;       using the INT instruction. Each interrupt handler routine is defined by using our "menter" macro, which simply
  1720                                  ;       establishes a label defining the offset address of the entry point from the start of the kernel section. This
  1721                                  ;       label is referenced in the "mint" and "mtrap" macros found in the IDT to specify the address of the handlers.
  1722                                  ;
  1723                                  ;=======================================================================================================================
  1724                                  section                 kernel  vstart=0h                                       ;data offsets relative to 0
  1725                                                          cpu     386                                             ;allow 80386 instructions
  1726                                                          bits    32                                              ;this is 32-bit code
  1727                                  ;=======================================================================================================================
  1728                                  ;
  1729                                  ;       CPU Interrupt Handlers
  1730                                  ;
  1731                                  ;       The first 32 entries in the Interrupt Descriptor Table are reserved for use by CPU interrupts. The handling
  1732                                  ;       of these interrupts is expanded here to display the contents of registers at the time of the interrupt.
  1733                                  ;
  1734                                  ;=======================================================================================================================
  1735                                  ;-----------------------------------------------------------------------------------------------------------------------
  1736                                  ;
  1737                                  ;       INT0    Divide By Zero
  1738                                  ;
  1739                                  ;-----------------------------------------------------------------------------------------------------------------------
  1740                                                          menter  dividebyzero                                    ;divide by zero
  1740                              <1> ?%1 equ ($-$$)
  1741 00000000 6A00                                            push    0                                               ;store interrupt nbr
  1742 00000002 68[29030000]                                    push    czIntDivideByZero                               ;store message offset
  1743 00000007 E947010000                                      jmp     ReportInterrupt                                 ;report interrupt
  1744                                  ;-----------------------------------------------------------------------------------------------------------------------
  1745                                  ;
  1746                                  ;       INT1    Single Step
  1747                                  ;
  1748                                  ;-----------------------------------------------------------------------------------------------------------------------
  1749                                                          menter  singlestep                                      ;single step
  1749                              <1> ?%1 equ ($-$$)
  1750 0000000C 6A01                                            push    1                                               ;store interrupt nbr
  1751 0000000E 68[3A030000]                                    push    czIntSingleStep                                 ;store message offset
  1752 00000013 E93B010000                                      jmp     ReportInterrupt                                 ;report interrupt
  1753                                  ;-----------------------------------------------------------------------------------------------------------------------
  1754                                  ;
  1755                                  ;       INT2    Non-Maskable Interrupt
  1756                                  ;
  1757                                  ;-----------------------------------------------------------------------------------------------------------------------
  1758                                                          menter  nmi                                             ;non-maskable
  1758                              <1> ?%1 equ ($-$$)
  1759 00000018 6A02                                            push    2                                               ;store interrupt nbr
  1760 0000001A 68[46030000]                                    push    czIntNonMaskable                                ;store message offset
  1761 0000001F E92F010000                                      jmp     ReportInterrupt                                 ;report interrupt
  1762                                  ;-----------------------------------------------------------------------------------------------------------------------
  1763                                  ;
  1764                                  ;       INT3    Break
  1765                                  ;
  1766                                  ;-----------------------------------------------------------------------------------------------------------------------
  1767                                                          menter  break                                           ;break
  1767                              <1> ?%1 equ ($-$$)
  1768 00000024 6A03                                            push    3                                               ;store interrupt nbr
  1769 00000026 68[5D030000]                                    push    czIntBreak                                      ;store message offset
  1770 0000002B E923010000                                      jmp     ReportInterrupt                                 ;report interrupt
  1771                                  ;-----------------------------------------------------------------------------------------------------------------------
  1772                                  ;
  1773                                  ;       INT4    Into
  1774                                  ;
  1775                                  ;-----------------------------------------------------------------------------------------------------------------------
  1776                                                          menter  into                                            ;into
  1776                              <1> ?%1 equ ($-$$)
  1777 00000030 6A04                                            push    4                                               ;store interrupt nbr
  1778 00000032 68[63030000]                                    push    czIntInto                                       ;store message offset
  1779 00000037 E917010000                                      jmp     ReportInterrupt                                 ;report interrupt
  1780                                  ;-----------------------------------------------------------------------------------------------------------------------
  1781                                  ;
  1782                                  ;       INT5    Bounds
  1783                                  ;
  1784                                  ;-----------------------------------------------------------------------------------------------------------------------
  1785                                                          menter  bounds                                          ;bounds
  1785                              <1> ?%1 equ ($-$$)
  1786 0000003C 6A05                                            push    5                                               ;store interrupt nbr
  1787 0000003E 68[68030000]                                    push    czIntBounds                                     ;store message offset
  1788 00000043 E90B010000                                      jmp     ReportInterrupt                                 ;report interrupt
  1789                                  ;-----------------------------------------------------------------------------------------------------------------------
  1790                                  ;
  1791                                  ;       INT6    Bad Operation Code
  1792                                  ;
  1793                                  ;-----------------------------------------------------------------------------------------------------------------------
  1794                                                          menter  badopcode                                       ;bad opcode interrupt
  1794                              <1> ?%1 equ ($-$$)
  1795 00000048 6A06                                            push    6                                               ;store interrupt nbr
  1796 0000004A 68[6F030000]                                    push    czIntBadOpCode                                  ;store message offset
  1797 0000004F E9FF000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1798                                  ;-----------------------------------------------------------------------------------------------------------------------
  1799                                  ;
  1800                                  ;       INT7    No Coprocessor
  1801                                  ;
  1802                                  ;-----------------------------------------------------------------------------------------------------------------------
  1803                                                          menter  nocoproc                                        ;no coprocessor interrupt
  1803                              <1> ?%1 equ ($-$$)
  1804 00000054 6A07                                            push    7                                               ;store interrupt nbr
  1805 00000056 68[82030000]                                    push    czIntNoCoprocessor                              ;store message offset
  1806 0000005B E9F3000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1807                                  ;-----------------------------------------------------------------------------------------------------------------------
  1808                                  ;
  1809                                  ;       INT8    Double Fault
  1810                                  ;
  1811                                  ;-----------------------------------------------------------------------------------------------------------------------
  1812                                                          menter  doublefault                                     ;doublefault interrupt
  1812                              <1> ?%1 equ ($-$$)
  1813 00000060 6A08                                            push    8                                               ;store interrupt nbr
  1814 00000062 68[91030000]                                    push    czIntDoubleFault                                ;store message offset
  1815 00000067 E9E7000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1816                                  ;-----------------------------------------------------------------------------------------------------------------------
  1817                                  ;
  1818                                  ;       INT9    Operand
  1819                                  ;
  1820                                  ;-----------------------------------------------------------------------------------------------------------------------
  1821                                                          menter  operand                                         ;operand interrupt
  1821                              <1> ?%1 equ ($-$$)
  1822 0000006C 6A09                                            push    9                                               ;store interrupt nbr
  1823 0000006E 68[9E030000]                                    push    czIntOperand                                    ;store message offset
  1824 00000073 E9DB000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1825                                  ;-----------------------------------------------------------------------------------------------------------------------
  1826                                  ;
  1827                                  ;       INT10   Bad Task State Segment
  1828                                  ;
  1829                                  ;-----------------------------------------------------------------------------------------------------------------------
  1830                                                          menter  badtss                                          ;bad TSS interrupt
  1830                              <1> ?%1 equ ($-$$)
  1831 00000078 6A0A                                            push    10                                              ;store interrupt nbr
  1832 0000007A 68[A6030000]                                    push    czIntBadTSS                                     ;store message offset
  1833 0000007F E9CF000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1834                                  ;-----------------------------------------------------------------------------------------------------------------------
  1835                                  ;
  1836                                  ;       INT11   Not Present
  1837                                  ;
  1838                                  ;-----------------------------------------------------------------------------------------------------------------------
  1839                                                          menter  notpresent                                      ;not present interrupt
  1839                              <1> ?%1 equ ($-$$)
  1840 00000084 6A0B                                            push    11                                              ;store interrupt nbr
  1841 00000086 68[BD030000]                                    push    czIntNotPresent                                 ;store message offset
  1842 0000008B E9C3000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1843                                  ;-----------------------------------------------------------------------------------------------------------------------
  1844                                  ;
  1845                                  ;       INT12   Stack Limit
  1846                                  ;
  1847                                  ;-----------------------------------------------------------------------------------------------------------------------
  1848                                                          menter  stacklimit                                      ;stack limit interrupt
  1848                              <1> ?%1 equ ($-$$)
  1849 00000090 6A0C                                            push    12                                              ;store interrupt nbr
  1850 00000092 68[C9030000]                                    push    czIntStackLimit                                 ;store message offset
  1851 00000097 E9B7000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1852                                  ;-----------------------------------------------------------------------------------------------------------------------
  1853                                  ;
  1854                                  ;       INT13   General Protection Fault
  1855                                  ;
  1856                                  ;-----------------------------------------------------------------------------------------------------------------------
  1857                                                          menter  protection                                      ;protection fault interrupt
  1857                              <1> ?%1 equ ($-$$)
  1858 0000009C 6A0D                                            push    13                                              ;store interrupt nbr
  1859 0000009E 68[D5030000]                                    push    czIntProtection                                 ;store message offset
  1860 000000A3 E9AB000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1861                                  ;-----------------------------------------------------------------------------------------------------------------------
  1862                                  ;
  1863                                  ;       INT14   Reserved
  1864                                  ;
  1865                                  ;-----------------------------------------------------------------------------------------------------------------------
  1866                                                          menter  int14                                           ;(reserved)
  1866                              <1> ?%1 equ ($-$$)
  1867 000000A8 6A0E                                            push    14                                              ;store interrupt nbr
  1868 000000AA 68[06040000]                                    push    czIntReserved                                   ;store message offset
  1869 000000AF E99F000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1870                                  ;-----------------------------------------------------------------------------------------------------------------------
  1871                                  ;
  1872                                  ;       INT15   Reserved
  1873                                  ;
  1874                                  ;-----------------------------------------------------------------------------------------------------------------------
  1875                                                          menter  int15                                           ;(reserved)
  1875                              <1> ?%1 equ ($-$$)
  1876 000000B4 6A0F                                            push    15                                              ;store interrupt nbr
  1877 000000B6 68[06040000]                                    push    czIntReserved                                   ;store message offset
  1878 000000BB E993000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1879                                  ;-----------------------------------------------------------------------------------------------------------------------
  1880                                  ;
  1881                                  ;       INT16   Coprocessor Calculation
  1882                                  ;
  1883                                  ;-----------------------------------------------------------------------------------------------------------------------
  1884                                                          menter  coproccalc                                      ;coprocessor calculation
  1884                              <1> ?%1 equ ($-$$)
  1885 000000C0 6A10                                            push    16                                              ;store interrupt nbr
  1886 000000C2 68[EE030000]                                    push    czIntCoprocessorCalc                            ;store message offset
  1887 000000C7 E987000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1888                                  ;-----------------------------------------------------------------------------------------------------------------------
  1889                                  ;
  1890                                  ;       INT17   Reserved
  1891                                  ;
  1892                                  ;-----------------------------------------------------------------------------------------------------------------------
  1893                                                          menter  int17                                           ;(reserved)
  1893                              <1> ?%1 equ ($-$$)
  1894 000000CC 6A11                                            push    17                                              ;store interrupt nbr
  1895 000000CE 68[06040000]                                    push    czIntReserved                                   ;store message offset
  1896 000000D3 EB7E                                            jmp     ReportInterrupt                                 ;report interrupt
  1897                                  ;-----------------------------------------------------------------------------------------------------------------------
  1898                                  ;
  1899                                  ;       INT18   Reserved
  1900                                  ;
  1901                                  ;-----------------------------------------------------------------------------------------------------------------------
  1902                                                          menter  int18                                           ;(reserved)
  1902                              <1> ?%1 equ ($-$$)
  1903 000000D5 6A12                                            push    18                                              ;store interrupt nbr
  1904 000000D7 68[06040000]                                    push    czIntReserved                                   ;store message offset
  1905 000000DC EB75                                            jmp     ReportInterrupt                                 ;report interrupt
  1906                                  ;-----------------------------------------------------------------------------------------------------------------------
  1907                                  ;
  1908                                  ;       INT19   Reserved
  1909                                  ;
  1910                                  ;-----------------------------------------------------------------------------------------------------------------------
  1911                                                          menter  int19                                           ;(reserved)
  1911                              <1> ?%1 equ ($-$$)
  1912 000000DE 6A13                                            push    19                                              ;store interrupt nbr
  1913 000000E0 68[06040000]                                    push    czIntReserved                                   ;store message offset
  1914 000000E5 EB6C                                            jmp     ReportInterrupt                                 ;report interrupt
  1915                                  ;-----------------------------------------------------------------------------------------------------------------------
  1916                                  ;
  1917                                  ;       INT20   Reserved
  1918                                  ;
  1919                                  ;-----------------------------------------------------------------------------------------------------------------------
  1920                                                          menter  int20                                           ;(reserved)
  1920                              <1> ?%1 equ ($-$$)
  1921 000000E7 6A14                                            push    20                                              ;store interrupt nbr
  1922 000000E9 68[06040000]                                    push    czIntReserved                                   ;store message offset
  1923 000000EE EB63                                            jmp     ReportInterrupt                                 ;report interrupt
  1924                                  ;-----------------------------------------------------------------------------------------------------------------------
  1925                                  ;
  1926                                  ;       INT21   Reserved
  1927                                  ;
  1928                                  ;-----------------------------------------------------------------------------------------------------------------------
  1929                                                          menter  int21                                           ;(reserved)
  1929                              <1> ?%1 equ ($-$$)
  1930 000000F0 6A15                                            push    21                                              ;store interrupt nbr
  1931 000000F2 68[06040000]                                    push    czIntReserved                                   ;store message offset
  1932 000000F7 EB5A                                            jmp     ReportInterrupt                                 ;report interrupt
  1933                                  ;-----------------------------------------------------------------------------------------------------------------------
  1934                                  ;
  1935                                  ;       INT22   Reserved
  1936                                  ;
  1937                                  ;-----------------------------------------------------------------------------------------------------------------------
  1938                                                          menter  int22                                           ;(reserved)
  1938                              <1> ?%1 equ ($-$$)
  1939 000000F9 6A16                                            push    22                                              ;store interrupt nbr
  1940 000000FB 68[06040000]                                    push    czIntReserved                                   ;store message offset
  1941 00000100 EB51                                            jmp     ReportInterrupt                                 ;report interrupt
  1942                                  ;-----------------------------------------------------------------------------------------------------------------------
  1943                                  ;
  1944                                  ;       INT23   Reserved
  1945                                  ;
  1946                                  ;-----------------------------------------------------------------------------------------------------------------------
  1947                                                          menter  int23                                           ;(reserved)
  1947                              <1> ?%1 equ ($-$$)
  1948 00000102 6A17                                            push    23                                              ;store interrupt nbr
  1949 00000104 68[06040000]                                    push    czIntReserved                                   ;store message offset
  1950 00000109 EB48                                            jmp     ReportInterrupt                                 ;report interrupt
  1951                                  ;-----------------------------------------------------------------------------------------------------------------------
  1952                                  ;
  1953                                  ;       INT24   Reserved
  1954                                  ;
  1955                                  ;-----------------------------------------------------------------------------------------------------------------------
  1956                                                          menter  int24                                           ;(reserved)
  1956                              <1> ?%1 equ ($-$$)
  1957 0000010B 6A18                                            push    24                                              ;store interrupt nbr
  1958 0000010D 68[06040000]                                    push    czIntReserved                                   ;store message offset
  1959 00000112 EB3F                                            jmp     ReportInterrupt                                 ;report interrupt
  1960                                  ;-----------------------------------------------------------------------------------------------------------------------
  1961                                  ;
  1962                                  ;       INT25   Reserved
  1963                                  ;
  1964                                  ;-----------------------------------------------------------------------------------------------------------------------
  1965                                                          menter  int25                                           ;(reserved)
  1965                              <1> ?%1 equ ($-$$)
  1966 00000114 6A19                                            push    25                                              ;store interrupt nbr
  1967 00000116 68[06040000]                                    push    czIntReserved                                   ;store message offset
  1968 0000011B EB36                                            jmp     ReportInterrupt                                 ;report interrupt
  1969                                  ;-----------------------------------------------------------------------------------------------------------------------
  1970                                  ;
  1971                                  ;       INT26   Reserved
  1972                                  ;
  1973                                  ;-----------------------------------------------------------------------------------------------------------------------
  1974                                                          menter  int26                                           ;(reserved)
  1974                              <1> ?%1 equ ($-$$)
  1975 0000011D 6A1A                                            push    26                                              ;store interrupt nbr
  1976 0000011F 68[06040000]                                    push    czIntReserved                                   ;store message offset
  1977 00000124 EB2D                                            jmp     ReportInterrupt                                 ;report interrupt
  1978                                  ;-----------------------------------------------------------------------------------------------------------------------
  1979                                  ;
  1980                                  ;       INT27   Reserved
  1981                                  ;
  1982                                  ;-----------------------------------------------------------------------------------------------------------------------
  1983                                                          menter  int27                                           ;(reserved)
  1983                              <1> ?%1 equ ($-$$)
  1984 00000126 6A1B                                            push    27                                              ;store interrupt nbr
  1985 00000128 68[06040000]                                    push    czIntReserved                                   ;store message offset
  1986 0000012D EB24                                            jmp     ReportInterrupt                                 ;report interrupt
  1987                                  ;-----------------------------------------------------------------------------------------------------------------------
  1988                                  ;
  1989                                  ;       INT28   Reserved
  1990                                  ;
  1991                                  ;-----------------------------------------------------------------------------------------------------------------------
  1992                                                          menter  int28                                           ;(reserved)
  1992                              <1> ?%1 equ ($-$$)
  1993 0000012F 6A1C                                            push    28                                              ;store interrupt nbr
  1994 00000131 68[06040000]                                    push    czIntReserved                                   ;store message offset
  1995 00000136 EB1B                                            jmp     ReportInterrupt                                 ;report interrupt
  1996                                  ;-----------------------------------------------------------------------------------------------------------------------
  1997                                  ;
  1998                                  ;       INT29   Reserved
  1999                                  ;
  2000                                  ;-----------------------------------------------------------------------------------------------------------------------
  2001                                                          menter  int29                                           ;(reserved)
  2001                              <1> ?%1 equ ($-$$)
  2002 00000138 6A1D                                            push    29                                              ;store interrupt nbr
  2003 0000013A 68[06040000]                                    push    czIntReserved                                   ;store message offset
  2004 0000013F EB12                                            jmp     ReportInterrupt                                 ;report interrupt
  2005                                  ;-----------------------------------------------------------------------------------------------------------------------
  2006                                  ;
  2007                                  ;       INT30   Reserved
  2008                                  ;
  2009                                  ;-----------------------------------------------------------------------------------------------------------------------
  2010                                                          menter  int30                                           ;(reserved)
  2010                              <1> ?%1 equ ($-$$)
  2011 00000141 6A1E                                            push    30                                              ;store interrupt nbr
  2012 00000143 68[06040000]                                    push    czIntReserved                                   ;store message offset
  2013 00000148 EB09                                            jmp     ReportInterrupt                                 ;report interrupt
  2014                                  ;-----------------------------------------------------------------------------------------------------------------------
  2015                                  ;
  2016                                  ;       INT31   Reserved
  2017                                  ;
  2018                                  ;-----------------------------------------------------------------------------------------------------------------------
  2019                                                          menter  int31                                           ;(reserved)
  2019                              <1> ?%1 equ ($-$$)
  2020 0000014A 6A1F                                            push    31                                              ;store interrupt nbr
  2021 0000014C 68[06040000]                                    push    czIntReserved                                   ;store message offset
  2022 00000151 EB00                                            jmp     ReportInterrupt                                 ;report interrupt
  2023                                  ;-----------------------------------------------------------------------------------------------------------------------
  2024                                  ;
  2025                                  ;       Routine:        ReportInterrupt
  2026                                  ;
  2027                                  ;       Description:    This routine will be used to respond to processor interrupts that are not otherwise handled.
  2028                                  ;                       At this stage, we simply restore the stack and return from the interrupt.
  2029                                  ;
  2030                                  ;       In:             [ESP+16]        EFLAGS                                  stored by interrupt call
  2031                                  ;                       [ESP+12]        CS                                      stored by interrupt call
  2032                                  ;                       [ESP+8]         EIP                                     stored by interrupt call
  2033                                  ;                       [ESP+4]         interrupt number (0-31)                 stored by push instruction
  2034                                  ;                       [ESP+0]         error message address                   stored by push instructions
  2035                                  ;
  2036                                  ;       Out:            N/A             This routine does not exit.
  2037                                  ;
  2038                                  ;-----------------------------------------------------------------------------------------------------------------------
  2039 00000153 1E                      ReportInterrupt         push    ds                                              ;save DS at time of interrupt
  2040 00000154 06                                              push    es                                              ;save ES at time of interrupt
  2041 00000155 60                                              pushad                                                  ;save EAX,ECX,EDX,EBX,EBP,ESP,ESI,EDI
  2042 00000156 89E5                                            mov     ebp,esp                                         ;EBP --> [EDI]
  2043                                  ;
  2044                                  ;       Addressability to registers at the time of the interrupt is now established as:
  2045                                  ;
  2046                                  ;                       [EBP+56]        EFLAGS
  2047                                  ;                       [EBP+52]        CS
  2048                                  ;                       [EBP+48]        EIP
  2049                                  ;                       [EBP+44]        interrupt number (0-31)
  2050                                  ;                       [EBP+40]        error message address
  2051                                  ;                       [EBP+36]        DS
  2052                                  ;                       [EBP+32]        ES
  2053                                  ;                       [EBP+28]        EAX
  2054                                  ;                       [EBP+24]        ECX
  2055                                  ;                       [EBP+20]        EDX
  2056                                  ;                       [EBP+16]        EBX
  2057                                  ;                       [EBP+12]        ESP
  2058                                  ;                       [EBP+8]         EBP
  2059                                  ;                       [EBP+4]         ESI
  2060                                  ;                       [EBP+0]         EDI
  2061                                  ;
  2062 00000158 0E                                              push    cs                                              ;load code selector ...
  2063 00000159 1F                                              pop     ds                                              ;... into DS
  2064 0000015A 6A20                                            push    EGDTCGA                                         ;load CGA memory selector ...
  2065 0000015C 07                                              pop     es                                              ;... into ES
  2066                                  ;
  2067                                  ;       Display the interrupt report boundary box.
  2068                                  ;
  2069 0000015D B10D                                            mov     cl,13                                           ;column
  2070 0000015F B506                                            mov     ch,6                                            ;row
  2071 00000161 B232                                            mov     dl,50                                           ;width
  2072 00000163 B608                                            mov     dh,8                                            ;height
  2073 00000165 B707                                            mov     bh,07h                                          ;attribute
  2074 00000167 E84C030000                                      call    DrawTextDialogBox                               ;draw text dialog box
  2075                                  ;
  2076                                  ;       Display the report header.
  2077                                  ;
  2078 0000016C B10F                                            mov     cl,15                                           ;column
  2079 0000016E B507                                            mov     ch,7                                            ;row
  2080 00000170 BE[0F040000]                                    mov     esi,czIntHeader                                 ;interrupt message header
  2081 00000175 E80F0E0000                                      call    SetConsoleString                                ;draw text string
  2082                                  ;
  2083                                  ;       Display the interrupt description label.
  2084                                  ;
  2085 0000017A B10F                                            mov     cl,15                                           ;column
  2086 0000017C B508                                            mov     ch,8                                            ;row
  2087 0000017E BE[3E040000]                                    mov     esi,czIntLabel                                  ;interrupt message description lead
  2088 00000183 E8010E0000                                      call    SetConsoleString                                ;draw text string
  2089                                  ;
  2090                                  ;       Display the interrupt number.
  2091                                  ;
  2092 00000188 8B452C                                          mov     eax,[ebp+44]                                    ;interrupt number
  2093 0000018B B11A                                            mov     cl,26                                           ;column
  2094 0000018D B508                                            mov     ch,8                                            ;row
  2095 0000018F E8740B0000                                      call    PutConsoleHexByte                               ;draw ASCII hex byte
  2096                                  ;
  2097                                  ;       Display the interrupt name.
  2098                                  ;
  2099 00000194 B11D                                            mov     cl,29                                           ;column
  2100 00000196 B508                                            mov     ch,8                                            ;row
  2101 00000198 8B7528                                          mov     esi,[ebp+40]                                    ;interrupt-specific message
  2102 0000019B E8E90D0000                                      call    SetConsoleString                                ;display interrupt description
  2103                                  ;
  2104                                  ;       Display the register values header.
  2105                                  ;
  2106 000001A0 B10F                                            mov     cl,15                                           ;column
  2107 000001A2 B50A                                            mov     ch,10                                           ;row
  2108 000001A4 BE[4A040000]                                    mov     esi,czIntRegsHeader                             ;interrupt registers header
  2109 000001A9 E8DB0D0000                                      call    SetConsoleString                                ;draw text string
  2110                                  ;
  2111                                  ;       Display the EAX register label and value.
  2112                                  ;
  2113 000001AE B10F                                            mov     cl,15                                           ;column
  2114 000001B0 B50B                                            mov     ch,11                                           ;row
  2115 000001B2 BE[72040000]                                    mov     esi,czIntEAX                                    ;register EAX label
  2116 000001B7 E8CD0D0000                                      call    SetConsoleString                                ;draw label
  2117 000001BC 8B451C                                          mov     eax,[ebp+28]                                    ;EAX value at interrupt
  2118 000001BF B113                                            mov     cl,19                                           ;column
  2119 000001C1 B50B                                            mov     ch,11                                           ;row
  2120 000001C3 E85A0B0000                                      call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2121                                  ;
  2122                                  ;       Display the ECX register label and value.
  2123                                  ;
  2124 000001C8 B10F                                            mov     cl,15                                           ;column
  2125 000001CA B50C                                            mov     ch,12                                           ;row
  2126 000001CC BE[77040000]                                    mov     esi,czIntECX                                    ;label
  2127 000001D1 E8B30D0000                                      call    SetConsoleString                                ;draw label
  2128 000001D6 8B4518                                          mov     eax,[ebp+24]                                    ;ECX value at interrupt
  2129 000001D9 B113                                            mov     cl,19                                           ;column
  2130 000001DB B50C                                            mov     ch,12                                           ;row
  2131 000001DD E8400B0000                                      call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2132                                  ;
  2133                                  ;       Display the EDX register label and value.
  2134                                  ;
  2135 000001E2 B10F                                            mov     cl,15                                           ;column
  2136 000001E4 B50D                                            mov     ch,13                                           ;row
  2137 000001E6 BE[7C040000]                                    mov     esi,czIntEDX                                    ;label
  2138 000001EB E8990D0000                                      call    SetConsoleString                                ;draw label
  2139 000001F0 8B4514                                          mov     eax,[ebp+20]                                    ;EDX value at interrupt
  2140 000001F3 B113                                            mov     cl,19                                           ;column
  2141 000001F5 B50D                                            mov     ch,13                                           ;row
  2142 000001F7 E8260B0000                                      call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2143                                  ;
  2144                                  ;       Display the EBX register label and value.
  2145                                  ;
  2146 000001FC B10F                                            mov     cl,15                                           ;column
  2147 000001FE B50E                                            mov     ch,14                                           ;row
  2148 00000200 BE[81040000]                                    mov     esi,czIntEBX                                    ;label
  2149 00000205 E87F0D0000                                      call    SetConsoleString                                ;draw label
  2150 0000020A 8B4510                                          mov     eax,[ebp+16]                                    ;EBX value at interrupt
  2151 0000020D B113                                            mov     cl,19                                           ;column
  2152 0000020F B50E                                            mov     ch,14                                           ;row
  2153 00000211 E80C0B0000                                      call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2154                                  ;
  2155                                  ;       Display the ESI register label and value.
  2156                                  ;
  2157 00000216 B11D                                            mov     cl,29                                           ;column
  2158 00000218 B50B                                            mov     ch,11                                           ;row
  2159 0000021A BE[86040000]                                    mov     esi,czIntESI                                    ;label
  2160 0000021F E8650D0000                                      call    SetConsoleString                                ;draw label
  2161 00000224 8B4504                                          mov     eax,[ebp+4]                                     ;ESI
  2162 00000227 B121                                            mov     cl,33                                           ;column
  2163 00000229 B50B                                            mov     ch,11                                           ;row
  2164 0000022B E8F20A0000                                      call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2165                                  ;
  2166                                  ;       Display the EDI register label and value.
  2167                                  ;
  2168 00000230 B11D                                            mov     cl,29                                           ;column
  2169 00000232 B50C                                            mov     ch,12                                           ;row
  2170 00000234 BE[8B040000]                                    mov     esi,czIntEDI                                    ;label
  2171 00000239 E84B0D0000                                      call    SetConsoleString                                ;draw label
  2172 0000023E 8B4500                                          mov     eax,[ebp+0]                                     ;EDI
  2173 00000241 B121                                            mov     cl,33                                           ;column
  2174 00000243 B50C                                            mov     ch,12                                           ;row
  2175 00000245 E8D80A0000                                      call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2176                                  ;
  2177                                  ;       Display the EBP register label and value.
  2178                                  ;
  2179 0000024A B11D                                            mov     cl,29                                           ;column
  2180 0000024C B50D                                            mov     ch,13                                           ;row
  2181 0000024E BE[90040000]                                    mov     esi,czIntEBP                                    ;label
  2182 00000253 E8310D0000                                      call    SetConsoleString                                ;draw label
  2183 00000258 8B4508                                          mov     eax,[ebp+8]                                     ;EBP
  2184 0000025B B121                                            mov     cl,33                                           ;column
  2185 0000025D B50D                                            mov     ch,13                                           ;row
  2186 0000025F E8BE0A0000                                      call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2187                                  ;
  2188                                  ;       Display the DS register label and value.
  2189                                  ;
  2190 00000264 B12A                                            mov     cl,42                                           ;column
  2191 00000266 B50B                                            mov     ch,11                                           ;row
  2192 00000268 BE[9A040000]                                    mov     esi,czIntDS                                     ;label
  2193 0000026D E8170D0000                                      call    SetConsoleString                                ;draw label
  2194 00000272 31C0                                            xor     eax,eax                                         ;zero register
  2195 00000274 668B4524                                        mov     ax,[ebp+36]                                     ;DS
  2196 00000278 B12E                                            mov     cl,46                                           ;column
  2197 0000027A B50B                                            mov     ch,11                                           ;row
  2198 0000027C E8B10A0000                                      call    PutConsoleHexWord                               ;draw ASCII hex word
  2199                                  ;
  2200                                  ;       Display the ES register label and value.
  2201                                  ;
  2202 00000281 B12A                                            mov     cl,42                                           ;column
  2203 00000283 B50C                                            mov     ch,12                                           ;row
  2204 00000285 BE[9F040000]                                    mov     esi,czIntES                                     ;label
  2205 0000028A E8FA0C0000                                      call    SetConsoleString                                ;draw label
  2206 0000028F 31C0                                            xor     eax,eax                                         ;zero register
  2207 00000291 668B4520                                        mov     ax,[ebp+32]                                     ;ES
  2208 00000295 B12E                                            mov     cl,46                                           ;column
  2209 00000297 B50C                                            mov     ch,12                                           ;row
  2210 00000299 E8940A0000                                      call    PutConsoleHexWord                               ;draw ASCII hex word
  2211                                  ;
  2212                                  ;       Display the SS register label and value.
  2213                                  ;
  2214 0000029E B12A                                            mov     cl,42                                           ;column
  2215 000002A0 B50D                                            mov     ch,13                                           ;row
  2216 000002A2 BE[A4040000]                                    mov     esi,czIntSS                                     ;label
  2217 000002A7 E8DD0C0000                                      call    SetConsoleString                                ;draw label
  2218 000002AC 31C0                                            xor     eax,eax                                         ;zero register
  2219 000002AE 668CD0                                          mov     ax,ss                                           ;SS
  2220 000002B1 B12E                                            mov     cl,46                                           ;column
  2221 000002B3 B50D                                            mov     ch,13                                           ;row
  2222 000002B5 E8780A0000                                      call    PutConsoleHexWord                               ;draw ASCII hex word
  2223                                  ;
  2224                                  ;       Display the CS register lable and value.
  2225                                  ;
  2226 000002BA B12A                                            mov     cl,42                                           ;column
  2227 000002BC B50E                                            mov     ch,14                                           ;row
  2228 000002BE BE[A9040000]                                    mov     esi,czIntCS                                     ;label
  2229 000002C3 E8C10C0000                                      call    SetConsoleString                                ;draw label
  2230 000002C8 31C0                                            xor     eax,eax                                         ;zero register
  2231 000002CA 668B4534                                        mov     ax,[ebp+52]                                     ;CS
  2232 000002CE B12E                                            mov     cl,46                                           ;column
  2233 000002D0 B50E                                            mov     ch,14                                           ;row
  2234 000002D2 E85B0A0000                                      call    PutConsoleHexWord                               ;draw ASCII hex word
  2235                                  ;
  2236                                  ;       Display the EFLAGS register label and value.
  2237                                  ;
  2238 000002D7 B133                                            mov     cl,51                                           ;column
  2239 000002D9 B50B                                            mov     ch,11                                           ;row
  2240 000002DB BE[AE040000]                                    mov     esi,czIntEFLAGS                                 ;label
  2241 000002E0 E8A40C0000                                      call    SetConsoleString                                ;draw label
  2242 000002E5 8B4538                                          mov     eax,[ebp+56]                                    ;EFLAGS
  2243 000002E8 B137                                            mov     cl,55                                           ;column
  2244 000002EA B50B                                            mov     ch,11                                           ;row
  2245 000002EC E8310A0000                                      call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2246                                  ;
  2247                                  ;       Display the ESP register label and value.
  2248                                  ;
  2249 000002F1 B133                                            mov     cl,51                                           ;column
  2250 000002F3 B50D                                            mov     ch,13                                           ;row
  2251 000002F5 BE[95040000]                                    mov     esi,czIntESP                                    ;label
  2252 000002FA E88A0C0000                                      call    SetConsoleString                                ;draw label
  2253 000002FF 8B450C                                          mov     eax,[ebp+12]                                    ;ESP
  2254 00000302 B137                                            mov     cl,55                                           ;column
  2255 00000304 B50D                                            mov     ch,13                                           ;row
  2256 00000306 E8170A0000                                      call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2257                                  ;
  2258                                  ;       Display the EIP register label and value.
  2259                                  ;
  2260 0000030B B133                                            mov     cl,51                                           ;column
  2261 0000030D B50E                                            mov     ch,14                                           ;row
  2262 0000030F BE[B3040000]                                    mov     esi,czIntEIP                                    ;label
  2263 00000314 E8700C0000                                      call    SetConsoleString                                ;draw label
  2264 00000319 8B4530                                          mov     eax,[ebp+48]                                    ;EIP lo-order 32-bits
  2265 0000031C B137                                            mov     cl,55                                           ;column
  2266 0000031E B50E                                            mov     ch,14                                           ;row
  2267 00000320 E8FD090000                                      call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2268                                  ;
  2269                                  ;       Halt and loop until reset.
  2270                                  ;
  2271 00000325 FB                      .10                     sti                                                     ;enable maskable interrupts
  2272 00000326 F4                                              hlt                                                     ;halt processor
  2273 00000327 EBFC                                            jmp     .10                                             ;resume on interrupt
  2274                                  ;-----------------------------------------------------------------------------------------------------------------------
  2275                                  ;
  2276                                  ;       Processor Interrupt Name Strings
  2277                                  ;
  2278                                  ;-----------------------------------------------------------------------------------------------------------------------
  2279 00000329 4469766973696F6E20-     czIntDivideByZero       db      "Division by zero",0
  2279 00000332 6279207A65726F00   
  2280 0000033A 53696E676C65207374-     czIntSingleStep         db      "Single step",0
  2280 00000343 657000             
  2281 00000346 4E6F6E2D6D61736B61-     czIntNonMaskable        db      "Non-maskable interrupt",0
  2281 0000034F 626C6520696E746572-
  2281 00000358 7275707400         
  2282 0000035D 427265616B00            czIntBreak              db      "Break",0
  2283 00000363 496E746F00              czIntInto               db      "Into",0
  2284 00000368 426F756E647300          czIntBounds             db      "Bounds",0
  2285 0000036F 426164204F70657261-     czIntBadOpCode          db      "Bad Operation Code",0
  2285 00000378 74696F6E20436F6465-
  2285 00000381 00                 
  2286 00000382 4E6F20436F70726F63-     czIntNoCoprocessor      db      "No Coprocessor",0
  2286 0000038B 6573736F7200       
  2287 00000391 446F75626C65204661-     czIntDoubleFault        db      "Double Fault",0
  2287 0000039A 756C7400           
  2288 0000039E 4F706572616E6400        czIntOperand            db      "Operand",0
  2289 000003A6 426164205461736B20-     czIntBadTSS             db      "Bad Task State Segment",0
  2289 000003AF 537461746520536567-
  2289 000003B8 6D656E7400         
  2290 000003BD 4E6F74205072657365-     czIntNotPresent         db      "Not Present",0
  2290 000003C6 6E7400             
  2291 000003C9 537461636B204C696D-     czIntStackLimit         db      "Stack Limit",0
  2291 000003D2 697400             
  2292 000003D5 47656E6572616C2050-     czIntProtection         db      "General Protection Fault",0
  2292 000003DE 726F74656374696F6E-
  2292 000003E7 204661756C7400     
  2293 000003EE 436F70726F63657373-     czIntCoprocessorCalc    db      "Coprocessor Calculation",0
  2293 000003F7 6F722043616C63756C-
  2293 00000400 6174696F6E00       
  2294 00000406 526573657276656400      czIntReserved           db      "Reserved",0
  2295                                  ;-----------------------------------------------------------------------------------------------------------------------
  2296                                  ;
  2297                                  ;       Processor Interrupt Handling Strings
  2298                                  ;
  2299                                  ;-----------------------------------------------------------------------------------------------------------------------
  2300 0000040F 416E20756E68616E64-     czIntHeader             db      "An unhandled processor interrupt has occurred:",0
  2300 00000418 6C65642070726F6365-
  2300 00000421 73736F7220696E7465-
  2300 0000042A 727275707420686173-
  2300 00000433 206F63637572726564-
  2300 0000043C 3A00               
  2301 0000043E 496E74657272757074-     czIntLabel              db      "Interrupt #",0
  2301 00000447 202300             
  2302 0000044A 526567697374657273-     czIntRegsHeader         db      "Registers at the time of the interrupt:",0
  2302 00000453 206174207468652074-
  2302 0000045C 696D65206F66207468-
  2302 00000465 6520696E7465727275-
  2302 0000046E 70743A00           
  2303 00000472 4541583A00              czIntEAX                db      "EAX:",0
  2304 00000477 4543583A00              czIntECX                db      "ECX:",0
  2305 0000047C 4544583A00              czIntEDX                db      "EDX:",0
  2306 00000481 4542583A00              czIntEBX                db      "EBX:",0
  2307 00000486 4553493A00              czIntESI                db      "ESI:",0
  2308 0000048B 4544493A00              czIntEDI                db      "EDI:",0
  2309 00000490 4542503A00              czIntEBP                db      "EBP:",0
  2310 00000495 4553503A00              czIntESP                db      "ESP:",0
  2311 0000049A 2044533A00              czIntDS                 db      " DS:",0
  2312 0000049F 2045533A00              czIntES                 db      " ES:",0
  2313 000004A4 2053533A00              czIntSS                 db      " SS:",0
  2314 000004A9 2043533A00              czIntCS                 db      " CS:",0
  2315 000004AE 464C473A00              czIntEFLAGS             db      "FLG:",0
  2316 000004B3 4549503A00              czIntEIP                db      "EIP:",0
  2317                                  ;-----------------------------------------------------------------------------------------------------------------------
  2318                                  ;
  2319                                  ;       Routine:        DrawTextDialogBox
  2320                                  ;
  2321                                  ;       Description:    This routine opens a text-mode dialog box with an ASCII border.
  2322                                  ;
  2323                                  ;       In:             CL      upper left column (0-79)
  2324                                  ;                       CH      upper left row (0-24)
  2325                                  ;                       DL      column width, excluding border
  2326                                  ;                       DH      row height, excluding border
  2327                                  ;                       BH      color attribute
  2328                                  ;
  2329                                  ;-----------------------------------------------------------------------------------------------------------------------
  2330 000004B8 51                      DrawTextDialogBox       push    ecx                                             ;save non-volatile regs
  2331 000004B9 56                                              push    esi                                             ;
  2332 000004BA 57                                              push    edi                                             ;
  2333 000004BB 06                                              push    es                                              ;
  2334 000004BC 6A20                                            push    EGDTCGA                                         ;load CGA selector ...
  2335 000004BE 07                                              pop     es                                              ;... into ES
  2336                                  ;
  2337                                  ;       Compute target display offset.
  2338                                  ;
  2339 000004BF 31C0                                            xor     eax,eax                                         ;zero register
  2340 000004C1 88E8                                            mov     al,ch                                           ;row
  2341 000004C3 B4A0                                            mov     ah,ECONROWBYTES                                 ;mulitplicand
  2342 000004C5 F6E4                                            mul     ah                                              ;row offset
  2343 000004C7 00C8                                            add     al,cl                                           ;add column
  2344 000004C9 80D400                                          adc     ah,0                                            ;add overflow
  2345 000004CC 00C8                                            add     al,cl                                           ;add column
  2346 000004CE 80D400                                          adc     ah,0                                            ;add overflow
  2347 000004D1 89C7                                            mov     edi,eax                                         ;target row offset
  2348                                  ;
  2349                                  ;       Display top border row.
  2350                                  ;
  2351 000004D3 57                                              push    edi                                             ;save target row offset
  2352 000004D4 88FC                                            mov     ah,bh                                           ;attribute
  2353 000004D6 B0DA                                            mov     al,EASCIIBORDSGLUPRLFT                          ;upper-left single border
  2354 000004D8 66AB                                            stosw                                                   ;display character and attribute
  2355 000004DA B0C4                                            mov     al,EASCIIBORDSGLHORZ                            ;horizontal single border
  2356 000004DC 31C9                                            xor     ecx,ecx                                         ;zero register
  2357 000004DE 88D1                                            mov     cl,dl                                           ;width, excluding border
  2358 000004E0 F366AB                                          rep     stosw                                           ;display horizontal border
  2359 000004E3 B0BF                                            mov     al,EASCIIBORDSGLUPRRGT                          ;upper-right single border
  2360 000004E5 66AB                                            stosw                                                   ;display character and attribute
  2361 000004E7 5F                                              pop     edi                                             ;restore target row offset
  2362 000004E8 81C7A0000000                                    add     edi,ECONROWBYTES                                ;next row
  2363                                  ;
  2364                                  ;       Display dialog box body rows.
  2365                                  ;
  2366 000004EE 31C9                                            xor     ecx,ecx                                         ;zero register
  2367 000004F0 88F1                                            mov     cl,dh                                           ;height, excluding border
  2368 000004F2 51                      .10                     push    ecx                                             ;save remaining rows
  2369 000004F3 57                                              push    edi                                             ;save target row offset
  2370 000004F4 88FC                                            mov     ah,bh                                           ;attribute
  2371 000004F6 B0B3                                            mov     al,EASCIIBORDSGLVERT                            ;vertical single border
  2372 000004F8 66AB                                            stosw                                                   ;display character and attribute
  2373 000004FA B020                                            mov     al,EASCIISPACE                                  ;space
  2374 000004FC 31C9                                            xor     ecx,ecx                                         ;zero register
  2375 000004FE 88D1                                            mov     cl,dl                                           ;width, excluding border
  2376 00000500 F366AB                                          rep     stosw                                           ;display row
  2377 00000503 B0B3                                            mov     al,EASCIIBORDSGLVERT                            ;vertical single border
  2378 00000505 66AB                                            stosw                                                   ;display character and attribute
  2379 00000507 5F                                              pop     edi                                             ;restore target row offset
  2380 00000508 81C7A0000000                                    add     edi,ECONROWBYTES                                ;next row
  2381 0000050E 59                                              pop     ecx                                             ;remaining rows
  2382 0000050F E2E1                                            loop    .10                                             ;next row
  2383                                  ;
  2384                                  ;       Display bottom border row.
  2385                                  ;
  2386 00000511 57                                              push    edi                                             ;save target row offset
  2387 00000512 88FC                                            mov     ah,bh                                           ;attribute
  2388 00000514 B0C0                                            mov     al,EASCIIBORDSGLLWRLFT                          ;lower-left single border
  2389 00000516 66AB                                            stosw                                                   ;display character and attribute
  2390 00000518 B0C4                                            mov     al,EASCIIBORDSGLHORZ                            ;horizontal single border
  2391 0000051A 31C9                                            xor     ecx,ecx                                         ;zero register
  2392 0000051C 88D1                                            mov     cl,dl                                           ;width, excluding border
  2393 0000051E F366AB                                          rep     stosw                                           ;display horizontal border
  2394 00000521 B0D9                                            mov     al,EASCIIBORDSGLLWRRGT                          ;lower-right single border
  2395 00000523 66AB                                            stosw                                                   ;display character and attribute
  2396 00000525 5F                                              pop     edi                                             ;restore target row offset
  2397 00000526 81C7A0000000                                    add     edi,ECONROWBYTES                                ;next row
  2398                                  ;
  2399                                  ;       Restore and return.
  2400                                  ;
  2401 0000052C 07                                              pop     es                                              ;restore non-volatile regs
  2402 0000052D 5F                                              pop     edi                                             ;
  2403 0000052E 5E                                              pop     esi                                             ;
  2404 0000052F 59                                              pop     ecx                                             ;
  2405 00000530 C3                                              ret                                                     ;return
  2406                                  ;=======================================================================================================================
  2407                                  ;
  2408                                  ;       Hardware Device Interupts
  2409                                  ;
  2410                                  ;       The next 16 interrupts are defined as our hardware interrupts. These interrupts vectors (20h-2Fh) are mapped to
  2411                                  ;       the hardware interrupts IRQ0-IRQF by the BIOS when the call to the BIOS is made invoking BIOS function 89h
  2412                                  ;       (BX=2028h).
  2413                                  ;
  2414                                  ;=======================================================================================================================
  2415                                  ;-----------------------------------------------------------------------------------------------------------------------
  2416                                  ;
  2417                                  ;       IRQ0    Clock Tick Interrupt
  2418                                  ;
  2419                                  ;       PC compatible systems contain or emulate the function of the Intel 8253 Programmable Interval Timer (PIT).
  2420                                  ;       Channel 0 of this chip decrements an internal counter to zero and then issues a hardware interrupt. The default
  2421                                  ;       rate at which IRQ0 occurs is approximately 18.2 times per second or, more accurately, 1,573,040 times per day.
  2422                                  ;
  2423                                  ;       Every time IRQ0 occurs, a counter at 40:6c is incremented. When the number of ticks reaches the maximum for one
  2424                                  ;       day, the counter is set to zero and the number of days counter at 40:70 is incremented.
  2425                                  ;
  2426                                  ;       This handler also decrements the floppy drive motor count at 40:40 if it is not zero. When this count reaches
  2427                                  ;       zero, the floppy disk motors are turned off.
  2428                                  ;
  2429                                  ;-----------------------------------------------------------------------------------------------------------------------
  2430                                                          menter  clocktick                                       ;clock tick interrupt
  2430                              <1> ?%1 equ ($-$$)
  2431 00000531 50                                              push    eax                                             ;save non-volatile regs
  2432 00000532 52                                              push    edx                                             ;
  2433 00000533 1E                                              push    ds                                              ;
  2434                                  ;
  2435                                  ;       End the interrupt.
  2436                                  ;
  2437 00000534 E88A0A0000                                      call    PutPrimaryEndOfInt                              ;send EOI to primary PIC
  2438                                  ;
  2439                                  ;       Update the clock tick count and the elapsed days as needed.
  2440                                  ;
  2441 00000539 6A18                                            push    EGDTOSDATA                                      ;load OS data selector ...
  2442 0000053B 1F                                              pop     ds                                              ;... into data segment register
  2443 0000053C A16C040000                                      mov     eax,[wdClockTicks]                              ;EAX = clock ticks
  2444 00000541 40                                              inc     eax                                             ;increment clock ticks
  2445 00000542 3DB0001800                                      cmp     eax,EPITDAYTICKS                                ;clock ticks per day?
  2446 00000547 7208                                            jb      irq0.10                                         ;no, skip ahead
  2447 00000549 FE0570040000                                    inc     byte [wbClockDays]                              ;increment clock days
  2448 0000054F 31C0                                            xor     eax,eax                                         ;reset clock ticks
  2449 00000551 A36C040000              irq0.10                 mov     dword [wdClockTicks],eax                        ;save clock ticks
  2450                                  ;
  2451                                  ;       Decrement floppy disk motor timeout.
  2452                                  ;
  2453 00000556 803D4004000000                                  cmp     byte [wbFDCMotor],0                             ;floppy motor timeout?
  2454 0000055D 741E                                            je      irq0.20                                         ;yes, skip ahead
  2455 0000055F FE0D40040000                                    dec     byte [wbFDCMotor]                               ;decrement motor timeout
  2456 00000565 7516                                            jnz     irq0.20                                         ;skip ahead if non-zero
  2457                                  ;
  2458                                  ;       Turn off the floppy disk motor if appropriate.
  2459                                  ;
  2460 00000567 FB                                              sti                                                     ;enable maskable interrupts
  2461 00000568 B603                    irq0.15                 mov     dh,EFDCPORTHI                                   ;FDC controller port hi
  2462 0000056A B2F4                                            mov     dl,EFDCPORTLOSTAT                               ;FDC main status register
  2463 0000056C EC                                              in      al,dx                                           ;FDC main status byte
  2464 0000056D A810                                            test    al,EFDCSTATBUSY                                 ;test FDC main status for busy
  2465 0000056F 75F7                                            jnz     irq0.15                                         ;wait while busy
  2466 00000571 B00C                                            mov     al,EFDCMOTOROFF                                 ;motor-off / enable/ DMA setting
  2467 00000573 A23F040000                                      mov     byte [wbFDCControl],al                          ;save motor-off setting
  2468 00000578 B603                                            mov     dh,EFDCPORTHI                                   ;FDC port hi
  2469 0000057A B2F2                                            mov     dl,EFDCPORTLOOUT                                ;FDC digital output register
  2470 0000057C EE                                              out     dx,al                                           ;turn motor off
  2471                                  ;
  2472                                  ;       Enable maskable interrupts.
  2473                                  ;
  2474 0000057D FB                      irq0.20                 sti                                                     ;enable maskable interrupts
  2475                                  ;
  2476                                  ;       Restore and return.
  2477                                  ;
  2478 0000057E 1F                                              pop     ds                                              ;restore modified regs
  2479 0000057F 5A                                              pop     edx                                             ;
  2480 00000580 58                                              pop     eax                                             ;
  2481 00000581 CF                                              iretd                                                   ;return
  2482                                  ;-----------------------------------------------------------------------------------------------------------------------
  2483                                  ;
  2484                                  ;       IRQ1    Keyboard Interrupt
  2485                                  ;
  2486                                  ;       This handler is called when an IRQ1 hardware interrupt occurs, caused by a keyboard event. The scan-code(s)
  2487                                  ;       corresponding to the keyboard event are read and message events are appended to the message queue. Since this
  2488                                  ;       code is called in response to a hardware interrupt, no task switch occurs. We need to preseve the state of
  2489                                  ;       ALL modified registers upon return.
  2490                                  ;
  2491                                  ;       Make/Break                      Base            Shift           Message
  2492                                  ;                                                                       KEYDOWN         KEYUP           CHAR
  2493                                  ;                                                                       Norm/Shift      Norm/Shift      Norm/Shift
  2494                                  ;                                                                       AX   AX         AX   AX         AX   AX
  2495                                  ;       01/81                           Escape                          011B/011B       811B/811B       011B/011B
  2496                                  ;       02/82                           1               !               0231/0221       8231/8221       0231/0221
  2497                                  ;       03/83                           2               @               0332/0340       8332/8340       0332/0340
  2498                                  ;       04/84                           3               #               0433/0423       8433/8423       0433/0423
  2499                                  ;       05/85                           4               $               0534/0524       8534/8524       0534/0524
  2500                                  ;       06/86                           5               %               0635/0625       8635/8625       0635/0625
  2501                                  ;       07/87                           6               ^               0736/075E       8736/875E       0736/075E
  2502                                  ;       08/88                           7               &               0837/0826       8837/8826       0837/0826
  2503                                  ;       09/89                           8               *               0938/092A       8938/892A       0938/092A
  2504                                  ;       0A/8A                           9               (               0A39/0A28       8A39/8A28       0A39/9A28
  2505                                  ;       0B/8B                           0               )               0B30/0B29       8B30/8B29       0B30/0B29
  2506                                  ;       0C/8C                           -               _               0C2D/0C5F       8C2D/8C5F       0C2D/0C5F
  2507                                  ;       0D/8D                           =               +               0D3D/0D2B       8D3D/8D2B       0D3D/0D2B
  2508                                  ;       0E/8E                           Backspace                       0E08/0E08       8E08/8E08       0E08/0E08
  2509                                  ;       0F/8F                           Tab                             0F09/0F09       8F09/8F09       0F09/0F09
  2510                                  ;       10/90                           q               Q               1071/1051       9071/9051       1071/1051
  2511                                  ;       11/91                           w               W               1177/1157       9177/9157       1177/1157
  2512                                  ;       12/92                           e               E               1265/1245       9265/9245       1265/1245
  2513                                  ;       13/93                           r               R               1372/1352       9372/9352       1371/1352
  2514                                  ;       14/94                           t               T               1474/1454       9474/9454       1474/1454
  2515                                  ;       15/95                           y               Y               1579/1559       9579/9559       1579/1559
  2516                                  ;       16/96                           u               U               1675/1655       9675/9655       1675/1655
  2517                                  ;       17/97                           i               I               1769/1749       9769/9749       1769/1749
  2518                                  ;       18/98                           o               O               186F/184F       986F/984F       186F/184F
  2519                                  ;       19/99                           p               P               1970/1950       9970/9950       1970/1950
  2520                                  ;       1A/9A                           [               {               1A5B/1A7B       9A5B/9A7B       1A58/1A7B
  2521                                  ;       1B/9B                           ]               }               1B5D/1B7D       9B5D/9B7D       1B5D/1B7D
  2522                                  ;       1C/9C                           Enter                           1C00/1C00       9C00/9C00
  2523                                  ;       1D/9D                           Left Ctrl                       1D00/1D00       9D00/9D00
  2524                                  ;       1E/9E                           a               A               1E61/1E41       9E61/9E41       1E61/1E41
  2525                                  ;       1F/9F                           s               S               1F73/1F53       9F73/9F53       1F73/1F53
  2526                                  ;       20/A0                           d               D               2064/2044       A064/A044       2064/2044
  2527                                  ;       21/A1                           f               F               2166/2146       A166/A146       2166/2146
  2528                                  ;       22/A2                           g               G               2267/2247       A267/A247       2267/2247
  2529                                  ;       23/A3                           h               H               2368/2348       A368/A348       2368/2348
  2530                                  ;       24/A4                           j               J               246A/244A       A46A/A44A       246A/244A
  2531                                  ;       25/A5                           k               K               256B/254B       A56B/A54B       256B/254B
  2532                                  ;       26/A6                           l               L               266C/264C       A66C/A64C       266C/264C
  2533                                  ;       27/A7                           ;               :               273B/273A       A73B/A73A       273B/273A
  2534                                  ;       28/A8                           '               "               2827/2822       A827/A822       2827/2822
  2535                                  ;       29/A9                           `               ~               2960/297E       A960/A97E       2960/297E
  2536                                  ;       2A/AA                           Left Shift                      2A00/2A00       AA00/AA00
  2537                                  ;       2B/AB                           \               |               2B5C/2B7C       AB5C/AB7C       2B5C/2B7C
  2538                                  ;       2C/AC                           z               Z               2C7A/2C5A       AC7A/AC5A       2C7A/2C5A
  2539                                  ;       2D/AD                           x               X               2D78/2D58       AD78/AD58       2D78/2D58
  2540                                  ;       2E/AE                           c               C               2E63/2E43       AE63/AE43       2E63/2E43
  2541                                  ;       2F/AF                           v               V               2F76/2F56       AF76/AF56       2F76/2F56
  2542                                  ;       30/B0                           b               B               3062/3042       B062/B042       3062/3042
  2543                                  ;       31/B1                           n               N               316E/314E       B16E/B14E       316E/314E
  2544                                  ;       32/B2                           m               M               326D/324D       B26D/B24D       326D/324D
  2545                                  ;       33/B3                           ,               <               332C/333C       B32C/B33C       332C/333C
  2546                                  ;       34/B4                           .               >               342E/343E       B42E/B43E       342E/343E
  2547                                  ;       35/B5                           /               ?               352F/353F       B52F/B53F       352F/353F
  2548                                  ;       36/B6                           Right Shift                     3600/3600       B600/B600
  2549                                  ;       37/B7                           Keypad *                        372A/372A       B72A/B72A       372A/372A
  2550                                  ;       38/B8                           Left Alt                        3800/3800       B800/B800
  2551                                  ;       39/B9                           Spacebar                        3920/3920       B920/B920       3920/3920
  2552                                  ;       3A/BA                           Caps Lock                       3A00/3A00       BA00/BA00
  2553                                  ;       3B/BB                           F1                              3B00/3B00       BB00/BB00
  2554                                  ;       3C/BC                           F2                              3C00/3C00       BC00/BC00
  2555                                  ;       3D/BD                           F3                              3D00/3D00       BD00/BD00
  2556                                  ;       3E/BE                           F4                              3E00/3E00       BE00/BE00
  2557                                  ;       3F/BF                           F5                              3F00/3F00       BF00/BF00
  2558                                  ;       40/C0                           F6                              4000/4000       C000/C000
  2559                                  ;       41/C1                           F7                              4100/4100       C100/C100
  2560                                  ;       42/C2                           F8                              4200/4200       C200/C200
  2561                                  ;       43/C3                           F9                              4300/4300       C300/C300
  2562                                  ;       44/C4                           F10                             4400/4400       C400/C400
  2563                                  ;       45/C5                           Num-Lock                        4500/4500       C500/C500
  2564                                  ;       46/C6                           Scroll-Lock                     4600/4600       C600/C600
  2565                                  ;       47/C7                           Keypad-7                        4700/4700       C700/C700
  2566                                  ;       47/C7                           Num-Lock Keypad-7               4737/4737       C737/C737       4737/4737
  2567                                  ;       48/C8                           Keypad-8                        4800/4800       C800/C800
  2568                                  ;       48/C8                           Num-Lock Keypad-8               4838/4838       C838/C838       4838/4838
  2569                                  ;       49/C9                           Keypad-9                        4900/4900       C900/C900
  2570                                  ;       49/C9                           Num-Lock Keypad-9               4939/4939       C939/C939       4939/4939
  2571                                  ;       4A/CA                           Keypad-Minus                    4A2D/4A2D       CA2D/CA2D       4A2D/4A2D
  2572                                  ;       4B/CB                           Keypad-4                        4B00/4B00       CB00/CB00
  2573                                  ;       4B/CB                           Num-Lock Keypad-4               4B34/4B34       CB34/CB34       4B34/4B34
  2574                                  ;       4C/CC                           Keypad-5                        4C00/4C00       CC00/CC00
  2575                                  ;       4C/CC                           Num-Lock Keypad-5               4C35/4C35       CC35/CC35       4C35/4C35
  2576                                  ;       4D/CD                           Keypad-6                        4D00/4D00       CD00/CD00
  2577                                  ;       4D/CD                           Num-Lock Keypad-6               4D36/4D36       CD36/CD36       4D36/4D36
  2578                                  ;       4E/CE                           Keypad-Plus                     4E2B/4E2B       CE2B/CE2B       4E2B/4E2B
  2579                                  ;       4F/CF                           Keypad-1                        4F00/4F00       CF00/CF00
  2580                                  ;       4F/CF                           Num-Lock Keypad-1               4F31/4F31       CF31/CF31       4F31/4F31
  2581                                  ;       50/D0                           Keypad-2                        5000/5000       D000/D000
  2582                                  ;       50/D0                           Num-Lock Keypad-2               5032/5032       D032/D032       5032/5032
  2583                                  ;       51/D1                           Keypad-3                        5100/5100       D100/D100
  2584                                  ;       51/D1                           Num-Lock Keypad-3               5133/5133       D133/D133       5133/5133
  2585                                  ;       52/D2                           Keypad-0                        5200/5200       D200/D200
  2586                                  ;       52/D2                           Num-Lock Keypad-0               5230/5230       D230/D230       5230/5230
  2587                                  ;       53/D3                           Keypad-Period                   537F/537F       D37F/D37F       537F/537F
  2588                                  ;       53/D3                           Num-Lock Keypad-Period          532E/532E       D32E/D32E       532E/532E
  2589                                  ;       54/D4                           Alt-PrntScrn                    5400/5400       D400/D400
  2590                                  ;       57/D7                           F11                             5700/5700       D700/D700
  2591                                  ;       58/D8                           F12                             5800/5800       D800/D800
  2592                                  ;
  2593                                  ;       E0 5B/E0 DB                     Left-Windows                    5B00/5B00       DB00/DB00
  2594                                  ;       E0 5C/E0 DC                     Right-Windows                   5C00/5C00       DC00/DC00
  2595                                  ;       E0 5D/E0 DD                     Right-Click                     5D00/5D00       DD00/DD00
  2596                                  ;
  2597                                  ;       E1 1D 45/E1 9D C5               Pause-Break                    *6500/6500      *E500/E500
  2598                                  ;       E1 1D 45/E1 9D C5               Shift Pause-Break              *6500/6500      *E500/E500
  2599                                  ;       E1 1D 45/E1 9D C5               Alt Pause-Break                *6500/6500      *E500/E500
  2600                                  ;
  2601                                  ;       E0 46/E0 C6                     Ctrl Pause-Break               *6600/6600      *E600/E600
  2602                                  ;
  2603                                  ;       E0 47/E0 C7                     Home                           *6700/6700      *E700/E700
  2604                                  ;       E0 47/E0 AA                     Num-Lock Home                  *6700/6700      *E700/E700
  2605                                  ;       E0 47/E0 2A                     Left-Shift Home                *6700/6700      *E700/E700
  2606                                  ;       E0 47/E0 36                     Right-Shift Home               *6700/6700      *E700/E700
  2607                                  ;
  2608                                  ;       E0 48/E0 C8                     Up-Arrow                       *6800/6800      *E800/E800
  2609                                  ;       E0 48/E0 AA                     Num-Lock Up-Arrow              *6800/6800      *E800/E800
  2610                                  ;       E0 48/E0 2A                     Left-Shift Up-Arrow            *6800/6800      *E800/E800
  2611                                  ;       E0 48/E0 36                     Right-Shift Up-Arrow           *6800/6800      *E800/E800
  2612                                  ;
  2613                                  ;       E0 49/E0 C9                     Page-Up                        *6900/6900      *E900/E900
  2614                                  ;       E0 49/E0 AA                     Num-Lock Page-Up               *6900/6900      *E900/E900
  2615                                  ;       E0 49/E0 2A                     left-Shift Page-Up             *6900/6900      *E900/E900
  2616                                  ;       E0 49/E0 36                     Right-Shift Page-Up            *6900/6900      *E900/E900
  2617                                  ;
  2618                                  ;       E0 4B/E0 CB                     Left-Arrow                     *6B00/6B00      *EB00/EB00
  2619                                  ;       E0 4B/E0 AA                     Num-Lock Left-Arrow            *6B00/6B00      *EB00/EB00
  2620                                  ;       E0 4B/E0 2A                     Left-Shift Left-Arrow          *6B00/6B00      *EB00/EB00
  2621                                  ;       E0 4B/E0 36                     Right-Shift Left-Arrow         *6B00/6B00      *EB00/EB00
  2622                                  ;
  2623                                  ;       E0 4D/E0 CD                     Right-Arrow                    *6D00/6D00      *ED00/ED00
  2624                                  ;       E0 4D/E0 AA                     Num-Lock Right-Arrow           *6D00/6D00      *ED00/ED00
  2625                                  ;       E0 4D/E0 2A                     Left-Shift Right-Arrow         *6D00/6D00      *ED00/ED00
  2626                                  ;       E0 4D/E0 36                     Right-Shift Right-Arrow        *6D00/6D00      *ED00/ED00
  2627                                  ;
  2628                                  ;       E0 4F/E0 CF                     End                            *6F00/6F00      *EF00/EF00
  2629                                  ;       E0 4F/E0 AA                     Num-Lock End                   *6F00/6F00      *EF00/EF00
  2630                                  ;       E0 4F/E0 2A                     Left-Shift End                 *6F00/6F00      *EF00/EF00
  2631                                  ;       E0 4F/E0 36                     Right-Shift End                *6F00/6F00      *EF00/EF00
  2632                                  ;
  2633                                  ;       E0 50/E0 D0                     Down-Arrow                     *7000/7000      *F000/F000
  2634                                  ;       E0 50/E0 AA                     Num-Lock Down-Arrow            *7000/7000      *F000/F000
  2635                                  ;       E0 50/E0 2A                     Left-Shift Down-Arrow          *7000/7000      *F000/F000
  2636                                  ;       E0 50/E0 36                     Right-Shift Down-Arrow         *7000/7000      *F000/F000
  2637                                  ;
  2638                                  ;       E0 51/E0 D1                     Page-Down                      *7100/7100      *F100/F100
  2639                                  ;       E0 51/E0 AA                     Num-Lock Page-Down             *7100/7100      *F100/F100
  2640                                  ;       E0 51/E0 2A                     Left-Shift Page-Down           *7100/7100      *F100/F100
  2641                                  ;       E0 51/E0 36                     Right-Shift Page-Down          *7100/7100      *F100/F100
  2642                                  ;
  2643                                  ;       E0 52/E0 D2                     Insert                         *7200/7200      *F200/F200
  2644                                  ;       E0 52/E0 AA                     Num-Lock Insert                *7200/7200      *F200/F200
  2645                                  ;       E0 52/E0 2A                     Left-Shift Insert              *7200/7200      *F200/F200
  2646                                  ;       E0 52/E0 36                     Right-Shift Insert             *7200/7200      *F200/F200
  2647                                  ;
  2648                                  ;       E0 53/E0 D3                     Delete                         *737F/737F      *F37F/F37F      *737F/737F
  2649                                  ;       E0 53/E0 AA                     Num-Lock Delete                *737F/737F      *F37F/F37F      *737F/737F
  2650                                  ;       E0 53/E0 2A                     Left-Shift Delete              *737F/737F      *F37F/F37F      *737F/737F
  2651                                  ;       E0 53/E0 36                     Right-Shift Delete             *737F/737F      *F37F/F37F      *737F/737F
  2652                                  ;
  2653                                  ;       E0 35/E0 B5                     Keypad-Slash                   *752F/752F      *F52F/F52F      *752F/752F
  2654                                  ;       E0 35/E0 AA                     Num-Lock Keypad-Slash          *752F/752F      *F52F/F52F      *752F/752F
  2655                                  ;       E0 35/E0 2A                     Left-Shift Keypad-Slash        *752F/752F      *F52F/F52F      *752F/752F
  2656                                  ;       E0 35/E0 36                     Right-Shift Keypad-Slash       *752F/752F      *F52F/F52F      *752F/752F
  2657                                  ;
  2658                                  ;       E0 37/E0 B7 E0 AA               PrntScrn                       *7700/7700      *F700/F700
  2659                                  ;       E0 37/E0 B7 E0 B7               Shift/Ctrl PrntScrn            *7700/7700      *F700/F700
  2660                                  ;
  2661                                  ;       E0 38/E0 B8                     Right Alt                      *7800/7800      *F800/F800
  2662                                  ;       E0 1C/E0 9C                     Keypad Enter                   *7C00/7C00      *FC00/FC00
  2663                                  ;       E0 1D/E0 9D                     Right Ctrl                     *7D00/7D00      *FD00/FD00
  2664                                  ;
  2665                                  ;       *OS Custom Scan Code in Messages
  2666                                  ;
  2667                                  ;-----------------------------------------------------------------------------------------------------------------------
  2668                                                          menter  keyboard                                        ;keyboard interrrupt
  2668                              <1> ?%1 equ ($-$$)
  2669 00000582 50                                              push    eax                                             ;save non-volatile regs
  2670 00000583 53                                              push    ebx                                             ;
  2671 00000584 51                                              push    ecx                                             ;
  2672 00000585 52                                              push    edx                                             ;
  2673 00000586 56                                              push    esi                                             ;
  2674 00000587 1E                                              push    ds                                              ;
  2675                                  ;
  2676                                  ;       End the interrupt.
  2677                                  ;
  2678 00000588 E8360A0000                                      call    PutPrimaryEndOfInt                              ;send EOI to primary PIC
  2679                                  ;
  2680                                  ;       Reset codes and flags.
  2681                                  ;
  2682 0000058D 6A18                                            push    EGDTOSDATA                                      ;load OS data selector ...
  2683 0000058F 1F                                              pop     ds                                              ;... into data segment register
  2684 00000590 BE1A0F0000                                      mov     esi,wsKeybData                                  ;keyboard data addr
  2685 00000595 8A4604                                          mov     al,[esi+KEYBDATA.scan]                          ;load previous scan code
  2686 00000598 884606                                          mov     [esi+KEYBDATA.last],al                          ;... into previous scan code field
  2687 0000059B 30C0                                            xor     al,al                                           ;zero reg
  2688 0000059D 884605                                          mov     [esi+KEYBDATA.char],al                          ;zero ASCII char code
  2689 000005A0 884604                                          mov     [esi+KEYBDATA.scan],al                          ;zero ASCII scan code
  2690 000005A3 8806                                            mov     [esi+KEYBDATA.scan0],al                         ;zero scan code buffer 0
  2691 000005A5 884601                                          mov     [esi+KEYBDATA.scan1],al                         ;zero scan code buffer 1
  2692 000005A8 884602                                          mov     [esi+KEYBDATA.scan2],al                         ;zero scan code buffer 2
  2693 000005AB 884603                                          mov     [esi+KEYBDATA.scan3],al                         ;zero scan code buffer 3
  2694 000005AE B080                                            mov     al,EKEYFTIMEOUT                                 ;timeout indicator
  2695 000005B0 F6D0                                            not     al                                              ;status flag mask
  2696 000005B2 204609                                          and     byte [esi+KEYBDATA.status],al                   ;clear timeout indicator
  2697                                  ;
  2698                                  ;       Hold shift and lock settings. Get first scan code. Ignore ACK and NAK from the controller.
  2699                                  ;
  2700 000005B5 8A5E07                                          mov     bl,[esi+KEYBDATA.shift]                         ;shift flags
  2701 000005B8 8A7E08                                          mov     bh,[esi+KEYBDATA.lock]                          ;locl flags
  2702 000005BB E8590A0000                                      call    WaitForKeyOutBuffer                             ;controller timeout?
  2703 000005C0 7442                                            jz      irq1.timeout                                    ;yes, skip ahead
  2704 000005C2 E460                                            in      al,EKEYBPORTDATA                                ;read scan code
  2705 000005C4 3CFA                                            cmp     al,0FAh                                         ;keyboard ACK?
  2706 000005C6 0F84F0010000                                    je      irq1.exit                                       ;yes, branch
  2707 000005CC 3CFC                                            cmp     al,0FCh                                         ;keyboard NAK?
  2708 000005CE 0F84E8010000                                    je      irq1.exit                                       ;yes, branch
  2709 000005D4 8806                                            mov     [esi+KEYBDATA.scan0],al                         ;save scan code 0
  2710                                  ;
  2711                                  ;       If the 1st scan code is e1, take the 2nd and 3rd scan code. Use the 3rd scan code.
  2712                                  ;
  2713 000005D6 3CE1                                            cmp     al,EKEYBCODEEXT1                                ;extended scan code 1? (e1)
  2714 000005D8 7534                                            jne     irq1.notext1                                    ;no, branch
  2715 000005DA E83A0A0000                                      call    WaitForKeyOutBuffer                             ;controller timeout?
  2716 000005DF 7423                                            jz      irq1.timeout                                    ;yes, skip ahead
  2717 000005E1 E460                                            in      al,EKEYBPORTDATA                                ;read scan code
  2718 000005E3 884601                                          mov     [esi+KEYBDATA.scan1],al                         ;save scan code 1 (1d)
  2719 000005E6 E82E0A0000                                      call    WaitForKeyOutBuffer                             ;controller timeout?
  2720 000005EB 7417                                            jz      irq1.timeout                                    ;yes, skip ahead
  2721 000005ED E460                                            in      al,EKEYBPORTDATA                                ;read scan code
  2722 000005EF 884602                                          mov     [esi+KEYBDATA.scan2],al                         ;save scan code 2 (45/c5)
  2723 000005F2 0FB6C0                                          movzx   eax,al                                          ;expand scan code to index
  2724 000005F5 2E8A80[D1070000]                                mov     al,[cs:tscan2ext+eax]                           ;translate scan code
  2725 000005FC 884604                                          mov     [esi+KEYBDATA.scan],al                          ;save final scan code
  2726 000005FF E990010000                                      jmp     irq1.putkeydown                                 ;put key-down message
  2727                                  ;
  2728                                  ;       Handle keyboard read timeout. This should not occur under normal circumstances. Its occurrence suggests an error
  2729                                  ;       in the keyboard scan code handling. An error indicator will be shown in the OIA.
  2730                                  ;
  2731 00000604 B080                    irq1.timeout            mov     al,EKEYFTIMEOUT                                 ;keyboard controller timeout flag
  2732 00000606 084609                                          or      [esi+KEYBDATA.status],al                        ;set controller status
  2733 00000609 E9A9010000                                      jmp     irq1.putoia                                     ;continue
  2734                                  ;
  2735                                  ;       If the 1st scan code is e0, take the 2nd scan code. If the 2nd scan code is b7 get the 2nd pair.
  2736                                  ;
  2737 0000060E 3CE0                    irq1.notext1            cmp     al,EKEYBCODEEXT0                                ;extended scan code 0?
  2738 00000610 0F85BC000000                                    jne     irq1.notext0                                    ;no, branch
  2739 00000616 E8FE090000                                      call    WaitForKeyOutBuffer                             ;controller timeout?
  2740 0000061B 74E7                                            jz      irq1.timeout                                    ;yes, skip ahead
  2741 0000061D E460                                            in      al,EKEYBPORTDATA                                ;read scan code
  2742 0000061F 884601                                          mov     [esi+KEYBDATA.scan1],al                         ;save scan code 1
  2743 00000622 3CB7                                            cmp     al,EKEYBPADASTERISKUP                           ;print-screen (b7)?
  2744 00000624 752C                                            jne     irq1.notprntscrn                                ;no, branch.
  2745                                  ;
  2746                                  ;       Get the second pair of scan-codes. Only the Print Screen key should generate a second pair.
  2747                                  ;
  2748 00000626 E8EE090000                                      call    WaitForKeyOutBuffer                             ;controller timeout?
  2749 0000062B 74D7                                            jz      irq1.timeout                                    ;yes, skip ahead
  2750 0000062D E460                                            in      al,EKEYBPORTDATA                                ;read scan code 2
  2751 0000062F 884602                                          mov     [esi+KEYBDATA.scan2],al                         ;save scan code 2
  2752 00000632 E8E2090000                                      call    WaitForKeyOutBuffer                             ;controller timeout?
  2753 00000637 74CB                                            jz      irq1.timeout                                    ;yes, skip ahead
  2754 00000639 E460                                            in      al,EKEYBPORTDATA                                ;read scan code 3
  2755 0000063B 884603                                          mov     [esi+KEYBDATA.scan3],al                         ;save scan code 3
  2756 0000063E B0F7                                            mov     al,0F7h                                         ;print-screen up
  2757 00000640 884604                                          mov     [esi+KEYBDATA.scan],al                          ;save final scan code
  2758 00000643 E94C010000                                      jmp     irq1.putkeydown                                 ;put key-down message and update OIA
  2759                                  ;
  2760                                  ;       Where needed, use the last scan code and resume above.
  2761                                  ;
  2762 00000648 8A4606                  irq1.uselastscan        mov     al,[esi+KEYBDATA.last]                          ;previous scan code
  2763 0000064B 0C80                                            or      al,EKEYBUP                                      ;set break bit
  2764 0000064D 884604                                          mov     [esi+KEYBDATA.scan],al                          ;save as final scan code
  2765 00000650 EB47                                            jmp     irq1.checkchar                                  ;continue
  2766                                  ;
  2767                                  ;       Some num-lock + extended key combinations return a shift or num-lock make code. Here we need to rely on the
  2768                                  ;       previous scan code to determine what key is in break mode.
  2769                                  ;
  2770 00000652 3C2A                    irq1.notprntscrn        cmp     al,EKEYBSHIFTLDOWN                              ;left-shift down (2a)? left-shift
  2771 00000654 74F2                                            je      irq1.uselastscan                                ;yes, use last scan
  2772 00000656 3CAA                                            cmp     al,EKEYBSHIFTLUP                                ;left-shift up (aa)? num-lock
  2773 00000658 74EE                                            je      irq1.uselastscan                                ;yes, use last scan
  2774 0000065A 3C36                                            cmp     al,EKEYBSHIFTRDOWN                              ;right-shift down (36)? right-shift
  2775 0000065C 74EA                                            je      irq1.uselastscan
  2776                                  ;
  2777                                  ;       All remaining extended codes can be translated. Additionally, some extended scan codes set or reset shift flags
  2778                                  ;       or toggle locks.
  2779                                  ;
  2780 0000065E 0FB6C0                                          movzx   eax,al                                          ;extend scan code to table index
  2781 00000661 2E8A80[D1070000]                                mov     al,[cs:tscan2ext+eax]                           ;translate to alternate scan code
  2782 00000668 884604                                          mov     [esi+KEYBDATA.scan],al                          ;save final scan code
  2783 0000066B B408                                            mov     ah,EKEYFCTRLRIGHT                               ;right control flag
  2784 0000066D 3CFD                                            cmp     al,EKEYBCTRLRUP                                 ;right control up?
  2785 0000066F 7455                                            je      irq1.shiftclear                                 ;yes, reset flag
  2786 00000671 3C7D                                            cmp     al,EKEYBCTRLRDOWN                               ;right control down?
  2787 00000673 744D                                            je      irq1.shiftset                                   ;yes, set flag
  2788 00000675 B420                                            mov     ah,EKEYFALTRIGHT                                ;right alt flag
  2789 00000677 3CF8                                            cmp     al,EKEYBALTRUP                                  ;alt key up code?
  2790 00000679 744B                                            je      irq1.shiftclear                                 ;yes, reset flag
  2791 0000067B 3C78                                            cmp     al,EKEYBALTRDOWN                                ;alt key down code?
  2792 0000067D 7443                                            je      irq1.shiftset                                   ;yes, set flag
  2793 0000067F B440                                            mov     ah,EKEYFWINLEFT                                 ;left win flag
  2794 00000681 3CDB                                            cmp     al,EKEYBWINLUP                                  ;left win up?
  2795 00000683 7441                                            je      irq1.shiftclear                                 ;yes, reset flag
  2796 00000685 3C5B                                            cmp     al,EKEYBWINLDOWN                                ;left win down?
  2797 00000687 7439                                            je      irq1.shiftset                                   ;yes, set flag
  2798 00000689 B480                                            mov     ah,EKEYFWINRIGHT                                ;right win flag
  2799 0000068B 3CDC                                            cmp     al,EKEYBWINRUP                                  ;right win up?
  2800 0000068D 7437                                            je      irq1.shiftclear                                 ;yes, reset flag
  2801 0000068F 3C5C                                            cmp     al,EKEYBWINRDOWN                                ;right win down?
  2802 00000691 742F                                            je      irq1.shiftset                                   ;yes, set flag
  2803 00000693 B408                                            mov     ah,EKEYFLOCKINSERT                              ;insert flag
  2804 00000695 3C72                                            cmp     al,EKEYBINSERTDOWN                              ;translated insert scan code?
  2805 00000697 741A                                            je      irq1.locktoggle                                 ;yes, branch
  2806                                  ;
  2807                                  ;       Extended scan codes for Delete and num-pad slash generate ASCII character codes.
  2808                                  ;
  2809 00000699 247F                    irq1.checkchar          and     al,EKEYBMAKECODEMASK                            ;mask out break bit
  2810 0000069B B27F                                            mov     dl,EASCIIDELETE                                 ;ASCII delete
  2811 0000069D 3C73                                            cmp     al,EKEYBDELETEDOWN                              ;delete down?
  2812 0000069F 740A                                            je      irq1.savechar                                   ;yes, branch
  2813 000006A1 B22F                                            mov     dl,EASCIISLASH                                  ;ASCII slash
  2814 000006A3 3C75                                            cmp     al,EKEYBPADSLASHDOWN                            ;keypad-slash down?
  2815 000006A5 0F85E9000000                                    jne     irq1.putkeydown                                 ;no, put key-down msg and update OIA
  2816 000006AB 885605                  irq1.savechar           mov     [esi+KEYBDATA.char],dl                          ;store ASCII code
  2817 000006AE E9C4000000                                      jmp     irq1.putmessage                                 ;put char, key-down msg and upate OIA
  2818                                  ;
  2819                                  ;       Flip lock toggles if a toggle key (caps-lock, num-lock, scroll-lock, insert)
  2820                                  ;
  2821 000006B3 30E7                    irq1.locktoggle         xor     bh,ah                                           ;toggle lock flag
  2822 000006B5 887E08                                          mov     [esi+KEYBDATA.lock],bh                          ;save lock flags
  2823 000006B8 E81F090000                                      call    SetKeyboardLamps                                ;update keyboard lamps
  2824 000006BD E9F5000000                                      jmp     irq1.putoia                                     ;update OIA
  2825                                  ;
  2826                                  ;       Set/reset shift flags if a shift key (shift, alt, ctrl, windows)
  2827                                  ;
  2828 000006C2 08E3                    irq1.shiftset           or      bl,ah                                           ;set shift flag
  2829 000006C4 EB04                                            jmp     short irq1.shift                                ;skip ahead
  2830 000006C6 F6D4                    irq1.shiftclear         not     ah                                              ;convert flag to mask
  2831 000006C8 20E3                                            and     bl,ah                                           ;reset shift flag
  2832 000006CA 885E07                  irq1.shift              mov     [esi+KEYBDATA.shift],bl                         ;save shift flags
  2833 000006CD E9E5000000                                      jmp     irq1.putoia                                     ;update OIA
  2834                                  ;
  2835                                  ;       Check for shift and lock keys first. Note: When num-lock is set, holding shift while pressing a num-pad causes
  2836                                  ;       a shift break (aa/b6) to be sent ahead of the num-pad key make code.
  2837                                  ;
  2838 000006D2 884604                  irq1.notext0            mov     [esi+KEYBDATA.scan],al                          ;save final scan code
  2839 000006D5 B402                                            mov     ah,EKEYFSHIFTLEFT                               ;left shift flag
  2840 000006D7 3CAA                                            cmp     al,EKEYBSHIFTLUP                                ;left shift key up code?
  2841 000006D9 74EB                                            je      irq1.shiftclear                                 ;yes, reset flag
  2842 000006DB 3C2A                                            cmp     al,EKEYBSHIFTLDOWN                              ;left shift key down code?
  2843 000006DD 74E3                                            je      irq1.shiftset                                   ;yes, set flag
  2844 000006DF B410                                            mov     ah,EKEYFSHIFTRIGHT                              ;right shift flag
  2845 000006E1 3CB6                                            cmp     al,EKEYBSHIFTRUP                                ;right shift key up code?
  2846 000006E3 74E1                                            je      irq1.shiftclear                                 ;yes, reset flag
  2847 000006E5 3C36                                            cmp     al,EKEYBSHIFTRDOWN                              ;right shift key down code?
  2848 000006E7 74D9                                            je      irq1.shiftset                                   ;yes, set flag
  2849 000006E9 B401                                            mov     ah,EKEYFCTRLLEFT                                ;left control flag
  2850 000006EB 3C9D                                            cmp     al,EKEYBCTRLLUP                                 ;control key up code?
  2851 000006ED 74D7                                            je      irq1.shiftclear                                 ;yes, reset flag
  2852 000006EF 3C1D                                            cmp     al,EKEYBCTRLLDOWN                               ;control key down code?
  2853 000006F1 74CF                                            je      irq1.shiftset                                   ;yes, set flag
  2854 000006F3 B404                                            mov     ah,EKEYFALTLEFT                                 ;left alt flag
  2855 000006F5 3CB8                                            cmp     al,EKEYBALTLUP                                  ;alt key up code?
  2856 000006F7 74CD                                            je      irq1.shiftclear                                 ;yes, reset flag
  2857 000006F9 3C38                                            cmp     al,EKEYBALTLDOWN                                ;alt key down code?
  2858 000006FB 74C5                                            je      irq1.shiftset                                   ;yes, set flag
  2859                                  ;
  2860                                  ;       Handle lock keys.
  2861                                  ;
  2862 000006FD B404                                            mov     ah,EKEYFLOCKCAPS                                ;caps-lock flag
  2863 000006FF 3C3A                                            cmp     al,EKEYBCAPSDOWN                                ;caps-lock key down code?
  2864 00000701 74B0                                            je      irq1.locktoggle                                 ;yes, toggle lamps and flags
  2865 00000703 B402                                            mov     ah,EKEYFLOCKNUM                                 ;num-lock flag
  2866 00000705 3C45                                            cmp     al,EKEYBNUMDOWN                                 ;num-lock key down code?
  2867 00000707 74AA                                            je      irq1.locktoggle                                 ;yes, toggle lamps and flags
  2868 00000709 B401                                            mov     ah,EKEYFLOCKSCROLL                              ;scroll-lock flag
  2869 0000070B 3C46                                            cmp     al,EKEYBSCROLLDOWN                              ;scroll-lock key down code?
  2870 0000070D 74A4                                            je      irq1.locktoggle                                 ;yes, toggle lamps and flags
  2871 0000070F F6460802                                        test    byte [esi+KEYBDATA.lock],EKEYFLOCKNUM           ;num-lock?
  2872 00000713 7506                                            jnz     irq1.translate                                  ;yes, branch
  2873 00000715 B408                                            mov     ah,EKEYFLOCKINSERT                              ;insert lock flag
  2874 00000717 3C52                                            cmp     al,EKEYBPADINSERTDOWN                           ;keypad-insert down?
  2875 00000719 7498                                            je      irq1.locktoggle                                 ;yes, toggle lamps and flags
  2876                                  ;
  2877                                  ;       Get base or shifted ASCII char.
  2878                                  ;
  2879 0000071B 247F                    irq1.translate          and     al,EKEYBMAKECODEMASK                            ;make code
  2880 0000071D 0FB6C0                                          movzx   eax,al                                          ;table index
  2881 00000720 BA[D1080000]                                    mov     edx,tscan2ascii                                 ;base table
  2882 00000725 F6460712                                        test    byte [esi+KEYBDATA.shift],EKEYFSHIFT            ;left or right shift?
  2883 00000729 7405                                            jz      irq1.getchar                                    ;no, branch
  2884 0000072B BA[51090000]                                    mov     edx,tscan2shift                                 ;shift rable
  2885 00000730 2E8A0402                irq1.getchar            mov     al,[cs:edx+eax]                                 ;ASCII code
  2886                                  ;
  2887                                  ;       Check if caps-lock and alphabetic.
  2888                                  ;
  2889 00000734 F6460804                                        test    byte [esi+KEYBDATA.lock],EKEYFLOCKCAPS          ;caps-lock?
  2890 00000738 7417                                            jz      irq1.checknum                                   ;no, branch
  2891 0000073A 3C41                                            cmp     al,EASCIIUPPERA                                 ;caps range (low)
  2892 0000073C 7213                                            jb      irq1.checknum                                   ;branch if non-alpha
  2893 0000073E 3C5A                                            cmp     al,EASCIIUPPERZ                                 ;caps range (high)
  2894 00000740 7608                                            jbe     irq1.swapcase                                   ;branch if alpha
  2895 00000742 3C61                                            cmp     al,EASCIILOWERA                                 ;base range (low)
  2896 00000744 720B                                            jb      irq1.checknum                                   ;branch if non-alpha
  2897 00000746 3C7A                                            cmp     al,EASCIILOWERZ                                 ;base range (high)
  2898 00000748 7707                                            ja      irq1.checknum                                   ;branch if alpha
  2899                                  ;
  2900                                  ;       If caps-lock is enabled and the ASCII char is alphabetic, swap the ASCII case bit.
  2901                                  ;
  2902 0000074A 3420                    irq1.swapcase           xor     al,020h                                         ;swap case bit
  2903 0000074C 884605                                          mov     [esi+KEYBDATA.char],al                          ;save ASCII char code
  2904 0000074F EB26                                            jmp     irq1.putmessage                                 ;put char, key-down msgs; update OIA
  2905                                  ;
  2906                                  ;       Check if num-lock and keypad numeral.
  2907                                  ;
  2908 00000751 F6460802                irq1.checknum           test    byte [esi+KEYBDATA.lock],EKEYFLOCKNUM           ;num-lock?
  2909 00000755 741D                                            jz      irq1.notnum                                     ;no, branch
  2910 00000757 8A5604                                          mov     dl,[esi+KEYBDATA.scan]                          ;scan code
  2911 0000075A 80E27F                                          and     dl,EKEYBMAKECODEMASK                            ;make code
  2912 0000075D 80FA47                                          cmp     dl,EKEYBPAD7DOWN                                ;keypad numeral range (low)
  2913 00000760 7212                                            jb      irq1.notnum                                     ;branch if non-numeral
  2914 00000762 80FA53                                          cmp     dl,EKEYBPADDELETEDOWN                           ;keypad numeral range (high)
  2915 00000765 770D                                            ja      irq1.notnum                                     ;branch if non-numeral
  2916 00000767 80EA47                                          sub     dl,EKEYBPAD7DOWN                                ;lookup table index
  2917 0000076A 0FB6D2                                          movzx   edx,dl                                          ;extend to register
  2918 0000076D 2E8A82[C4070000]                                mov     al,[cs:tscankeypad+edx]                         ;translate to numeral equivalent
  2919 00000774 884605                  irq1.notnum             mov     [esi+KEYBDATA.char],al                          ;save ASCII character code
  2920                                  ;
  2921                                  ;       Put messages into the message queue.
  2922                                  ;
  2923 00000777 8A4605                  irq1.putmessage         mov     al,[esi+KEYBDATA.char]                          ;ASCII code
  2924 0000077A 8A6604                                          mov     ah,[esi+KEYBDATA.scan]                          ;final scan code
  2925 0000077D 84C0                                            test    al,al                                           ;printable char?
  2926 0000077F 7413                                            jz      irq1.putkeydown                                 ;no, skip ahead
  2927 00000781 BA00000241                                      mov     edx,EMSGKEYCHAR                                 ;key-character event
  2928 00000786 25FFFF0000                                      and     eax,0FFFFh                                      ;clear high-order word
  2929 0000078B 09C2                                            or      edx,eax                                         ;msg id and codes
  2930 0000078D 31C9                                            xor     ecx,ecx                                         ;null param
  2931 0000078F E8B7070000                                      call    PutMessage                                      ;put message to console
  2932 00000794 8A4605                  irq1.putkeydown         mov     al,[esi+KEYBDATA.char]                          ;ASCII char
  2933 00000797 8A6604                                          mov     ah,[esi+KEYBDATA.scan]                          ;final scan code
  2934 0000079A BA00000041                                      mov     edx,EMSGKEYDOWN                                 ;assume key-down event
  2935 0000079F F6C480                                          test    ah,EKEYBUP                                      ;release scan-code?
  2936 000007A2 7405                                            jz      irq1.makecode                                   ;no, skip ahead
  2937 000007A4 BA00000141                                      mov     edx,EMSGKEYUP                                   ;key-up event
  2938 000007A9 25FFFF0000              irq1.makecode           and     eax,0FFFFh                                      ;clear high-order word
  2939 000007AE 09C2                                            or      edx,eax                                         ;msg id and codes
  2940 000007B0 31C9                                            xor     ecx,ecx                                         ;null param
  2941 000007B2 E894070000                                      call    PutMessage                                      ;put message to console
  2942                                  ;
  2943                                  ;       Update operator information area. Enable maskable ints.
  2944                                  ;
  2945 000007B7 E886050000              irq1.putoia             call    PutConsoleOIA                                   ;OIA shift indicators
  2946 000007BC FB                      irq1.exit               sti                                                     ;enable maskable interrupts
  2947                                  ;
  2948                                  ;       Restore and return.
  2949                                  ;
  2950 000007BD 1F                                              pop     ds                                              ;restore non-volatile regs
  2951 000007BE 5E                                              pop     esi                                             ;
  2952 000007BF 5A                                              pop     edx                                             ;
  2953 000007C0 59                                              pop     ecx                                             ;
  2954 000007C1 5B                                              pop     ebx                                             ;
  2955 000007C2 58                                              pop     eax                                             ;
  2956 000007C3 CF                                              iretd                                                   ;return
  2957                                  ;-----------------------------------------------------------------------------------------------------------------------
  2958                                  ;       Scan-Code to ASCII Translation Tables
  2959                                  ;-----------------------------------------------------------------------------------------------------------------------
  2960                                  ;
  2961                                  ;       Keypad directional to numeral
  2962                                  ;
  2963 000007C4 3738392D3435362B        tscankeypad             db      037h,038h,039h,02Dh,034h,035h,036h,02Bh         ;47-4e  789-456+
  2964 000007CC 313233302E                                      db      031h,032h,033h,030h,02Eh                        ;4f-53  1230.
  2965                                  ;
  2966                                  ;       Scan Code to Extended Scan Code
  2967                                  ;
  2968 000007D1 0000000000000000        tscan2ext               db      000h,000h,000h,000h,000h,000h,000h,000h         ;00-07
  2969 000007D9 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;08-0f
  2970 000007E1 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;10-17
  2971 000007E9 000000007C7D0000                                db      000h,000h,000h,000h,07Ch,07Dh,000h,000h         ;18-1f  1c->7c,1d->7d
  2972 000007F1 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;20-27
  2973 000007F9 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;28-2f
  2974 00000801 0000000000750077                                db      000h,000h,000h,000h,000h,075h,000h,077h         ;30-37  35->75,37->77
  2975 00000809 7800000000000000                                db      078h,000h,000h,000h,000h,000h,000h,000h         ;38-3f  38->78
  2976 00000811 0000000000656667                                db      000h,000h,000h,000h,000h,065h,066h,067h         ;40-47  45->65,46-66,47->67
  2977 00000819 68694A6B4C6D4E6F                                db      068h,069h,04Ah,06Bh,04Ch,06Dh,04Eh,06Fh         ;48-4f  48->68,49->69,4b->6b,4d->6d,4f->6f
  2978 00000821 7071727300000000                                db      070h,071h,072h,073h,000h,000h,000h,000h         ;50-57  50->70,51->71,52->72,53->73
  2979 00000829 0000005B5C5D0000                                db      000h,000h,000h,05Bh,05Ch,05Dh,000h,000h         ;58-5f  5b->5b,5c->5c,5d->5d
  2980 00000831 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;60-67
  2981 00000839 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;68-6f
  2982 00000841 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;70-77
  2983 00000849 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;78-7f
  2984 00000851 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;80-87
  2985 00000859 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;88-8f
  2986 00000861 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;90-97
  2987 00000869 00000000FCFD0000                                db      000h,000h,000h,000h,0FCh,0FDh,000h,000h         ;98-9f  9c->fc,9d->fd
  2988 00000871 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;a0-a7
  2989 00000879 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;a8-af
  2990 00000881 0000000000F500F7                                db      000h,000h,000h,000h,000h,0F5h,000h,0F7h         ;b0-b7  b5->f5,b7->f7
  2991 00000889 F800000000000000                                db      0F8h,000h,000h,000h,000h,000h,000h,000h         ;b8-bf  b8->f8
  2992 00000891 0000000000E5E6E7                                db      000h,000h,000h,000h,000h,0E5h,0E6h,0E7h         ;c0-c7  c5->e5,c6->e6,c7->e7
  2993 00000899 E8E9CAEBCCEDCEEF                                db      0E8h,0E9h,0CAh,0EBh,0CCh,0EDh,0CEh,0EFh         ;c8-cf  c8->e8,c9->e9,cb->eb,cd->ed,cf->ef
  2994 000008A1 F0F1F2F300000000                                db      0F0h,0F1h,0F2h,0F3h,000h,000h,000h,000h         ;d0-d7  d0->f0,d1->f1,d2->f2,d3->f3
  2995 000008A9 000000DBDCDDDE00                                db      000h,000h,000h,0DBh,0DCh,0DDh,0DEh,000h         ;d8-df  db->db,dc->dc,de->de
  2996 000008B1 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;e0-e7
  2997 000008B9 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;e8-ef
  2998 000008C1 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;f0-f7
  2999 000008C9 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;f8-ff
  3000                                  ;
  3001                                  ;       Scan Code to Base ASCII
  3002                                  ;
  3003 000008D1 001B313233343536        tscan2ascii             db      000h,01Bh,031h,032h,033h,034h,035h,036h         ;00-07
  3004 000008D9 373839302D3D0809                                db      037h,038h,039h,030h,02Dh,03Dh,008h,009h         ;08-0f
  3005 000008E1 7177657274797569                                db      071h,077h,065h,072h,074h,079h,075h,069h         ;10-17
  3006 000008E9 6F705B5D00006173                                db      06Fh,070h,05Bh,05Dh,000h,000h,061h,073h         ;18-1f
  3007 000008F1 646667686A6B6C3B                                db      064h,066h,067h,068h,06Ah,06Bh,06Ch,03Bh         ;20-27
  3008 000008F9 2760005C7A786376                                db      027h,060h,000h,05Ch,07Ah,078h,063h,076h         ;28-2f
  3009 00000901 626E6D2C2E2F002A                                db      062h,06Eh,06Dh,02Ch,02Eh,02Fh,000h,02Ah         ;30-37
  3010 00000909 0020000000000000                                db      000h,020h,000h,000h,000h,000h,000h,000h         ;38-3f
  3011 00000911 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;40-47
  3012 00000919 00002D0000002B00                                db      000h,000h,02Dh,000h,000h,000h,02Bh,000h         ;48-4f
  3013 00000921 0000007F00000000                                db      000h,000h,000h,07Fh,000h,000h,000h,000h         ;50-57
  3014 00000929 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;58-5f
  3015 00000931 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;60-67
  3016 00000939 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;68-6f
  3017 00000941 0000007F002F0000                                db      000h,000h,000h,07Fh,000h,02Fh,000h,000h         ;70-77
  3018 00000949 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;78-7f
  3019                                  ;
  3020                                  ;       Scan Code to Shifted ASCII
  3021                                  ;
  3022 00000951 001B21402324255E        tscan2shift             db      000h,01Bh,021h,040h,023h,024h,025h,05Eh         ;80-87
  3023 00000959 262A28295F2B0809                                db      026h,02Ah,028h,029h,05Fh,02Bh,008h,009h         ;88-8f
  3024 00000961 5157455254595549                                db      051h,057h,045h,052h,054h,059h,055h,049h         ;90-97
  3025 00000969 4F507B7D00004153                                db      04Fh,050h,07Bh,07Dh,000h,000h,041h,053h         ;98-9f
  3026 00000971 444647484A4B4C3A                                db      044h,046h,047h,048h,04Ah,04Bh,04Ch,03Ah         ;a0-a7
  3027 00000979 227E007C5A584356                                db      022h,07Eh,000h,07Ch,05Ah,058h,043h,056h         ;a8-af
  3028 00000981 424E4D3C3E3F002A                                db      042h,04Eh,04Dh,03Ch,03Eh,03Fh,000h,02Ah         ;b0-b7
  3029 00000989 0020000000000000                                db      000h,020h,000h,000h,000h,000h,000h,000h         ;b8-bf
  3030 00000991 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;c0-c7
  3031 00000999 00002D0000002B00                                db      000h,000h,02Dh,000h,000h,000h,02Bh,000h         ;c8-cf
  3032 000009A1 0000007F00000000                                db      000h,000h,000h,07Fh,000h,000h,000h,000h         ;d0-d7
  3033 000009A9 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;d8-df
  3034 000009B1 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;e0-e7
  3035 000009B9 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;e8-ef
  3036 000009C1 0000007F002F0000                                db      000h,000h,000h,07Fh,000h,02Fh,000h,000h         ;f0-f7
  3037 000009C9 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;f8-ff
  3038                                  ;-----------------------------------------------------------------------------------------------------------------------
  3039                                  ;
  3040                                  ;       IRQ2    Secondary 8259A Cascade Hardware Interrupt
  3041                                  ;
  3042                                  ;-----------------------------------------------------------------------------------------------------------------------
  3043                                                          menter  iochannel                                       ;secondary 8259A cascade
  3043                              <1> ?%1 equ ($-$$)
  3044 000009D1 50                                              push    eax                                             ;save modified regs
  3045 000009D2 EB45                                            jmp     hwint                                           ;end interrupt and return
  3046                                  ;-----------------------------------------------------------------------------------------------------------------------
  3047                                  ;
  3048                                  ;       IRQ3    Communication Port 2 Hardware Interrupt
  3049                                  ;
  3050                                  ;-----------------------------------------------------------------------------------------------------------------------
  3051                                                          menter  com2                                            ;serial port 2 interrupt
  3051                              <1> ?%1 equ ($-$$)
  3052 000009D4 50                                              push    eax                                             ;save modified regs
  3053 000009D5 EB42                                            jmp     hwint                                           ;end interrupt and return
  3054                                  ;-----------------------------------------------------------------------------------------------------------------------
  3055                                  ;
  3056                                  ;       IRQ4    Communication Port 1 Hardware Interrupt
  3057                                  ;
  3058                                  ;-----------------------------------------------------------------------------------------------------------------------
  3059                                                          menter  com1                                            ;serial port 1 interrupt
  3059                              <1> ?%1 equ ($-$$)
  3060 000009D7 50                                              push    eax                                             ;save modified regs
  3061 000009D8 EB3F                                            jmp     hwint                                           ;end interrupt and return
  3062                                  ;-----------------------------------------------------------------------------------------------------------------------
  3063                                  ;
  3064                                  ;       IRQ5    Parallel Port 2 Hardware Interrupt
  3065                                  ;
  3066                                  ;-----------------------------------------------------------------------------------------------------------------------
  3067                                                          menter  lpt2                                            ;parallel port 2 interrupt
  3067                              <1> ?%1 equ ($-$$)
  3068 000009DA 50                                              push    eax                                             ;save modified regs
  3069 000009DB EB3C                                            jmp     hwint                                           ;end interrupt and return
  3070                                  ;-----------------------------------------------------------------------------------------------------------------------
  3071                                  ;
  3072                                  ;       IRQ6    Diskette Hardware Interrupt
  3073                                  ;
  3074                                  ;-----------------------------------------------------------------------------------------------------------------------
  3075                                                          menter  diskette                                        ;floppy disk interrupt
  3075                              <1> ?%1 equ ($-$$)
  3076 000009DD 50                                              push    eax                                             ;save non-volatile regs
  3077 000009DE 1E                                              push    ds                                              ;
  3078 000009DF E8DF050000                                      call    PutPrimaryEndOfInt                              ;end the interrupt
  3079 000009E4 6A18                                            push    EGDTOSDATA                                      ;load OS data selector ...
  3080 000009E6 1F                                              pop     ds                                              ;... into DS register
  3081 000009E7 A03E040000                                      mov     al,[wbFDCStatus]                                ;AL = FDC calibration status
  3082 000009EC 0C80                                            or      al,10000000b                                    ;set IRQ flag
  3083 000009EE A23E040000                                      mov     [wbFDCStatus],al                                ;update FDC calibration status
  3084 000009F3 FB                                              sti                                                     ;enable maskable interrupts
  3085 000009F4 1F                                              pop     ds                                              ;restore non-volatile regs
  3086 000009F5 58                                              pop     eax                                             ;
  3087 000009F6 CF                                              iretd                                                   ;return from interrupt
  3088                                  ;-----------------------------------------------------------------------------------------------------------------------
  3089                                  ;
  3090                                  ;       IRQ7    Parallel Port 1 Hardware Interrupt
  3091                                  ;
  3092                                  ;-----------------------------------------------------------------------------------------------------------------------
  3093                                                          menter  lpt1                                            ;parallel port 1 interrupt
  3093                              <1> ?%1 equ ($-$$)
  3094 000009F7 50                                              push    eax                                             ;save modified regs
  3095 000009F8 EB1F                                            jmp     hwint                                           ;end interrupt and return
  3096                                  ;-----------------------------------------------------------------------------------------------------------------------
  3097                                  ;
  3098                                  ;       IRQ8    Real-time Clock Hardware Interrupt
  3099                                  ;
  3100                                  ;-----------------------------------------------------------------------------------------------------------------------
  3101                                                          menter  rtclock                                         ;real-time clock interrupt
  3101                              <1> ?%1 equ ($-$$)
  3102 000009FA 50                                              push    eax                                             ;save modified regs
  3103 000009FB EB15                                            jmp     hwwint                                          ;end interrupt and return
  3104                                  ;-----------------------------------------------------------------------------------------------------------------------
  3105                                  ;
  3106                                  ;       IRQ9    CGA Vertical Retrace Hardware Interrupt
  3107                                  ;
  3108                                  ;-----------------------------------------------------------------------------------------------------------------------
  3109                                                          menter  retrace                                         ;CGA vertical retrace interrupt
  3109                              <1> ?%1 equ ($-$$)
  3110 000009FD 50                                              push    eax                                             ;save modified regs
  3111 000009FE EB12                                            jmp     hwwint                                          ;end interrupt and return
  3112                                  ;-----------------------------------------------------------------------------------------------------------------------
  3113                                  ;
  3114                                  ;       IRQ10   Reserved Hardware Interrupt
  3115                                  ;
  3116                                  ;-----------------------------------------------------------------------------------------------------------------------
  3117                                                          menter  irq10                                           ;reserved
  3117                              <1> ?%1 equ ($-$$)
  3118 00000A00 50                                              push    eax                                             ;save modified regs
  3119 00000A01 EB0F                                            jmp     hwwint                                          ;end interrupt and return
  3120                                  ;-----------------------------------------------------------------------------------------------------------------------
  3121                                  ;
  3122                                  ;       IRQ11   Reserved Hardware Interrupt
  3123                                  ;
  3124                                  ;-----------------------------------------------------------------------------------------------------------------------
  3125                                                          menter  irq11                                           ;reserved
  3125                              <1> ?%1 equ ($-$$)
  3126 00000A03 50                                              push    eax                                             ;save modified regs
  3127 00000A04 EB0C                                            jmp     hwwint                                          ;end interrupt and return
  3128                                  ;-----------------------------------------------------------------------------------------------------------------------
  3129                                  ;
  3130                                  ;       IRQ12   PS/2 Mouse Hardware Interrupt
  3131                                  ;
  3132                                  ;-----------------------------------------------------------------------------------------------------------------------
  3133                                                          menter  ps2mouse                                        ;PS/2 mouse interrupt
  3133                              <1> ?%1 equ ($-$$)
  3134 00000A06 50                                              push    eax                                             ;save modified regs
  3135 00000A07 EB09                                            jmp     hwwint                                          ;end interrupt and return
  3136                                  ;-----------------------------------------------------------------------------------------------------------------------
  3137                                  ;
  3138                                  ;       IRQ13   Coprocessor Hardware Interrupt
  3139                                  ;
  3140                                  ;-----------------------------------------------------------------------------------------------------------------------
  3141                                                          menter  coprocessor                                     ;coprocessor interrupt
  3141                              <1> ?%1 equ ($-$$)
  3142 00000A09 50                                              push    eax                                             ;save modified regs
  3143 00000A0A EB06                                            jmp     hwwint                                          ;end interrupt and return
  3144                                  ;-----------------------------------------------------------------------------------------------------------------------
  3145                                  ;
  3146                                  ;       IRQ14   Fixed Disk Hardware Interrupt
  3147                                  ;
  3148                                  ;-----------------------------------------------------------------------------------------------------------------------
  3149                                                          menter  fixeddisk                                       ;fixed disk interrupt
  3149                              <1> ?%1 equ ($-$$)
  3150 00000A0C 50                                              push    eax                                             ;save modified regs
  3151 00000A0D EB03                                            jmp     hwwint                                          ;end interrupt and return
  3152                                  ;-----------------------------------------------------------------------------------------------------------------------
  3153                                  ;
  3154                                  ;       IRQ15   Reserved Hardware Interrupt
  3155                                  ;
  3156                                  ;-----------------------------------------------------------------------------------------------------------------------
  3157                                                          menter  irq15                                           ;reserved
  3157                              <1> ?%1 equ ($-$$)
  3158 00000A0F 50                                              push    eax                                             ;save modified regs
  3159 00000A10 EB00                                            jmp     hwwint                                          ;end interrupt and return
  3160                                  ;-----------------------------------------------------------------------------------------------------------------------
  3161                                  ;
  3162                                  ;       Exit from hardware interrupt
  3163                                  ;
  3164                                  ;-----------------------------------------------------------------------------------------------------------------------
  3165 00000A12 E8B1050000              hwwint                  call    PutSecondaryEndOfInt                            ;send EOI to secondary PIC
  3166 00000A17 EB05                                            jmp     hwint90                                         ;skip ahead
  3167 00000A19 E8A5050000              hwint                   call    PutPrimaryEndOfInt                              ;send EOI to primary PIC
  3168 00000A1E FB                      hwint90                 sti                                                     ;enable maskable interrupts
  3169 00000A1F 58                                              pop     eax                                             ;restore modified regs
  3170 00000A20 CF                                              iretd                                                   ;return from interrupt
  3171                                  ;-----------------------------------------------------------------------------------------------------------------------
  3172                                  ;
  3173                                  ;       INT 30h Operating System Software Service Interrupt
  3174                                  ;
  3175                                  ;       Interrupt 30h is used by our operating system as an entry point for many commonly-used subroutines reusable by
  3176                                  ;       any task. These routines include low-level i/o functions that shield applications from having to handle
  3177                                  ;       device-specific communications. On entry to this interrupt, AL contains a function number that is used to load
  3178                                  ;       the entry address of the specific function from a table.
  3179                                  ;
  3180                                  ;-----------------------------------------------------------------------------------------------------------------------
  3181                                                          menter  svc
  3181                              <1> ?%1 equ ($-$$)
  3182 00000A21 3C0D                                            cmp     al,maxtsvc                                      ;is our function out of range?
  3183 00000A23 730D                                            jae     svc90                                           ;yes, skip ahead
  3184 00000A25 0FB6C0                                          movzx   eax,al                                          ;function
  3185 00000A28 C1E002                                          shl     eax,2                                           ;offset into table
  3186 00000A2B 2EFF90[330A0000]                                call    dword [cs:tsvc+eax]                             ;far call to indirect address
  3187 00000A32 CF                      svc90                   iretd                                                   ;return from interrupt
  3188                                  ;-----------------------------------------------------------------------------------------------------------------------
  3189                                  ;
  3190                                  ;       Service Request Table
  3191                                  ;
  3192                                  ;
  3193                                  ;       These tsvce macros expand to define an address vector table for the service request interrupt (int 30h).
  3194                                  ;
  3195                                  ;-----------------------------------------------------------------------------------------------------------------------
  3196                                  tsvc                    tsvce   AllocateMemory                                  ;allocate memory block
  3196                              <1> tsvc :
  3196                              <1> e%1 equ ($-tsvc)/4
  3196 00000A33 [670A0000]          <1>  dd %1
  3197                                                          tsvce   CompareMemory                                   ;compare memory
  3197                              <1> e%1 equ ($-tsvc)/4
  3197 00000A37 [C20C0000]          <1>  dd %1
  3198                                                          tsvce   DecimalToUnsigned                               ;convert decimal string to unsigned integer
  3198                              <1> e%1 equ ($-tsvc)/4
  3198 00000A3B [A50E0000]          <1>  dd %1
  3199                                                          tsvce   FreeMemory                                      ;free memory block
  3199                              <1> e%1 equ ($-tsvc)/4
  3199 00000A3F [850B0000]          <1>  dd %1
  3200                                                          tsvce   GetConsoleMessage                               ;get message
  3200                              <1> e%1 equ ($-tsvc)/4
  3200 00000A43 [FE0C0000]          <1>  dd %1
  3201                                                          tsvce   HexadecimalToUnsigned                           ;convert hexadecimal string to unsigned integer
  3201                              <1> e%1 equ ($-tsvc)/4
  3201 00000A47 [D80E0000]          <1>  dd %1
  3202                                                          tsvce   PlaceCursor                                     ;place the cursor at the current loc
  3202                              <1> e%1 equ ($-tsvc)/4
  3202 00000A4B [990F0000]          <1>  dd %1
  3203                                                          tsvce   PutConsoleOIA                                   ;display the operator information area
  3203                              <1> e%1 equ ($-tsvc)/4
  3203 00000A4F [420D0000]          <1>  dd %1
  3204                                                          tsvce   ResetSystem                                     ;reset system using 8042 chip
  3204                              <1> e%1 equ ($-tsvc)/4
  3204 00000A53 [CD0F0000]          <1>  dd %1
  3205                                                          tsvce   SetKeyboardLamps                                ;turn keboard LEDs on or off
  3205                              <1> e%1 equ ($-tsvc)/4
  3205 00000A57 [DC0F0000]          <1>  dd %1
  3206                                                          tsvce   UnsignedToHexadecimal                           ;convert unsigned integer to hexadecimal string
  3206                              <1> e%1 equ ($-tsvc)/4
  3206 00000A5B [F60E0000]          <1>  dd %1
  3207                                                          tsvce   UpperCaseString                                 ;upper-case string
  3207                              <1> e%1 equ ($-tsvc)/4
  3207 00000A5F [DF0C0000]          <1>  dd %1
  3208                                                          tsvce   Yield                                           ;yield to system
  3208                              <1> e%1 equ ($-tsvc)/4
  3208 00000A63 [A20E0000]          <1>  dd %1
  3209                                  maxtsvc                 equ     ($-tsvc)/4                                      ;function out of range
  3210                                  ;-----------------------------------------------------------------------------------------------------------------------
  3211                                  ;
  3212                                  ;       Service Request Macros
  3213                                  ;
  3214                                  ;       These macros provide positional parameterization of service request calls.
  3215                                  ;
  3216                                  ;-----------------------------------------------------------------------------------------------------------------------
  3217                                  %macro                  allocateMemory 1
  3218                                                          mov     ecx,%1                                          ;bytes to allocate
  3219                                                          mov     al,eAllocateMemory                              ;allocate memory fn.
  3220                                                          int     _svc                                            ;invoke OS service
  3221                                  %endmacro
  3222                                  %macro                  compareMemory 0
  3223                                                          mov     al,eCompareMemory                               ;function code
  3224                                                          int     _svc                                            ;invoke OS service
  3225                                  %endmacro
  3226                                  %macro                  decimalToUnsigned 0
  3227                                                          mov     al,eDecimalToUnsigned                           ;function code
  3228                                                          int     _svc                                            ;invoke OS servie
  3229                                  %endmacro
  3230                                  %macro                  freeMemory 1
  3231                                                          mov     edx,%1                                          ;address of memory block
  3232                                                          mov     al,eFreeMemory                                  ;function code
  3233                                                          int     _svc                                            ;invoke OS service
  3234                                  %endmacro
  3235                                  %macro                  getConsoleMessage 0
  3236                                                          mov     al,eGetConsoleMessage                           ;function code
  3237                                                          int     _svc                                            ;invoke OS service
  3238                                  %endmacro
  3239                                  %macro                  hexadecimalToUnsigned 0
  3240                                                          mov     al,eHexadecimalToUnsigned                       ;function code
  3241                                                          int     _svc                                            ;invoke OS service
  3242                                  %endmacro
  3243                                  %macro                  placeCursor 0
  3244                                                          mov     al,ePlaceCursor                                 ;function code
  3245                                                          int     _svc                                            ;invoke OS service
  3246                                  %endmacro
  3247                                  %macro                  putConsoleOIA 0
  3248                                                          mov     al,ePutConsoleOIA                               ;function code
  3249                                                          int     _svc                                            ;invoke OS service
  3250                                  %endmacro
  3251                                  %macro                  resetSystem 0
  3252                                                          mov     al,eResetSystem                                 ;function code
  3253                                                          int     _svc                                            ;invoke OS service
  3254                                  %endmacro
  3255                                  %macro                  setKeyboardLamps 0
  3256                                                          mov     al,eSetKeyboardLamps                            ;function code
  3257                                                          int     _svc                                            ;invoke OS service
  3258                                  %endmacro
  3259                                  %macro                  unsignedToHexadecimal 0
  3260                                                          mov     al,eUnsignedToHexadecimal                       ;function code
  3261                                                          int     _svc                                            ;invoke OS service
  3262                                  %endmacro
  3263                                  %macro                  upperCaseString 0
  3264                                                          mov     al,eUpperCaseString                             ;function code
  3265                                                          int     _svc                                            ;invoke OS service
  3266                                  %endmacro
  3267                                  %macro                  yield 0
  3268                                                          mov     al,eYield                                       ;function code
  3269                                                          int     _svc                                            ;invoke OS service
  3270                                  %endmacro
  3271                                  ;=======================================================================================================================
  3272                                  ;
  3273                                  ;       Kernel Function Library
  3274                                  ;
  3275                                  ;=======================================================================================================================
  3276                                  ;=======================================================================================================================
  3277                                  ;
  3278                                  ;       Memory Helper Routines
  3279                                  ;
  3280                                  ;       AllocateMemory
  3281                                  ;       FreeMemory
  3282                                  ;
  3283                                  ;=======================================================================================================================
  3284                                  ;-----------------------------------------------------------------------------------------------------------------------
  3285                                  ;
  3286                                  ;       Routine:        AllocateMemory
  3287                                  ;
  3288                                  ;       Description:    This routine allocates a memory block for the given task.
  3289                                  ;
  3290                                  ;       In:             ECX     bytes of memory to allocate
  3291                                  ;
  3292                                  ;       Out:            EAX     !0      address of user portion of newly allocated memory block
  3293                                  ;                               0       unable to allocate memory
  3294                                  ;
  3295                                  ;-----------------------------------------------------------------------------------------------------------------------
  3296 00000A67 53                      AllocateMemory          push    ebx                                             ;save non-volatile regs
  3297 00000A68 51                                              push    ecx                                             ;
  3298 00000A69 56                                              push    esi                                             ;
  3299 00000A6A 1E                                              push    ds                                              ;
  3300                                  ;
  3301                                  ;       Address kernel memory structures
  3302                                  ;
  3303 00000A6B 6A18                                            push    EGDTOSDATA                                      ;load OS data GDT selector ...
  3304 00000A6D 1F                                              pop     ds                                              ;... into data segment reg
  3305 00000A6E BE240F0000                                      mov     esi,wsConsoleMemRoot                            ;memory root structure address
  3306                                  ;
  3307                                  ;       Set requested size to minimum block size if requested size is too small.
  3308                                  ;
  3309 00000A73 81F900010000                                    cmp     ecx,EMEMMINSIZE                                 ;is requested size too small?
  3310 00000A79 7305                                            jae     .10                                             ;no, branch
  3311 00000A7B B900010000                                      mov     ecx,EMEMMINSIZE                                 ;set requested size to minimum
  3312 00000A80 83C120                  .10                     add     ecx,EMEMBLOCKLEN                                ;add header block length
  3313                                  ;
  3314                                  ;       Find the first free memory block large enough to satisfy the request.
  3315                                  ;
  3316 00000A83 8B4608                                          mov     eax,[esi+MEMROOT.firstfree]                     ;first free block ptr
  3317 00000A86 85C0                    .20                     test    eax,eax                                         ;end of free block chain?
  3318 00000A88 0F84F2000000                                    jz      .220                                            ;yes, branch
  3319 00000A8E 3B4804                                          cmp     ecx,[eax+MEMBLOCK.bytes]                        ;free block big enough?
  3320 00000A91 7605                                            jbe     .30                                             ;yes, branch
  3321 00000A93 8B4018                                          mov     eax,[eax+MEMBLOCK.nextblock]                    ;next free block addr
  3322 00000A96 EBEE                                            jmp     .20                                             ;continue
  3323                                  ;-----------------------------------------------------------------------------------------------------------------------
  3324                                  ;
  3325                                  ;       Address the previous and next free memory blocks.
  3326                                  ;
  3327 00000A98 8B581C                  .30                     mov     ebx,[eax+MEMBLOCK.previousblock]                ;previous free block addr
  3328 00000A9B 8B5018                                          mov     edx,[eax+MEMBLOCK.nextblock]                    ;next free block addr
  3329                                  ;
  3330                                  ;       Remove the free memory block from the forward free memory block chain.
  3331                                  ;
  3332 00000A9E 85DB                                            test    ebx,ebx                                         ;any previous free memory block?
  3333 00000AA0 7405                                            jz      .40                                             ;no, branch
  3334 00000AA2 895318                                          mov     [ebx+MEMBLOCK.nextblock],edx                    ;remove free block from forwrad chain
  3335 00000AA5 EB03                                            jmp     .50                                             ;continue
  3336 00000AA7 895608                  .40                     mov     [esi+MEMROOT.firstfree],edx                     ;next free is now also the first free
  3337                                  ;
  3338                                  ;       Remove the free memory block from the reverse free memory block chain.
  3339                                  ;
  3340 00000AAA 85D2                    .50                     test    edx,edx                                         ;any next free memory block?
  3341 00000AAC 7405                                            jz      .60                                             ;no, branch
  3342 00000AAE 895A1C                                          mov     [edx+MEMBLOCK.previousblock],ebx                ;remove free block from reverse chain
  3343 00000AB1 EB03                                            jmp     .70                                             ;continue
  3344 00000AB3 895E0C                  .60                     mov     [esi+MEMROOT.lastfree],ebx                      ;previous free is now also the last free
  3345                                  ;-----------------------------------------------------------------------------------------------------------------------
  3346                                  ;
  3347                                  ;       Determine if the free memory block can be split.
  3348                                  ;
  3349 00000AB6 8B5804                  .70                     mov     ebx,[eax+MEMBLOCK.bytes]                        ;size of free memory block
  3350 00000AB9 29CB                                            sub     ebx,ecx                                         ;subtract requested memory size
  3351 00000ABB 81FB00010000                                    cmp     ebx,EMEMMINSIZE                                 ;remaining block can stand alone?
  3352 00000AC1 7263                                            jb      .150                                            ;no, branch
  3353                                  ;
  3354                                  ;       We know that our block can be split to create a new free memory block. We update the size of our free memory
  3355                                  ;       block to the requested memory size. We update the next contiguous block pointer to point just past the end
  3356                                  ;       of the requested memory size.
  3357                                  ;
  3358 00000AC3 894804                                          mov     [eax+MEMBLOCK.bytes],ecx                        ;shorten memory block size
  3359 00000AC6 89C2                                            mov     edx,eax                                         ;memory block address
  3360 00000AC8 01CA                                            add     edx,ecx                                         ;address new new next contig block
  3361 00000ACA 8B4810                                          mov     ecx,[eax+MEMBLOCK.nextcontig]                   ;next contig block address
  3362 00000ACD 895010                                          mov     [eax+MEMBLOCK.nextcontig],edx                   ;update next contig block address
  3363                                  ;
  3364                                  ;       If there is a next contiguous block, we update that memory block's previous contig pointer to point to the new
  3365                                  ;       free block we are splitting off. If there is no next contiguous block, we update the last contig block pointer.
  3366                                  ;
  3367 00000AD0 E305                                            jecxz   .80                                             ;no next contig, branch
  3368 00000AD2 895114                                          mov     [ecx+MEMBLOCK.previouscontig],edx               ;update previous contig pointer
  3369 00000AD5 EB03                                            jmp     .90                                             ;continue
  3370 00000AD7 895604                  .80                     mov     [esi+MEMROOT.lastcontig],edx                    ;update last contig pointer
  3371                                  ;
  3372                                  ;       Now that the contig block pointers have been updated, we initialize the new free block members.
  3373                                  ;
  3374 00000ADA 895A04                  .90                     mov     [edx+MEMBLOCK.bytes],ebx                        ;set the block size
  3375 00000ADD 894A10                                          mov     [edx+MEMBLOCK.nextcontig],ecx                   ;set the next contig block addr
  3376 00000AE0 894214                                          mov     [edx+MEMBLOCK.previouscontig],eax               ;set the previous contig block addr
  3377 00000AE3 BB46524545                                      mov     ebx,EMEMFREECODE                                ;free memory signature
  3378 00000AE8 891A                                            mov     [edx+MEMBLOCK.signature],ebx                    ;set the block signature
  3379 00000AEA 31DB                                            xor     ebx,ebx                                         ;zero register
  3380 00000AEC 895A0C                                          mov     [edx+MEMBLOCK.reserved],ebx                     ;set reserved
  3381 00000AEF 895A08                                          mov     [edx+MEMBLOCK.owner],ebx                        ;set the owner
  3382                                  ;
  3383                                  ;       Find the proper location in the free block chain for the new free block
  3384                                  ;
  3385 00000AF2 8B5A04                                          mov     ebx,[edx+MEMBLOCK.bytes]                        ;free block size
  3386 00000AF5 8B4E08                                          mov     ecx,[esi+MEMROOT.firstfree]                     ;first free block addr
  3387 00000AF8 E30A                    .100                    jecxz   .110                                            ;branch if at end of chain
  3388 00000AFA 3B5904                                          cmp     ebx,[ecx+MEMBLOCK.bytes]                        ;new block smaller or equal?
  3389 00000AFD 7605                                            jbe     .110                                            ;yes, branch
  3390 00000AFF 8B4918                                          mov     ecx,[ecx+MEMBLOCK.nextblock]                    ;next free block addr
  3391 00000B02 EBF4                                            jmp     .100                                            ;continue
  3392                                  ;
  3393                                  ;       Having found the proper location for our new free block, we store the address of the following free block, or
  3394                                  ;       zero if our new free block is larger than any other, as our next free block. Then, we take the address of our
  3395                                  ;       next block's previous block or the global last-free block as our new previous block and update the previous
  3396                                  ;       block of hte next block, if there is one.
  3397                                  ;
  3398 00000B04 894A18                  .110                    mov     [edx+MEMBLOCK.nextblock],ecx                    ;set the new free block's next ptr
  3399 00000B07 8B5E0C                                          mov     ebx,[esi+MEMROOT.lastfree]                      ;last free block addr
  3400 00000B0A E308                                            jecxz   .120                                            ;branch if no next block
  3401 00000B0C 8B591C                                          mov     ebx,[ecx+MEMBLOCK.previousblock]                ;next block's previous block
  3402 00000B0F 89511C                                          mov     [ecx+MEMBLOCK.previousblock],edx                ;set the next block's previous block
  3403 00000B12 EB03                                            jmp     .130                                            ;continue
  3404 00000B14 89560C                  .120                    mov     [esi+MEMROOT.lastfree],edx                      ;set the new last free block
  3405                                  ;
  3406                                  ;       Store our previous block pointer. If we have a previous free block, update that block's next block pointer to
  3407                                  ;       point to the new block. Since the new block may now be the first or last user block, we update the first and/or
  3408                                  ;       last user block pointers if necessary.
  3409                                  ;
  3410 00000B17 895A1C                  .130                    mov     [edx+MEMBLOCK.previousblock],ebx                ;set the previous block pointer
  3411 00000B1A 85DB                                            test    ebx,ebx                                         ;is there a previous block?
  3412 00000B1C 7405                                            jz      .140                                            ;no, branch
  3413 00000B1E 895318                                          mov     [ebx+MEMBLOCK.nextblock],edx                    ;set the previous block's next ptr
  3414 00000B21 EB03                                            jmp     .150                                            ;continue
  3415 00000B23 895608                  .140                    mov     [esi+MEMROOT.firstfree],edx                     ;set the new first free ptr
  3416                                  ;
  3417                                  ;       Update the newly allocated block's owner and signature.
  3418                                  ;
  3419 00000B26 BA55534552              .150                    mov     edx,EMEMUSERCODE                                ;user memory signature
  3420 00000B2B 8910                                            mov     [eax+MEMBLOCK.signature],edx                    ;set the block signature
  3421 00000B2D 31D2                                            xor     edx,edx                                         ;zero register
  3422 00000B2F 660F00CA                                        str     dx                                              ;load the task state register
  3423 00000B33 895008                                          mov     [eax+MEMBLOCK.owner],edx                        ;set the block owner
  3424                                  ;
  3425                                  ;       Remove the allocated block from the free block chain and insert it into the user block chain.
  3426                                  ;
  3427 00000B36 8B4E10                                          mov     ecx,[esi+MEMROOT.firsttask]                     ;first task block
  3428 00000B39 E323                    .160                    jecxz   .180                                            ;branch if at end of chain
  3429 00000B3B 3B5108                                          cmp     edx,[ecx+MEMBLOCK.owner]                        ;does this block belong to the task?
  3430 00000B3E 721E                                            jb      .180                                            ;branch if block belongs to next task
  3431 00000B40 7405                                            je      .170                                            ;branch if block belongs to this task
  3432 00000B42 8B4918                                          mov     ecx,[ecx+MEMBLOCK.nextblock]                    ;next task block
  3433 00000B45 EBF2                                            jmp     .160                                            ;continue
  3434                                  ;
  3435                                  ;       We have found the start of our task's user block chain or the start of the next task's user block chain. If we
  3436                                  ;       have found the next task's chain, then we have no other user memory for this task and we can simply add the
  3437                                  ;       block here. If we are at the start of our task's user block chain, then we need to further seek for the proper
  3438                                  ;       place to insert the block.
  3439                                  ;
  3440 00000B47 8B5004                  .170                    mov     edx,[eax+MEMBLOCK.bytes]                        ;size of block in bytes
  3441 00000B4A 3B5104                                          cmp     edx,[ecx+MEMBLOCK.bytes]                        ;less or equal to chain block?
  3442 00000B4D 760F                                            jbe     .180                                            ;yes, branch
  3443 00000B4F 8B4918                                          mov     ecx,[ecx+MEMBLOCK.nextblock]                    ;next chain block address
  3444 00000B52 85C9                                            test    ecx,ecx                                         ;end of chain?
  3445 00000B54 7408                                            jz      .180                                            ;yes, branch
  3446 00000B56 8B5008                                          mov     edx,[eax+MEMBLOCK.owner]                        ;owning task
  3447 00000B59 3B5108                                          cmp     edx,[ecx+MEMBLOCK.owner]                        ;same task?
  3448 00000B5C 74E9                                            je      .170                                            ;yes, continue search
  3449                                  ;
  3450                                  ;       We have found the proper place in our task's user-block chain to insert our new user block. It may also be the
  3451                                  ;       end of the user-block chain. To insert our new user block, first we update the next-block pointer. Then, we load
  3452                                  ;       the next-block's previous-block pointer or the global last-user block pointer if we have no next-block. If we
  3453                                  ;       do have a previous-block, we update that block's next-block pointer.
  3454                                  ;
  3455 00000B5E 894818                  .180                    mov     [eax+MEMBLOCK.nextblock],ecx                    ;set the next task block
  3456 00000B61 8B5E14                                          mov     ebx,[esi+MEMROOT.lasttask]                      ;last task block
  3457 00000B64 E308                                            jecxz   .190                                            ;branch if no next-task block
  3458 00000B66 8B591C                                          mov     ebx,[ecx+MEMBLOCK.previousblock]                ;next-task's previous-task block
  3459 00000B69 89411C                                          mov     [ecx+MEMBLOCK.previousblock],eax                ;update next-task block's previous-task
  3460 00000B6C EB03                                            jmp     .200                                            ;continue
  3461 00000B6E 894614                  .190                    mov     [esi+MEMROOT.lasttask],eax                      ;new block is the last user-block
  3462                                  ;
  3463                                  ;       Now wes tore our previous-block pointer and, if we have a previous-free block, we update that block's next-
  3464                                  ;       block pointer to point to our block. Since our block may now be the first or last user-block, we update the
  3465                                  ;       global first and/or last user-block pointers if necessary.
  3466                                  ;
  3467 00000B71 89581C                  .200                    mov     [eax+MEMBLOCK.previousblock],ebx                ;set the previous task block
  3468 00000B74 85DB                                            test    ebx,ebx                                         ;do we have a previous task block?
  3469 00000B76 7405                                            jz      .210                                            ;no, branch
  3470 00000B78 894318                                          mov     [ebx+MEMBLOCK.nextblock],eax                    ;set previous-block's next-task block
  3471 00000B7B EB03                                            jmp     .220                                            ;continue
  3472 00000B7D 894610                  .210                    mov     [esi+MEMROOT.firsttask],eax                     ;new block is the first user-block
  3473                                  ;
  3474                                  ;       Restore registers and return to caller.
  3475                                  ;
  3476 00000B80 1F                      .220                    pop     ds                                              ;restore non-volatie regs
  3477 00000B81 5E                                              pop     esi                                             ;
  3478 00000B82 59                                              pop     ecx                                             ;
  3479 00000B83 5B                                              pop     ebx                                             ;
  3480 00000B84 C3                                              ret                                                     ;return
  3481                                  ;-----------------------------------------------------------------------------------------------------------------------
  3482                                  ;
  3483                                  ;       Routine:        FreeMemory
  3484                                  ;
  3485                                  ;       Description:    This routine frees a memory block for the given task. The address provided in EDX points to the
  3486                                  ;                       memory block header. The memory block must be USER memory, not a FREE memory block. If the block
  3487                                  ;                       is adjacent to a contiguous FREE memory block, then the blocks are merged. The residual FREE
  3488                                  ;                       memory is repositioned in the FREE memory block chain according to size. The user portion of the
  3489                                  ;                       block, following the block header, is reset (wiped) with the memory wipe value.
  3490                                  ;
  3491                                  ;       In:             EDX     memory block to free, relative to EGDTOSDATA
  3492                                  ;
  3493                                  ;       Out:            EAX     -1      invalid memory block
  3494                                  ;                               0       memory block freed
  3495                                  ;
  3496                                  ;-----------------------------------------------------------------------------------------------------------------------
  3497 00000B85 53                      FreeMemory              push    ebx                                             ;save non-volatile regs
  3498 00000B86 51                                              push    ecx                                             ;
  3499 00000B87 56                                              push    esi                                             ;
  3500 00000B88 57                                              push    edi                                             ;
  3501 00000B89 1E                                              push    ds                                              ;
  3502 00000B8A 06                                              push    es                                              ;
  3503                                  ;
  3504                                  ;       Address the root memory structure
  3505                                  ;
  3506 00000B8B 6A18                                            push    EGDTOSDATA                                      ;load OS data selector ...
  3507 00000B8D 07                                              pop     es                                              ;... into extra segment reg
  3508 00000B8E 6A18                                            push    EGDTOSDATA                                      ;load OS data selector ...
  3509 00000B90 1F                                              pop     ds                                              ;... into data segment reg
  3510 00000B91 BE240F0000                                      mov     esi,wsConsoleMemRoot                            ;memory root structure
  3511 00000B96 89D7                                            mov     edi,edx                                         ;memory block address
  3512                                  ;
  3513                                  ;       If the block is FREE, return success. Otherwise, if it is not USER, return with error.
  3514                                  ;
  3515 00000B98 31C0                                            xor     eax,eax                                         ;indicate success
  3516 00000B9A 813F46524545                                    cmp     dword [edi+MEMBLOCK.signature],EMEMFREECODE     ;is the block FREE?
  3517 00000BA0 0F8415010000                                    je      .240                                            ;yes, branch
  3518 00000BA6 48                                              dec     eax                                             ;indicate failure
  3519 00000BA7 813F55534552                                    cmp     dword [edi+MEMBLOCK.signature],EMEMUSERCODE     ;is the block USER?
  3520 00000BAD 0F8508010000                                    jne     .240                                            ;no, branch
  3521                                  ;-----------------------------------------------------------------------------------------------------------------------
  3522                                  ;
  3523                                  ;       Unlink the USER memory block.
  3524                                  ;
  3525                                  ;-----------------------------------------------------------------------------------------------------------------------
  3526                                  ;
  3527                                  ;       Set the block signature. Reset owner.
  3528                                  ;
  3529 00000BB3 C70746524545                                    mov     dword [edi+MEMBLOCK.signature],EMEMFREECODE     ;set FREE block signature
  3530 00000BB9 31C0                                            xor     eax,eax                                         ;zero register
  3531 00000BBB 894708                                          mov     [edi+MEMBLOCK.owner],eax                        ;zero block owner
  3532                                  ;
  3533                                  ;       Wipe user area.
  3534                                  ;
  3535 00000BBE 57                                              push    edi                                             ;save block address
  3536 00000BBF 8B4F04                                          mov     ecx,[edi+MEMBLOCK.bytes]                        ;block size
  3537 00000BC2 83E920                                          sub     ecx,EMEMBLOCKLEN                                ;subtract header size
  3538 00000BC5 83C720                                          add     edi,EMEMBLOCKLEN                                ;point to user area
  3539 00000BC8 B000                                            mov     al,EMEMWIPEBYTE                                 ;memory wipe byte
  3540 00000BCA F3AA                                            rep     stosb                                           ;clear memory
  3541 00000BCC 5F                                              pop     edi                                             ;restore block address
  3542                                  ;
  3543                                  ;       Address the preceding and following USER memory blocks
  3544                                  ;
  3545 00000BCD 8B5F1C                                          mov     ebx,[edi+MEMBLOCK.previousblock]                ;previous block pointer
  3546 00000BD0 8B4F18                                          mov     ecx,[edi+MEMBLOCK.nextblock]                    ;next block pointer
  3547                                  ;
  3548                                  ;       If a USER block precedes this block, update that block's next pointer. Otherwise, update the first task
  3549                                  ;       pointer to point to the USER block following this block.
  3550                                  ;
  3551 00000BD3 85DB                                            test    ebx,ebx                                         ;is there a previous block?
  3552 00000BD5 7405                                            jz      .10                                             ;no, branch
  3553 00000BD7 894B18                                          mov     [ebx+MEMBLOCK.nextblock],ecx                    ;update previous block's next pointer
  3554 00000BDA EB03                                            jmp     .20                                             ;continue
  3555 00000BDC 894E10                  .10                     mov     [esi+MEMROOT.firsttask],ecx                     ;update first USER pointer
  3556                                  ;
  3557                                  ;       If a USER block follows this block, update that block's previous pointer. Otherwise, update the last task
  3558                                  ;       pointer to point to the USER block preceding this block.
  3559                                  ;
  3560 00000BDF E305                    .20                     jecxz   .30                                             ;branch if no next block
  3561 00000BE1 89591C                                          mov     [ecx+MEMBLOCK.previousblock],ebx                ;update next block's previous pointer
  3562 00000BE4 EB03                                            jmp     .40                                             ;continue
  3563 00000BE6 895E14                  .30                     mov     [esi+MEMROOT.lasttask],ebx                      ;update last USER pointer
  3564                                  ;-----------------------------------------------------------------------------------------------------------------------
  3565                                  ;
  3566                                  ;       Merge with a previous contiguous FREE memory block.
  3567                                  ;
  3568                                  ;-----------------------------------------------------------------------------------------------------------------------
  3569                                  ;
  3570                                  ;       Address the preceding and following contiguous memory blocks.
  3571                                  ;
  3572 00000BE9 8B5F14                  .40                     mov     ebx,[edi+MEMBLOCK.previouscontig]               ;previous contiguous block ptr
  3573 00000BEC 8B4F10                                          mov     ecx,[edi+MEMBLOCK.nextcontig]                   ;next contiguous block ptr
  3574                                  ;
  3575                                  ;       Verify we have a previous contiguous FREE block.
  3576                                  ;
  3577 00000BEF 85DB                                            test    ebx,ebx                                         ;is there a previous block?
  3578 00000BF1 7442                                            jz      .100                                            ;no, branch
  3579 00000BF3 813B46524545                                    cmp     dword [ebx+MEMBLOCK.signature],EMEMFREECODE     ;is the previous block FREE?
  3580 00000BF9 753A                                            jne     .100                                            ;no, branch
  3581                                  ;
  3582                                  ;       Update adjacent block's contiguous pointers.
  3583                                  ;
  3584 00000BFB 894B10                                          mov     [ebx+MEMBLOCK.nextcontig],ecx                   ;update previous contig's next contig
  3585 00000BFE E305                                            jecxz   .50                                             ;branch if no next contiguous block
  3586 00000C00 895914                                          mov     [ecx+MEMBLOCK.previouscontig],ebx               ;update next congit's previous contig
  3587 00000C03 EB03                                            jmp     .60                                             ;continue
  3588 00000C05 895E04                  .50                     mov     [esi+MEMROOT.lastcontig],ebx                    ;update last contig pointer
  3589                                  ;
  3590                                  ;       Update the size of the merged FREE block.
  3591                                  ;
  3592 00000C08 8B4704                  .60                     mov     eax,[edi+MEMBLOCK.bytes]                        ;current block size
  3593 00000C0B 014304                                          add     [ebx+MEMBLOCK.bytes],eax                        ;update previous block's size
  3594                                  ;
  3595                                  ;       Having merged our new free block into the previous free block, make the previous free block the current block
  3596                                  ;
  3597 00000C0E B920000000                                      mov     ecx,EMEMBLOCKLEN                                ;block header length
  3598 00000C13 B000                                            mov     al,EMEMWIPEBYTE                                 ;memory wipe byte
  3599 00000C15 F3AA                                            rep     stosb                                           ;clear memory header
  3600 00000C17 89DF                                            mov     edi,ebx                                         ;current block is now previous block
  3601                                  ;-----------------------------------------------------------------------------------------------------------------------
  3602                                  ;
  3603                                  ;       Unlink the previous contiguous FREE memory block
  3604                                  ;
  3605                                  ;-----------------------------------------------------------------------------------------------------------------------
  3606                                  ;
  3607                                  ;       Address the preceding and following USER memory blocks
  3608                                  ;
  3609 00000C19 8B5F1C                                          mov     ebx,[edi+MEMBLOCK.previousblock]                ;previous block pointer
  3610 00000C1C 8B4F18                                          mov     ecx,[edi+MEMBLOCK.nextblock]                    ;next block pointer
  3611                                  ;
  3612                                  ;       Update the previous block's next-block pointer if there is a previous block. Otherwise, update the first free
  3613                                  ;       block pointer.
  3614                                  ;
  3615 00000C1F 85DB                                            test    ebx,ebx                                         ;is there a previous block?
  3616 00000C21 7405                                            jz      .70                                             ;no, branch
  3617 00000C23 894B18                                          mov     [ebx+MEMBLOCK.nextblock],ecx                    ;update previous block's next pointer
  3618 00000C26 EB03                                            jmp     .80                                             ;branch
  3619 00000C28 894E08                  .70                     mov     [esi+MEMROOT.firstfree],ecx                     ;update first FREE block pointer
  3620                                  ;
  3621                                  ;       Update the next block's previous-block pointer if there is a next block. Otherwise, update the last free block
  3622                                  ;       pointer.
  3623                                  ;
  3624 00000C2B E305                    .80                     jecxz   .90                                             ;branch if no next block
  3625 00000C2D 89591C                                          mov     [ecx+MEMBLOCK.previousblock],ebx                ;update next block's previous pointer
  3626 00000C30 EB03                                            jmp     .100                                            ;continue
  3627 00000C32 895E0C                  .90                     mov     [esi+MEMROOT.lastfree],ebx                      ;update last FREE block pointer
  3628                                  ;-----------------------------------------------------------------------------------------------------------------------
  3629                                  ;
  3630                                  ;       Merge with a following contiguous FREE memory block.
  3631                                  ;
  3632                                  ;-----------------------------------------------------------------------------------------------------------------------
  3633                                  ;
  3634                                  ;       Verify we have a following contiguous FREE block.
  3635                                  ;
  3636 00000C35 8B4F10                  .100                    mov     ecx,[edi+MEMBLOCK.nextcontig]                   ;next contiguous block ptr
  3637 00000C38 E34B                                            jecxz   .170                                            ;branch if no next contiguous block
  3638 00000C3A 813946524545                                    cmp     dword [ecx+MEMBLOCK.signature],EMEMFREECODE     ;is the next-contiguous block free?
  3639 00000C40 7543                                            jne     .170                                            ;no, branch
  3640                                  ;
  3641                                  ;       Add the size of the following adjacent FREE block to this block's size.
  3642                                  ;
  3643 00000C42 8B4104                                          mov     eax,[ecx+MEMBLOCK.bytes]                        ;next contiguous (free) block size
  3644 00000C45 014704                                          add     [edi+MEMBLOCK.bytes],eax                        ;add size to this block's size
  3645                                  ;
  3646                                  ;       Unlink the following contiguous FREE block from the contiguous block chain.
  3647                                  ;
  3648 00000C48 8B4110                                          mov     eax,[ecx+MEMBLOCK.nextcontig]                   ;following block's next-contig ptr
  3649 00000C4B 894710                                          mov     [edi+MEMBLOCK.nextcontig],eax                   ;update this block's next-contig ptr
  3650 00000C4E 85C0                                            test    eax,eax                                         ;does a block follow the next contig blk
  3651 00000C50 7405                                            jz      .110                                            ;no, branch
  3652 00000C52 897814                                          mov     [eax+MEMBLOCK.previouscontig],edi               ;update following block's prev contig
  3653 00000C55 EB03                                            jmp     .120                                            ;continue
  3654 00000C57 897E04                  .110                    mov     [esi+MEMROOT.lastcontig],edi                    ;update last contig block ptr
  3655                                  ;-----------------------------------------------------------------------------------------------------------------------
  3656                                  ;
  3657                                  ;       Unlink the following contiguous FREE memory block
  3658                                  ;
  3659                                  ;-----------------------------------------------------------------------------------------------------------------------
  3660                                  ;
  3661                                  ;       Unlink the following adjacent FREE block from the FREE block chain.
  3662                                  ;
  3663 00000C5A 57                      .120                    push    edi                                             ;save this block
  3664 00000C5B 89CF                                            mov     edi,ecx                                         ;next contiguous block
  3665 00000C5D 51                                              push    ecx                                             ;save next contiguous block
  3666                                  ;
  3667                                  ;       Address the preceding and following USER memory blocks
  3668                                  ;
  3669 00000C5E 8B5F1C                                          mov     ebx,[edi+MEMBLOCK.previousblock]                ;next contig's previous block pointer
  3670 00000C61 8B4F18                                          mov     ecx,[edi+MEMBLOCK.nextblock]                    ;next contig's next block pointer
  3671                                  ;
  3672                                  ;       Update the previous block's next-block pointer if there is a previous block. Otherwise, update the first free
  3673                                  ;       block pointer.
  3674                                  ;
  3675 00000C64 85DB                                            test    ebx,ebx                                         ;is there a previous block?
  3676 00000C66 7405                                            jz      .130                                            ;no, branch
  3677 00000C68 894B18                                          mov     [ebx+MEMBLOCK.nextblock],ecx                    ;update next contig's prev blk next-ptr
  3678 00000C6B EB03                                            jmp     .140                                            ;branch
  3679 00000C6D 894E08                  .130                    mov     [esi+MEMROOT.firstfree],ecx                     ;update first FREE block pointer
  3680                                  ;
  3681                                  ;       Update the next block's previous-block pointer if there is a next block. Otherwise, update the last free block
  3682                                  ;       pointer.
  3683                                  ;
  3684 00000C70 E305                    .140                    jecxz   .150                                            ;branch if no next block
  3685 00000C72 89591C                                          mov     [ecx+MEMBLOCK.previousblock],ebx                ;update next contig's next blk prev-ptr
  3686 00000C75 EB03                                            jmp     .160                                            ;continue
  3687 00000C77 895E0C                  .150                    mov     [esi+MEMROOT.lastfree],ebx                      ;update last FREE block pointer
  3688                                  ;
  3689                                  ;       Clear next contiguous block's header
  3690                                  ;
  3691 00000C7A 5F                      .160                    pop     edi                                             ;next congiguous block pointer
  3692 00000C7B B920000000                                      mov     ecx,EMEMBLOCKLEN                                ;memory block header length
  3693 00000C80 B000                                            mov     al,EMEMWIPEBYTE                                 ;memory wipe byte
  3694 00000C82 F3AA                                            rep     stosb                                           ;clear memory header
  3695 00000C84 5F                                              pop     edi                                             ;this block's pointer
  3696                                  ;-----------------------------------------------------------------------------------------------------------------------
  3697                                  ;
  3698                                  ;       Insert the final FREE block back into the block chain.
  3699                                  ;
  3700                                  ;-----------------------------------------------------------------------------------------------------------------------
  3701                                  ;
  3702                                  ;       Walk the FREE memory chain until a block is found that is larger than or equal in size to the block being
  3703                                  ;       inserted. The block being inserted will be inserted before that block or after the last block found if none
  3704                                  ;       all are smaller in size.
  3705                                  ;
  3706 00000C85 8B5F04                  .170                    mov     ebx,[edi+MEMBLOCK.bytes]                        ;size of block
  3707 00000C88 8B4E08                                          mov     ecx,[esi+MEMROOT.firstfree]                     ;first free block ptr
  3708 00000C8B E30A                    .180                    jecxz   .190                                            ;exit if no ptr
  3709 00000C8D 3B5904                                          cmp     ebx,[ecx+MEMBLOCK.bytes]                        ;next block bigger?
  3710 00000C90 7205                                            jb      .190                                            ;yes, branch
  3711 00000C92 8B4918                                          mov     ecx,[ecx+MEMBLOCK.nextblock]                    ;next free memory block
  3712 00000C95 EBF4                                            jmp     .180                                            ;continue
  3713                                  ;
  3714                                  ;       Set the next-block pointer. Determine the previous-block, which may be the last FREE block if we found no
  3715                                  ;       larger free block. Update the next block's previous block pointer.
  3716                                  ;
  3717 00000C97 894F18                  .190                    mov     [edi+MEMBLOCK.nextblock],ecx                    ;set the next block ptr
  3718 00000C9A 8B5E0C                                          mov     ebx,[esi+MEMROOT.lastfree]                      ;assume all blocks smaller
  3719 00000C9D E308                                            jecxz   .200                                            ;branch if no block found
  3720 00000C9F 8B591C                                          mov     ebx,[ecx+MEMBLOCK.previousblock]                ;next block's previous block ptr
  3721 00000CA2 89791C                                          mov     [ecx+MEMBLOCK.previousblock],edi                ;update next block's previous ptr
  3722 00000CA5 EB03                                            jmp     .210                                            ;continue
  3723 00000CA7 897E0C                  .200                    mov     [esi+MEMROOT.lastfree],edi                      ;this block is now the last free
  3724                                  ;
  3725                                  ;       Set our previous block pointer to either the previous pointer of the found block or the last free block.
  3726                                  ;       If there is no previous block pointer, then this block now the first FREE block. Otherwise update that block's
  3727                                  ;       next pointer.
  3728                                  ;
  3729 00000CAA 895F1C                  .210                    mov     [edi+MEMBLOCK.previousblock],ebx                ;set the previous block ptr
  3730 00000CAD 85DB                                            test    ebx,ebx                                         ;do we have a previous block?
  3731 00000CAF 7405                                            jz      .220                                            ;no, branch
  3732 00000CB1 897B18                                          mov     [ebx+MEMBLOCK.nextblock],edi                    ;update previous block's next block ptr
  3733 00000CB4 EB03                                            jmp     .230                                            ;continue
  3734 00000CB6 897E08                  .220                    mov     [esi+MEMROOT.firstfree],edi                     ;update first free ptr
  3735                                  ;
  3736                                  ;       The memory free has completed.
  3737                                  ;
  3738 00000CB9 31C0                    .230                    xor     eax,eax                                         ;indicate success
  3739                                  ;
  3740                                  ;       Restore and return.
  3741                                  ;
  3742 00000CBB 07                      .240                    pop     es                                              ;restore non-volatile regs
  3743 00000CBC 1F                                              pop     ds                                              ;
  3744 00000CBD 5F                                              pop     edi                                             ;
  3745 00000CBE 5E                                              pop     esi                                             ;
  3746 00000CBF 59                                              pop     ecx                                             ;
  3747 00000CC0 5B                                              pop     ebx                                             ;
  3748 00000CC1 C3                                              ret                                                     ;return
  3749                                  ;=======================================================================================================================
  3750                                  ;
  3751                                  ;       String Helper Routines
  3752                                  ;
  3753                                  ;       CompareMemory
  3754                                  ;       UpperCaseString
  3755                                  ;
  3756                                  ;=======================================================================================================================
  3757                                  ;-----------------------------------------------------------------------------------------------------------------------
  3758                                  ;
  3759                                  ;       Routine:        CompareMemory
  3760                                  ;
  3761                                  ;       Description:    This routine compares two byte arrays.
  3762                                  ;
  3763                                  ;       In:             DS:EDX  first source address
  3764                                  ;                       DS:EBX  second source address
  3765                                  ;                       ECX     comparison length
  3766                                  ;
  3767                                  ;       Out:            EDX     first source address
  3768                                  ;                       EBX     second source address
  3769                                  ;                       ECX     0       array 1 = array 2
  3770                                  ;                               <0      array 1 < array 2
  3771                                  ;                               >0      array 1 > array 2
  3772                                  ;
  3773                                  ;-----------------------------------------------------------------------------------------------------------------------
  3774 00000CC2 56                      CompareMemory           push    esi                                             ;save non-volatile regs
  3775 00000CC3 57                                              push    edi                                             ;
  3776 00000CC4 06                                              push    es                                              ;
  3777 00000CC5 1E                                              push    ds                                              ;copy DS
  3778 00000CC6 07                                              pop     es                                              ;... to ES
  3779 00000CC7 89D6                                            mov     esi,edx                                         ;first source address
  3780 00000CC9 89DF                                            mov     edi,ebx                                         ;second source address
  3781 00000CCB FC                                              cld                                                     ;forward strings
  3782 00000CCC F3A6                                            rep     cmpsb                                           ;compare bytes
  3783 00000CCE B000                                            mov     al,0                                            ;default result
  3784 00000CD0 7406                                            jz      .10                                             ;branch if arrays equal
  3785 00000CD2 B001                                            mov     al,1                                            ;positive result
  3786 00000CD4 7302                                            jnc     .10                                             ;branch if target > source
  3787 00000CD6 B0FF                                            mov     al,-1                                           ;negative result
  3788 00000CD8 0FBEC8                  .10                     movsx   ecx,al                                          ;extend sign
  3789 00000CDB 07                                              pop     es                                              ;restore non-volatile regs
  3790 00000CDC 5F                                              pop     edi                                             ;
  3791 00000CDD 5E                                              pop     esi                                             ;
  3792 00000CDE C3                                              ret                                                     ;return
  3793                                  ;-----------------------------------------------------------------------------------------------------------------------
  3794                                  ;
  3795                                  ;       Routine:        UpperCaseString
  3796                                  ;
  3797                                  ;       Description:    This routine places all characters in the given string to upper case.
  3798                                  ;
  3799                                  ;       In:             DS:EDX  string address
  3800                                  ;
  3801                                  ;       Out:            EDX     string address
  3802                                  ;
  3803                                  ;-----------------------------------------------------------------------------------------------------------------------
  3804 00000CDF 56                      UpperCaseString         push    esi                                             ;save non-volatile regs
  3805 00000CE0 89D6                                            mov     esi,edx                                         ;string address
  3806 00000CE2 FC                                              cld                                                     ;forward strings
  3807 00000CE3 AC                      .10                     lodsb                                                   ;string character
  3808 00000CE4 84C0                                            test    al,al                                           ;null?
  3809 00000CE6 740F                                            jz      .20                                             ;yes, skip ahead
  3810 00000CE8 3C61                                            cmp     al,EASCIILOWERA                                 ;lower-case? (lower bounds)
  3811 00000CEA 72F7                                            jb      .10                                             ;no, continue
  3812 00000CEC 3C7A                                            cmp     al,EASCIILOWERZ                                 ;lower-case? (upper bounds)
  3813 00000CEE 77F3                                            ja      .10                                             ;no, continue
  3814 00000CF0 24DF                                            and     al,EASCIICASEMASK                               ;mask for upper case
  3815 00000CF2 8846FF                                          mov     [esi-1],al                                      ;upper character
  3816 00000CF5 EBEC                                            jmp     .10                                             ;continue
  3817 00000CF7 5E                      .20                     pop     esi                                             ;restore non-volatile regs
  3818 00000CF8 C3                                              ret                                                     ;return
  3819                                  ;=======================================================================================================================
  3820                                  ;
  3821                                  ;       Console Helper Routines
  3822                                  ;
  3823                                  ;       GetConsoleMessage
  3824                                  ;       PutConsoleHexByte
  3825                                  ;       PutConsoleHexDword
  3826                                  ;       PutConsoleHexWord
  3827                                  ;       PutConsoleOIA
  3828                                  ;       Yield
  3829                                  ;
  3830                                  ;=======================================================================================================================
  3831                                  ;-----------------------------------------------------------------------------------------------------------------------
  3832                                  ;
  3833                                  ;       Routine:        GetConsoleMessage
  3834                                  ;
  3835                                  ;       Description:    This routine waits for the next message to be queued.
  3836                                  ;
  3837                                  ;       Out:            EAX     message params
  3838                                  ;
  3839                                  ;-----------------------------------------------------------------------------------------------------------------------
  3840 00000CF9 E8A4010000              GetConsoleMessage.10    call    Yield                                           ;pass control or halt
  3841 00000CFE E813020000              GetConsoleMessage       call    GetMessage                                      ;get the next message
  3842 00000D03 85C0                                            test    eax,eax                                         ;do we have a message?
  3843 00000D05 74F2                                            jz      GetConsoleMessage.10                            ;no, continue
  3844 00000D07 C3                                              ret                                                     ;return
  3845                                  ;-----------------------------------------------------------------------------------------------------------------------
  3846                                  ;
  3847                                  ;       Routine:        PutConsoleHexByte
  3848                                  ;
  3849                                  ;       Description:    This routine writes two ASCII characters to the console representing a byte value.
  3850                                  ;
  3851                                  ;       In:             AL      byte value
  3852                                  ;                       CL      column
  3853                                  ;                       CH      row
  3854                                  ;                       DS      OS data selector
  3855                                  ;                       ES      CGA selector
  3856                                  ;
  3857                                  ;-----------------------------------------------------------------------------------------------------------------------
  3858 00000D08 50                      PutConsoleHexByte       push    eax                                             ;save non-volatile regs
  3859 00000D09 C0E804                                          shr     al,4                                            ;hi-order nybble
  3860 00000D0C E803000000                                      call    .10                                             ;make ASCII and store
  3861 00000D11 58                                              pop     eax                                             ;byte value
  3862 00000D12 240F                                            and     al,0Fh                                          ;lo-order nybble
  3863 00000D14 0C30                    .10                     or      al,EASCIIZERO                                   ;apply ASCII zone
  3864 00000D16 3C39                                            cmp     al,EASCIININE                                   ;numeric?
  3865 00000D18 7602                                            jbe     .20                                             ;yes, skip ahead
  3866 00000D1A 0407                                            add     al,7                                            ;add ASCII offset for alpha
  3867 00000D1C E852020000              .20                     call    SetConsoleChar                                  ;display ASCII character
  3868 00000D21 C3                                              ret                                                     ;return
  3869                                  ;-----------------------------------------------------------------------------------------------------------------------
  3870                                  ;
  3871                                  ;       Routine:        PutConsoleHexDword
  3872                                  ;
  3873                                  ;       Description:    This routine writes eight ASCII characters to the console representing a doubleword value.
  3874                                  ;
  3875                                  ;       In:             EAX     value
  3876                                  ;                       CL      column
  3877                                  ;                       CH      row
  3878                                  ;                       DS      OS data selector
  3879                                  ;                       ES      CGA selector
  3880                                  ;
  3881                                  ;-----------------------------------------------------------------------------------------------------------------------
  3882 00000D22 50                      PutConsoleHexDword      push    eax                                             ;save value
  3883 00000D23 C1E810                                          shr     eax,16                                          ;high-order word
  3884 00000D26 E807000000                                      call    PutConsoleHexWord                               ;display high-order word
  3885 00000D2B 58                                              pop     eax                                             ;restore value
  3886 00000D2C E801000000                                      call    PutConsoleHexWord                               ;display low-order word
  3887 00000D31 C3                                              ret                                                     ;return
  3888                                  ;-----------------------------------------------------------------------------------------------------------------------
  3889                                  ;
  3890                                  ;       Routine:        PutConsoleHexWord
  3891                                  ;
  3892                                  ;       Description:    This routine writes four ASCII characters to the console representing a word value.
  3893                                  ;
  3894                                  ;       In:             EAX     value
  3895                                  ;                       CL      column
  3896                                  ;                       CH      row
  3897                                  ;                       DS      OS data selector
  3898                                  ;                       ES      CGA selector
  3899                                  ;
  3900                                  ;-----------------------------------------------------------------------------------------------------------------------
  3901 00000D32 50                      PutConsoleHexWord       push    eax                                             ;save value
  3902 00000D33 C1E808                                          shr     eax,8                                           ;high-order byte
  3903 00000D36 E8CDFFFFFF                                      call    PutConsoleHexByte                               ;display high-order byte
  3904 00000D3B 58                                              pop     eax                                             ;restore value
  3905 00000D3C E8C7FFFFFF                                      call    PutConsoleHexByte                               ;display low-order byte
  3906 00000D41 C3                                              ret                                                     ;return
  3907                                  ;-----------------------------------------------------------------------------------------------------------------------
  3908                                  ;
  3909                                  ;       Routine:        PutConsoleOIA
  3910                                  ;
  3911                                  ;       Description:    This routine updates the Operator Information Area (OIA).
  3912                                  ;
  3913                                  ;       In:             DS      OS data selector
  3914                                  ;
  3915                                  ;       0         1         2         3         4         5         6         7
  3916                                  ;       01234567890123456789012345678901234567890123456789012345678901234567890123456789
  3917                                  ;       00112233  WSCA  XXAA                    C                         ASCW    ^CNS !
  3918                                  ;
  3919                                  ;-----------------------------------------------------------------------------------------------------------------------
  3920 00000D42 53                      PutConsoleOIA           push    ebx                                             ;save non-volatile regs
  3921 00000D43 51                                              push    ecx                                             ;
  3922 00000D44 56                                              push    esi                                             ;
  3923 00000D45 06                                              push    es                                              ;
  3924                                  ;
  3925                                  ;       Address OS data and video memory
  3926                                  ;
  3927 00000D46 6A20                                            push    EGDTCGA                                         ;load CGA selector ...
  3928 00000D48 07                                              pop     es                                              ;... into extra segment register
  3929                                  ;
  3930                                  ;       Display up to six keyboard scan codes
  3931                                  ;
  3932 00000D49 BE1A0F0000                                      mov     esi,wsKeybData                                  ;keyboard data addr
  3933 00000D4E 8D36                                            lea     esi,[esi+KEYBDATA.scan0]                        ;scan code 0
  3934 00000D50 31DB                                            xor     ebx,ebx                                         ;zero register
  3935 00000D52 B718                                            mov     bh,ECONOIAROW                                   ;OIA row
  3936 00000D54 31C9                                            xor     ecx,ecx                                         ;zero register
  3937 00000D56 B104                                            mov     cl,4                                            ;maximum scan code count
  3938 00000D58 51                      .10                     push    ecx                                             ;save remaining count
  3939 00000D59 89D9                                            mov     ecx,ebx                                         ;row, column
  3940 00000D5B AC                                              lodsb                                                   ;read scan code
  3941 00000D5C 84C0                                            test    al,al                                           ;scan code present?
  3942 00000D5E 7407                                            jz      .20                                             ;no, skip ahead
  3943 00000D60 E8A3FFFFFF                                      call    PutConsoleHexByte                               ;display scan code
  3944 00000D65 EB0E                                            jmp     .30                                             ;continue
  3945 00000D67 B020                    .20                     mov     al,' '                                          ;ASCII space
  3946 00000D69 E805020000                                      call    SetConsoleChar                                  ;display space
  3947 00000D6E B020                                            mov     al,' '                                          ;ASCII space
  3948 00000D70 E8FE010000                                      call    SetConsoleChar                                  ;display space
  3949 00000D75 80C302                  .30                     add     bl,2                                            ;next column (+2)
  3950 00000D78 59                                              pop     ecx                                             ;restore remaining
  3951 00000D79 E2DD                                            loop    .10                                             ;next code
  3952                                  ;
  3953                                  ;       Display left shift, control, alt indicators
  3954                                  ;
  3955 00000D7B BE1A0F0000                                      mov     esi,wsKeybData                                  ;keyboard data
  3956 00000D80 B518                                            mov     ch,ECONOIAROW                                   ;OIA row
  3957 00000D82 B020                                            mov     al,EASCIISPACE                                  ;ASCII space
  3958 00000D84 F6460740                                        test    byte [esi+KEYBDATA.shift],EKEYFWINLEFT          ;left-windows?
  3959 00000D88 7402                                            jz      .35                                             ;no, branch
  3960 00000D8A B057                                            mov     al,'W'                                          ;yes, indicate with 'W'
  3961 00000D8C B10A                    .35                     mov     cl,10                                           ;indicator column
  3962 00000D8E E8E0010000                                      call    SetConsoleChar                                  ;display ASCII indicator
  3963 00000D93 B020                                            mov     al,EASCIISPACE                                  ;space is default character
  3964 00000D95 F6460702                                        test    byte [esi+KEYBDATA.shift],EKEYFSHIFTLEFT        ;left-shift?
  3965 00000D99 7402                                            jz      .40                                             ;no, skip ahead
  3966 00000D9B B053                                            mov     al,'S'                                          ;yes, indicate with 'S'
  3967 00000D9D B10B                    .40                     mov     cl,11                                           ;indicator column
  3968 00000D9F E8CF010000                                      call    SetConsoleChar                                  ;display ASCII character
  3969 00000DA4 B020                                            mov     al,EASCIISPACE                                  ;ASCII space
  3970 00000DA6 F6460701                                        test    byte [esi+KEYBDATA.shift],EKEYFCTRLLEFT         ;left-ctrl?
  3971 00000DAA 7402                                            jz      .50                                             ;no, skip ahead
  3972 00000DAC B043                                            mov     al,'C'                                          ;yes, indicate with 'C'
  3973 00000DAE B10C                    .50                     mov     cl,12                                           ;indicator column
  3974 00000DB0 E8BE010000                                      call    SetConsoleChar                                  ;display ASCII character
  3975 00000DB5 B020                                            mov     al,EASCIISPACE                                  ;ASCII space
  3976 00000DB7 F6460704                                        test    byte [esi+KEYBDATA.shift],EKEYFALTLEFT          ;left-alt?
  3977 00000DBB 7402                                            jz      .60                                             ;no, skip ahead
  3978 00000DBD B041                                            mov     al,'A'                                          ;yes, indicate with 'A'
  3979 00000DBF B10D                    .60                     mov     cl,13                                           ;indicator column
  3980 00000DC1 E8AD010000                                      call    SetConsoleChar                                  ;display ASCII character
  3981                                  ;
  3982                                  ;       We do not display left or right shift make or break codes even if they are stored as the final
  3983                                  ;       scan code because these are immediately sent after num-pad digits if both num-lock and scroll
  3984                                  ;       are enabled. We don not display the scan code and char code if the scan code is null.
  3985                                  ;
  3986 00000DC6 8A4604                                          mov     al,[esi+KEYBDATA.scan]                          ;final scan code
  3987 00000DC9 84C0                                            test    al,al                                           ;null?
  3988 00000DCB 7421                                            jz      .65                                             ;yes, branch
  3989 00000DCD 3C2A                                            cmp     al,EKEYBSHIFTLDOWN                              ;left shift make?
  3990 00000DCF 741D                                            je      .65                                             ;yes, branch
  3991 00000DD1 3CAA                                            cmp     al,EKEYBSHIFTLUP                                ;left shift break?
  3992 00000DD3 7419                                            je      .65                                             ;yes, branch
  3993 00000DD5 3C36                                            cmp     al,EKEYBSHIFTRDOWN                              ;right shift make?
  3994 00000DD7 7415                                            je      .65                                             ;yes, branch
  3995 00000DD9 3CB6                                            cmp     al,EKEYBSHIFTRUP                                ;right shift break?
  3996 00000DDB 7411                                            je      .65                                             ;yes, branch
  3997                                  ;
  3998                                  ;       Display scan code returned in messages.
  3999                                  ;
  4000 00000DDD B110                                            mov     cl,16                                           ;column
  4001 00000DDF E824FFFFFF                                      call    PutConsoleHexByte                               ;store hex byte
  4002 00000DE4 8A4605                                          mov     al,[esi+KEYBDATA.char]                          ;ASCII char
  4003 00000DE7 B112                                            mov     cl,18                                           ;column
  4004 00000DE9 E81AFFFFFF                                      call    PutConsoleHexByte                               ;store hex byte
  4005                                  ;
  4006                                  ;       Display ASCII character.
  4007                                  ;
  4008 00000DEE 8A4605                  .65                     mov     al,[esi+KEYBDATA.char]                          ;ASCII char
  4009 00000DF1 3C20                                            cmp     al,EASCIISPACE                                  ;printable? (lower-bounds)
  4010 00000DF3 7204                                            jb      .70                                             ;no, skip ahead
  4011 00000DF5 3C7E                                            cmp     al,EASCIITILDE                                  ;printable? (upper-bounds)
  4012 00000DF7 7602                                            jbe     .80                                             ;yes, branch
  4013 00000DF9 B020                    .70                     mov     al,EASCIISPACE                                  ;use space for non-printables
  4014 00000DFB 88FD                    .80                     mov     ch,bh                                           ;OIA row
  4015 00000DFD B128                                            mov     cl,40                                           ;character display column
  4016 00000DFF E86F010000                                      call    SetConsoleChar                                  ;display ASCII character
  4017                                  ;
  4018                                  ;       Display right alt, control, shift indicators
  4019                                  ;
  4020 00000E04 B020                                            mov     al,EASCIISPACE                                  ;ASCII space
  4021 00000E06 F6460720                                        test    byte [esi+KEYBDATA.shift],EKEYFALTRIGHT         ;right-alt?
  4022 00000E0A 7402                                            jz      .90                                             ;no, skip ahead
  4023 00000E0C B041                                            mov     al,'A'                                          ;yes, indicate with 'A'
  4024 00000E0E B142                    .90                     mov     cl,66                                           ;indicator column
  4025 00000E10 E85E010000                                      call    SetConsoleChar                                  ;display ASCII character
  4026 00000E15 B020                                            mov     al,EASCIISPACE                                  ;ASCII space
  4027 00000E17 F6460708                                        test    byte [esi+KEYBDATA.shift],EKEYFCTRLRIGHT        ;right-ctrl?
  4028 00000E1B 7402                                            jz      .100                                            ;no, skip ahead
  4029 00000E1D B043                                            mov     al,'C'                                          ;yes, indicate with 'C'
  4030 00000E1F B143                    .100                    mov     cl,67                                           ;indicator column
  4031 00000E21 E84D010000                                      call    SetConsoleChar                                  ;display ASCII character
  4032 00000E26 B020                                            mov     al,EASCIISPACE                                  ;ASCII space
  4033 00000E28 F6460710                                        test    byte [esi+KEYBDATA.shift],EKEYFSHIFTRIGHT       ;right-shift
  4034 00000E2C 7402                                            jz      .110                                            ;no, skip ahead
  4035 00000E2E B053                                            mov     al,'S'                                          ;yes, indicate with 'S'
  4036 00000E30 B144                    .110                    mov     cl,68                                           ;indicator column
  4037 00000E32 E83C010000                                      call    SetConsoleChar                                  ;display ASCII character
  4038 00000E37 B020                                            mov     al,EASCIISPACE                                  ;ASCII space
  4039 00000E39 F6460780                                        test    byte [esi+KEYBDATA.shift],EKEYFWINRIGHT         ;right-windows?
  4040 00000E3D 7402                                            jz      .115                                            ;no, branch
  4041 00000E3F B057                                            mov     al,'W'                                          ;yes, indicate wiht 'W'
  4042 00000E41 B145                    .115                    mov     cl,69                                           ;indicator column
  4043 00000E43 E82B010000                                      call    SetConsoleChar                                  ;display ASCII character
  4044                                  ;
  4045                                  ;       Display Insert, Caps, Scroll and Num-Lock indicators.
  4046                                  ;
  4047 00000E48 B020                                            mov     al,EASCIISPACE                                  ;ASCII space
  4048 00000E4A F6460808                                        test    byte [esi+KEYBDATA.lock],EKEYFLOCKINSERT        ;insert mode?
  4049 00000E4E 7402                                            jz      .120                                            ;no, branch
  4050 00000E50 B05E                                            mov     al,EASCIICARET                                  ;indicate with a caret '^'
  4051 00000E52 B14A                    .120                    mov     cl,74                                           ;indicoator column
  4052 00000E54 E81A010000                                      call    SetConsoleChar                                  ;display ASCII character
  4053 00000E59 B020                                            mov     al,EASCIISPACE                                  ;ASCII space
  4054 00000E5B F6460801                                        test    byte [esi+KEYBDATA.lock],EKEYFLOCKSCROLL        ;scroll-lock?
  4055 00000E5F 7402                                            jz      .130                                            ;no, skip ahead
  4056 00000E61 B053                                            mov     al,'S'                                          ;yes, indicate with 'S'
  4057 00000E63 B14B                    .130                    mov     cl,75                                           ;indicator column
  4058 00000E65 E809010000                                      call    SetConsoleChar                                  ;display ASCII character
  4059 00000E6A B020                                            mov     al,EASCIISPACE                                  ;ASCII space
  4060 00000E6C F6460802                                        test    byte [esi+KEYBDATA.lock],EKEYFLOCKNUM           ;num-lock?
  4061 00000E70 7402                                            jz      .140                                            ;no, skip ahead
  4062 00000E72 B04E                                            mov     al,'N'                                          ;yes, indicate with 'N'
  4063 00000E74 B14C                    .140                    mov     cl,76                                           ;indicator column
  4064 00000E76 E8F8000000                                      call    SetConsoleChar                                  ;display ASCII character
  4065 00000E7B B020                                            mov     al,EASCIISPACE                                  ;ASCII space
  4066 00000E7D F6460804                                        test    byte [esi+KEYBDATA.lock],EKEYFLOCKCAPS          ;caps-lock?
  4067 00000E81 7402                                            jz      .150                                            ;no, skip ahead
  4068 00000E83 B043                                            mov     al,'C'                                          ;yes, indicate with 'C'
  4069 00000E85 B14D                    .150                    mov     cl,77                                           ;indicator column
  4070 00000E87 E8E7000000                                      call    SetConsoleChar                                  ;display ASCII character
  4071                                  ;
  4072                                  ;       Display timeout flag.
  4073                                  ;
  4074 00000E8C B020                                            mov     al,EASCIISPACE                                  ;ASCII space
  4075 00000E8E F6460980                                        test    byte [esi+KEYBDATA.status],EKEYFTIMEOUT         ;keyboard timeout?
  4076 00000E92 7402                                            jz      .155                                            ;no, branch
  4077 00000E94 B021                                            mov     al,'!'                                          ;ASCII indicator
  4078 00000E96 B14F                    .155                    mov     cl,79                                           ;indicator column
  4079 00000E98 E8D6000000                                      call    SetConsoleChar                                  ;display ASCII character
  4080                                  ;
  4081                                  ;       Restore and return.
  4082                                  ;
  4083 00000E9D 07                      .160                    pop     es                                              ;restore non-volatile regs
  4084 00000E9E 5E                                              pop     esi                                             ;
  4085 00000E9F 59                                              pop     ecx                                             ;
  4086 00000EA0 5B                                              pop     ebx                                             ;
  4087 00000EA1 C3                                              ret                                                     ;return
  4088                                  ;-----------------------------------------------------------------------------------------------------------------------
  4089                                  ;
  4090                                  ;       Routine:        Yield
  4091                                  ;
  4092                                  ;       Description:    This routine passes control to the next ready task or enter halt.
  4093                                  ;
  4094                                  ;-----------------------------------------------------------------------------------------------------------------------
  4095 00000EA2 FB                      Yield                   sti                                                     ;enable maskagle interrupts
  4096 00000EA3 F4                                              hlt                                                     ;halt until external interrupt
  4097 00000EA4 C3                                              ret                                                     ;return
  4098                                  ;=======================================================================================================================
  4099                                  ;
  4100                                  ;       Data-Type Conversion Helper Routines
  4101                                  ;
  4102                                  ;       DecimalToUnsigned
  4103                                  ;       HexadecimalToUnsigned
  4104                                  ;       UnsignedToHexadecimal
  4105                                  ;
  4106                                  ;=======================================================================================================================
  4107                                  ;-----------------------------------------------------------------------------------------------------------------------
  4108                                  ;
  4109                                  ;       Routine:        DecimalToUnsigned
  4110                                  ;
  4111                                  ;       Description:    This routine returns an unsigned integer of the value of the input ASCIIZ decimal string.
  4112                                  ;
  4113                                  ;       Input:          DS:EDX  null-terminated decimal string address
  4114                                  ;
  4115                                  ;       Output:         EAX     unsigned integer value
  4116                                  ;
  4117                                  ;-----------------------------------------------------------------------------------------------------------------------
  4118 00000EA5 56                      DecimalToUnsigned       push    esi                                             ;save non-volatile regs
  4119 00000EA6 89D6                                            mov     esi,edx                                         ;source address
  4120 00000EA8 31D2                                            xor     edx,edx                                         ;zero total
  4121 00000EAA AC                      .10                     lodsb                                                   ;source byte
  4122 00000EAB 3C2C                                            cmp     al,','                                          ;comma?
  4123 00000EAD 74FB                                            je      .10                                             ;yes, ignore
  4124 00000EAF 84C0                                            test    al,al                                           ;end of string?
  4125 00000EB1 7421                                            jz      .30                                             ;yes, done
  4126 00000EB3 3C2E                                            cmp     al,'.'                                          ;decimal point?
  4127 00000EB5 741D                                            je      .30                                             ;yes, done
  4128 00000EB7 3C30                                            cmp     al,'0'                                          ;numeral?
  4129 00000EB9 7217                                            jb      .20                                             ;no, invalid string
  4130 00000EBB 3C39                                            cmp     al,'9'                                          ;numeral?
  4131 00000EBD 7713                                            ja      .20                                             ;no, invalid string
  4132 00000EBF 240F                                            and     al,00Fh                                         ;mask ASCII zone
  4133 00000EC1 50                                              push    eax                                             ;save numeral
  4134 00000EC2 D1E2                                            shl     edx,1                                           ;total * 2
  4135 00000EC4 89D0                                            mov     eax,edx                                         ;total * 2
  4136 00000EC6 C1E202                                          shl     edx,2                                           ;total * 8
  4137 00000EC9 01C2                                            add     edx,eax                                         ;total * 10
  4138 00000ECB 58                                              pop     eax                                             ;restore numeral
  4139 00000ECC 01C2                                            add     edx,eax                                         ;accumulate decimal digit
  4140 00000ECE 31C0                                            xor     eax,eax                                         ;zero register
  4141 00000ED0 EBD8                                            jmp     .10                                             ;next
  4142 00000ED2 31D2                    .20                     xor     edx,edx                                         ;zero result on error
  4143 00000ED4 89D0                    .30                     mov     eax,edx                                         ;result
  4144 00000ED6 5E                                              pop     esi                                             ;restore non-volatile regs
  4145 00000ED7 C3                                              ret                                                     ;return
  4146                                  ;-----------------------------------------------------------------------------------------------------------------------
  4147                                  ;
  4148                                  ;       Routine:        HexadecimalToUnsigned
  4149                                  ;
  4150                                  ;       Description:    This routine returns an unsigned integer of the value of the input ASCIIZ hexadecimal string.
  4151                                  ;
  4152                                  ;       Input:          DS:EDX  null-terminated hexadecimal string address
  4153                                  ;
  4154                                  ;       Output:         EAX     unsigned integer value
  4155                                  ;
  4156                                  ;-----------------------------------------------------------------------------------------------------------------------
  4157 00000ED8 56                      HexadecimalToUnsigned   push    esi                                             ;save non-volatile regs
  4158 00000ED9 89D6                                            mov     esi,edx                                         ;source address
  4159 00000EDB 31D2                                            xor     edx,edx                                         ;zero register
  4160 00000EDD AC                      .10                     lodsb                                                   ;source byte
  4161 00000EDE 84C0                                            test    al,al                                           ;end of string?
  4162 00000EE0 7410                                            jz      .30                                             ;yes, branch
  4163 00000EE2 3C39                                            cmp     al,'9'                                          ;hexadecimal?
  4164 00000EE4 7602                                            jna     .20                                             ;no, skip ahead
  4165 00000EE6 2C37                                            sub     al,037h                                         ;'A' = 41h, less 37h = 0Ah
  4166 00000EE8 83E00F                  .20                     and     eax,00Fh                                        ;remove ascii zone
  4167 00000EEB C1E204                                          shl     edx,4                                           ;previous total x 16
  4168 00000EEE 01C2                                            add     edx,eax                                         ;add prior value x 16
  4169 00000EF0 EBEB                                            jmp     .10                                             ;next
  4170 00000EF2 89D0                    .30                     mov     eax,edx                                         ;result
  4171 00000EF4 5E                                              pop     esi                                             ;restore non-volatile regs
  4172 00000EF5 C3                                              ret                                                     ;return
  4173                                  ;-----------------------------------------------------------------------------------------------------------------------
  4174                                  ;
  4175                                  ;       Routine:        UnsignedToHexadecimal
  4176                                  ;
  4177                                  ;       Description:    This routine creates an ASCIIZ string representing the hexadecimal value of binary input
  4178                                  ;
  4179                                  ;       Input:          DS:EDX  output buffer address
  4180                                  ;                       ECX     32-bit binary
  4181                                  ;
  4182                                  ;-----------------------------------------------------------------------------------------------------------------------
  4183 00000EF6 57                      UnsignedToHexadecimal   push    edi                                             ;store non-volatile regs
  4184 00000EF7 89D7                                            mov     edi,edx                                         ;output buffer address
  4185 00000EF9 89CA                                            mov     edx,ecx                                         ;32-bit unsigned
  4186 00000EFB 31C9                                            xor     ecx,ecx                                         ;zero register
  4187 00000EFD B108                                            mov     cl,8                                            ;nybble count
  4188 00000EFF C1C204                  .10                     rol     edx,4                                           ;next hi-order nybble in bits 0-3
  4189 00000F02 88D0                                            mov     al,dl                                           ;????bbbb
  4190 00000F04 240F                                            and     al,00Fh                                         ;mask out bits 4-7
  4191 00000F06 0C30                                            or      al,EASCIIZERO                                   ;mask in ascii zone
  4192 00000F08 3C39                                            cmp     al,EASCIININE                                   ;A through F?
  4193 00000F0A 7602                                            jbe     .20                                             ;no, skip ahead
  4194 00000F0C 0407                                            add     al,7                                            ;41h through 46h
  4195 00000F0E AA                      .20                     stosb                                                   ;store hexnum
  4196 00000F0F E2EE                                            loop    .10                                             ;next nybble
  4197 00000F11 30C0                                            xor     al,al                                           ;zero reg
  4198 00000F13 AA                                              stosb                                                   ;null terminate
  4199 00000F14 5F                                              pop     edi                                             ;restore non-volatile regs
  4200 00000F15 C3                                              ret                                                     ;return
  4201                                  ;=======================================================================================================================
  4202                                  ;
  4203                                  ;       Message Queue Helper Routines
  4204                                  ;
  4205                                  ;       GetMessage
  4206                                  ;       PutMessage
  4207                                  ;
  4208                                  ;=======================================================================================================================
  4209                                  ;-----------------------------------------------------------------------------------------------------------------------
  4210                                  ;
  4211                                  ;       Routine:        GetMessage
  4212                                  ;
  4213                                  ;       Description:    This routine reads and removes a message from the message queue.
  4214                                  ;
  4215                                  ;       Out:            EAX     lo-order message data
  4216                                  ;                       EDX     hi-order message data
  4217                                  ;
  4218                                  ;                       CY      0 = message read
  4219                                  ;                               1 = no message to read
  4220                                  ;
  4221                                  ;-----------------------------------------------------------------------------------------------------------------------
  4222 00000F16 53                      GetMessage              push    ebx                                             ;save non-volatile regs
  4223 00000F17 51                                              push    ecx                                             ;
  4224 00000F18 1E                                              push    ds                                              ;
  4225 00000F19 6A2C                                            push    ELDTMQ                                          ;load message queue selector ...
  4226 00000F1B 1F                                              pop     ds                                              ;... into data segment register
  4227 00000F1C 8B1D00000000                                    mov     ebx,[MQHead]                                    ;head ptr
  4228 00000F22 8B03                                            mov     eax,[ebx]                                       ;lo-order 32 bits
  4229 00000F24 8B5304                                          mov     edx,[ebx+4]                                     ;hi-order 32 bits
  4230 00000F27 09D0                                            or      eax,edx                                         ;is queue empty?
  4231 00000F29 F9                                              stc                                                     ;assume queue is emtpy
  4232 00000F2A 741B                                            jz      .20                                             ;yes, skip ahead
  4233 00000F2C 31C9                                            xor     ecx,ecx                                         ;store zero
  4234 00000F2E 890B                                            mov     [ebx],ecx                                       ;... in lo-order dword
  4235 00000F30 894B04                                          mov     [ebx+4],ecx                                     ;... in hi-order dword
  4236 00000F33 83C308                                          add     ebx,8                                           ;next queue element
  4237 00000F36 81E3FC030000                                    and     ebx,03FCh                                       ;at end of queue?
  4238 00000F3C 7502                                            jnz     .10                                             ;no, skip ahead
  4239 00000F3E B308                                            mov     bl,8                                            ;reset to 1st entry
  4240 00000F40 891D00000000            .10                     mov     [MQHead],ebx                                    ;save new head ptr
  4241 00000F46 F8                                              clc                                                     ;indicate message read
  4242 00000F47 1F                      .20                     pop     ds                                              ;restore non-volatile regs
  4243 00000F48 59                                              pop     ecx                                             ;
  4244 00000F49 5B                                              pop     ebx                                             ;
  4245 00000F4A C3                                              ret                                                     ;return
  4246                                  ;-----------------------------------------------------------------------------------------------------------------------
  4247                                  ;
  4248                                  ;       Routine:        PutMessage
  4249                                  ;
  4250                                  ;       Description:    This routine adds a message to the message queue.
  4251                                  ;
  4252                                  ;       In:             ECX     hi-order data word
  4253                                  ;                       EDX     lo-order data word
  4254                                  ;
  4255                                  ;       Out:            CY      0 = success
  4256                                  ;                               1 = fail: queue is full
  4257                                  ;
  4258                                  ;-----------------------------------------------------------------------------------------------------------------------
  4259 00000F4B 1E                      PutMessage              push    ds                                              ;save non-volatile regs
  4260 00000F4C 6A2C                                            push    ELDTMQ                                          ;load task message queue selector ...
  4261 00000F4E 1F                                              pop     ds                                              ;... into data segment register
  4262 00000F4F A104000000                                      mov     eax,[MQTail]                                    ;tail ptr
  4263 00000F54 833800                                          cmp     dword [eax],0                                   ;is queue full?
  4264 00000F57 F9                                              stc                                                     ;assume failure
  4265 00000F58 7517                                            jne     .20                                             ;yes, cannot store
  4266 00000F5A 8910                                            mov     [eax],edx                                       ;store lo-order data
  4267 00000F5C 894804                                          mov     [eax+4],ecx                                     ;store hi-order data
  4268 00000F5F 83C008                                          add     eax,8                                           ;next queue element adr
  4269 00000F62 25FC030000                                      and     eax,03FCh                                       ;at end of queue?
  4270 00000F67 7502                                            jnz     .10                                             ;no, skip ahead
  4271 00000F69 B008                                            mov     al,8                                            ;reset to top of queue
  4272 00000F6B A304000000              .10                     mov     [MQTail],eax                                    ;save new tail ptr
  4273 00000F70 F8                                              clc                                                     ;indicate success
  4274 00000F71 1F                      .20                     pop     ds                                              ;restore non-volatile regs
  4275 00000F72 C3                                              ret                                                     ;return
  4276                                  ;=======================================================================================================================
  4277                                  ;
  4278                                  ;       Memory-Mapped Video Routines
  4279                                  ;
  4280                                  ;       These routines read and/or write directly to CGA video memory (B800:0)
  4281                                  ;
  4282                                  ;       SetConsoleChar
  4283                                  ;       SetConsoleString
  4284                                  ;
  4285                                  ;=======================================================================================================================
  4286                                  ;-----------------------------------------------------------------------------------------------------------------------
  4287                                  ;
  4288                                  ;       Routine:        SetConsoleChar
  4289                                  ;
  4290                                  ;       Description:    This routine outputs an ASCII character at the given row and column.
  4291                                  ;
  4292                                  ;       In:             AL      ASCII character
  4293                                  ;                       CL      column
  4294                                  ;                       CH      row
  4295                                  ;                       ES      CGA selector
  4296                                  ;
  4297                                  ;       Out:            EAX     last target address written (ES:)
  4298                                  ;                       CL      column + 1
  4299                                  ;
  4300                                  ;-----------------------------------------------------------------------------------------------------------------------
  4301 00000F73 88C2                    SetConsoleChar          mov     dl,al                                           ;ASCII character
  4302 00000F75 0FB6C5                                          movzx   eax,ch                                          ;row
  4303 00000F78 B450                                            mov     ah,ECONCOLS                                     ;cols/row
  4304 00000F7A F6E4                                            mul     ah                                              ;row * cols/row
  4305 00000F7C 00C8                                            add     al,cl                                           ;add column
  4306 00000F7E 80D400                                          adc     ah,0                                            ;handle carry
  4307 00000F81 D1E0                                            shl     eax,1                                           ;screen offset
  4308 00000F83 268810                                          mov     [es:eax],dl                                     ;store character
  4309 00000F86 FEC1                                            inc     cl                                              ;next column
  4310 00000F88 C3                                              ret                                                     ;return
  4311                                  ;-----------------------------------------------------------------------------------------------------------------------
  4312                                  ;
  4313                                  ;       Routine:        SetConsoleString
  4314                                  ;
  4315                                  ;       Description:    This routine outputs a sequence of ASCII character at the given row and column.
  4316                                  ;
  4317                                  ;       In:             ESI     source offset (DS:)
  4318                                  ;                       CL      column
  4319                                  ;                       CH      row
  4320                                  ;                       ES      CGA selector
  4321                                  ;
  4322                                  ;-----------------------------------------------------------------------------------------------------------------------
  4323 00000F89 56                      SetConsoleString        push    esi                                             ;save non-volatile regs
  4324 00000F8A FC                                              cld                                                     ;forward strings
  4325 00000F8B AC                      .10                     lodsb                                                   ;next ASCII character
  4326 00000F8C 84C0                                            test    al,al                                           ;end of string?
  4327 00000F8E 7407                                            jz      .20                                             ;yes, branch
  4328 00000F90 E8DEFFFFFF                                      call    SetConsoleChar                                  ;store character
  4329 00000F95 EBF4                                            jmp     .10                                             ;continue
  4330 00000F97 5E                      .20                     pop     esi                                             ;restore non-volatile regs
  4331 00000F98 C3                                              ret                                                     ;return
  4332                                  ;=======================================================================================================================
  4333                                  ;
  4334                                  ;       Input/Output Routines
  4335                                  ;
  4336                                  ;       These routines read and/or write directly to ports.
  4337                                  ;
  4338                                  ;       PlaceCursor
  4339                                  ;       PutPrimaryEndOfInt
  4340                                  ;       PutSecondaryEndOfInt
  4341                                  ;       ResetSystem
  4342                                  ;       SetKeyboardLamps
  4343                                  ;       WaitForKeyInBuffer
  4344                                  ;       WaitForKeyOutBuffer
  4345                                  ;
  4346                                  ;=======================================================================================================================
  4347                                  ;-----------------------------------------------------------------------------------------------------------------------
  4348                                  ;
  4349                                  ;       Routine:        PlaceCursor
  4350                                  ;
  4351                                  ;       Description:    This routine positions the cursor on the console.
  4352                                  ;
  4353                                  ;       In:             DS      OS data selector
  4354                                  ;
  4355                                  ;-----------------------------------------------------------------------------------------------------------------------
  4356 00000F99 51                      PlaceCursor             push    ecx                                             ;save non-volatile regs
  4357 00000F9A A0190F0000                                      mov     al,[wbConsoleRow]                               ;AL = row
  4358 00000F9F B450                                            mov     ah,ECONCOLS                                     ;AH = cols/row
  4359 00000FA1 F6E4                                            mul     ah                                              ;row offset
  4360 00000FA3 0205180F0000                                    add     al,[wbConsoleColumn]                            ;add column
  4361 00000FA9 80D400                                          adc     ah,0                                            ;add overflow
  4362 00000FAC 89C1                                            mov     ecx,eax                                         ;screen offset
  4363 00000FAE B2D4                                            mov     dl,ECRTPORTLO                                   ;crt controller port lo
  4364 00000FB0 B603                                            mov     dh,ECRTPORTHI                                   ;crt controller port hi
  4365 00000FB2 B00E                                            mov     al,ECRTCURLOCHI                                 ;crt cursor loc reg hi
  4366 00000FB4 EE                                              out     dx,al                                           ;select register
  4367 00000FB5 42                                              inc     edx                                             ;data port
  4368 00000FB6 88E8                                            mov     al,ch                                           ;hi-order cursor loc
  4369 00000FB8 EE                                              out     dx,al                                           ;store hi-order loc
  4370 00000FB9 4A                                              dec     edx                                             ;register select port
  4371 00000FBA B00F                                            mov     al,ECRTCURLOCLO                                 ;crt cursor loc reg lo
  4372 00000FBC EE                                              out     dx,al                                           ;select register
  4373 00000FBD 42                                              inc     edx                                             ;data port
  4374 00000FBE 88C8                                            mov     al,cl                                           ;lo-order cursor loc
  4375 00000FC0 EE                                              out     dx,al                                           ;store lo-order loc
  4376 00000FC1 59                                              pop     ecx                                             ;restore non-volatile regs
  4377 00000FC2 C3                                              ret                                                     ;return
  4378                                  ;-----------------------------------------------------------------------------------------------------------------------
  4379                                  ;
  4380                                  ;       Routine:        PutPrimaryEndOfInt
  4381                                  ;
  4382                                  ;       Description:    This routine sends a non-specific end-of-interrupt signal to the primary PIC.
  4383                                  ;
  4384                                  ;-----------------------------------------------------------------------------------------------------------------------
  4385 00000FC3 B020                    PutPrimaryEndOfInt      mov     al,EPICEOI                                      ;non-specific end-of-interrupt
  4386 00000FC5 E620                                            out     EPICPORTPRI,al                                  ;send EOI to primary PIC
  4387 00000FC7 C3                                              ret                                                     ;return
  4388                                  ;-----------------------------------------------------------------------------------------------------------------------
  4389                                  ;
  4390                                  ;       Routine:        PutSecondaryEndOfInt
  4391                                  ;
  4392                                  ;       Description:    This routine sends a non-specific end-of-interrupt signal to the secondary PIC.
  4393                                  ;
  4394                                  ;-----------------------------------------------------------------------------------------------------------------------
  4395 00000FC8 B020                    PutSecondaryEndOfInt    mov     al,EPICEOI                                      ;non-specific end-of-interrupt
  4396 00000FCA E6A0                                            out     EPICPORTSEC,al                                  ;send EOI to secondary PIC
  4397 00000FCC C3                                              ret                                                     ;return
  4398                                  ;-----------------------------------------------------------------------------------------------------------------------
  4399                                  ;
  4400                                  ;       Routine:        ResetSystem
  4401                                  ;
  4402                                  ;       Description:    This routine restarts the system using the 8042 controller.
  4403                                  ;
  4404                                  ;       Out:            N/A     This routine does not return.
  4405                                  ;
  4406                                  ;-----------------------------------------------------------------------------------------------------------------------
  4407 00000FCD B9FFFF1F00              ResetSystem             mov     ecx,001fffffh                                   ;delay to clear ints
  4408 00000FD2 E2FE                                            loop    $                                               ;clear interrupts
  4409 00000FD4 B0FE                                            mov     al,EKEYBCMDRESET                                ;mask out bit zero
  4410 00000FD6 E664                                            out     EKEYBPORTSTAT,al                                ;drive bit zero low
  4411 00000FD8 FB                      .10                     sti                                                     ;enable maskable interrupts
  4412 00000FD9 F4                                              hlt                                                     ;halt until interrupt
  4413 00000FDA EBFC                                            jmp     .10                                             ;repeat until reset kicks in
  4414                                  ;-----------------------------------------------------------------------------------------------------------------------
  4415                                  ;
  4416                                  ;       Routine:        SetKeyboardLamps
  4417                                  ;
  4418                                  ;       Description:    This routine sends the set/reset mode indicators command to the keyboard device.
  4419                                  ;
  4420                                  ;       In:             BH      00000CNS (C:Caps Lock,N:Num Lock,S:Scroll Lock)
  4421                                  ;
  4422                                  ;-----------------------------------------------------------------------------------------------------------------------
  4423 00000FDC 53                      SetKeyboardLamps        push    ebx                                             ;save non-volatile regs
  4424 00000FDD 56                                              push    esi                                             ;
  4425 00000FDE BE1A0F0000                                      mov     esi,wsKeybData                                  ;keyboard data addr
  4426 00000FE3 8A7E08                                          mov     bh,[esi+KEYBDATA.lock]                          ;lock flags
  4427 00000FE6 E820000000                                      call    WaitForKeyInBuffer                              ;wait for input buffer ready
  4428 00000FEB B0ED                                            mov     al,EKEYBCMDLAMPS                                ;set/reset lamps command
  4429 00000FED E660                                            out     EKEYBPORTDATA,al                                ;send command to 8042
  4430 00000FEF E825000000                                      call    WaitForKeyOutBuffer                             ;wait for 8042 result
  4431 00000FF4 E460                                            in      al,EKEYBPORTDATA                                ;read 8042 'ACK' (0fah)
  4432 00000FF6 E810000000                                      call    WaitForKeyInBuffer                              ;wait for input buffer ready
  4433 00000FFB 88F8                                            mov     al,bh                                           ;set/reset lamps value
  4434 00000FFD 2407                                            and     al,7                                            ;mask for lamp switches
  4435 00000FFF E660                                            out     EKEYBPORTDATA,al                                ;send lamps value
  4436 00001001 E813000000                                      call    WaitForKeyOutBuffer                             ;wait for 8042 result
  4437 00001006 E460                                            in      al,EKEYBPORTDATA                                ;read 8042 'ACK' (0fah)
  4438 00001008 5E                                              pop     esi                                             ;restore non-volatile regs
  4439 00001009 5B                                              pop     ebx                                             ;
  4440 0000100A C3                                              ret                                                     ;return
  4441                                  ;-----------------------------------------------------------------------------------------------------------------------
  4442                                  ;
  4443                                  ;       Routine:        WaitForKeyInBuffer
  4444                                  ;
  4445                                  ;       Description:    This routine waits for keyboard input buffer to be ready for input.
  4446                                  ;
  4447                                  ;       Out:            ZF      1 = Input buffer ready
  4448                                  ;                               0 = Input buffer not ready after timeout
  4449                                  ;
  4450                                  ;-----------------------------------------------------------------------------------------------------------------------
  4451 0000100B 51                      WaitForKeyInBuffer      push    ecx                                             ;save non-volatile regs
  4452 0000100C B900000100                                      mov     ecx,EKEYBWAITLOOP                               ;keyboard controller timeout
  4453 00001011 E464                    .10                     in      al,EKEYBPORTSTAT                                ;keyboard status byte
  4454 00001013 A802                                            test    al,EKEYBBITIN                                   ;is input buffer still full?
  4455 00001015 E0FA                                            loopnz  .10                                             ;yes, repeat till timeout
  4456 00001017 59                                              pop     ecx                                             ;restore non-volatile regs
  4457 00001018 C3                                              ret                                                     ;return
  4458                                  ;-----------------------------------------------------------------------------------------------------------------------
  4459                                  ;
  4460                                  ;       Routine:        WaitForKeyOutBuffer
  4461                                  ;
  4462                                  ;       Description:    This routine waits for keyboard output buffer to have data to read.
  4463                                  ;
  4464                                  ;       Out:            ZF      1 = Output buffer has data from controller
  4465                                  ;                               0 = Output buffer empty after timeout
  4466                                  ;
  4467                                  ;-----------------------------------------------------------------------------------------------------------------------
  4468 00001019 51                      WaitForKeyOutBuffer     push    ecx                                             ;save non-volatile regs
  4469 0000101A B900000100                                      mov     ecx,EKEYBWAITLOOP                               ;keyboard controller timeout
  4470 0000101F E464                    .10                     in      al,EKEYBPORTSTAT                                ;keyboard status byte
  4471 00001021 A801                                            test    al,EKEYBBITOUT                                  ;output buffer status bit
  4472 00001023 E1FA                                            loopz   .10                                             ;loop until output buffer bit
  4473 00001025 59                                              pop     ecx                                             ;restore non-volatile regs
  4474 00001026 C3                                              ret                                                     ;return
  4475                                  ;-----------------------------------------------------------------------------------------------------------------------
  4476                                  ;
  4477                                  ;       End of the Kernel Function Library
  4478                                  ;
  4479                                  ;-----------------------------------------------------------------------------------------------------------------------
  4480 00001027 00<rept>                                        times   8192-($-$$) db 0h                               ;zero fill to end of section
  4481                                  ;=======================================================================================================================
  4482                                  ;
  4483                                  ;       Console Task
  4484                                  ;
  4485                                  ;       The only task defined in the kernel is the console task. This task consists of code, data, stack, and task state
  4486                                  ;       segments and a local descriptor table. The console task accepts and echos user keyboard input to the console
  4487                                  ;       screen and responds to user commands.
  4488                                  ;
  4489                                  ;=======================================================================================================================
  4490                                  ;-----------------------------------------------------------------------------------------------------------------------
  4491                                  ;
  4492                                  ;       Console Stack                                                           @disk: 007600   @mem:  004000
  4493                                  ;
  4494                                  ;       This is the stack for the console task. It supports 448 nested calls.
  4495                                  ;
  4496                                  ;-----------------------------------------------------------------------------------------------------------------------
  4497                                  section                 constack                                                ;console task stack
  4498 00000000 00<rept>                                        times   1792-($-$$) db 0h                               ;zero fill to end of section
  4499                                  ;-----------------------------------------------------------------------------------------------------------------------
  4500                                  ;
  4501                                  ;       Console Local Descriptor Table                                          @disk: 007d00   @mem:  004700
  4502                                  ;
  4503                                  ;       This is the LDT for the console task. It defines the stack, code, data and queue segments as well as data
  4504                                  ;       aliases for the TSS LDT. Data aliases allow inspection and altering of the TSS and LDT. This LDT can hold up to
  4505                                  ;       16 descriptors. Six are initially defined.
  4506                                  ;
  4507                                  ;-----------------------------------------------------------------------------------------------------------------------
  4508                                  section                 conldt                                                  ;console local descriptors
  4509 00000000 7F00804700934000                                dq      004093004780007Fh                               ;04 TSS alias
  4510 00000008 7F00004700934000                                dq      004093004700007Fh                               ;0c LDT alias
  4511 00000010 FF06004000934000                                dq      00409300400006FFh                               ;14 stack
  4512 00000018 FFFF00000093CF00                                dq      00CF93000000FFFFh                               ;1c data
  4513 00000020 FF0F0050009B4000                                dq      00409B0050000FFFh                               ;24 code
  4514 00000028 FF07004800934000                                dq      00409300480007FFh                               ;2c message queue
  4515 00000030 00<rept>                                        times   128-($-$$) db 0h                                ;zero fill to end of section
  4516                                  ;-----------------------------------------------------------------------------------------------------------------------
  4517                                  ;
  4518                                  ;       Console Task State Segment                                              @disk: 007d80   @mem:  004780
  4519                                  ;
  4520                                  ;       This is the TSS for the console task. All rings share the same stack. DS and ES are set to the console data
  4521                                  ;       segment. CS to console code.
  4522                                  ;
  4523                                  ;-----------------------------------------------------------------------------------------------------------------------
  4524                                  section                 contss                                                  ;console task state segment
  4525 00000000 00000000                                        dd      0                                               ;00 back-link tss
  4526 00000004 00070000                                        dd      0700h                                           ;04 esp ring 0
  4527 00000008 14000000                                        dd      0014h                                           ;08 ss ring 0
  4528 0000000C 00070000                                        dd      0700h                                           ;0c esp ring 1
  4529 00000010 14000000                                        dd      0014h                                           ;10 es ring 1
  4530 00000014 00070000                                        dd      0700h                                           ;14 esp ring 2
  4531 00000018 14000000                                        dd      0014h                                           ;18 ss ring 2
  4532 0000001C 00000000                                        dd      0                                               ;1c cr ring 3
  4533 00000020 00000000                                        dd      0                                               ;20 eip
  4534 00000024 00020000                                        dd      0200h                                           ;24 eflags
  4535 00000028 00000000                                        dd      0                                               ;28 eax
  4536 0000002C 00000000                                        dd      0                                               ;2c ecx
  4537 00000030 00000000                                        dd      0                                               ;30 edx
  4538 00000034 00000000                                        dd      0                                               ;34 ebx
  4539 00000038 00070000                                        dd      0700h                                           ;38 esp ring 3
  4540 0000003C 00000000                                        dd      0                                               ;3c ebp
  4541 00000040 00000000                                        dd      0                                               ;40 esi
  4542 00000044 00000000                                        dd      0                                               ;44 edi
  4543 00000048 1C000000                                        dd      001Ch                                           ;48 es
  4544 0000004C 24000000                                        dd      0024h                                           ;4c cs
  4545 00000050 14000000                                        dd      0014h                                           ;50 ss ring 3
  4546 00000054 1C000000                                        dd      001Ch                                           ;54 ds
  4547 00000058 00000000                                        dd      0                                               ;58 fs
  4548 0000005C 00000000                                        dd      0                                               ;5c gs
  4549 00000060 60000000                                        dd      EGDTCONSOLELDT                                  ;60 ldt selector in gdt
  4550 00000064 00<rept>                                        times   128-($-$$) db 0h                                ;zero fill to end of section
  4551                                  ;-----------------------------------------------------------------------------------------------------------------------
  4552                                  ;
  4553                                  ;       Console Message Queue                                                   @disk: 007e00   @mem: 004800
  4554                                  ;
  4555                                  ;       The console message queue is 2048 bytes of memory organized as a queue of 510 double words (4 bytes each) and
  4556                                  ;       two double word values that act as indices. The queue is a FIFO that is fed by the keyboard hardware interrupt
  4557                                  ;       handler and consumed by a service routine called from a task. Each queue entry defines an input (keystroke)
  4558                                  ;       event.
  4559                                  ;
  4560                                  ;-----------------------------------------------------------------------------------------------------------------------
  4561                                  section                 conmque                                                 ;console message queue
  4562 00000000 08000000                                        dd      8                                               ;head pointer
  4563 00000004 08000000                                        dd      8                                               ;tail pointer
  4564 00000008 00000000<rept>                                  times   510 dd 0                                        ;queue elements
  4565                                  ;-----------------------------------------------------------------------------------------------------------------------
  4566                                  ;
  4567                                  ;       Console Code                                                            @disk: 008600   @mem: 005000
  4568                                  ;
  4569                                  ;       This is the code for the console task. The task is defined in the GDT in two descriptors, the Local Descriptor
  4570                                  ;       Table (LDT) at 0050h and the Task State Segment (TSS) at 0058h. Jumping to or calling a TSS selector causes a
  4571                                  ;       task switch, giving control to the code for the task at the CS:IP defined in the TSS for the current ring level.
  4572                                  ;       The initial CS:IP in the Console TSS is 24h:0, where 24h is a selector in the LDT. This selector points to the
  4573                                  ;       concode section, loaded into memory 5000h by the Loader. The console task is dedicated to accepting user key-
  4574                                  ;       board input, echoing to the console screen and responding to user commands.
  4575                                  ;
  4576                                  ;       When control reaches this section, our addressability is set up according to the following diagram.
  4577                                  ;
  4578                                  ;       DS,ES --------> 000000  +-----------------------------------------------+ DS,ES:0000
  4579                                  ;                               |  Real Mode Interrupt Vectors                  |
  4580                                  ;                       000400  +-----------------------------------------------+ DS,ES:0400
  4581                                  ;                               |  Reserved BIOS Memory Area                    |
  4582                                  ;                       000800  +-----------------------------------------------+ DS,ES:0800
  4583                                  ;                               |  Shared Kernel Memory Area                    |
  4584                                  ;                       001000  +-----------------------------------------------+               <-- GDTR
  4585                                  ;                               |  Global Descriptor Table (GDT)                |
  4586                                  ;                       001800  +-----------------------------------------------+               <-- IDTR
  4587                                  ;                               |  Interrupt Descriptor Table (IDT)             |
  4588                                  ;                       002000  +-----------------------------------------------+
  4589                                  ;                               |  Interrupt Handlers                           |
  4590                                  ;                               |  Kernel Function Library                      |
  4591                                  ;       SS -----------> 004000  +===============================================+ SS:0000
  4592                                  ;                               |  Console Task Stack Area                      |
  4593                                  ;       SS:SP --------> 004700  +-----------------------------------------------+ SS:0700       <-- LDTR = GDT.SEL 0050h
  4594                                  ;                               |  Console Task Local Descriptor Table (LDT)    |
  4595                                  ;                       004780  +-----------------------------------------------+               <-- TR  = GDT.SEL 0058h
  4596                                  ;                               |  Console Task Task State Segment (TSS)        |
  4597                                  ;                       004800  +-----------------------------------------------+
  4598                                  ;                               |  Console Task Message Queue                   |
  4599                                  ;       CS:IP --------> 005000  +-----------------------------------------------+ CS:0000
  4600                                  ;                               |  Console Task Code                            |
  4601                                  ;                               |  Console Task Constants                       |
  4602                                  ;                       006000  +===============================================+
  4603                                  ;
  4604                                  ;-----------------------------------------------------------------------------------------------------------------------
  4605                                  ;=======================================================================================================================
  4606                                  ;
  4607                                  ;       Console Task Routines
  4608                                  ;
  4609                                  ;       ConCode                 Console task entry point
  4610                                  ;       ConClearPanel           Clear the panel area of video memory to spaces
  4611                                  ;       ConDrawFields           Draw the panel fields to video memory
  4612                                  ;       ConDrawField            Draw a panel field to video memory
  4613                                  ;       ConPutCursor            Place the cursor at the current index into the current field
  4614                                  ;       ConHandlerMain          Handle attention keys on the main panel
  4615                                  ;       ConHandlerView          Handle attention keys on the memory panel
  4616                                  ;       ConTakeToken            Extract the next token from a buffer
  4617                                  ;       ConDetermineCommand     Determine if a buffer value is a command
  4618                                  ;       ConGo                   Handle the go command
  4619                                  ;       ConFree                 Handle the free command
  4620                                  ;       ConInt6                 Handle the Int6 command
  4621                                  ;       ConReset                Handle the reset command
  4622                                  ;       ConView                 Handle the view command
  4623                                  ;       ConClearField           Clear a panel field to nulls
  4624                                  ;       ConMain                 Handle the main command
  4625                                  ;       ConMalloc               Handle the malloc command
  4626                                  ;
  4627                                  ;=======================================================================================================================
  4628                                  section                 concode vstart=05000h                                   ;labels relative to 5000h
  4629                                  ;
  4630                                  ;       Initialize console work areas to low values.
  4631                                  ;
  4632 00000000 BF00080000              ConCode                 mov     edi,ECONDATA                                    ;OS console data address
  4633 00000005 30C0                                            xor     al,al                                           ;initialization value
  4634 00000007 B93C070000                                      mov     ecx,ECONDATALEN                                 ;size of OS console data
  4635 0000000C FC                                              cld                                                     ;forward strings
  4636 0000000D F3AA                                            rep     stosb                                           ;initialize data
  4637                                  ;
  4638                                  ;       Initialize the Operator Information Area (OIA).
  4639                                  ;
  4640 0000000F 06                                              push    es                                              ;save extra segment
  4641 00000010 6A20                                            push    EGDTCGA                                         ;load CGA video selector...
  4642 00000012 07                                              pop     es                                              ;...into extra segment reg
  4643 00000013 BF000F0000                                      mov     edi,ECONROWS*ECONROWBYTES                       ;target offset
  4644 00000018 B820702070                                      mov     eax,ECONOIADWORD                                ;OIA attribute and space
  4645 0000001D B928000000                                      mov     ecx,ECONROWDWORDS                               ;double-words per row
  4646 00000022 F3AB                                            rep     stosd                                           ;reset OIA
  4647 00000024 07                                              pop     es                                              ;restore extra segment
  4648                                  ;
  4649                                  ;       Set num-lock and update lamps
  4650                                  ;       Display the initial OIA
  4651                                  ;
  4652 00000025 800D220F000002                                  or      byte [wsKeybData+KEYBDATA.lock],EKEYFLOCKNUM    ;BIOS boots with num-lock on
  4653                                                          setKeyboardLamps
  4653 0000002C B009                <1>  mov al,eSetKeyboardLamps
  4653 0000002E CD30                <1>  int _svc
  4654                                                          putConsoleOIA
  4654 00000030 B007                <1>  mov al,ePutConsoleOIA
  4654 00000032 CD30                <1>  int _svc
  4655                                  ;
  4656                                  ;       Set the current panel to Main, clear and redraw all fields.
  4657                                  ;
  4658 00000034 E83E030000                                      call    ConMain                                         ;initialize panel
  4659                                  ;
  4660                                  ;       Place the cursor at the current field index.
  4661                                  ;
  4662 00000039 E8BA010000              .10                     call    ConPutCursor                                    ;place the cursor
  4663                                  ;
  4664                                  ;       Get the next key-down message.
  4665                                  ;
  4666                                  .20                     getConsoleMessage                                       ;get a console message
  4666                              <1> .20 :
  4666 0000003E B004                <1>  mov al,eGetConsoleMessage
  4666 00000040 CD30                <1>  int _svc
  4667                                  ;
  4668 00000042 89C2                                            mov     edx,eax                                         ;message and params
  4669 00000044 81E20000FFFF                                    and     edx,0FFFF0000h                                  ;mask for message
  4670 0000004A 81FA00000041                                    cmp     edx,EMSGKEYDOWN                                 ;keydown message?
  4671 00000050 75EC                                            jne     .20                                             ;no, next message
  4672                                  ;
  4673                                  ;       Give the message to the panel event-handler first.
  4674                                  ;
  4675 00000052 8B0D00080000                                    mov     ecx,[wdConsoleHandler]                          ;handler addr?
  4676 00000058 E304                                            jecxz   .30                                             ;no, branch
  4677 0000005A FFD1                                            call    ecx                                             ;event handled?
  4678 0000005C 72E0                                            jc     .20                                              ;yes, next message
  4679                                  ;
  4680                                  ;       To handle the event here, we need a current field that has a buffer.
  4681                                  ;
  4682 0000005E 8B1D08080000            .30                     mov     ebx,[wdConsoleField]                            ;field addr
  4683 00000064 85DB                                            test    ebx,ebx                                         ;field addr?
  4684 00000066 74D6                                            jz      .20                                             ;no, next message
  4685 00000068 8B0B                                            mov     ecx,[ebx]                                       ;buffer addr?
  4686 0000006A E3D2                                            jecxz   .20                                             ;no, next message
  4687 0000006C 0FB65307                                        movzx   edx,byte [ebx+7]                                ;field index
  4688                                  ;
  4689                                  ;       Handle tab down and shift-tab down to navigate panel fields.
  4690                                  ;
  4691 00000070 80FC0F                                          cmp     ah,EKEYBTABDOWN                                 ;tab down?
  4692 00000073 756C                                            jne     .100                                            ;no, branch
  4693 00000075 F605210F000012                                  test    byte [wsKeybData+KEYBDATA.shift],EKEYFSHIFT     ;shift?
  4694 0000007C 7438                                            jz      .80                                             ;no, tab forward
  4695                                  ;
  4696                                  ;       Handle backward-tab.
  4697                                  ;
  4698 0000007E 3B1D04080000            .40                     cmp     ebx,[wdConsolePanel]                            ;at first field?
  4699 00000084 7605                                            jna     .50                                             ;yes, branch
  4700 00000086 8D5BF4                                          lea     ebx,[ebx-12]                                    ;previous field
  4701 00000089 EB15                                            jmp     .70                                             ;branch
  4702 0000008B 8B1D04080000            .50                     mov     ebx,[wdConsolePanel]                            ;sanity check
  4703 00000091 837B0C00                                        cmp     dword [ebx+12],0                                ;last field?
  4704 00000095 74A7                                            je      .20                                             ;yes, next message (only 1 field)
  4705 00000097 8D5B0C                  .60                     lea     ebx,[ebx+12]                                    ;next field
  4706 0000009A 837B0C00                                        cmp     dword [ebx+12],0                                ;last field?
  4707 0000009E 75F7                                            jne     .60                                             ;no, continue
  4708 000000A0 3B1D08080000            .70                     cmp     ebx,[wdConsoleField]                            ;back to current field?
  4709 000000A6 7496                                            je      .20                                             ;yes, next message
  4710 000000A8 F6430B80                                        test    byte [ebx+11],80h                               ;input field?
  4711 000000AC 74D0                                            jz      .40                                             ;no, next field
  4712 000000AE 891D08080000                                    mov     [wdConsoleField],ebx                            ;set current field
  4713 000000B4 EB83                                            jmp     .10                                             ;place cursor and get message
  4714                                  ;
  4715                                  ;       Handle forward-tab.
  4716 000000B6 8D5B0C                  .80                     lea     ebx,[ebx+12]                                    ;next field addr
  4717 000000B9 833B00                                          cmp     dword [ebx],0                                   ;end of panel?
  4718 000000BC 7506                                            jne     .90                                             ;no, branch
  4719 000000BE 8B1D04080000                                    mov     ebx,[wdConsolePanel]                            ;start of panel
  4720 000000C4 3B1D08080000            .90                     cmp     ebx,[wdConsoleField]                            ;back to current field?
  4721 000000CA 0F846EFFFFFF                                    je      .20                                             ;yes, next message
  4722 000000D0 F6430B80                                        test    byte [ebx+11],80h                               ;input field?
  4723 000000D4 74E0                                            jz      .80                                             ;no, next field
  4724 000000D6 891D08080000                                    mov     [wdConsoleField],ebx                            ;set current field
  4725 000000DC E958FFFFFF                                      jmp     .10                                             ;place cursor and get message
  4726                                  ;
  4727                                  ;       Handle left or up arrow.
  4728                                  ;
  4729 000000E1 80FC6B                  .100                    cmp     ah,EKEYBLEFTARROWDOWN                           ;left-arrow down?
  4730 000000E4 7405                                            je      .110                                            ;yes, branch
  4731 000000E6 80FC68                                          cmp     ah,EKEYBUPARROWDOWN                             ;up-arrow down?
  4732 000000E9 7510                                            jne     .120                                            ;no, branch
  4733 000000EB 84D2                    .110                    test    dl,dl                                           ;index is zero?
  4734 000000ED 0F844BFFFFFF                                    jz      .20                                             ;yes, next message
  4735 000000F3 FE4B07                                          dec     byte [ebx+7]                                    ;decrement index
  4736 000000F6 E93EFFFFFF                                      jmp     .10                                             ;put cursor and next message
  4737                                  ;
  4738                                  ;       Handle right or down arrow.
  4739                                  ;
  4740 000000FB 80FC6D                  .120                    cmp     ah,EKEYBRIGHTARROWDOWN                          ;right-arrow down?
  4741 000000FE 7405                                            je      .130                                            ;yes, branch
  4742 00000100 80FC70                                          cmp     ah,EKEYBDOWNARROWDOWN                           ;down-arrow down?
  4743 00000103 751D                                            jne     .140                                            ;no, branch
  4744 00000105 803C1100                .130                    cmp     byte [ecx+edx],0                                ;end of input?
  4745 00000109 0F842FFFFFFF                                    je      .20                                             ;yes, next message
  4746 0000010F FEC2                                            inc     dl                                              ;increment index
  4747 00000111 3A5306                                          cmp     dl,byte [ebx+6]                                 ;end of field?
  4748 00000114 0F8324FFFFFF                                    jnb     .20                                             ;yes, next message
  4749 0000011A 885307                                          mov     [ebx+7],dl                                      ;save new index
  4750 0000011D E917FFFFFF                                      jmp     .10                                             ;put cursor and next message
  4751                                  ;
  4752                                  ;       Handle backspace
  4753                                  ;
  4754 00000122 80FC0E                  .140                    cmp     ah,EKEYBBACKSPACE                               ;backspace?
  4755 00000125 751D                                            jne     .160                                            ;no, branch
  4756 00000127 84D2                                            test    dl,dl                                           ;index is zero?
  4757 00000129 0F840FFFFFFF                                    jz      .20                                             ;yes, next message
  4758 0000012F FE4B07                                          dec     byte [ebx+7]                                    ;decrement index
  4759 00000132 89CF                                            mov     edi,ecx                                         ;buffer addr
  4760 00000134 8D7C17FF                                        lea     edi,[edi+edx-1]                                 ;end of buffer
  4761 00000138 89FE                                            mov     esi,edi                                         ;end of buffer
  4762 0000013A 46                                              inc     esi                                             ;source address
  4763 0000013B FC                                              cld                                                     ;forward strings
  4764 0000013C AC                      .150                    lodsb                                                   ;character
  4765 0000013D AA                                              stosb                                                   ;save over previous
  4766 0000013E 84C0                                            test    al,al                                           ;end of input?
  4767 00000140 75FA                                            jnz     .150                                            ;no, continue
  4768 00000142 EB1D                                            jmp     .170                                            ;draw field, put cursor, next message
  4769                                  ;
  4770                                  ;       Handle printables
  4771                                  ;
  4772 00000144 3C20                    .160                    cmp     al,EASCIISPACE                                  ;printable range? (low)
  4773 00000146 0F82F2FEFFFF                                    jb      .20                                             ;no, next message
  4774 0000014C 3C7E                                            cmp     al,EASCIITILDE                                  ;printable range? (high)
  4775 0000014E 0F87EAFEFFFF                                    ja      .20                                             ;no, next message
  4776 00000154 880411                                          mov     [ecx+edx],al                                    ;store char in buffer
  4777 00000157 FEC2                                            inc     dl                                              ;advance index
  4778 00000159 3A5306                                          cmp     dl,[ebx+6]                                      ;end of field?
  4779 0000015C 7303                                            jnb     .170                                            ;yes, branch
  4780 0000015E 885307                                          mov     [ebx+7],dl                                      ;save new index
  4781 00000161 E84F000000              .170                    call    ConDrawField                                    ;redraw field
  4782 00000166 E9CEFEFFFF                                      jmp     .10                                             ;put cursor and get message
  4783                                  ;-----------------------------------------------------------------------------------------------------------------------
  4784                                  ;
  4785                                  ;       Routine:        ConClearPanel
  4786                                  ;
  4787                                  ;       Description:    This routine clears the console panel video memory. The panel field buffer values
  4788                                  ;                       are not disturbed.
  4789                                  ;
  4790                                  ;-----------------------------------------------------------------------------------------------------------------------
  4791 0000016B 51                      ConClearPanel           push    ecx                                             ;save non-volatile regs
  4792 0000016C 57                                              push    edi                                             ;
  4793 0000016D 06                                              push    es                                              ;
  4794                                  ;
  4795                                  ;       Clear panel rows.
  4796                                  ;
  4797 0000016E 6A20                                            push    EGDTCGA                                         ;load CGA video selector...
  4798 00000170 07                                              pop     es                                              ;...into extra segment reg
  4799 00000171 31FF                                            xor     edi,edi                                         ;target offset
  4800 00000173 B820072007                                      mov     eax,ECONCLEARDWORD                              ;initialization value
  4801 00000178 B9C0030000                                      mov     ecx,ECONROWS*ECONROWDWORDS                      ;double-words to clear
  4802 0000017D FC                                              cld                                                     ;forward strings
  4803 0000017E F3AB                                            rep     stosd                                           ;reset screen body
  4804                                  ;
  4805                                  ;       Restore and return.
  4806                                  ;
  4807 00000180 07                                              pop     es                                              ;restore non-volatile regs
  4808 00000181 5F                                              pop     edi                                             ;
  4809 00000182 59                                              pop     ecx                                             ;
  4810 00000183 C3                                              ret                                                     ;return
  4811                                  ;-----------------------------------------------------------------------------------------------------------------------
  4812                                  ;
  4813                                  ;       Routine:        ConDrawFields
  4814                                  ;
  4815                                  ;       Description:    This routine draws the panel fields. If there is no active input field, the first input
  4816                                  ;                       field of the panel is set as the active field.
  4817                                  ;
  4818                                  ;-----------------------------------------------------------------------------------------------------------------------
  4819 00000184 53                      ConDrawFields           push    ebx                                             ;save non-volatile regs
  4820                                  ;
  4821                                  ;       Exit if no panel
  4822                                  ;
  4823 00000185 8B1D04080000                                    mov     ebx,[wdConsolePanel]                            ;panel definition addr
  4824 0000018B 85DB                                            test    ebx,ebx                                         ;have panel?
  4825 0000018D 7424                                            jz      .30                                             ;no, branch
  4826                                  ;
  4827                                  ;       Loop until end of panel
  4828                                  ;
  4829 0000018F 833B00                  .10                     cmp     dword [ebx],0                                   ;end of panel?
  4830 00000192 741F                                            je      .30                                             ;yes, branch
  4831                                  ;
  4832                                  ;       If input field and we have no active field, set as active field
  4833                                  ;
  4834 00000194 F6430B80                                        test    byte [ebx+11],80h                               ;input field?
  4835 00000198 740F                                            jz      .20                                             ;no, branch
  4836 0000019A 833D0808000000                                  cmp     dword [wdConsoleField],0                        ;have active field?
  4837 000001A1 7506                                            jne     .20                                             ;yes, branch
  4838 000001A3 891D08080000                                    mov     [wdConsoleField],ebx                            ;set active field
  4839                                  ;
  4840                                  ;       Draw the field and loop to the next field.
  4841                                  ;
  4842 000001A9 E807000000              .20                     call    ConDrawField                                    ;draw field
  4843 000001AE 8D5B0C                                          lea     ebx,[ebx+12]                                    ;next field addr
  4844 000001B1 EBDC                                            jmp     .10                                             ;next field
  4845                                  ;
  4846                                  ;       Restore and return.
  4847                                  ;
  4848 000001B3 5B                      .30                     pop     ebx                                             ;restore non-volatile regs
  4849 000001B4 C3                                              ret                                                     ;return
  4850                                  ;-----------------------------------------------------------------------------------------------------------------------
  4851                                  ;
  4852                                  ;       Routine:        ConDrawField
  4853                                  ;
  4854                                  ;       Description:    This routine draws the contents of a panel field.
  4855                                  ;
  4856                                  ;       In:             DS:EBX  field definition address
  4857                                  ;                               [ebx+0]         field buffer address
  4858                                  ;                               [ebx+4]         row (0-23)
  4859                                  ;                               [ebx+5]         column (0,79)
  4860                                  ;                               [ebx+6]         size (0-255)
  4861                                  ;                               [ebx+7]         cursor index (0-255)
  4862                                  ;                               [ebx+8]         1st selected index (0-255)
  4863                                  ;                               [ebx+9]         last selected index (0-255)
  4864                                  ;                               [ebx+10]        attribute
  4865                                  ;                               [ebx+11]        flags
  4866                                  ;                                               80h = input field
  4867                                  ;
  4868                                  ;-----------------------------------------------------------------------------------------------------------------------
  4869 000001B5 51                      ConDrawField            push    ecx                                             ;save non-volatile regs
  4870 000001B6 56                                              push    esi                                             ;
  4871 000001B7 57                                              push    edi                                             ;
  4872 000001B8 06                                              push    es                                              ;
  4873                                  ;
  4874                                  ;       Exit if no field or zero size.
  4875                                  ;
  4876 000001B9 85DB                                            test    ebx,ebx                                         ;have field?
  4877 000001BB 7436                                            jz      .30                                             ;no, exit
  4878 000001BD 0FB64B06                                        movzx   ecx,byte [ebx+6]                                ;have size?
  4879 000001C1 E330                                            jecxz   .30                                             ;no, exit
  4880                                  ;
  4881                                  ;       Address video memory.
  4882                                  ;
  4883 000001C3 6A20                                            push    EGDTCGA                                         ;load CGA video selector...
  4884 000001C5 07                                              pop     es                                              ;...into extra segment reg
  4885                                  ;
  4886                                  ;       Compute the target offset.
  4887                                  ;
  4888 000001C6 0FB64304                                        movzx   eax,byte [ebx+4]                                ;row
  4889 000001CA B450                                            mov     ah,ECONCOLS                                     ;columns per row
  4890 000001CC F6E4                                            mul     ah                                              ;row offset
  4891 000001CE 024305                                          add     al,byte [ebx+5]                                 ;add column
  4892 000001D1 80D400                                          adc     ah,0                                            ;handle overflow
  4893 000001D4 D1E0                                            shl     eax,1                                           ;two-bytes per column
  4894 000001D6 89C7                                            mov     edi,eax                                         ;target offset
  4895                                  ;
  4896                                  ;       Display field characters.
  4897                                  ;
  4898 000001D8 8A630A                                          mov     ah,[ebx+10]                                     ;attribute
  4899 000001DB FC                                              cld                                                     ;forward strings
  4900 000001DC 8B33                                            mov     esi,[ebx]                                       ;field buffer addr
  4901 000001DE 85F6                                            test    esi,esi                                         ;have field buffer?
  4902 000001E0 740C                                            jz      .20                                             ;no, exit
  4903 000001E2 AC                      .10                     lodsb                                                   ;field character
  4904 000001E3 84C0                                            test    al,al                                           ;end of value?
  4905 000001E5 7407                                            jz      .20                                             ;yes, branch
  4906 000001E7 66AB                                            stosw                                                   ;store character with attribute
  4907 000001E9 49                                              dec     ecx                                             ;decrement remaining size
  4908 000001EA E307                                            jecxz   .30                                             ;exit if field full
  4909 000001EC EBF4                                            jmp     .10                                             ;next character
  4910                                  ;
  4911                                  ;       Clear the remaining field.
  4912                                  ;
  4913 000001EE B020                    .20                     mov     al,EASCIISPACE                                  ;ASCII space
  4914 000001F0 F366AB                                          rep     stosw                                           ;store space with attribute
  4915                                  ;
  4916                                  ;       Restore and return.
  4917                                  ;
  4918 000001F3 07                      .30                     pop     es                                              ;restore non-volatile regs
  4919 000001F4 5F                                              pop     edi                                             ;
  4920 000001F5 5E                                              pop     esi                                             ;
  4921 000001F6 59                                              pop     ecx                                             ;
  4922 000001F7 C3                                              ret                                                     ;return
  4923                                  ;-----------------------------------------------------------------------------------------------------------------------
  4924                                  ;
  4925                                  ;       Routine:        ConPutCursor
  4926                                  ;
  4927                                  ;       Description:    This routine places the cursor at the current index into the current field.
  4928                                  ;
  4929                                  ;-----------------------------------------------------------------------------------------------------------------------
  4930 000001F8 51                      ConPutCursor            push    ecx                                             ;save non-volatile regs
  4931 000001F9 8B0D08080000                                    mov     ecx,[wdConsoleField]                            ;current field?
  4932 000001FF E317                                            jecxz   .10                                             ;no, branch
  4933 00000201 8A4104                                          mov     al,[ecx+4]                                      ;field row
  4934 00000204 A2190F0000                                      mov     [wbConsoleRow],al                               ;set current row
  4935 00000209 8A4105                                          mov     al,[ecx+5]                                      ;field column
  4936 0000020C 024107                                          add     al,[ecx+7]                                      ;field offset
  4937 0000020F A2180F0000                                      mov     [wbConsoleColumn],al                            ;set curren tcol
  4938                                                          placeCursor                                             ;place the cursor
  4938 00000214 B006                <1>  mov al,ePlaceCursor
  4938 00000216 CD30                <1>  int _svc
  4939 00000218 59                      .10                     pop     ecx                                             ;restore non-volatile regs
  4940 00000219 C3                                              ret                                                     ;return
  4941                                  ;-----------------------------------------------------------------------------------------------------------------------
  4942                                  ;
  4943                                  ;       Routine:        ConHandlerMain
  4944                                  ;
  4945                                  ;       Description:    This routine is called to handle user input in the main console panel when a field is exited.
  4946                                  ;                       The event handler must set the carry flag if the event is not completely handled. In this case
  4947                                  ;                       the event will be forwarded to the current field.
  4948                                  ;
  4949                                  ;       In:             EAX     Message params
  4950                                  ;                       EDX     Message class
  4951                                  ;
  4952                                  ;       Out:            CY      1: Event handling complete
  4953                                  ;                               0: Event handling not complete
  4954                                  ;
  4955                                  ;-----------------------------------------------------------------------------------------------------------------------
  4956 0000021A 53                      ConHandlerMain          push    ebx                                             ;save non-volatile regs
  4957                                  ;
  4958                                  ;       Handle enter and keypad-enter.
  4959                                  ;
  4960 0000021B 80FC1C                                          cmp     ah,EKEYBENTERDOWN                               ;enter down?
  4961 0000021E 7408                                            je      .10                                             ;yes, branch
  4962 00000220 80FC7C                                          cmp     ah,EKEYBPADENTERDOWN                            ;keypad-enter down?
  4963 00000223 7403                                            je      .10                                             ;yes, branch
  4964 00000225 F8                                              clc                                                     ;event not handled
  4965 00000226 EB40                                            jmp     .90                                             ;branch
  4966                                  ;
  4967                                  ;       Take the first token entered.
  4968                                  ;
  4969 00000228 BA10080000              .10                     mov     edx,wzConsoleInBuffer                           ;console input buffer addr
  4970 0000022D BB60080000                                      mov     ebx,wzConsoleToken                              ;token buffer
  4971 00000232 E883000000                                      call    ConTakeToken                                    ;take first command token
  4972                                  ;
  4973                                  ;       Evaluate token.
  4974                                  ;
  4975 00000237 BA60080000                                      mov     edx,wzConsoleToken                              ;token buffer
  4976 0000023C E8AE000000                                      call    ConDetermineCommand                             ;determine if this is a command
  4977 00000241 83F806                                          cmp     eax,ECONJMPTBLCNT                               ;command number in range?
  4978 00000244 730D                                            jnb     .20                                             ;no, branch
  4979 00000246 C1E002                                          shl     eax,2                                           ;convert number to array offset
  4980 00000249 BA[AD070000]                                    mov     edx,tConJmpTbl                                  ;command handler address table base
  4981 0000024E 8B0402                                          mov     eax,[edx+eax]                                   ;command handler address
  4982 00000251 FFD0                                            call    eax                                             ;handler command
  4983                                  ;
  4984                                  ;       Clear field.
  4985                                  ;
  4986 00000253 BB[7D050000]            .20                     mov     ebx,czPnlConInp                                 ;main panel input field
  4987 00000258 E8C4000000                                      call    ConClearField                                   ;clear the field contents
  4988 0000025D E853FFFFFF                                      call    ConDrawField                                    ;draw the field
  4989 00000262 E891FFFFFF                                      call    ConPutCursor                                    ;place the cursor
  4990 00000267 F9                                              stc                                                     ;event is handled
  4991                                  ;
  4992                                  ;       Restore and return.
  4993                                  ;
  4994 00000268 5B                      .90                     pop     ebx                                             ;restore non-volatile regs
  4995 00000269 C3                                              ret                                                     ;return
  4996                                  ;-----------------------------------------------------------------------------------------------------------------------
  4997                                  ;
  4998                                  ;       Routine:        ConHandlerView
  4999                                  ;
  5000                                  ;       Description:    This routine is called to handle user input in the mem console panel when a field is exited.
  5001                                  ;                       The event handler must set the carry flag if the event is not completely handled. In this case
  5002                                  ;                       the event will be forwarded to the current field.
  5003                                  ;
  5004                                  ;       In:             EAX     message params
  5005                                  ;
  5006                                  ;       Out:            CY      1: Event handling complete
  5007                                  ;                               0: Event handling not complete
  5008                                  ;
  5009                                  ;-----------------------------------------------------------------------------------------------------------------------
  5010 0000026A 53                      ConHandlerView          push    ebx                                             ;save non-volatile regs
  5011                                  ;
  5012                                  ;       Handle panel-specific input:
  5013                                  ;
  5014                                  ;       page-up:                scroll memory address back one page
  5015                                  ;       scroll page-up:         scroll memory address back to XXXX0000
  5016                                  ;       ctrl page-up:           scroll memory address back to XX000000
  5017                                  ;       alt page-up:            scroll memory address back to 00000000
  5018                                  ;
  5019                                  ;       page-down:              scroll memory address forward one page
  5020                                  ;       scroll page-down:       scroll memory address forward to XXXX0000
  5021                                  ;       ctrl page-down:         scroll memory address forward to XX000000
  5022                                  ;       alt page-down:          scroll memory address forward to FFFEFFC0
  5023                                  ;
  5024                                  ;       Handle enter and keypad-enter.
  5025                                  ;
  5026 0000026B 80FC1C                                          cmp     ah,EKEYBENTERDOWN                               ;enter down?
  5027 0000026E 7408                                            je      .10                                             ;yes, branch
  5028 00000270 80FC7C                                          cmp     ah,EKEYBPADENTERDOWN                            ;keypad-enter down?
  5029 00000273 7403                                            je      .10                                             ;yes, branch
  5030 00000275 F8                                              clc                                                     ;event not handled
  5031 00000276 EB40                                            jmp     .90                                             ;branch
  5032                                  ;
  5033                                  ;       Take the first token from the input bufer.
  5034                                  ;
  5035 00000278 BA10080000              .10                     mov     edx,wzConsoleInBuffer                           ;console input buffer addr
  5036 0000027D BB60080000                                      mov     ebx,wzConsoleToken                              ;token buffer
  5037 00000282 E833000000                                      call    ConTakeToken                                    ;take first command token
  5038                                  ;
  5039                                  ;       Determine which command was entered.
  5040                                  ;
  5041 00000287 BA60080000                                      mov     edx,wzConsoleToken                              ;token buffer
  5042 0000028C E85E000000                                      call    ConDetermineCommand                             ;determine if this is a command
  5043 00000291 83F806                                          cmp     eax,ECONJMPTBLCNT                               ;command number in range?
  5044 00000294 730D                                            jnb     .20                                             ;no, branch
  5045                                  ;
  5046                                  ;       Call the command handler.
  5047                                  ;
  5048 00000296 C1E002                                          shl     eax,2                                           ;convert number to array offset
  5049 00000299 BA[AD070000]                                    mov     edx,tConJmpTbl                                  ;command handler address table base
  5050 0000029E 8B0402                                          mov     eax,[edx+eax]                                   ;command handler address
  5051 000002A1 FFD0                                            call    eax                                             ;handler command
  5052                                  ;
  5053                                  ;       Clear and redraw the command field; place the cursor.
  5054                                  ;
  5055 000002A3 BB[9D070000]            .20                     mov     ebx,czPnlMenuInp                                ;panel input field
  5056 000002A8 E874000000                                      call    ConClearField                                   ;clear the field
  5057 000002AD E803FFFFFF                                      call    ConDrawField                                    ;draw the field
  5058 000002B2 E841FFFFFF                                      call    ConPutCursor                                    ;place the cursor
  5059 000002B7 F9                                              stc                                                     ;event is handled
  5060                                  ;
  5061                                  ;       Restore and return.
  5062                                  ;
  5063 000002B8 5B                      .90                     pop     ebx                                             ;restore non-volatile regs
  5064 000002B9 C3                                              ret                                                     ;return
  5065                                  ;-----------------------------------------------------------------------------------------------------------------------
  5066                                  ;
  5067                                  ;       Routine:        ConTakeToken
  5068                                  ;
  5069                                  ;       Description:    This routine extracts the next token from the given source buffer.
  5070                                  ;
  5071                                  ;       In:             DS:EDX  source buffer address
  5072                                  ;                       DS:EBX  target buffer address
  5073                                  ;
  5074                                  ;       Out:            DS:EDX  source buffer address
  5075                                  ;                       DS:EBX  target buffer address
  5076                                  ;
  5077                                  ;       Command Form:   Line    = *3( *SP 1*ALNUM )
  5078                                  ;
  5079                                  ;-----------------------------------------------------------------------------------------------------------------------
  5080 000002BA 56                      ConTakeToken            push    esi                                             ;save non-volatile regs
  5081 000002BB 57                                              push    edi                                             ;
  5082 000002BC 06                                              push    es                                              ;
  5083                                  ;
  5084                                  ;       Address source and target; null-terminate target buffer.
  5085                                  ;
  5086 000002BD 1E                                              push    ds                                              ;load data segment selector ...
  5087 000002BE 07                                              pop     es                                              ;... into extra segment reg
  5088 000002BF 89D6                                            mov     esi,edx                                         ;source buffer address
  5089 000002C1 89DF                                            mov     edi,ebx                                         ;target buffer address
  5090 000002C3 C60700                                          mov     byte [edi],0                                    ;null-terminate target buffer
  5091                                  ;
  5092                                  ;       Trim leading space; exit if no token.
  5093                                  ;
  5094 000002C6 FC                                              cld                                                     ;forward strings
  5095 000002C7 AC                      .10                     lodsb                                                   ;load byte
  5096 000002C8 3C20                                            cmp     al,EASCIISPACE                                  ;space?
  5097 000002CA 74FB                                            je      .10                                             ;yes, continue
  5098 000002CC 84C0                                            test    al,al                                           ;end of line?
  5099 000002CE 7410                                            jz      .40                                             ;yes, branch
  5100                                  ;
  5101                                  ;       Store non-spaces into target buffer.
  5102                                  ;
  5103 000002D0 AA                      .20                     stosb                                                   ;store byte
  5104 000002D1 AC                                              lodsb                                                   ;load byte
  5105 000002D2 84C0                                            test    al,al                                           ;end of line?
  5106 000002D4 740A                                            jz      .40                                             ;no, continue
  5107 000002D6 3C20                                            cmp     al,EASCIISPACE                                  ;space?
  5108 000002D8 75F6                                            jne     .20                                             ;no, continue
  5109                                  ;
  5110                                  ;       Walk over spaces trailing the stored token; point to final space.
  5111                                  ;
  5112 000002DA AC                      .30                     lodsb                                                   ;load byte
  5113 000002DB 3C20                                            cmp     al,EASCIISPACE                                  ;space?
  5114 000002DD 74FB                                            je      .30                                             ;yes, continue
  5115 000002DF 4E                                              dec     esi                                             ;pre-position
  5116                                  ;
  5117                                  ;       Null-terminate target buffer; advance remaining source bytes.
  5118                                  ;
  5119 000002E0 C60700                  .40                     mov     byte [edi],0                                    ;terminate buffer
  5120 000002E3 89D7                                            mov     edi,edx                                         ;source buffer address
  5121 000002E5 AC                      .50                     lodsb                                                   ;remaining byte
  5122 000002E6 AA                                              stosb                                                   ;move to front of buffer
  5123 000002E7 84C0                                            test    al,al                                           ;end of line?
  5124 000002E9 75FA                                            jnz     .50                                             ;no, continue
  5125                                  ;
  5126                                  ;       Restore and return.
  5127                                  ;
  5128 000002EB 07                                              pop     es                                              ;restore non-volatile regs
  5129 000002EC 5F                                              pop     edi                                             ;
  5130 000002ED 5E                                              pop     esi                                             ;
  5131 000002EE C3                                              ret                                                     ;return
  5132                                  ;-----------------------------------------------------------------------------------------------------------------------
  5133                                  ;
  5134                                  ;       Routine:        ConDetermineCommand
  5135                                  ;
  5136                                  ;       Description:    This routine determines the command number for the command at DS:EDX.
  5137                                  ;
  5138                                  ;       input:          DS:EDX  command address
  5139                                  ;
  5140                                  ;       output:         EAX     !ECONJMPTBLCNT = command nbr
  5141                                  ;                               ECONJMPTBLCNT = no match fond
  5142                                  ;
  5143                                  ;-----------------------------------------------------------------------------------------------------------------------
  5144 000002EF 53                      ConDetermineCommand     push    ebx                                             ;save non-volatile regs
  5145 000002F0 51                                              push    ecx                                             ;
  5146 000002F1 56                                              push    esi                                             ;
  5147 000002F2 57                                              push    edi                                             ;
  5148                                  ;
  5149                                  ;       Upper-case the command; prepare to search command table.
  5150                                  ;
  5151                                                          upperCaseString                                         ;upper-case string at EDX
  5151 000002F3 B00B                <1>  mov al,eUpperCaseString
  5151 000002F5 CD30                <1>  int _svc
  5152 000002F7 BE[C5070000]                                    mov     esi,tConCmdTbl                                  ;commands table
  5153 000002FC 31FF                                            xor     edi,edi                                         ;intialize command number
  5154 000002FE FC                                              cld                                                     ;forward strings
  5155                                  ;
  5156                                  ;       Exit if end of table.
  5157                                  ;
  5158 000002FF AC                      .10                     lodsb                                                   ;command length
  5159 00000300 0FB6C8                                          movzx   ecx,al                                          ;command length
  5160 00000303 E30D                                            jecxz   .20                                             ;branch if end of table
  5161                                  ;
  5162                                  ;       Compare command to table entry; exit if match.
  5163                                  ;
  5164 00000305 89F3                                            mov     ebx,esi                                         ;table entry address
  5165 00000307 01CE                                            add     esi,ecx                                         ;next table entry address
  5166                                                          compareMemory                                           ;compare byte arrays at EDX, EBX
  5166 00000309 B001                <1>  mov al,eCompareMemory
  5166 0000030B CD30                <1>  int _svc
  5167 0000030D E303                                            jecxz   .20                                             ;branch if equal
  5168                                  ;
  5169                                  ;       Next table element.
  5170                                  ;
  5171 0000030F 47                                              inc     edi                                             ;increment command nbr
  5172 00000310 EBED                                            jmp     .10                                             ;repeat
  5173                                  ;
  5174                                  ;       Return command number or ECONJMPTBLCNT.
  5175                                  ;
  5176 00000312 89F8                    .20                     mov     eax,edi                                         ;command number
  5177                                  ;
  5178                                  ;       Restore and return.
  5179                                  ;
  5180 00000314 5F                                              pop     edi                                             ;restore non-volatile regs
  5181 00000315 5E                                              pop     esi                                             ;
  5182 00000316 59                                              pop     ecx                                             ;
  5183 00000317 5B                                              pop     ebx                                             ;
  5184 00000318 C3                                              ret                                                     ;return
  5185                                  ;-----------------------------------------------------------------------------------------------------------------------
  5186                                  ;
  5187                                  ;       Routine:        ConInt6
  5188                                  ;
  5189                                  ;       Description:    This routine issues an interrupt 6 to exercise the interrupt handler.
  5190                                  ;
  5191                                  ;-----------------------------------------------------------------------------------------------------------------------
  5192 00000319 0F0B                    ConInt6                 ud2                                                     ;raise bad opcode exception
  5193 0000031B C3                                              ret                                                     ;return (not executed)
  5194                                  ;-----------------------------------------------------------------------------------------------------------------------
  5195                                  ;
  5196                                  ;       Routine:        ConReset
  5197                                  ;
  5198                                  ;       Description:    This routine handles the reset command.
  5199                                  ;
  5200                                  ;-----------------------------------------------------------------------------------------------------------------------
  5201                                  ConReset                resetSystem                                             ;issue system reset
  5201                              <1> ConReset :
  5201 0000031C B008                <1>  mov al,eResetSystem
  5201 0000031E CD30                <1>  int _svc
  5202 00000320 C3                                              ret                                                     ;return
  5203                                  ;-----------------------------------------------------------------------------------------------------------------------
  5204                                  ;
  5205                                  ;       Routine:        ConClearField
  5206                                  ;
  5207                                  ;       Description:    This routine clears a panel field to nulls.
  5208                                  ;
  5209                                  ;       In:             DS:EBX  panel field address
  5210                                  ;                       ES:     OS data segment
  5211                                  ;
  5212                                  ;-----------------------------------------------------------------------------------------------------------------------
  5213 00000321 53                      ConClearField           push    ebx                                             ;save non-volatile regs
  5214 00000322 57                                              push    edi                                             ;
  5215                                  ;
  5216                                  ;       Exit if no field.
  5217                                  ;
  5218 00000323 85DB                                            test    ebx,ebx                                         ;have field?
  5219 00000325 7414                                            jz      .10                                             ;no, exit
  5220                                  ;
  5221                                  ;       Reset cursor index to zero; exit if no size or no buffer.
  5222                                  ;
  5223 00000327 30C0                                            xor     al,al                                           ;zero register
  5224 00000329 884307                                          mov     byte [ebx+7],al                                 ;zero cursor index
  5225 0000032C 0FB64B06                                        movzx   ecx,byte [ebx+6]                                ;field size?
  5226 00000330 E309                                            jecxz   .10                                             ;no, exit
  5227 00000332 8B3B                                            mov     edi,[ebx]                                       ;field bufer
  5228 00000334 85FF                                            test    edi,edi                                         ;field buffer?
  5229 00000336 7403                                            jz      .10                                             ;no, exit
  5230                                  ;
  5231                                  ;       Reset field to nulls.
  5232                                  ;
  5233 00000338 FC                                              cld                                                     ;forward strings
  5234 00000339 F3AA                                            rep     stosb                                           ;clear buffer
  5235                                  ;
  5236                                  ;       Restore and return.
  5237                                  ;
  5238 0000033B 5F                      .10                     pop     edi                                             ;restore non-volatile regs
  5239 0000033C 5B                                              pop     ebx                                             ;
  5240 0000033D C3                                              ret                                                     ;return
  5241                                  ;-----------------------------------------------------------------------------------------------------------------------
  5242                                  ;
  5243                                  ;       Routine:        ConFree
  5244                                  ;
  5245                                  ;       Description:    This routine handles the FREE command.
  5246                                  ;
  5247                                  ;       Input:          wzConsoleInBuffer contains parameter(s)
  5248                                  ;
  5249                                  ;-----------------------------------------------------------------------------------------------------------------------
  5250 0000033E 53                      ConFree                 push    ebx                                             ;save non-volatile regs
  5251 0000033F 51                                              push    ecx                                             ;
  5252 00000340 56                                              push    esi                                             ;
  5253 00000341 57                                              push    edi                                             ;
  5254                                  ;
  5255                                  ;       Get address parameter
  5256                                  ;
  5257 00000342 BA10080000                                      mov     edx,wzConsoleInBuffer                           ;console input buffer address (param)
  5258 00000347 BB60080000                                      mov     ebx,wzConsoleToken                              ;console command token address
  5259 0000034C E869FFFFFF                                      call    ConTakeToken                                    ;take first param as token
  5260                                  ;
  5261                                  ;       Convert input parameter from hexadecimal string to binary
  5262                                  ;
  5263 00000351 803D6008000000                                  cmp     byte [wzConsoleToken],0                         ;token found?
  5264 00000358 7418                                            je      .10                                             ;no, branch
  5265 0000035A BA60080000                                      mov     edx,wzConsoleToken                              ;first param as token address
  5266                                                          hexadecimalToUnsigned                                   ;convert string token to unsigned
  5266 0000035F B005                <1>  mov al,eHexadecimalToUnsigned
  5266 00000361 CD30                <1>  int _svc
  5267 00000363 85C0                                            test    eax,eax                                         ;valid parameter?
  5268 00000365 740B                                            jz      .10                                             ;no, branch
  5269                                  ;
  5270                                  ;       Free memory block
  5271                                  ;
  5272                                                          freeMemory eax                                          ;free memory
  5272 00000367 89C2                <1>  mov edx,%1
  5272 00000369 B003                <1>  mov al,eFreeMemory
  5272 0000036B CD30                <1>  int _svc
  5273 0000036D 83F8FF                                          cmp     eax,-1                                          ;memory freed?
  5274 00000370 7400                                            je      .10                                             ;no, branch
  5275                                  ;
  5276                                  ;       Indicate memory freed
  5277                                  ;
  5278                                  ;                        putConsoleString czOK                                   ;indicate success
  5279                                  ;
  5280                                  ;       Restore and return
  5281                                  ;
  5282 00000372 5F                      .10                     pop     edi                                             ;restore non-volatile regs
  5283 00000373 5E                                              pop     esi                                             ;
  5284 00000374 59                                              pop     ecx                                             ;
  5285 00000375 5B                                              pop     ebx                                             ;
  5286 00000376 C3                                              ret                                                     ;return
  5287                                  ;-----------------------------------------------------------------------------------------------------------------------
  5288                                  ;
  5289                                  ;       Routine:        ConMain
  5290                                  ;
  5291                                  ;       Description:    This routine sets the current panel to the main panel (CON001).
  5292                                  ;
  5293                                  ;       In:             ES:     OS data segment
  5294                                  ;
  5295                                  ;-----------------------------------------------------------------------------------------------------------------------
  5296 00000377 51                      ConMain                 push    ecx                                             ;save non-volatile regs
  5297 00000378 57                                              push    edi                                             ;
  5298                                  ;
  5299                                  ;       Initialize panel storage areas
  5300                                  ;
  5301 00000379 BFF00E0000                                      mov     edi,wzFldMenuOptn0                              ;first menu option storage
  5302 0000037E 31C0                                            xor     eax,eax                                         ;zero reg
  5303 00000380 B05F                                            mov     al,EASCIIUNDERSCORE                             ;input placeholder
  5304 00000382 31C9                                            xor     ecx,ecx                                         ;zero reg
  5305 00000384 B105                                            mov     cl,5                                            ;input field count
  5306 00000386 FC                                              cld                                                     ;forward strings
  5307 00000387 F366AB                                          rep     stosw                                           ;reset input fields
  5308                                  ;
  5309                                  ;       Initialize current handler, panel, field.
  5310                                  ;
  5311 0000038A A1[CD040000]                                    mov     eax,[cdHandlerMain]                             ;main panel handler CS-relative addr
  5312 0000038F A300080000                                      mov     [wdConsoleHandler],eax                          ;set panel handler addr
  5313 00000394 B8[D5040000]                                    mov     eax,czPnlCon001                                 ;main panel addr
  5314 00000399 A304080000                                      mov     [wdConsolePanel],eax                            ;set panel addr
  5315 0000039E B8[7D050000]                                    mov     eax,czPnlConInp                                 ;main panel command field addr
  5316 000003A3 A308080000                                      mov     [wdConsoleField],eax                            ;set active field
  5317                                  ;
  5318                                  ;       Clear panel video memory and draw fields
  5319                                  ;
  5320 000003A8 E8BEFDFFFF                                      call    ConClearPanel                                   ;clear panel
  5321 000003AD E8D2FDFFFF                                      call    ConDrawFields                                   ;draw fields
  5322                                  ;
  5323                                  ;       Restore and return.
  5324                                  ;
  5325 000003B2 5F                                              pop     edi                                             ;restore non-volatile regs
  5326 000003B3 59                                              pop     ecx                                             ;
  5327 000003B4 C3                                              ret                                                     ;return
  5328                                  ;-----------------------------------------------------------------------------------------------------------------------
  5329                                  ;
  5330                                  ;       Routine:        ConMalloc
  5331                                  ;
  5332                                  ;       Description:    This routine handles the MALLOC command.
  5333                                  ;
  5334                                  ;       Input:          wzConsoleInBuffer contains parameter(s)
  5335                                  ;
  5336                                  ;-----------------------------------------------------------------------------------------------------------------------
  5337 000003B5 53                      ConMalloc               push    ebx                                             ;save non-volatile regs
  5338 000003B6 51                                              push    ecx                                             ;
  5339 000003B7 56                                              push    esi                                             ;
  5340 000003B8 57                                              push    edi                                             ;
  5341                                  ;
  5342                                  ;       Get size parameter
  5343                                  ;
  5344 000003B9 BA10080000                                      mov     edx,wzConsoleInBuffer                           ;console input buffer address (params)
  5345 000003BE BB60080000                                      mov     ebx,wzConsoleToken                              ;console command token address
  5346 000003C3 E8F2FEFFFF                                      call    ConTakeToken                                    ;take first param as token
  5347                                  ;
  5348                                  ;       Convert input parameter from decimal string to binary
  5349                                  ;
  5350 000003C8 803D6008000000                                  cmp     byte [wzConsoleToken],0                         ;token found?
  5351 000003CF 7422                                            je      .10                                             ;no, branch
  5352 000003D1 BA60080000                                      mov     edx,wzConsoleToken                              ;first param as token address
  5353                                                          decimalToUnsigned                                       ;convert string token to unsigned
  5353 000003D6 B002                <1>  mov al,eDecimalToUnsigned
  5353 000003D8 CD30                <1>  int _svc
  5354 000003DA 85C0                                            test    eax,eax                                         ;valid parameter?
  5355 000003DC 7415                                            jz      .10                                             ;no, branch
  5356                                  ;
  5357                                  ;       Allocate memory block
  5358                                  ;
  5359                                                          allocateMemory eax                                      ;allocate memory
  5359 000003DE 89C1                <1>  mov ecx,%1
  5359 000003E0 B000                <1>  mov al,eAllocateMemory
  5359 000003E2 CD30                <1>  int _svc
  5360 000003E4 85C0                                            test    eax,eax                                         ;memory allocated?
  5361 000003E6 740B                                            jz      .10                                             ;no, branch
  5362                                  ;
  5363                                  ;       Report allocated memory block address
  5364                                  ;
  5365 000003E8 BAB0080000                                      mov     edx,wzConsoleOutBuffer                          ;output buffer address
  5366 000003ED 89C1                                            mov     ecx,eax                                         ;memory address
  5367                                                          unsignedToHexadecimal                                   ;convert memory address to hex
  5367 000003EF B00A                <1>  mov al,eUnsignedToHexadecimal
  5367 000003F1 CD30                <1>  int _svc
  5368                                  ;                        putConsoleString wzConsoleOutBuffer                     ;display memory address
  5369                                  ;                        call    ConPutNewLine                                   ;display new line
  5370 000003F3 5F                      .10                     pop     edi                                             ;restore non-volatile regs
  5371 000003F4 5E                                              pop     esi                                             ;
  5372 000003F5 59                                              pop     ecx                                             ;
  5373 000003F6 5B                                              pop     ebx                                             ;
  5374 000003F7 C3                                              ret                                                     ;return
  5375                                  ;-----------------------------------------------------------------------------------------------------------------------
  5376                                  ;
  5377                                  ;       Routine:        ConView
  5378                                  ;
  5379                                  ;       Description:    This routine handles the view command.
  5380                                  ;
  5381                                  ;       In:             ES:     OS data segment
  5382                                  ;
  5383                                  ;                       wzConsoleInBuffer contains parameter(s)
  5384                                  ;
  5385                                  ;-----------------------------------------------------------------------------------------------------------------------
  5386 000003F8 53                      ConView                 push    ebx                                             ;save non-volatile regs
  5387 000003F9 51                                              push    ecx                                             ;
  5388 000003FA 56                                              push    esi                                             ;
  5389 000003FB 57                                              push    edi                                             ;
  5390                                  ;
  5391                                  ;       Update the source address if a parameter is given.
  5392                                  ;
  5393 000003FC BA10080000                                      mov     edx,wzConsoleInBuffer                           ;console input buffer address (params)
  5394 00000401 BB60080000                                      mov     ebx,wzConsoleToken                              ;console command token address
  5395 00000406 E8AFFEFFFF                                      call    ConTakeToken                                    ;take first param as token
  5396 0000040B 803D6008000000                                  cmp     byte [wzConsoleToken],0                         ;token found?
  5397 00000412 740E                                            je      .10                                             ;no, branch
  5398 00000414 BA60080000                                      mov     edx,wzConsoleToken                              ;first param as token address
  5399                                                          hexadecimalToUnsigned                                   ;convert string token to unsigned
  5399 00000419 B005                <1>  mov al,eHexadecimalToUnsigned
  5399 0000041B CD30                <1>  int _svc
  5400 0000041D A30C080000                                      mov     [wdConsoleMemBase],eax                          ;save console memory address
  5401                                  ;
  5402                                  ;       Initialize panel storage areas.
  5403                                  ;
  5404 00000422 BFF00E0000              .10                     mov     edi,wzFldMenuOptn0                              ;first menu option storage
  5405 00000427 31C0                                            xor     eax,eax                                         ;zero reg
  5406 00000429 B05F                                            mov     al,EASCIIUNDERSCORE                             ;input placeholder
  5407 0000042B 31C9                                            xor     ecx,ecx                                         ;zero reg
  5408 0000042D B114                                            mov     cl,20                                           ;input field count
  5409 0000042F FC                                              cld                                                     ;forward strings
  5410 00000430 F366AB                                          rep     stosw                                           ;reset input fields
  5411                                  ;
  5412                                  ;       Setup source address and row count.
  5413                                  ;
  5414 00000433 8B350C080000                                    mov     esi,[wdConsoleMemBase]                          ;source memory address
  5415 00000439 31C9                                            xor     ecx,ecx                                         ;zero register
  5416 0000043B B114                                            mov     cl,20                                           ;row count
  5417 0000043D BB00090000                                      mov     ebx,wzConsoleMemBuf0                            ;output buffer address
  5418                                  ;
  5419                                  ;       Start the row with the source address in hexadecimal.
  5420                                  ;
  5421 00000442 51                      .20                     push    ecx                                             ;save remaining rows
  5422 00000443 89DF                                            mov     edi,ebx                                         ;output buffer address
  5423 00000445 89FA                                            mov     edx,edi                                         ;output buffer address
  5424 00000447 89F1                                            mov     ecx,esi                                         ;console memory address
  5425                                                          unsignedToHexadecimal                                   ;convert unsigned address to hex string
  5425 00000449 B00A                <1>  mov al,eUnsignedToHexadecimal
  5425 0000044B CD30                <1>  int _svc
  5426 0000044D 83C708                                          add     edi,8                                           ;end of memory addr hexnum
  5427 00000450 B020                                            mov     al,EASCIISPACE                                  ;ascii space delimiter
  5428 00000452 AA                                              stosb                                                   ;store delimiter
  5429                                  ;
  5430                                  ;       Output 16 ASCII hexadecimal byte values for the row.
  5431                                  ;
  5432 00000453 31C9                                            xor     ecx,ecx                                         ;zero register
  5433 00000455 B110                                            mov     cl,16                                           ;loop count
  5434 00000457 51                      .30                     push    ecx                                             ;save loop count
  5435 00000458 B020                                            mov     al,EASCIISPACE                                  ;ascii space
  5436 0000045A AA                                              stosb                                                   ;store delimiter
  5437 0000045B AC                                              lodsb                                                   ;memory byte
  5438 0000045C 88C4                                            mov     ah,al                                           ;memory byte
  5439 0000045E C0E804                                          shr     al,4                                            ;high-order in bits 3-0
  5440 00000461 0C30                                            or      al,EASCIIZERO                                   ;apply ascii numeric zone
  5441 00000463 3C39                                            cmp     al,EASCIININE                                   ;numeric range?
  5442 00000465 7602                                            jbe     .40                                             ;yes, skip ahead
  5443 00000467 0407                                            add     al,7                                            ;adjust ascii for 'A'-'F'
  5444 00000469 AA                      .40                     stosb                                                   ;store ascii hexadecimal of high-order
  5445 0000046A 88E0                                            mov     al,ah                                           ;low-order in bits 3-0
  5446 0000046C 240F                                            and     al,0fh                                          ;mask out high-order bits
  5447 0000046E 0C30                                            or      al,EASCIIZERO                                   ;apply ascii numeric zone
  5448 00000470 3C39                                            cmp     al,EASCIININE                                   ;numeric range?
  5449 00000472 7602                                            jbe     .50                                             ;yes, skip ahead
  5450 00000474 0407                                            add     al,7                                            ;adjust ascii for 'A'-'F'
  5451 00000476 AA                      .50                     stosb                                                   ;store ascii hexadecimal of low-order
  5452 00000477 59                                              pop     ecx                                             ;loop count
  5453 00000478 E2DD                                            loop    .30                                             ;next
  5454                                  ;
  5455                                  ;       Output printable ASCII character section for the row.
  5456                                  ;
  5457 0000047A B020                                            mov     al,EASCIISPACE                                  ;ascii space
  5458 0000047C AA                                              stosb                                                   ;store delimiter
  5459 0000047D AA                                              stosb                                                   ;store delimiter
  5460 0000047E 83EE10                                          sub     esi,16                                          ;reset source pointer
  5461 00000481 B110                                            mov     cl,16                                           ;loop count
  5462 00000483 AC                      .60                     lodsb                                                   ;source byte
  5463 00000484 3C20                                            cmp     al,EASCIISPACE                                  ;printable? (low-range test)
  5464 00000486 7204                                            jb      .70                                             ;no, skip ahead
  5465 00000488 3C7E                                            cmp     al,EASCIITILDE                                  ;printable? (high-range test)
  5466 0000048A 7602                                            jbe     .80                                             ;yes, skip ahead
  5467 0000048C B020                    .70                     mov     al,EASCIISPACE                                  ;display space instead of printable
  5468 0000048E AA                      .80                     stosb                                                   ;store printable ascii byte
  5469 0000048F E2F2                                            loop    .60                                             ;next source byte
  5470 00000491 30C0                                            xor     al,al                                           ;zero reg
  5471 00000493 AA                                              stosb                                                   ;null-terminate buffer
  5472                                  ;
  5473                                  ;       Display constructed output buffer and newline.
  5474                                  ;
  5475 00000494 83C34C                                          add     ebx,76                                          ;next contiguous output buffer addr
  5476                                  ;
  5477                                  ;       Repeat until all lines displayed and preserve source address.
  5478                                  ;
  5479 00000497 59                                              pop     ecx                                             ;remaining rows
  5480 00000498 E2A8                                            loop    .20                                             ;next row
  5481 0000049A 89350C080000                                    mov     [wdConsoleMemBase],esi                          ;update console memory address
  5482                                  ;
  5483                                  ;       Update the handler, panel and field identifiers.
  5484                                  ;
  5485 000004A0 A1[D1040000]                                    mov     eax,[cdHandlerView]                             ;mem panel handler
  5486 000004A5 A300080000                                      mov     [wdConsoleHandler],eax                          ;set panel handler addr
  5487 000004AA B8[8D050000]                                    mov     eax,czPnlMem001                                 ;initial console panel
  5488 000004AF A304080000                                      mov     [wdConsolePanel],eax                            ;set panel template addr
  5489 000004B4 B8[9D070000]                                    mov     eax,czPnlMenuInp                                ;menu panel command field addr
  5490 000004B9 A308080000                                      mov     [wdConsoleField],eax                            ;set active field
  5491                                  ;
  5492                                  ;       Clear and redraw the panel.
  5493                                  ;
  5494 000004BE E8A8FCFFFF                                      call    ConClearPanel                                   ;clear the panel
  5495 000004C3 E8BCFCFFFF                                      call    ConDrawFields                                   ;draw panel fields
  5496                                  ;
  5497                                  ;       Restore and return.
  5498                                  ;
  5499 000004C8 5F                                              pop     edi                                             ;restore non-volatile regs
  5500 000004C9 5E                                              pop     esi                                             ;
  5501 000004CA 59                                              pop     ecx                                             ;
  5502 000004CB 5B                                              pop     ebx                                             ;
  5503 000004CC C3                                              ret                                                     ;return
  5504                                  ;-----------------------------------------------------------------------------------------------------------------------
  5505                                  ;
  5506                                  ;       Constants
  5507                                  ;
  5508                                  ;-----------------------------------------------------------------------------------------------------------------------
  5509 000004CD 1A020000                cdHandlerMain           dd      ConHandlerMain - ConCode                        ;main panel code segment offset
  5510 000004D1 6A020000                cdHandlerView           dd      ConHandlerView - ConCode                        ;view panel code segment offset
  5511                                  ;-----------------------------------------------------------------------------------------------------------------------
  5512                                  ;
  5513                                  ;       Panels
  5514                                  ;
  5515                                  ;       Notes:          1.      Each field MUST have an address of a constant or an input field.
  5516                                  ;                       2.      The constant text or input field MUST be at least the length of the field.
  5517                                  ;                       3.      Field constant text or field values MUST be comprised of printable characters.
  5518                                  ;
  5519                                  ;-----------------------------------------------------------------------------------------------------------------------
  5520                                                                                                                  ;---------------------------------------
  5521                                                                                                                  ;  Main Panel
  5522                                                                                                                  ;---------------------------------------
  5523 000004D5 [E3070000]              czPnlCon001             dd      czFldPnlIdCon001                                ;field text
  5524 000004D9 0000060000000700                                db      0,0,6,0,0,0,7,0                                 ;row col siz ndx 1st nth atr flg
  5525 000004E1 [EA070000]                                      dd      czFldTitleCon001
  5526 000004E5 00210E0000000700                                db      0,33,14,0,0,0,7,0
  5527 000004ED [F9070000]                                      dd      czFldDatTmCon001
  5528 000004F1 003F110000000700                                db      0,63,17,0,0,0,7,0
  5529 000004F9 F00E0000                                        dd      wzFldMenuOptn0
  5530 000004FD 0201010000000280                                db      2,1,1,0,0,0,2,80h
  5531 00000505 [25080000]                                      dd      czFldLblMainDevices
  5532 00000509 0204070000000700                                db      2,4,7,0,0,0,7,0
  5533 00000511 F20E0000                                        dd      wzFldMenuOptn1
  5534 00000515 0301010000000280                                db      3,1,1,0,0,0,2,80h
  5535 0000051D [2D080000]                                      dd      czFldLblMainMemory
  5536 00000521 0304060000000700                                db      3,4,6,0,0,0,7,0
  5537 00000529 F40E0000                                        dd      wzFldMenuOptn2
  5538 0000052D 0401010000000280                                db      4,1,1,0,0,0,2,80h
  5539 00000535 [34080000]                                      dd      czFldLblMainNetwork
  5540 00000539 0404070000000700                                db      4,4,7,0,0,0,7,0
  5541 00000541 F60E0000                                        dd      wzFldMenuOptn3
  5542 00000545 0501010000000280                                db      5,1,1,0,0,0,2,80h
  5543 0000054D [3C080000]                                      dd      czFldLblMainStorage
  5544 00000551 0504070000000700                                db      5,4,7,0,0,0,7,0
  5545 00000559 F80E0000                                        dd      wzFldMenuOptn4
  5546 0000055D 0601010000000280                                db      6,1,1,0,0,0,2,80h
  5547 00000565 [44080000]                                      dd      czFldLblMainSystem
  5548 00000569 0604060000000700                                db      6,4,6,0,0,0,7,0
  5549 00000571 [0B080000]                                      dd      czFldPrmptCon001
  5550 00000575 1700010000000700                                db      23,0,1,0,0,0,7,0
  5551 0000057D 10080000                czPnlConInp             dd      wzConsoleInBuffer
  5552 00000581 17014F0000000780                                db      23,1,79,0,0,0,7,80h
  5553 00000589 00000000                                        dd      0                                               ;end of panel
  5554                                                                                                                  ;---------------------------------------
  5555                                                                                                                  ;  Memory Display Panel
  5556                                                                                                                  ;---------------------------------------
  5557 0000058D [0D080000]              czPnlMem001             dd      czFldPnlIdMem001
  5558 00000591 0000060000000700                                db      0,0,6,0,0,0,7,0
  5559 00000599 [14080000]                                      dd      czFldTitleMem001
  5560 0000059D 00210E0000000700                                db      0,33,14,0,0,0,7,0
  5561 000005A5 [F9070000]                                      dd      czFldDatTmCon001
  5562 000005A9 003F110000000700                                db      0,63,17,0,0,0,7,0
  5563 000005B1 F00E0000                                        dd      wzFldMenuOptn0
  5564 000005B5 0201010000000280                                db      2,1,1,0,0,0,2,80h
  5565 000005BD 00090000                                        dd      wzConsoleMemBuf0
  5566 000005C1 02044B0000000700                                db      2,4,75,0,0,0,7,0
  5567 000005C9 F20E0000                                        dd      wzFldMenuOptn1
  5568 000005CD 0301010000000280                                db      3,1,1,0,0,0,2,80h
  5569 000005D5 4C090000                                        dd      wzConsoleMemBuf1
  5570 000005D9 03044B0000000700                                db      3,4,75,0,0,0,7,0
  5571 000005E1 F40E0000                                        dd      wzFldMenuOptn2
  5572 000005E5 0401010000000280                                db      4,1,1,0,0,0,2,80h
  5573 000005ED 98090000                                        dd      wzConsoleMemBuf2
  5574 000005F1 04044B0000000700                                db      4,4,75,0,0,0,7,0
  5575 000005F9 F60E0000                                        dd      wzFldMenuOptn3
  5576 000005FD 0501010000000280                                db      5,1,1,0,0,0,2,80h
  5577 00000605 E4090000                                        dd      wzConsoleMemBuf3
  5578 00000609 05044B0000000700                                db      5,4,75,0,0,0,7,0
  5579 00000611 F80E0000                                        dd      wzFldMenuOptn4
  5580 00000615 0601010000000280                                db      6,1,1,0,0,0,2,80h
  5581 0000061D 300A0000                                        dd      wzConsoleMemBuf4
  5582 00000621 06044B0000000700                                db      6,4,75,0,0,0,7,0
  5583 00000629 FA0E0000                                        dd      wzFldMenuOptn5
  5584 0000062D 0701010000000280                                db      7,1,1,0,0,0,2,80h
  5585 00000635 7C0A0000                                        dd      wzConsoleMemBuf5
  5586 00000639 07044B0000000700                                db      7,4,75,0,0,0,7,0
  5587 00000641 FC0E0000                                        dd      wzFldMenuOptn6
  5588 00000645 0801010000000280                                db      8,1,1,0,0,0,2,80h
  5589 0000064D C80A0000                                        dd      wzConsoleMemBuf6
  5590 00000651 08044B0000000700                                db      8,4,75,0,0,0,7,0
  5591 00000659 FE0E0000                                        dd      wzFldMenuOptn7
  5592 0000065D 0901010000000280                                db      9,1,1,0,0,0,2,80h
  5593 00000665 140B0000                                        dd      wzConsoleMemBuf7
  5594 00000669 09044B0000000700                                db      9,4,75,0,0,0,7,0
  5595 00000671 000F0000                                        dd      wzFldMenuOptn8
  5596 00000675 0A01010000000280                                db      10,1,1,0,0,0,2,80h
  5597 0000067D 600B0000                                        dd      wzConsoleMemBuf8
  5598 00000681 0A044B0000000700                                db      10,4,75,0,0,0,7,0
  5599 00000689 020F0000                                        dd      wzFldMenuOptn9
  5600 0000068D 0B01010000000280                                db      11,1,1,0,0,0,2,80h
  5601 00000695 AC0B0000                                        dd      wzConsoleMemBuf9
  5602 00000699 0B044B0000000700                                db      11,4,75,0,0,0,7,0
  5603 000006A1 040F0000                                        dd      wzFldMenuOptnA
  5604 000006A5 0C01010000000280                                db      12,1,1,0,0,0,2,80h
  5605 000006AD F80B0000                                        dd      wzConsoleMemBufA
  5606 000006B1 0C044B0000000700                                db      12,4,75,0,0,0,7,0
  5607 000006B9 060F0000                                        dd      wzFldMenuOptnB
  5608 000006BD 0D01010000000280                                db      13,1,1,0,0,0,2,80h
  5609 000006C5 440C0000                                        dd      wzConsoleMemBufB
  5610 000006C9 0D044B0000000700                                db      13,4,75,0,0,0,7,0
  5611 000006D1 080F0000                                        dd      wzFldMenuOptnC
  5612 000006D5 0E01010000000280                                db      14,1,1,0,0,0,2,80h
  5613 000006DD 900C0000                                        dd      wzConsoleMemBufC
  5614 000006E1 0E044B0000000700                                db      14,4,75,0,0,0,7,0
  5615 000006E9 0A0F0000                                        dd      wzFldMenuOptnD
  5616 000006ED 0F01010000000280                                db      15,1,1,0,0,0,2,80h
  5617 000006F5 DC0C0000                                        dd      wzConsoleMemBufD
  5618 000006F9 0F044B0000000700                                db      15,4,75,0,0,0,7,0
  5619 00000701 0C0F0000                                        dd      wzFldMenuOptnE
  5620 00000705 1001010000000280                                db      16,1,1,0,0,0,2,80h
  5621 0000070D 280D0000                                        dd      wzConsoleMemBufE
  5622 00000711 10044B0000000700                                db      16,4,75,0,0,0,7,0
  5623 00000719 0E0F0000                                        dd      wzFldMenuOptnF
  5624 0000071D 1101010000000280                                db      17,1,1,0,0,0,2,80h
  5625 00000725 740D0000                                        dd      wzConsoleMemBufF
  5626 00000729 11044B0000000700                                db      17,4,75,0,0,0,7,0
  5627 00000731 100F0000                                        dd      wzFldMenuOptn10
  5628 00000735 1201010000000280                                db      18,1,1,0,0,0,2,80h
  5629 0000073D C00D0000                                        dd      wzConsoleMemBuf10
  5630 00000741 12044B0000000700                                db      18,4,75,0,0,0,7,0
  5631 00000749 120F0000                                        dd      wzFldMenuOptn11
  5632 0000074D 1301010000000280                                db      19,1,1,0,0,0,2,80h
  5633 00000755 0C0E0000                                        dd      wzConsoleMemBuf11
  5634 00000759 13044B0000000700                                db      19,4,75,0,0,0,7,0
  5635 00000761 140F0000                                        dd      wzFldMenuOptn12
  5636 00000765 1401010000000280                                db      20,1,1,0,0,0,2,80h
  5637 0000076D 580E0000                                        dd      wzConsoleMemBuf12
  5638 00000771 14044B0000000700                                db      20,4,75,0,0,0,7,0
  5639 00000779 160F0000                                        dd      wzFldMenuOptn13
  5640 0000077D 1501010000000280                                db      21,1,1,0,0,0,2,80h
  5641 00000785 A40E0000                                        dd      wzConsoleMemBuf13
  5642 00000789 15044B0000000700                                db      21,4,75,0,0,0,7,0
  5643 00000791 [0B080000]                                      dd      czFldPrmptCon001
  5644 00000795 1700010000000700                                db      23,0,1,0,0,0,7,0
  5645 0000079D 10080000                czPnlMenuInp            dd      wzConsoleInBuffer
  5646 000007A1 17014F0000000780                                db      23,1,79,0,0,0,7,80h
  5647 000007A9 00000000                                        dd      0                                               ;end of panel
  5648                                  ;-----------------------------------------------------------------------------------------------------------------------
  5649                                  ;
  5650                                  ;       Tables
  5651                                  ;
  5652                                  ;-----------------------------------------------------------------------------------------------------------------------
  5653                                                                                                                  ;---------------------------------------
  5654                                                                                                                  ;  Command Jump Table
  5655                                                                                                                  ;---------------------------------------
  5656                                  tConJmpTbl              equ     $                                               ;command jump table
  5657 000007AD B5030000                                        dd      ConMalloc       - ConCode                       ;malloc command
  5658 000007B1 3E030000                                        dd      ConFree         - ConCode                       ;free command
  5659 000007B5 19030000                                        dd      ConInt6         - ConCode                       ;int6 command
  5660 000007B9 77030000                                        dd      ConMain         - ConCode                       ;go command
  5661 000007BD 1C030000                                        dd      ConReset        - ConCode                       ;reset command
  5662 000007C1 F8030000                                        dd      ConView         - ConCode                       ;view command
  5663                                  ECONJMPTBLL             equ     ($-tConJmpTbl)                                  ;table length
  5664                                  ECONJMPTBLCNT           equ     ECONJMPTBLL/4                                   ;table entries
  5665                                                                                                                  ;---------------------------------------
  5666                                                                                                                  ;  Command Name Table
  5667                                                                                                                  ;---------------------------------------
  5668                                  tConCmdTbl              equ     $                                               ;command name table
  5669 000007C5 074D414C4C4F4300                                db      7,"MALLOC",0                                    ;malloc command
  5670 000007CD 054652454500                                    db      5,"FREE",0                                      ;free command
  5671 000007D3 05494E543600                                    db      5,"INT6",0                                      ;int6 command
  5672 000007D9 024700                                          db      2,"G",0                                         ;go command
  5673 000007DC 025200                                          db      2,"R",0                                         ;reset command
  5674 000007DF 025600                                          db      2,"V",0                                         ;view command
  5675 000007E2 00                                              db      0                                               ;end of table
  5676                                  ;-----------------------------------------------------------------------------------------------------------------------
  5677                                  ;
  5678                                  ;       Strings
  5679                                  ;
  5680                                  ;-----------------------------------------------------------------------------------------------------------------------
  5681 000007E3 434F4E30303100          czFldPnlIdCon001        db      "CON001",0                                      ;main console panel id
  5682 000007EA 4F532056657273696F-     czFldTitleCon001        db      "OS Version 1.0",0                              ;main console panel title
  5682 000007F3 6E20312E3000       
  5683 000007F9 44442D4D4D4D2D5959-     czFldDatTmCon001        db      "DD-MMM-YYYY HH:MM",0                           ;panel date and time template
  5683 00000802 59592048483A4D4D00 
  5684 0000080B 3A00                    czFldPrmptCon001        db      ":",0                                           ;command prompt
  5685 0000080D 4D454D30303100          czFldPnlIdMem001        db      "MEM001",0                                      ;memory panel id
  5686 00000814 4D656D6F7279204469-     czFldTitleMem001        db      "Memory Display",0                              ;memory panel title
  5686 0000081D 73706C617900       
  5687 00000823 5F00                    czFldMenuOptn001        db      "_",0                                           ;menu option
  5688 00000825 4465766963657300        czFldLblMainDevices     db      "Devices",0                                     ;main panel devices label
  5689 0000082D 4D656D6F727900          czFldLblMainMemory      db      "Memory",0                                      ;main panel memory label
  5690 00000834 4E6574776F726B00        czFldLblMainNetwork     db      "Network",0                                     ;main panel network label
  5691 0000083C 53746F7261676500        czFldLblMainStorage     db      "Storage",0                                     ;main panel storage label
  5692 00000844 53797374656D00          czFldLblMainSystem      db      "System",0                                      ;main panel system label
  5693 0000084B 00<rept>                                        times   4096-($-$$) db 0h                               ;zero fill to end of section
  5694                                  %endif
  5695                                  %ifdef BUILDDISK
  5696                                  ;-----------------------------------------------------------------------------------------------------------------------
  5697                                  ;
  5698                                  ;       Free Disk Space                                                         @disk: 009600   @mem:  n/a
  5699                                  ;
  5700                                  ;       Following the convention introduced by DOS, we use the value 'F6' to indicate unused floppy disk storage.
  5701                                  ;
  5702                                  ;-----------------------------------------------------------------------------------------------------------------------
  5703                                  section                 unused                                                  ;unused disk space
  5704                                                          times   EBOOTDISKBYTES-09600h db 0F6h                   ;fill to end of disk image
  5705                                  %endif
  5706                                  ;=======================================================================================================================
  5707                                  ;
  5708                                  ;       End of Program Code
  5709                                  ;
  5710                                  ;=======================================================================================================================
