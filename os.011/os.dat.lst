     1                                  ;=======================================================================================================================
     2                                  ;
     3                                  ;       File:           os.asm
     4                                  ;
     5                                  ;       Project:        os.011
     6                                  ;
     7                                  ;       Description:    In this sample program, logic is added to allocate and free memory blocks at the kernel level.
     8                                  ;
     9                                  ;       Revised:        2 September 2019
    10                                  ;
    11                                  ;       Assembly:       nasm os.asm -f bin -o os.dat     -l os.dat.lst     -DBUILDBOOT
    12                                  ;                       nasm os.asm -f bin -o os.dsk     -l os.dsk.lst     -DBUILDDISK
    13                                  ;                       nasm os.asm -f bin -o os.com     -l os.com.lst     -DBUILDCOM
    14                                  ;                       nasm os.asm -f bin -o osprep.com -l osprep.com.lst -DBUILDPREP
    15                                  ;
    16                                  ;       Assembler:      Netwide Assembler (NASM) 2.14.02, 26 Dec 2018
    17                                  ;
    18                                  ;       Notice:         Copyright (C) 2010-2019 David J. Walling
    19                                  ;
    20                                  ;=======================================================================================================================
    21                                  ;-----------------------------------------------------------------------------------------------------------------------
    22                                  ;
    23                                  ;       Assembly Directives
    24                                  ;
    25                                  ;       Use one of the following as an assembly directive (-D) with NASM.
    26                                  ;
    27                                  ;       BUILDBOOT       Creates os.dat, a 512-byte boot sector as a standalone file.
    28                                  ;       BUILDDISK       Creates os.dsk, a 1.44MB (3.5") floppy disk image file.
    29                                  ;       BUILDCOM        Creates os.com, the OS loader and kernel as a standalone DOS program.
    30                                  ;       BUILDPREP       Creates osprep.com, a DOS program that prepares a floppy disk to boot the OS.
    31                                  ;
    32                                  ;-----------------------------------------------------------------------------------------------------------------------
    33                                  %ifdef BUILDDISK                                                                ;if we are building a disk image ...
    34                                  %define BUILDBOOT                                                               ;... also build the boot sector
    35                                  %define BUILDCOM                                                                ;... and the OS kernel
    36                                  %endif
    37                                  %ifdef BUILDPREP                                                                ;if creating the disk prep program ...
    38                                  %define BUILDBOOT                                                               ;... also build the boot sector
    39                                  %endif
    40                                  ;-----------------------------------------------------------------------------------------------------------------------
    41                                  ;
    42                                  ;       Conventions
    43                                  ;
    44                                  ;       Alignment:      In this document, columns are numbered beginning with 1. Logical tabs are set after every
    45                                  ;                       eight columns. Tabs are simulated using SPACE characters. Comments that span an entire line
    46                                  ;                       have a semicolon in line 1 and text begins in column 9. Assembly instructions (mnemonics)
    47                                  ;                       begin in column 25. Assembly operands begin in column 33. Inline comments begin in column 81.
    48                                  ;                       Lines should not extend beyond column 120.
    49                                  ;
    50                                  ;       Arguments:      Arguments are passed as registers and generally follow this order: EAX, ECX, EDX, EBX. ECX
    51                                  ;                       may be used as the sole parameter if a test for zero is required. EBX and EBP may be used as
    52                                  ;                       parameters if the routine is considered a "method" of an "object". In this case, EBX or EBP
    53                                  ;                       will address the object storage. If the routine is a general-purpose string or byte-array
    54                                  ;                       manipulator, ESI and EDI may be used as parameters to address input and/or ouput buffers.
    55                                  ;
    56                                  ;       Code Order:     Routines should appear in the order of their first likely use. Negative relative call or jump
    57                                  ;                       addresses usually, therefore, indicate reuse.
    58                                  ;
    59                                  ;       Comments:       A comment that spans the entire line begins with a semicolon in column 1. A comment that
    60                                  ;                       accompanies code on a line begins with a semicolon in column 81. Register names in comments
    61                                  ;                       are in upper case (EAX, EDI). Hexadecimal values in comments are in lower case (01fh, 0dah).
    62                                  ;                       Routines are preceded with a comment box that includes the routine name, description, and
    63                                  ;                       register contents on entry and exit, if applicable.
    64                                  ;
    65                                  ;       Constants:      Symbolic constants (equates) are named in all-caps beginning with 'E' (EDATAPORT). Constant
    66                                  ;                       stored values are named in camel case, starting with 'c' (cbMaxLines). The 2nd letter of the
    67                                  ;                       constant label indicates the storage type.
    68                                  ;
    69                                  ;                       cq......        constant quad-word (dq)
    70                                  ;                       cd......        constant double-word (dd)
    71                                  ;                       cw......        constant word (dw)
    72                                  ;                       cb......        constant byte (db)
    73                                  ;                       cz......        constant ASCIIZ (null-terminated) string
    74                                  ;                       cs......        constant non-terminated string (sequence of characters)
    75                                  ;
    76                                  ;       Instructions:   32-bit instructions are generally favored. 8-bit instructions and data are preferred for
    77                                  ;                       flags and status fields, etc. 16-bit instructions are avoided wherever possible to limit
    78                                  ;                       the generation of prefix bytes.
    79                                  ;
    80                                  ;       Labels:         Labels within a routine are numeric and begin with a period (.10, .20). Labels within a
    81                                  ;                       routine begin at ".10" and increment by 10.
    82                                  ;
    83                                  ;       Literals:       Literal values defined by external standards should be defined as symbolic constants
    84                                  ;                       (equates). Hexadecimal literals in code are in upper case with a leading '0' and trailing
    85                                  ;                       'h' (01Fh). Binary literal values in source code are encoded with a final 'b' (1010b).
    86                                  ;                       Decimal literal values in source code are strictly numerals (2048). Octal literal values
    87                                  ;                       are avoided. String literals are enclosed in double quotes, e.g. "Loading OS". Single
    88                                  ;                       character literals are enclosed in single quotes, e.g. 'A'.
    89                                  ;
    90                                  ;       Macros:         Macro names are in camel case, beginning with a lower-case letter (getDateString). Macro
    91                                  ;                       names describe an action and begin with a verb.
    92                                  ;
    93                                  ;       Memory Use:     Operating system memory allocation is avoided. Buffers are kept to as small a size as
    94                                  ;                       practicable. Data and code intermingling is avoided.
    95                                  ;
    96                                  ;       Registers:      Register names in comments are in upper case (EAX, EDX). Register names in source code are
    97                                  ;                       in lower case (eax, edx).
    98                                  ;
    99                                  ;       Return Values:  Routines return result values in EAX or ECX or both. Routines should indicate failure by
   100                                  ;                       setting the carry flag to 1. Routines may prefer the use of ECX as a return value if the
   101                                  ;                       value is to be tested for null upon return (using the jecxz instruction).
   102                                  ;
   103                                  ;       Routines:       Routine names are in mixed case and capitalized (GetYear, ReadRealTimeClock). Routine names
   104                                  ;                       begin with a verb (Get, Read, Load). Routines should have a single entry address and a single
   105                                  ;                       exit instruction (ret, iretd, etc.). Routines that serve as wrappers for library functions
   106                                  ;                       carry the same name as the library function but begin with a leading underscore (_) character.
   107                                  ;
   108                                  ;       Structures:     Structure names are in all-caps (DATETIME). Structure names describe a "thing" and so do NOT
   109                                  ;                       begin with a verb.
   110                                  ;
   111                                  ;       Usage:          Registers EBX, ECX, EBP, SS, CS, DS and ES are preserved by routines. Registers ESI and EDI
   112                                  ;                       are preserved unless they are input parameters. Registers EAX and ECX are preferred for
   113                                  ;                       returning response/result values. Registers EBX and EBP are preferred for context (structure)
   114                                  ;                       address parameters. Registers EAX, ECX, EDX and EBX are preferred for integral parameters.
   115                                  ;
   116                                  ;       Variables:      Variables are named in camel case, starting with 'w'. The 2nd letter of the variable label
   117                                  ;                       indicates the storage type.
   118                                  ;
   119                                  ;                       wq......        variable quad-word (resq)
   120                                  ;                       wd......        variable double-word (resd)
   121                                  ;                       ww......        variable word (resw)
   122                                  ;                       wb......        variable byte (resb)
   123                                  ;                       ws......        writable structure
   124                                  ;
   125                                  ;-----------------------------------------------------------------------------------------------------------------------
   126                                  ;=======================================================================================================================
   127                                  ;
   128                                  ;       Equates
   129                                  ;
   130                                  ;       The equate (equ) statement defines a symbolic name for a fixed value so that such a value can be defined and
   131                                  ;       verified once and then used throughout the code. Using symbolic names simplifies searching for where logical
   132                                  ;       values are used. Equate names are in all-caps and begin with the letter 'E'. Equates are grouped into related
   133                                  ;       sets. Equates in this sample program are defined in the following groupings:
   134                                  ;
   135                                  ;       Hardware-Defined Values
   136                                  ;
   137                                  ;       ECRT...         6845 Cathode Ray Tube (CRT) Controller values
   138                                  ;       EFDC...         NEC 765 Floppy Disk Controller (FDC) values
   139                                  ;       EKEYB...        8042 or "PS/2 Controller" (Keyboard Controller) values
   140                                  ;       EPIC...         8259 Programmable Interrupt Controller (PIC) values
   141                                  ;       EPIT...         8253 Programmable Interval Timer (PIT) values
   142                                  ;       EX86...         Intel x86 CPU architecture values
   143                                  ;
   144                                  ;       Firmware-Defined Values
   145                                  ;
   146                                  ;       EBIOS...        Basic Input/Output System (BIOS) values
   147                                  ;
   148                                  ;       Standards-Based Values
   149                                  ;
   150                                  ;       EASCII...       American Standard Code for Information Interchange (ASCII) values
   151                                  ;
   152                                  ;       Operating System Values
   153                                  ;
   154                                  ;       EBOOT...        Boot sector and loader values
   155                                  ;       ECON...         Console values (dimensions and attributes)
   156                                  ;       EGDT...         Global Descriptor Table (GDT) selector values
   157                                  ;       EKEYF...        Keyboard status flags
   158                                  ;       EKRN...         Kernel values (fixed locations and sizes)
   159                                  ;       ELDT...         Local Descriptor Table (LDT) selector values
   160                                  ;       EMEM...         Memory Management values
   161                                  ;       EMSG...         Message identifiers
   162                                  ;
   163                                  ;=======================================================================================================================
   164                                  ;-----------------------------------------------------------------------------------------------------------------------
   165                                  ;
   166                                  ;       Hardware-Defined Values
   167                                  ;
   168                                  ;-----------------------------------------------------------------------------------------------------------------------
   169                                  ;-----------------------------------------------------------------------------------------------------------------------
   170                                  ;
   171                                  ;       6845 Cathode Ray Tube (CRT) Controller                                  ECRT...
   172                                  ;
   173                                  ;       The Motorola 6845 CRT Controller (CRTC) is a programmable controller
   174                                  ;       for CGA, EGA, VGA and compatible video modes.
   175                                  ;
   176                                  ;-----------------------------------------------------------------------------------------------------------------------
   177                                  ECRTPORTHI              equ     003h                                            ;controller port hi
   178                                  ECRTPORTLO              equ     0D4h                                            ;controller port lo
   179                                  ECRTCURLOCHI            equ     00Eh                                            ;cursor loc reg hi
   180                                  ECRTCURLOCLO            equ     00Fh                                            ;cursor loc reg lo
   181                                  ;-----------------------------------------------------------------------------------------------------------------------
   182                                  ;
   183                                  ;       NEC 765 Floppy Disk Controller (FDC)                                    EFDC...
   184                                  ;
   185                                  ;       The NEC 765 FDC is a programmable controller for floppy disk drives.
   186                                  ;
   187                                  ;-----------------------------------------------------------------------------------------------------------------------
   188                                  EFDCPORTHI              equ     003h                                            ;controller port hi
   189                                  EFDCPORTLOOUT           equ     0F2h                                            ;digital output register lo
   190                                  EFDCPORTLOSTAT          equ     0F4h                                            ;main status register lo
   191                                  EFDCSTATBUSY            equ     010h                                            ;main status is busy
   192                                  EFDCMOTOROFF            equ     00Ch                                            ;motor off / enable / DMA
   193                                  ;-----------------------------------------------------------------------------------------------------------------------
   194                                  ;
   195                                  ;       8042 Keyboard Controller                                                EKEYB...
   196                                  ;
   197                                  ;       The 8042 Keyboard Controller (8042) is a programmable controller that accepts input signals from the keyboard
   198                                  ;       device. It also signals a hardware interrupt to the CPU when the low-order bit of I/O port 64h is set to zero.
   199                                  ;
   200                                  ;-----------------------------------------------------------------------------------------------------------------------
   201                                  EKEYBPORTDATA           equ     060h                                            ;data port
   202                                  EKEYBPORTSTAT           equ     064h                                            ;status port
   203                                  EKEYBCMDRESET           equ     0FEh                                            ;reset bit 0 to restart system
   204                                  EKEYBBITOUT             equ     001h                                            ;output buffer status bit
   205                                  EKEYBBITIN              equ     002h                                            ;input buffer status bit
   206                                  EKEYBCMDLAMPS           equ     0EDh                                            ;set/reset lamps command
   207                                  EKEYBWAITLOOP           equ     010000h                                         ;wait loop
   208                                                                                                                  ;---------------------------------------
   209                                                                                                                  ;       Keyboard Scan Codes
   210                                                                                                                  ;---------------------------------------
   211                                  EKEYBBACKSPACE          equ     00Eh                                            ;backspace down
   212                                  EKEYBTABDOWN            equ     00Fh                                            ;tab down
   213                                  EKEYBENTERDOWN          equ     01Ch                                            ;enter down
   214                                  EKEYBCTRLLDOWN          equ     01Dh                                            ;control down
   215                                  EKEYBSHIFTLDOWN         equ     02Ah                                            ;left shift down
   216                                  EKEYBSHIFTRDOWN         equ     036h                                            ;right shift down
   217                                  EKEYBALTLDOWN           equ     038h                                            ;alt down
   218                                  EKEYBCAPSDOWN           equ     03Ah                                            ;caps-lock down
   219                                  EKEYBNUMDOWN            equ     045h                                            ;num-lock down
   220                                  EKEYBSCROLLDOWN         equ     046h                                            ;scroll-lock down
   221                                  EKEYBPAD7DOWN           equ     047h                                            ;keypad-7 down
   222                                  EKEYBPADINSERTDOWN      equ     052h                                            ;keypad-insert down
   223                                  EKEYBPADDELETEDOWN      equ     053h                                            ;keypad-delete down
   224                                  EKEYBWINLDOWN           equ     05Bh                                            ;left windows (R) down
   225                                  EKEYBWINRDOWN           equ     05Ch                                            ;right windows (R) down
   226                                  EKEYBUPARROWDOWN        equ     068h                                            ;up-arrow down (e0 48)
   227                                  EKEYBLEFTARROWDOWN      equ     06Bh                                            ;left-arrow down (e0 4b)
   228                                  EKEYBRIGHTARROWDOWN     equ     06Dh                                            ;right-arrow down (e0 4d)
   229                                  EKEYBDOWNARROWDOWN      equ     070h                                            ;down-arrow down (e0 50)
   230                                  EKEYBINSERTDOWN         equ     072h                                            ;insert down (e0 52)
   231                                  EKEYBDELETEDOWN         equ     073h                                            ;delete down (e0 53)
   232                                  EKEYBPADSLASHDOWN       equ     075h                                            ;keypad slash down
   233                                  EKEYBALTRDOWN           equ     078h                                            ;right-alt down
   234                                  EKEYBPADENTERDOWN       equ     07Ch                                            ;keypad-enter down
   235                                  EKEYBCTRLRDOWN          equ     07Dh                                            ;right-control key down
   236                                  EKEYBMAKECODEMASK       equ     07Fh                                            ;make code mask
   237                                  EKEYBUP                 equ     080h                                            ;up
   238                                  EKEYBCTRLLUP            equ     09Dh                                            ;control key up
   239                                  EKEYBSHIFTLUP           equ     0AAh                                            ;left shift key up
   240                                  EKEYBSHIFTRUP           equ     0B6h                                            ;right shift key up
   241                                  EKEYBPADASTERISKUP      equ     0B7h                                            ;keypad asterisk up
   242                                  EKEYBALTLUP             equ     0B8h                                            ;left alt key up
   243                                  EKEYBWINLUP             equ     0DBh                                            ;left windows (R) up
   244                                  EKEYBWINRUP             equ     0DCh                                            ;right windows (R) up
   245                                  EKEYBCODEEXT0           equ     0E0h                                            ;extended scan code 0
   246                                  EKEYBCODEEXT1           equ     0E1h                                            ;extended scan code 1
   247                                  EKEYBALTRUP             equ     0F8h                                            ;right-alt up
   248                                  EKEYBCTRLRUP            equ     0FDh                                            ;left-control up
   249                                  ;-----------------------------------------------------------------------------------------------------------------------
   250                                  ;
   251                                  ;       8259 Peripheral Interrupt Controller                                    EPIC...
   252                                  ;
   253                                  ;       The 8259 Peripheral Interrupt Controller (PIC) is a programmable controller that accepts interrupt signals from
   254                                  ;       external devices and signals a hardware interrupt to the CPU.
   255                                  ;
   256                                  ;-----------------------------------------------------------------------------------------------------------------------
   257                                  EPICPORTPRI             equ     020h                                            ;primary control port 0
   258                                  EPICPORTPRI1            equ     021h                                            ;primary control port 1
   259                                  EPICPORTSEC             equ     0A0h                                            ;secondary control port 0
   260                                  EPICPORTSEC1            equ     0A1h                                            ;secondary control port 1
   261                                  EPICEOI                 equ     020h                                            ;non-specific EOI code
   262                                  ;-----------------------------------------------------------------------------------------------------------------------
   263                                  ;
   264                                  ;       8253 Programmable Interval Timer                                        EPIT...
   265                                  ;
   266                                  ;       The Intel 8253 Programmable Interval Timer (PIT) is a chip that produces a hardware interrupt (IRQ0)
   267                                  ;       approximately 18.2 times per second.
   268                                  ;
   269                                  ;-----------------------------------------------------------------------------------------------------------------------
   270                                  EPITDAYTICKS            equ     01800B0h                                        ;ticks per day
   271                                  ;-----------------------------------------------------------------------------------------------------------------------
   272                                  ;
   273                                  ;       x86 CPU Architecture                                                    ;EX86...
   274                                  ;
   275                                  ;-----------------------------------------------------------------------------------------------------------------------
   276                                  EX86DESCLEN             equ     8                                               ;size of a protected mode descriptor
   277                                  ;-----------------------------------------------------------------------------------------------------------------------
   278                                  ;
   279                                  ;       x86 Descriptor Access Codes                                             EX86ACC...
   280                                  ;
   281                                  ;       The x86 architecture supports the classification of memory areas or segments. Segment attributes are defined by
   282                                  ;       structures known as descriptors. Within a descriptor are access type codes that define the type of the segment.
   283                                  ;
   284                                  ;       0.......        Segment is not present in memory (triggers int 11)
   285                                  ;       1.......        Segment is present in memory
   286                                  ;       .LL.....        Segment is of privilege level LL (0,1,2,3)
   287                                  ;       ...0....        Segment is a system segment
   288                                  ;       ...00010                Local Descriptor Table
   289                                  ;       ...00101                Task Gate
   290                                  ;       ...010B1                Task State Segment (B:0=Available,1=Busy)
   291                                  ;       ...01100                Call Gate (386)
   292                                  ;       ...01110                Interrupt Gate (386)
   293                                  ;       ...01111                Trap Gate (386)
   294                                  ;       ...1...A        Segment is a code or data (A:1=Accesssed)
   295                                  ;       ...10DW.                Data (D:1=Expand Down,W:1=Writable)
   296                                  ;       ...11CR.                Code (C:1=Conforming,R:1=Readable)
   297                                  ;
   298                                  ;-----------------------------------------------------------------------------------------------------------------------
   299                                  EX86ACCINT              equ     10001110b                                       ;interrupt gate
   300                                  EX86ACCTRAP             equ     10001111b                                       ;trap gate
   301                                  ;-----------------------------------------------------------------------------------------------------------------------
   302                                  ;
   303                                  ;       Firmware-Defined Values
   304                                  ;
   305                                  ;-----------------------------------------------------------------------------------------------------------------------
   306                                  ;-----------------------------------------------------------------------------------------------------------------------
   307                                  ;
   308                                  ;       BIOS Interrupts and Functions                                           EBIOS...
   309                                  ;
   310                                  ;       Basic Input/Output System (BIOS) functions are grouped and accessed by issuing an interrupt call. Each
   311                                  ;       BIOS interrupt supports several functions. The function code is typically passed in the AH register.
   312                                  ;
   313                                  ;-----------------------------------------------------------------------------------------------------------------------
   314                                  EBIOSINTVIDEO           equ     010h                                            ;video services interrupt
   315                                  EBIOSFNSETVMODE         equ     000h                                            ;video set mode function
   316                                  EBIOSMODETEXT80         equ     003h                                            ;video mode 80x25 text
   317                                  EBIOSFNTTYOUTPUT        equ     00Eh                                            ;video TTY output function
   318                                  EBIOSINTDISKETTE        equ     013h                                            ;diskette services interrupt
   319                                  EBIOSFNREADSECTOR       equ     002h                                            ;diskette read sector function
   320                                  EBIOSFNWRITESECTOR      equ     003h                                            ;diskette write sector function
   321                                  EBIOSINTMISC            equ     015h                                            ;miscellaneous services interrupt
   322                                  EBIOSFNINITPROTMODE     equ     089h                                            ;initialize protected mode fn
   323                                  EBIOSINTKEYBOARD        equ     016h                                            ;keyboard services interrupt
   324                                  EBIOSFNKEYSTATUS        equ     001h                                            ;keyboard status function
   325                                  ;-----------------------------------------------------------------------------------------------------------------------
   326                                  ;
   327                                  ;       Standards-Based Values
   328                                  ;
   329                                  ;-----------------------------------------------------------------------------------------------------------------------
   330                                  ;-----------------------------------------------------------------------------------------------------------------------
   331                                  ;
   332                                  ;       ASCII                                                                   EASCII...
   333                                  ;
   334                                  ;-----------------------------------------------------------------------------------------------------------------------
   335                                  EASCIIRETURN            equ     00Dh                                            ;carriage return
   336                                  EASCIIESCAPE            equ     01Bh                                            ;escape
   337                                  EASCIISPACE             equ     020h                                            ;space
   338                                  EASCIISLASH             equ     02Fh                                            ;slash
   339                                  EASCIIZERO              equ     030h                                            ;zero
   340                                  EASCIININE              equ     039h                                            ;nine
   341                                  EASCIIUPPERA            equ     041h                                            ;'A'
   342                                  EASCIIUPPERZ            equ     05Ah                                            ;'Z'
   343                                  EASCIICARET             equ     05Eh                                            ;'^'
   344                                  EASCIIUNDERSCORE        equ     05Fh                                            ;'_'
   345                                  EASCIILOWERA            equ     061h                                            ;'a'
   346                                  EASCIILOWERZ            equ     07Ah                                            ;'z'
   347                                  EASCIITILDE             equ     07Eh                                            ;'~'
   348                                  EASCIIDELETE            equ     07Fh                                            ;del
   349                                  EASCIIBORDSGLVERT       equ     0B3h                                            ;vertical single border
   350                                  EASCIIBORDSGLUPRRGT     equ     0BFh                                            ;upper-right single border
   351                                  EASCIIBORDSGLLWRLFT     equ     0C0h                                            ;lower-left single border
   352                                  EASCIIBORDSGLHORZ       equ     0C4h                                            ;horizontal single border
   353                                  EASCIIBORDSGLLWRRGT     equ     0D9h                                            ;lower-right single border
   354                                  EASCIIBORDSGLUPRLFT     equ     0DAh                                            ;upper-left single border
   355                                  EASCIICASEMASK          equ     11011111b                                       ;case mask
   356                                  ;-----------------------------------------------------------------------------------------------------------------------
   357                                  ;
   358                                  ;       Operating System Values
   359                                  ;
   360                                  ;-----------------------------------------------------------------------------------------------------------------------
   361                                  ;-----------------------------------------------------------------------------------------------------------------------
   362                                  ;
   363                                  ;       Boot Sector and Loader Constants                                        EBOOT...
   364                                  ;
   365                                  ;       Equates in this section support the boot sector and the 16-bit operating system loader, which will be
   366                                  ;       responsible for placing the CPU into protected mode and calling the initial operating system task.
   367                                  ;
   368                                  ;-----------------------------------------------------------------------------------------------------------------------
   369                                  EBOOTSTACKTOP           equ     0100h                                           ;boot sector stack top relative to DS
   370                                  EBOOTSECTORBYTES        equ     512                                             ;bytes per sector
   371                                  EBOOTDIRENTRIES         equ     224                                             ;directory entries (1.44MB 3.5" FD)
   372                                  EBOOTDISKSECTORS        equ     2880                                            ;sectors per disk (1.44MB 3.5" FD)
   373                                  EBOOTDISKBYTES          equ     (EBOOTSECTORBYTES*EBOOTDISKSECTORS)             ;bytes per disk
   374                                  EBOOTFATBASE            equ     (EBOOTSTACKTOP+EBOOTSECTORBYTES)                ;offset of FAT I/O buffer rel to DS
   375                                  EBOOTMAXTRIES           equ     5                                               ;max read retries
   376                                  ;-----------------------------------------------------------------------------------------------------------------------
   377                                  ;       Console Constants                                                       ECON...
   378                                  ;-----------------------------------------------------------------------------------------------------------------------
   379                                  ECONCOLS                equ     80                                              ;columns per row
   380                                  ECONROWS                equ     24                                              ;console rows
   381                                  ECONOIAROW              equ     24                                              ;operator information area row
   382                                  ECONCOLBYTES            equ     2                                               ;bytes per column
   383                                  ECONROWBYTES            equ     (ECONCOLS*ECONCOLBYTES)                         ;bytes per row
   384                                  ECONROWDWORDS           equ     (ECONROWBYTES/4)                                ;double-words per row
   385                                  ECONCLEARDWORD          equ     007200720h                                      ;attribute and ASCII space
   386                                  ECONOIADWORD            equ     070207020h                                      ;attribute and ASCII space
   387                                  ;-----------------------------------------------------------------------------------------------------------------------
   388                                  ;       Global Descriptor Table (GDT) Selectors                                 EGDT...
   389                                  ;-----------------------------------------------------------------------------------------------------------------------
   390                                  EGDTOSDATA              equ     018h                                            ;kernel data selector
   391                                  EGDTCGA                 equ     020h                                            ;cga video selector
   392                                  EGDTLOADERCODE          equ     030h                                            ;loader code selector
   393                                  EGDTOSCODE              equ     048h                                            ;os kernel code selector
   394                                  EGDTLOADERLDT           equ     050h                                            ;loader local descriptor table selector
   395                                  EGDTLOADERTSS           equ     058h                                            ;loader task state segment selector
   396                                  EGDTCONSOLELDT          equ     060h                                            ;console local descriptor table selector
   397                                  EGDTCONSOLETSS          equ     068h                                            ;console task state segment selector
   398                                  ;-----------------------------------------------------------------------------------------------------------------------
   399                                  ;       Keyboard Flags                                                          EKEYF...
   400                                  ;-----------------------------------------------------------------------------------------------------------------------
   401                                  EKEYFCTRLLEFT           equ     00000001b                                       ;left control
   402                                  EKEYFSHIFTLEFT          equ     00000010b                                       ;left shift
   403                                  EKEYFALTLEFT            equ     00000100b                                       ;left alt
   404                                  EKEYFCTRLRIGHT          equ     00001000b                                       ;right control
   405                                  EKEYFSHIFTRIGHT         equ     00010000b                                       ;right shift
   406                                  EKEYFSHIFT              equ     00010010b                                       ;left or right shift
   407                                  EKEYFALTRIGHT           equ     00100000b                                       ;right alt
   408                                  EKEYFWINLEFT            equ     01000000b                                       ;left windows(R)
   409                                  EKEYFWINRIGHT           equ     10000000b                                       ;right windows (R)
   410                                  EKEYFLOCKSCROLL         equ     00000001b                                       ;scroll-lock flag
   411                                  EKEYFLOCKNUM            equ     00000010b                                       ;num-lock flag
   412                                  EKEYFLOCKCAPS           equ     00000100b                                       ;cap-lock flag
   413                                  EKEYFLOCKINSERT         equ     00001000b                                       ;insert-lock flag
   414                                  EKEYFTIMEOUT            equ     10000000b                                       ;controller timeout
   415                                  ;-----------------------------------------------------------------------------------------------------------------------
   416                                  ;       Kernel Constants                                                        EKRN...
   417                                  ;-----------------------------------------------------------------------------------------------------------------------
   418                                  EKRNCODEBASE            equ     01000h                                          ;kernel base address (0000:1000)
   419                                  EKRNCODESEG             equ     (EKRNCODEBASE >> 4)                             ;kernel code segment (0100:0000)
   420                                  EKRNCODELEN             equ     05000h                                          ;kernel code size (1000h to 6000h)
   421                                  EKRNCODESRCADR          equ     0500h                                           ;kernel code offset to loader DS:
   422                                  ;-----------------------------------------------------------------------------------------------------------------------
   423                                  ;       Local Descriptor Table (LDT) Selectors                                  ELDT...
   424                                  ;-----------------------------------------------------------------------------------------------------------------------
   425                                  ELDTMQ                  equ     02Ch                                            ;console task message queue
   426                                  ;-----------------------------------------------------------------------------------------------------------------------
   427                                  ;       Memory Management Constants                                             EMEM...
   428                                  ;-----------------------------------------------------------------------------------------------------------------------
   429                                  EMEMMINSIZE             equ     256                                             ;minimum heap block size (incl. hdr)
   430                                  EMEMFREECODE            equ     "FREE"                                          ;free memory signature
   431                                  EMEMUSERCODE            equ     "USER"                                          ;user memory signature
   432                                  EMEMWIPEBYTE            equ     000h                                            ;byte value to wipe storage
   433                                  ;-----------------------------------------------------------------------------------------------------------------------
   434                                  ;       Message Identifiers                                                     EMSG...
   435                                  ;-----------------------------------------------------------------------------------------------------------------------
   436                                  EMSGKEYDOWN             equ     041000000h                                      ;key-down
   437                                  EMSGKEYUP               equ     041010000h                                      ;key-up
   438                                  EMSGKEYCHAR             equ     041020000h                                      ;character
   439                                  ;=======================================================================================================================
   440                                  ;
   441                                  ;       Structures
   442                                  ;
   443                                  ;=======================================================================================================================
   444                                  ;-----------------------------------------------------------------------------------------------------------------------
   445                                  ;
   446                                  ;       KEYBDATA
   447                                  ;
   448                                  ;       The KEYBDATA structure holds variables used to handle keyboard events.
   449                                  ;
   450                                  ;-----------------------------------------------------------------------------------------------------------------------
   451                                  struc                   KEYBDATA
   452 00000000 <res 00000001>          .scan0                  resb    1                                               ;1st scan code
   453 00000001 <res 00000001>          .scan1                  resb    1                                               ;2nd scan code
   454 00000002 <res 00000001>          .scan2                  resb    1                                               ;3rd scan code
   455 00000003 <res 00000001>          .scan3                  resb    1                                               ;4th scan code
   456 00000004 <res 00000001>          .scan                   resb    1                                               ;active scan code
   457 00000005 <res 00000001>          .char                   resb    1                                               ;ASCII character
   458 00000006 <res 00000001>          .last                   resb    1                                               ;previous scan code
   459 00000007 <res 00000001>          .shift                  resb    1                                               ;shift flags (shift, ctrl, alt, win)
   460 00000008 <res 00000001>          .lock                   resb    1                                               ;lock flags (caps, num, scroll, insert)
   461 00000009 <res 00000001>          .status                 resb    1                                               ;status (timeout)
   462                                  EKEYBDATAL              equ     ($-.scan0)                                      ;structure length
   463                                  endstruc
   464                                  ;-----------------------------------------------------------------------------------------------------------------------
   465                                  ;
   466                                  ;       MEMBLOCK
   467                                  ;
   468                                  ;       The MEMBLOCK structure defines a memory block.
   469                                  ;
   470                                  ;-----------------------------------------------------------------------------------------------------------------------
   471                                  struc                   MEMBLOCK
   472 00000000 <res 00000004>          .signature              resd    1                                               ;starting signature
   473 00000004 <res 00000004>          .bytes                  resd    1                                               ;block size in bytes
   474 00000008 <res 00000004>          .owner                  resd    1                                               ;owning task
   475 0000000C <res 00000004>          .reserved               resd    1                                               ;reserved
   476 00000010 <res 00000004>          .nextcontig             resd    1                                               ;next contiguous block
   477 00000014 <res 00000004>          .previouscontig         resd    1                                               ;previous contiguous block
   478 00000018 <res 00000004>          .nextblock              resd    1                                               ;next free/task block
   479 0000001C <res 00000004>          .previousblock          resd    1                                               ;previous free/task block
   480                                  EMEMBLOCKLEN            equ     ($-.signature)
   481                                  endstruc
   482                                  ;-----------------------------------------------------------------------------------------------------------------------
   483                                  ;
   484                                  ;       MEMROOT
   485                                  ;
   486                                  ;       The MEMROOT structure defines starting and ending addresses of memory block chains.
   487                                  ;
   488                                  ;-----------------------------------------------------------------------------------------------------------------------
   489                                  struc                   MEMROOT
   490 00000000 <res 00000004>          .firstcontig            resd    1                                               ;first contiguous block
   491 00000004 <res 00000004>          .lastcontig             resd    1                                               ;last contiguous block
   492 00000008 <res 00000004>          .firstfree              resd    1                                               ;first free block
   493 0000000C <res 00000004>          .lastfree               resd    1                                               ;last free block
   494 00000010 <res 00000004>          .firsttask              resd    1                                               ;first task block
   495 00000014 <res 00000004>          .lasttask               resd    1                                               ;last task block
   496                                  EMEMROOTLEN             equ     ($-.firstcontig)
   497                                  endstruc
   498                                  ;-----------------------------------------------------------------------------------------------------------------------
   499                                  ;
   500                                  ;       MQUEUE
   501                                  ;
   502                                  ;       The MQUEUE structure maps memory used for a message queue.
   503                                  ;
   504                                  ;-----------------------------------------------------------------------------------------------------------------------
   505                                  struc                   MQUEUE
   506 00000000 <res 00000004>          MQHead                  resd    1                                               ;000 head ptr
   507 00000004 <res 00000004>          MQTail                  resd    1                                               ;004 tail ptr
   508 00000008 <res 000003F8>          MQData                  resd    254                                             ;message queue
   509                                  endstruc
   510                                  ;-----------------------------------------------------------------------------------------------------------------------
   511                                  ;
   512                                  ;       OSDATA
   513                                  ;
   514                                  ;       The OSDATA structure maps low-memory addresses used by the BIOS and the OS. Areas that may be in use by DOS or
   515                                  ;       other host operating systems that may be running when this OS is launched are avoided.
   516                                  ;
   517                                  ;-----------------------------------------------------------------------------------------------------------------------
   518                                  struc                   OSDATA
   519 00000000 <res 00000400>                                  resb    0400h                                           ;000 real mode interrupt vectors
   520 00000400 <res 00000002>                                  resw    1                                               ;400 COM1 port address
   521 00000402 <res 00000002>                                  resw    1                                               ;402 COM2 port address
   522 00000404 <res 00000002>                                  resw    1                                               ;404 COM3 port address
   523 00000406 <res 00000002>                                  resw    1                                               ;406 COM4 port address
   524 00000408 <res 00000002>                                  resw    1                                               ;408 LPT1 port address
   525 0000040A <res 00000002>                                  resw    1                                               ;40a LPT2 port address
   526 0000040C <res 00000002>                                  resw    1                                               ;40c LPT3 port address
   527 0000040E <res 00000002>                                  resw    1                                               ;40e LPT4 port address
   528 00000410 <res 00000002>                                  resb    2                                               ;410 equipment list flags
   529 00000412 <res 00000001>                                  resb    1                                               ;412 errors in PCjr infrared keybd link
   530 00000413 <res 00000002>                                  resw    1                                               ;413 memory size (kb) INT 12h
   531 00000415 <res 00000001>                                  resb    1                                               ;415 mfr error test scratchpad
   532 00000416 <res 00000001>                                  resb    1                                               ;416 PS/2 BIOS control flags
   533 00000417 <res 00000001>                                  resb    1                                               ;417 keyboard flag byte 0
   534 00000418 <res 00000001>                                  resb    1                                               ;418 keyboard flag byte 1
   535 00000419 <res 00000001>                                  resb    1                                               ;419 alternate keypad entry
   536 0000041A <res 00000002>                                  resw    1                                               ;41a keyboard buffer head offset
   537 0000041C <res 00000002>                                  resw    1                                               ;41c keyboard buffer tail offset
   538 0000041E <res 00000020>                                  resb    32                                              ;41e keyboard buffer
   539 0000043E <res 00000001>          wbFDCStatus             resb    1                                               ;43e drive recalibration status
   540 0000043F <res 00000001>          wbFDCControl            resb    1                                               ;43f FDC motor status/control byte
   541 00000440 <res 00000001>          wbFDCMotor              resb    1                                               ;440 FDC motor timeout byte
   542 00000441 <res 00000001>                                  resb    1                                               ;441 status of last diskette operation
   543 00000442 <res 00000007>                                  resb    7                                               ;442 NEC diskette controller status
   544 00000449 <res 00000001>                                  resb    1                                               ;449 current video mode
   545 0000044A <res 00000002>                                  resw    1                                               ;44a screen columns
   546 0000044C <res 00000002>                                  resw    1                                               ;44c video regen buffer size
   547 0000044E <res 00000002>                                  resw    1                                               ;44e current video page offset
   548 00000450 <res 00000010>                                  resw    8                                               ;450 cursor postions of pages 1-8
   549 00000460 <res 00000001>                                  resb    1                                               ;460 cursor ending scanline
   550 00000461 <res 00000001>                                  resb    1                                               ;461 cursor start scanline
   551 00000462 <res 00000001>                                  resb    1                                               ;462 active display page number
   552 00000463 <res 00000002>                                  resw    1                                               ;463 CRTC base port address
   553 00000465 <res 00000001>                                  resb    1                                               ;465 CRT mode control register value
   554 00000466 <res 00000001>                                  resb    1                                               ;466 CGA current color palette mask
   555 00000467 <res 00000002>                                  resw    1                                               ;467 CS:IP for 286 return from PROT MODE
   556 00000469 <res 00000003>                                  resb    3                                               ;469 vague
   557 0000046C <res 00000004>          wdClockTicks            resd    1                                               ;46c clock ticks
   558 00000470 <res 00000001>          wbClockDays             resb    1                                               ;470 clock days
   559 00000471 <res 00000001>                                  resb    1                                               ;471 bios break flag
   560 00000472 <res 00000002>                                  resw    1                                               ;472 soft reset
   561 00000474 <res 00000001>                                  resb    1                                               ;474 last hard disk operation status
   562 00000475 <res 00000001>                                  resb    1                                               ;475 hard disks attached
   563 00000476 <res 00000001>                                  resb    1                                               ;476 XT fised disk drive control byte
   564 00000477 <res 00000001>                                  resb    1                                               ;477 port offset to current fixed disk adapter
   565 00000478 <res 00000004>                                  resb    4                                               ;478 LPT timeout values
   566 0000047C <res 00000004>                                  resb    4                                               ;47c COM timeout values
   567 00000480 <res 00000002>                                  resw    1                                               ;480 keyboard buffer start offset
   568 00000482 <res 00000002>                                  resw    1                                               ;482 keyboard buffer end offset
   569 00000484 <res 00000001>                                  resb    1                                               ;484 Rows on screen less 1 (EGA+)
   570 00000485 <res 00000001>                                  resb    1                                               ;485 point height of character matrix (EGA+)
   571 00000486 <res 00000001>                                  resb    1                                               ;486 PC Jr initial keybd delay
   572 00000487 <res 00000001>                                  resb    1                                               ;487 EGA+ video mode ops
   573 00000488 <res 00000001>                                  resb    1                                               ;488 EGA feature bit switches
   574 00000489 <res 00000001>                                  resb    1                                               ;489 VGA video display data area
   575 0000048A <res 00000001>                                  resb    1                                               ;48a EGA+ display combination code
   576 0000048B <res 00000001>                                  resb    1                                               ;48b last diskette data rate selected
   577 0000048C <res 00000001>                                  resb    1                                               ;48c hard disk status from controller
   578 0000048D <res 00000001>                                  resb    1                                               ;48d hard disk error from controller
   579 0000048E <res 00000001>                                  resb    1                                               ;48e hard disk interrupt control flag
   580 0000048F <res 00000001>                                  resb    1                                               ;48f combination hard/floppy disk card
   581 00000490 <res 00000004>                                  resb    4                                               ;490 drive 0,1,2,3 media state
   582 00000494 <res 00000001>                                  resb    1                                               ;494 track currently seeked to on drive 0
   583 00000495 <res 00000001>                                  resb    1                                               ;495 track currently seeked to on drive 1
   584 00000496 <res 00000001>                                  resb    1                                               ;496 keyboard mode/type
   585 00000497 <res 00000001>                                  resb    1                                               ;497 keyboard LED flags
   586 00000498 <res 00000004>                                  resd    1                                               ;498 pointer to user wait complete flag
   587 0000049C <res 00000004>                                  resd    1                                               ;49c user wait time-out value in microseconds
   588 000004A0 <res 00000001>                                  resb    1                                               ;4a0 RTC wait function flag
   589 000004A1 <res 00000001>                                  resb    1                                               ;4a1 LANA DMA channel flags
   590 000004A2 <res 00000002>                                  resb    2                                               ;4a2 status of LANA 0,1
   591 000004A4 <res 00000004>                                  resd    1                                               ;4a4 saved hard disk interrupt vector
   592 000004A8 <res 00000004>                                  resd    1                                               ;4a8 BIOS video save/override pointer table addr
   593 000004AC <res 00000008>                                  resb    8                                               ;4ac reserved
   594 000004B4 <res 00000001>                                  resb    1                                               ;4b4 keyboard NMI control flags
   595 000004B5 <res 00000004>                                  resd    1                                               ;4b5 keyboard break pending flags
   596 000004B9 <res 00000001>                                  resb    1                                               ;4b9 Port 60 single byte queue
   597 000004BA <res 00000001>                                  resb    1                                               ;4ba scan code of last key
   598 000004BB <res 00000001>                                  resb    1                                               ;4bb NMI buffer head pointer
   599 000004BC <res 00000001>                                  resb    1                                               ;4bc NMI buffer tail pointer
   600 000004BD <res 00000010>                                  resb    16                                              ;4bd NMI scan code buffer
   601 000004CD <res 00000001>                                  resb    1                                               ;4cd unknown
   602 000004CE <res 00000002>                                  resw    1                                               ;4de day counter
   603 000004D0 <res 00000020>                                  resb    32                                              ;4d0 unknown
   604 000004F0 <res 00000010>                                  resb    16                                              ;4f0 intra-app comm area
   605 00000500 <res 00000001>                                  resb    1                                               ;500 print-screen status byte
   606 00000501 <res 00000003>                                  resb    3                                               ;501 used by BASIC
   607 00000504 <res 00000001>                                  resb    1                                               ;504 DOS single diskette mode
   608 00000505 <res 0000000A>                                  resb    10                                              ;505 POST work area
   609 0000050F <res 00000001>                                  resb    1                                               ;50f BASIC shell flag
   610 00000510 <res 00000002>                                  resw    1                                               ;510 BASIC default DS (DEF SEG)
   611 00000512 <res 00000004>                                  resd    1                                               ;512 BASIC INT 1C interrupt handler
   612 00000516 <res 00000004>                                  resd    1                                               ;516 BASIC INT 23 interrupt handler
   613 0000051A <res 00000004>                                  resd    1                                               ;51a BASIC INT 24 interrupt handler
   614 0000051E <res 00000002>                                  resw    1                                               ;51e unknown
   615 00000520 <res 00000002>                                  resw    1                                               ;520 DOS dynamic storage
   616 00000522 <res 0000000E>                                  resb    14                                              ;522 DOS diskette initialization table (INT 1e)
   617 00000530 <res 00000004>                                  resb    4                                               ;530 MODE command
   618 00000534 <res 000001CC>                                  resb    460                                             ;534 unused
   619 00000700 <res 00000100>                                  resb    256                                             ;700 i/o drivers from io.sys/ibmbio.com
   620                                  ;-----------------------------------------------------------------------------------------------------------------------
   621                                  ;
   622                                  ;       Kernel Variables                                                        @disk: N/A      @mem: 000800
   623                                  ;
   624                                  ;       Kernel variables may be accessed by interrupts or by the initial task (Console).
   625                                  ;
   626                                  ;-----------------------------------------------------------------------------------------------------------------------
   627                                  ECONDATA                equ     ($)
   628                                                                                                                  ;---------------------------------------
   629                                                                                                                  ;  panel handling
   630                                                                                                                  ;---------------------------------------
   631 00000800 <res 00000004>          wdConsoleHandler        resd    1                                               ;handler function
   632 00000804 <res 00000004>          wdConsolePanel          resd    1                                               ;panel definition addr
   633 00000808 <res 00000004>          wdConsoleField          resd    1                                               ;active field definition addr
   634 0000080C <res 00000004>          wdConsoleMemBase        resd    1                                               ;console memory address
   635 00000810 <res 00000050>          wzConsoleInBuffer       resb    80                                              ;command input buffer
   636 00000860 <res 00000050>          wzConsoleToken          resb    80                                              ;token buffer
   637 000008B0 <res 00000050>          wzConsoleOutBuffer      resb    80                                              ;output buffer
   638                                                                                                                  ;---------------------------------------
   639                                                                                                                  ;  memory panel fields
   640                                                                                                                  ;---------------------------------------
   641 00000900 <res 0000004C>          wzConsoleMemBuf0        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   642 0000094C <res 0000004C>          wzConsoleMemBuf1        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   643 00000998 <res 0000004C>          wzConsoleMemBuf2        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   644 000009E4 <res 0000004C>          wzConsoleMemBuf3        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   645 00000A30 <res 0000004C>          wzConsoleMemBuf4        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   646 00000A7C <res 0000004C>          wzConsoleMemBuf5        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   647 00000AC8 <res 0000004C>          wzConsoleMemBuf6        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   648 00000B14 <res 0000004C>          wzConsoleMemBuf7        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   649 00000B60 <res 0000004C>          wzConsoleMemBuf8        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   650 00000BAC <res 0000004C>          wzConsoleMemBuf9        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   651 00000BF8 <res 0000004C>          wzConsoleMemBufA        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   652 00000C44 <res 0000004C>          wzConsoleMemBufB        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   653 00000C90 <res 0000004C>          wzConsoleMemBufC        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   654 00000CDC <res 0000004C>          wzConsoleMemBufD        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   655 00000D28 <res 0000004C>          wzConsoleMemBufE        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   656 00000D74 <res 0000004C>          wzConsoleMemBufF        resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   657 00000DC0 <res 0000004C>          wzConsoleMemBuf10       resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   658 00000E0C <res 0000004C>          wzConsoleMemBuf11       resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   659 00000E58 <res 0000004C>          wzConsoleMemBuf12       resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   660 00000EA4 <res 0000004C>          wzConsoleMemBuf13       resb    76                                              ;aaaaaaaa  xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx  ................\0
   661                                                                                                                  ;---------------------------------------
   662                                                                                                                  ;  reusable menu option input
   663                                                                                                                  ;---------------------------------------
   664 00000EF0 <res 00000002>          wzFldMenuOptn0          resb    2                                               ;menu option 0  _\0
   665 00000EF2 <res 00000002>          wzFldMenuOptn1          resb    2                                               ;menu option 1
   666 00000EF4 <res 00000002>          wzFldMenuOptn2          resb    2                                               ;menu option 2
   667 00000EF6 <res 00000002>          wzFldMenuOptn3          resb    2                                               ;menu option 3
   668 00000EF8 <res 00000002>          wzFldMenuOptn4          resb    2                                               ;menu option 4
   669 00000EFA <res 00000002>          wzFldMenuOptn5          resb    2                                               ;menu option 5
   670 00000EFC <res 00000002>          wzFldMenuOptn6          resb    2                                               ;menu option 6
   671 00000EFE <res 00000002>          wzFldMenuOptn7          resb    2                                               ;menu option 7
   672 00000F00 <res 00000002>          wzFldMenuOptn8          resb    2                                               ;menu option 8
   673 00000F02 <res 00000002>          wzFldMenuOptn9          resb    2                                               ;menu option 9
   674 00000F04 <res 00000002>          wzFldMenuOptnA          resb    2                                               ;menu option A
   675 00000F06 <res 00000002>          wzFldMenuOptnB          resb    2                                               ;menu option B
   676 00000F08 <res 00000002>          wzFldMenuOptnC          resb    2                                               ;menu option C
   677 00000F0A <res 00000002>          wzFldMenuOptnD          resb    2                                               ;menu option D
   678 00000F0C <res 00000002>          wzFldMenuOptnE          resb    2                                               ;menu option E
   679 00000F0E <res 00000002>          wzFldMenuOptnF          resb    2                                               ;menu option F
   680 00000F10 <res 00000002>          wzFldMenuOptn10         resb    2                                               ;menu option 10
   681 00000F12 <res 00000002>          wzFldMenuOptn11         resb    2                                               ;menu option 11
   682 00000F14 <res 00000002>          wzFldMenuOptn12         resb    2                                               ;menu option 12
   683 00000F16 <res 00000002>          wzFldMenuOptn13         resb    2                                               ;menu option 13
   684                                                                                                                  ;---------------------------------------
   685                                                                                                                  ;  cursor placement
   686                                                                                                                  ;---------------------------------------
   687 00000F18 <res 00000001>          wbConsoleColumn         resb    1                                               ;console column
   688 00000F19 <res 00000001>          wbConsoleRow            resb    1                                               ;console row
   689                                                                                                                  ;---------------------------------------
   690                                                                                                                  ;  set by keyboard interrupt
   691                                                                                                                  ;---------------------------------------
   692 00000F1A <res 0000000A>          wsKeybData              resb    EKEYBDATAL                                      ;keyboard data
   693                                                                                                                  ;---------------------------------------
   694                                                                                                                  ;  memory management
   695                                                                                                                  ;---------------------------------------
   696 00000F24 <res 00000018>          wsConsoleMemRoot        resb    EMEMROOTLEN                                     ;memory root structure
   697                                  ECONDATALEN             equ     ($-ECONDATA)                                    ;size of console data area
   698                                  ;-----------------------------------------------------------------------------------------------------------------------
   699                                  ;
   700                                  ;       End of OS Variables
   701                                  ;
   702                                  ;-----------------------------------------------------------------------------------------------------------------------
   703                                  endstruc
   704                                  ;-----------------------------------------------------------------------------------------------------------------------
   705                                  ;
   706                                  ;       Macros
   707                                  ;
   708                                  ;       These macros are used to assist in defining descriptor tables and interrupt table offsets.
   709                                  ;
   710                                  ;-----------------------------------------------------------------------------------------------------------------------
   711                                  %macro                  mint    1
   712                                  _%1                     equ     ($-$$) / EX86DESCLEN
   713                                                          dq      ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
   714                                  %endmacro
   715                                  %macro                  mtrap   1
   716                                  _%1                     equ     ($-$$) / EX86DESCLEN
   717                                                          dq      ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
   718                                  %endmacro
   719                                  %macro                  menter  1
   720                                  ?%1                     equ     ($-$$)
   721                                  %endmacro
   722                                  %macro                  tsvce   1
   723                                  e%1                     equ     ($-tsvc)/4
   724                                                          dd      %1
   725                                  %endmacro
   726                                  %ifdef BUILDBOOT
   727                                  ;=======================================================================================================================
   728                                  ;
   729                                  ;       Boot Sector                                                             @disk: 000000   @mem: 007c00
   730                                  ;
   731                                  ;       The first sector of the diskette is the boot sector. The BIOS will load the boot sector into memory and pass
   732                                  ;       control to the code at the start of the sector. The boot sector code is responsible for loading the operating
   733                                  ;       system into memory. The boot sector contains a disk parameter table describing the geometry and allocation
   734                                  ;       of the diskette. Following the disk parameter table is code to load the operating system kernel into memory.
   735                                  ;
   736                                  ;       The "cpu" directive limits emitted code to those instructions supported by the most primitive processor
   737                                  ;       we expect to ever execute our code. The "vstart" parameter indicates addressability of symbols so as to
   738                                  ;       emulate the DOS .COM program model. Although the BIOS is expected to load the boot sector at address 7c00,
   739                                  ;       we do not make that assumption. The CPU starts in 16-bit addressing mode. A three-byte jump instruction is
   740                                  ;       immediately followed by the disk parameter table.
   741                                  ;
   742                                  ;=======================================================================================================================
   743                                                          cpu     8086                                            ;assume minimal CPU
   744                                  section                 boot    vstart=0100h                                    ;emulate .COM (CS,DS,ES=PSP) addressing
   745                                                          bits    16                                              ;16-bit code at power-up
   746                                  %ifdef BUILDPREP
   747                                  Boot                    jmp     word Prep                                       ;jump to preparation code
   748                                  %else
   749 00000000 E91B00                  Boot                    jmp     word Boot.10                                    ;jump over parameter table
   750                                  %endif
   751                                  ;-----------------------------------------------------------------------------------------------------------------------
   752                                  ;
   753                                  ;       Disk Parameter Table
   754                                  ;
   755                                  ;       The disk parameter table informs the BIOS of the floppy disk architecture. Here, we use parameters for the
   756                                  ;       3.5" 1.44MB floppy disk since this format is widely supported by virtual machine hypervisors.
   757                                  ;
   758                                  ;-----------------------------------------------------------------------------------------------------------------------
   759 00000003 4F53202020202020                                db      "OS      "                                      ;eight-byte label
   760 0000000B 0002                    cwSectorBytes           dw      EBOOTSECTORBYTES                                ;bytes per sector
   761 0000000D 01                      cbClusterSectors        db      1                                               ;sectors per cluster
   762 0000000E 0100                    cwReservedSectors       dw      1                                               ;reserved sectors
   763 00000010 02                      cbFatCount              db      2                                               ;file allocation table copies
   764 00000011 E000                    cwDirEntries            dw      EBOOTDIRENTRIES                                 ;max directory entries
   765 00000013 400B                    cwDiskSectors           dw      EBOOTDISKSECTORS                                ;sectors per disk
   766 00000015 F0                      cbDiskType              db      0F0h                                            ;1.44MB
   767 00000016 0900                    cwFatSectors            dw      9                                               ;sectors per FAT copy
   768                                  cbTrackSectors          equ     $                                               ;sectors per track (as byte)
   769 00000018 1200                    cwTrackSectors          dw      18                                              ;sectors per track (as word)
   770 0000001A 0200                    cwDiskSides             dw      2                                               ;sides per disk
   771 0000001C 0000                    cwSpecialSectors        dw      0                                               ;special sectors
   772                                  ;
   773                                  ;       BIOS typically loads the boot sector at absolute address 7c00 and sets the stack pointer at 512 bytes past
   774                                  ;       the end of the boot sector. But, since BIOS code varies, we don't make any assumptions as to where our boot
   775                                  ;       sector is loaded. For example, the initial CS:IP could be 0:7c00, 700:c00, 7c0:0, etc. To avoid assumptions,
   776                                  ;       we first normalize CS:IP to get the absolute segment address in BX. The comments below show the effect of this
   777                                  ;       code given several possible starting values for CS:IP.
   778                                  ;
   779                                                                                                                  ;CS:IP   0:7c00 700:c00 7c0:0
   780 0000001E E80000                  Boot.10                 call    word .20                                        ;[ESP] =   7c21     c21    21
   781                                  .@20                    equ     $-$$                                            ;.@20 = 021h
   782 00000021 58                      .20                     pop     ax                                              ;AX =      7c21     c21    21
   783 00000022 83E821                                          sub     ax,.@20                                         ;AX =      7c00     c00     0
   784 00000025 B104                                            mov     cl,4                                            ;shift count
   785 00000027 D3E8                                            shr     ax,cl                                           ;AX =       7c0      c0     0
   786 00000029 8CCB                                            mov     bx,cs                                           ;BX =         0     700   7c0
   787 0000002B 01C3                                            add     bx,ax                                           ;BX =       7c0     7c0   7c0
   788                                  ;
   789                                  ;       Now, since we are assembling our boot code to emulate the addressing of a .COM file, we want the DS and ES
   790                                  ;       registers to be set to where a Program Segment Prefix (PSP) would be, exactly 100h (256) bytes prior to
   791                                  ;       the start of our code. This will correspond to our assembled data address offsets. Note that we instructed
   792                                  ;       the assembler to produce addresses for our symbols that are offset from our code by 100h. See the "vstart"
   793                                  ;       parameter for the "section" directive above. We also set SS to the PSP and SP to the address of our i/o
   794                                  ;       buffer. This leaves 256 bytes of usable stack from 7b0:0 to 7b0:100.
   795                                  ;
   796                                  ;       Note that when a value is loaded into the stack segment register (SS) interrupts are disabled until the
   797                                  ;       completion of the following instruction.
   798                                  ;
   799 0000002D 83EB10                                          sub     bx,16                                           ;BX = 07b0
   800 00000030 8EDB                                            mov     ds,bx                                           ;DS = 07b0 = psp
   801 00000032 8EC3                                            mov     es,bx                                           ;ES = 07b0 = psp
   802 00000034 8ED3                                            mov     ss,bx                                           ;SS = 07b0 = psp (ints disabled)
   803 00000036 BC0001                                          mov     sp,EBOOTSTACKTOP                                ;SP = 0100       (ints enabled)
   804                                  ;
   805                                  ;       Our boot addressability is now set up according to the following diagram.
   806                                  ;
   807                                  ;       DS,ES,SS -----> 007b00  +-----------------------------------------------+ DS:0000
   808                                  ;                               |  Boot Stack & Boot PSP (Unused)               |
   809                                  ;                               |  256 = 100h bytes                             |
   810                                  ;       SS:SP --------> 007c00  +-----------------------------------------------+ DS:0100  07b0:0100
   811                                  ;                               |  Boot Sector (vstart=0100h)                   |
   812                                  ;                               |  1 sector = 512 = 200h bytes                  |
   813                                  ;                       007e00  +-----------------------------------------------+ DS:0300
   814                                  ;                               |  File Allocation Table (FAT) I/O Buffer       |
   815                                  ;                               |  9x512-byte sectors = 4,608 = 1200h bytes     |
   816                                  ;                       009000  +-----------------------------------------------+ DS:1500  08f0:0100
   817                                  ;                               |  Directory Sector Buffer & Kernel Load Area   |
   818                                  ;                               |  2 sectors = 1024 = 400h bytes
   819                                  ;                       009400  +-----------------------------------------------+ DS:1900
   820                                  ;
   821                                  ;       On entry, DL indicates the drive being booted from.
   822                                  ;
   823 00000039 8816[F801]                                      mov     [wbDrive],dl                                    ;[wbDrive] = drive being booted from
   824                                  ;
   825                                  ;       Compute directory i/o buffer address.
   826                                  ;
   827 0000003D A1[1600]                                        mov     ax,[cwFatSectors]                               ;AX = 0009 = FAT sectors
   828 00000040 F726[0B00]                                      mul     word [cwSectorBytes]                            ;DX:AX = 0000:1200 = FAT bytes
   829 00000044 050003                                          add     ax,EBOOTFATBASE                                 ;AX = 1500 = end of FAT buffer
   830 00000047 A3[EC01]                                        mov     [wwDirBuffer],ax                                ;[wwDirBuffer] = 1500
   831                                  ;
   832                                  ;       Compute segment where os.com will be loaded.
   833                                  ;
   834 0000004A D3E8                                            shr     ax,cl                                           ;AX = 0150
   835 0000004C 01D8                                            add     ax,bx                                           ;AX = 0150 + 07b0 = 0900
   836 0000004E 83E810                                          sub     ax,16                                           ;AX = 08f0
   837 00000051 A3[3F01]                                        mov     [wwLoadSegment],ax                              ;[wwLoadSegment] = 08f0
   838                                  ;
   839                                  ;       Set the video mode to 80 column, 25 row, text.
   840                                  ;
   841 00000054 B80300                                          mov     ax,EBIOSFNSETVMODE<<8|EBIOSMODETEXT80           ;set mode function, 80x25 text mode
   842 00000057 CD10                                            int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
   843                                  ;
   844                                  ;       Write a message to the console so we know we have our addressability established.
   845                                  ;
   846 00000059 BE[C501]                                        mov     si,czLoadMsg                                    ;loading message
   847 0000005C E84B01                                          call    BootPrint                                       ;display loader message
   848                                  ;
   849                                  ;       Initialize the number of directory sectors to search.
   850                                  ;
   851 0000005F A1[1100]                                        mov     ax,[cwDirEntries]                               ;AX = 224 = max dir entries
   852 00000062 A3[EE01]                                        mov     [wwEntriesLeft],ax                              ;[wwEntriesLeft] = 224
   853                                  ;
   854                                  ;       Compute number of directory sectors and initialize overhead count.
   855                                  ;
   856 00000065 89C1                                            mov     cx,ax                                           ;CX = 00e0 = 224 entries
   857 00000067 F726[B801]                                      mul     word [cwEntryLen]                               ;DX:AX = 224 * 32 = 7168
   858 0000006B F736[0B00]                                      div     word [cwSectorBytes]                            ;AX = 7168 / 512 = 14 = dir sectors
   859 0000006F A3[F001]                                        mov     [wwOverhead],ax                                 ;[wwOverhead] = 000e
   860                                  ;
   861                                  ;       Compute directory entries per sector.
   862                                  ;
   863 00000072 91                                              xchg    ax,cx                                           ;DX:AX = 0:00e0, CX = 0000e
   864 00000073 F7F1                                            div     cx                                              ;AX = 0010 = entries per dir sector
   865 00000075 A3[F201]                                        mov     [wwSectorEntries],ax                            ;[wwSectorEntries] = 0010
   866                                  ;
   867                                  ;       Compute first logical directory sector and update overhead count.
   868                                  ;
   869 00000078 A1[1600]                                        mov     ax,[cwFatSectors]                               ;AX = 0009 = FAT sectors per copy
   870 0000007B F626[1000]                                      mul     byte [cbFatCount]                               ;AX = 0012 = FAT sectors
   871 0000007F 0306[0E00]                                      add     ax,[cwReservedSectors]                          ;AX = 0013 = FAT plus reserved
   872 00000083 0306[1C00]                                      add     ax,[cwSpecialSectors]                           ;AX = 0013 = FAT + reserved + special
   873 00000087 A3[F401]                                        mov     [wwLogicalSector],ax                            ;[wwLogicalSector] = 0013
   874 0000008A 0106[F001]                                      add     [wwOverhead],ax                                 ;[wwOverhead] = 0021 = res+spec+FAT+dir
   875                                  ;
   876                                  ;       Read directory sector.
   877                                  ;
   878 0000008E B001                    .30                     mov     al,1                                            ;sector count
   879 00000090 A2[F601]                                        mov     [wbReadCount],al                                ;[wbReadCount] = 01
   880 00000093 8B1E[EC01]                                      mov     bx,[wwDirBuffer]                                ;BX = 1500
   881 00000097 E8A700                                          call    ReadSector                                      ;read sector into es:bx
   882                                  ;
   883                                  ;       Setup variables to search this directory sector.
   884                                  ;
   885 0000009A A1[EE01]                                        mov     ax,[wwEntriesLeft]                              ;directory entries to search
   886 0000009D 3B06[F201]                                      cmp     ax,[wwSectorEntries]                            ;need to search more sectors?
   887 000000A1 7603                                            jna     .40                                             ;no, continue
   888 000000A3 A1[F201]                                        mov     ax,[wwSectorEntries]                            ;yes, limit search to sector
   889 000000A6 2906[EE01]              .40                     sub     [wwEntriesLeft],ax                              ;update entries left to searh
   890 000000AA BE[BA01]                                        mov     si,cbKernelProgram                              ;program name
   891 000000AD 8B3E[EC01]                                      mov     di,[wwDirBuffer]                                ;DI = 1500
   892                                  ;
   893                                  ;       Loop through directory sectors searching for kernel program.
   894                                  ;
   895 000000B1 56                      .50                     push    si                                              ;save kernel name address
   896 000000B2 57                                              push    di                                              ;save dir i/o buffer address
   897 000000B3 B90B00                                          mov     cx,11                                           ;length of 8+3 name
   898 000000B6 FC                                              cld                                                     ;forward strings
   899 000000B7 F3A6                                            repe    cmpsb                                           ;compare entry name
   900 000000B9 5F                                              pop     di                                              ;restore dir i/o buffer address
   901 000000BA 5E                                              pop     si                                              ;restore kernel name address
   902 000000BB 7418                                            je      .60                                             ;exit loop if found
   903 000000BD 033E[B801]                                      add     di,[cwEntryLen]                                 ;point to next dir entry
   904 000000C1 48                                              dec     ax                                              ;decrement remaining entries
   905 000000C2 75ED                                            jnz     .50                                             ;next entry
   906                                  ;
   907                                  ;       Repeat search if we are not at the end of the directory.
   908                                  ;
   909 000000C4 FF06[F401]                                      inc     word [wwLogicalSector]                          ;increment logical sector
   910 000000C8 833E[EE01]00                                    cmp     word [wwEntriesLeft],0                          ;done with directory?
   911 000000CD 75BF                                            jne     .30                                             ;no, get next sector
   912 000000CF BE[E001]                                        mov     si,czNoKernel                                   ;missing kernel message
   913 000000D2 E9C000                                          jmp     BootExit                                        ;display message and exit
   914                                  ;
   915                                  ;       If we find the kernel program in the directory, read the FAT.
   916                                  ;
   917 000000D5 A1[0E00]                .60                     mov     ax,[cwReservedSectors]                          ;AX = 0001
   918 000000D8 A3[F401]                                        mov     [wwLogicalSector],ax                            ;start past boot sector
   919 000000DB A1[1600]                                        mov     ax,[cwFatSectors]                               ;AX = 0009
   920 000000DE A2[F601]                                        mov     [wbReadCount],al                                ;[wbReadCount] = 09
   921 000000E1 BB0003                                          mov     bx,EBOOTFATBASE                                 ;BX = 0300
   922 000000E4 E85A00                                          call    ReadSector                                      ;read FAT into buffer
   923                                  ;
   924                                  ;       Get the starting cluster of the kernel program and target address.
   925                                  ;
   926 000000E7 8B451A                                          mov     ax,[di+26]                                      ;AX = starting cluster of file
   927 000000EA C41E[3D01]                                      les     bx,[wwLoadOffset]                               ;ES:BX = kernel load add (08f0:0100)
   928                                  ;
   929                                  ;       Read each program cluster into RAM.
   930                                  ;
   931 000000EE 50                      .70                     push    ax                                              ;save cluster nbr
   932 000000EF 83E802                                          sub     ax,2                                            ;AX = cluster nbr base 0
   933 000000F2 8A0E[0D00]                                      mov     cl,[cbClusterSectors]                           ;CL = sectors per cluster
   934 000000F6 880E[F601]                                      mov     [wbReadCount],cl                                ;save sectors to read
   935 000000FA 30ED                                            xor     ch,ch                                           ;CX = sectors per cluster
   936 000000FC F7E1                                            mul     cx                                              ;DX:AX = logical cluster sector
   937 000000FE 0306[F001]                                      add     ax,[wwOverhead]                                 ;AX = kernel sector nbr
   938 00000102 A3[F401]                                        mov     [wwLogicalSector],ax                            ;save logical sector nbr
   939 00000105 E83900                                          call    ReadSector                                      ;read sectors into ES:BX
   940                                  ;
   941                                  ;       Update buffer pointer for next cluster.
   942                                  ;
   943 00000108 A0[0D00]                                        mov     al,[cbClusterSectors]                           ;AL = sectors per cluster
   944 0000010B 30E4                                            xor     ah,ah                                           ;AX = sectors per cluster
   945 0000010D F726[0B00]                                      mul     word [cwSectorBytes]                            ;DX:AX = cluster bytes
   946 00000111 01C3                                            add     bx,ax                                           ;BX = next cluster target address
   947 00000113 58                                              pop     ax                                              ;AX = restore cluster nbr
   948                                  ;
   949                                  ;       Compute next cluster number.
   950                                  ;
   951 00000114 89C1                                            mov     cx,ax                                           ;CX = cluster nbr
   952 00000116 89C7                                            mov     di,ax                                           ;DI = cluster nbr
   953 00000118 D1E8                                            shr     ax,1                                            ;AX = cluster/2
   954 0000011A 89C2                                            mov     dx,ax                                           ;DX = cluster/2
   955 0000011C 01D0                                            add     ax,dx                                           ;AX = 2*(cluster/2)
   956 0000011E 01D0                                            add     ax,dx                                           ;AX = 3*(cluster/2)
   957 00000120 83E701                                          and     di,1                                            ;get low bit
   958 00000123 01C7                                            add     di,ax                                           ;add one if cluster is odd
   959 00000125 81C70003                                        add     di,EBOOTFATBASE                                 ;add FAT buffer address
   960 00000129 8B05                                            mov     ax,[di]                                         ;get cluster bytes
   961                                  ;
   962                                  ;       Adjust cluster nbr by 4 bits if cluster is odd; test for end of chain.
   963                                  ;
   964 0000012B F6C101                                          test    cl,1                                            ;is cluster odd?
   965 0000012E 7404                                            jz      .80                                             ;no, skip ahead
   966 00000130 B104                                            mov     cl,4                                            ;shift count
   967 00000132 D3E8                                            shr     ax,cl                                           ;shift nybble low
   968 00000134 25FF0F                  .80                     and     ax,0FFFh                                        ;mask for 24 bits; next cluster nbr
   969 00000137 3DFF0F                                          cmp     ax,0FFFh                                        ;end of chain?
   970 0000013A 75B2                                            jne     .70                                             ;no, continue
   971                                  ;
   972                                  ;       Transfer control to the operating system program.
   973                                  ;
   974 0000013C EA                                              db      0EAh                                            ;jmp seg:offset
   975 0000013D 0001                    wwLoadOffset            dw      0100h                                           ;kernel entry offset
   976 0000013F F008                    wwLoadSegment           dw      08F0h                                           ;kernel entry segment (computed)
   977                                  ;
   978                                  ;       Read [wbReadCount] disk sectors from [wwLogicalSector] into ES:BX.
   979                                  ;
   980 00000141 A1[1800]                ReadSector              mov     ax,[cwTrackSectors]                             ;AX = sectors per track
   981 00000144 F726[1A00]                                      mul     word [cwDiskSides]                              ;DX:AX = sectors per cylinder
   982 00000148 89C1                                            mov     cx,ax                                           ;CX = sectors per cylinder
   983 0000014A A1[F401]                                        mov     ax,[wwLogicalSector]                            ;DX:AX = logical sector
   984 0000014D F7F1                                            div     cx                                              ;AX = cylinder; DX = cyl sector
   985 0000014F A2[FB01]                                        mov     [wbTrack],al                                    ;[wbTrack] = cylinder
   986 00000152 89D0                                            mov     ax,dx                                           ;AX = cyl sector
   987 00000154 F636[1800]                                      div     byte [cbTrackSectors]                           ;AH = sector, AL = head
   988 00000158 FEC4                                            inc     ah                                              ;AH = sector (1,2,3,...)
   989 0000015A A3[F901]                                        mov     [wbHead],ax                                     ;[wbHead]= head, [wwSectorTrack]= sector
   990                                  ;
   991                                  ;       Try maxtries times to read sector.
   992                                  ;
   993 0000015D B90500                                          mov     cx,EBOOTMAXTRIES                                ;CX = 0005
   994 00000160 53                      .10                     push    bx                                              ;save buffer address
   995 00000161 51                                              push    cx                                              ;save retry count
   996 00000162 8B16[F801]                                      mov     dx,[wwDriveHead]                                ;DH = head, DL = drive
   997 00000166 8B0E[FA01]                                      mov     cx,[wwSectorTrack]                              ;CH = track, CL = sector
   998 0000016A A1[F601]                                        mov     ax,[wwReadCountCommand]                         ;AH = fn., AL = sector count
   999 0000016D CD13                                            int     EBIOSINTDISKETTE                                ;read sector
  1000 0000016F 59                                              pop     cx                                              ;restore retry count
  1001 00000170 5B                                              pop     bx                                              ;restore buffer address
  1002 00000171 7343                                            jnc     BootReturn                                      ;skip ahead if done
  1003 00000173 E2EB                                            loop    .10                                             ;retry
  1004                                  ;
  1005                                  ;       Handle disk error: convert to ASCII and store in error string.
  1006                                  ;
  1007 00000175 88E0                                            mov     al,ah                                           ;AL = bios error code
  1008 00000177 30E4                                            xor     ah,ah                                           ;AX = bios error code
  1009 00000179 B210                                            mov     dl,16                                           ;divisor for base 16
  1010 0000017B F6F2                                            div     dl                                              ;AL = hi order, AH = lo order
  1011 0000017D 0D3030                                          or      ax,03030h                                       ;apply ASCII zone bits
  1012 00000180 80FC3A                                          cmp     ah,03Ah                                         ;range test ASCII numeral
  1013 00000183 7203                                            jb      .20                                             ;continue if numeral
  1014 00000185 80C407                                          add     ah,7                                            ;adjust for ASCII 'A'-'F'
  1015 00000188 3C3A                    .20                     cmp     al,03Ah                                         ;range test ASCII numeral
  1016 0000018A 7203                                            jb      .30                                             ;continue if numeral
  1017 0000018C 80C407                                          add     ah,7                                            ;adjust for ASCII 'A'-'F'
  1018 0000018F A3[DD01]                .30                     mov     [wzErrorCode],ax                                ;store ASCII error code
  1019 00000192 BE[D201]                                        mov     si,czErrorMsg                                   ;error message address
  1020 00000195 E81200                  BootExit                call    BootPrint                                       ;display messge to console
  1021                                  ;
  1022                                  ;       Wait for a key press.
  1023                                  ;
  1024 00000198 B401                    .10                     mov     ah,EBIOSFNKEYSTATUS                             ;BIOS keyboard status function
  1025 0000019A CD16                                            int     EBIOSINTKEYBOARD                                ;get keyboard status
  1026 0000019C 7504                                            jnz     .20                                             ;continue if key pressed
  1027 0000019E FB                                              sti                                                     ;enable maskable interrupts
  1028 0000019F F4                                              hlt                                                     ;wait for interrupt
  1029 000001A0 EBF6                                            jmp     .10                                             ;repeat
  1030                                  ;
  1031                                  ;       Reset the system.
  1032                                  ;
  1033 000001A2 B0FE                    .20                     mov     al,EKEYBCMDRESET                                ;8042 pulse output port pin
  1034 000001A4 E664                                            out     EKEYBPORTSTAT,al                                ;drive B0 low to restart
  1035 000001A6 FB                      .30                     sti                                                     ;enable maskable interrupts
  1036 000001A7 F4                                              hlt                                                     ;stop until reset, int, nmi
  1037 000001A8 EBFC                                            jmp     .30                                             ;loop until restart kicks in
  1038                                  ;
  1039                                  ;       Display text message.
  1040                                  ;
  1041 000001AA FC                      BootPrint               cld                                                     ;forward strings
  1042 000001AB AC                      .10                     lodsb                                                   ;load next byte at DS:SI in AL
  1043 000001AC 84C0                                            test    al,al                                           ;end of string?
  1044 000001AE 7406                                            jz      BootReturn                                      ;... yes, exit our loop
  1045 000001B0 B40E                                            mov     ah,EBIOSFNTTYOUTPUT                             ;BIOS teletype function
  1046 000001B2 CD10                                            int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
  1047 000001B4 EBF5                                            jmp     .10                                             ;repeat until done
  1048 000001B6 C3                      BootReturn              ret                                                     ;return
  1049                                  ;-----------------------------------------------------------------------------------------------------------------------
  1050                                  ;
  1051                                  ;       Constants
  1052                                  ;
  1053                                  ;-----------------------------------------------------------------------------------------------------------------------
  1054 000001B7 90                                              align   2
  1055 000001B8 2000                    cwEntryLen              dw      32                                              ;length of directory entry
  1056 000001BA 4F5320202020202043-     cbKernelProgram         db      "OS      COM"                                   ;kernel program name
  1056 000001C3 4F4D               
  1057 000001C5 4C6F6164696E67204F-     czLoadMsg               db      "Loading OS",13,10,0                            ;loading message
  1057 000001CE 530D0A00           
  1058 000001D2 4469736B206572726F-     czErrorMsg              db      "Disk error "                                   ;error message
  1058 000001DB 7220               
  1059 000001DD 202000                  wzErrorCode             db      020h,020h,0                                     ;error code and null terminator
  1060 000001E0 4F53206D697373696E-     czNoKernel              db      "OS missing",0                                  ;missing kernel message
  1060 000001E9 6700               
  1061                                  ;-----------------------------------------------------------------------------------------------------------------------
  1062                                  ;
  1063                                  ;       Work Areas
  1064                                  ;
  1065                                  ;-----------------------------------------------------------------------------------------------------------------------
  1066 000001EB 90                                              align   2
  1067 000001EC 0000                    wwDirBuffer             dw      0                                               ;directory i/o buffer address
  1068 000001EE 0000                    wwEntriesLeft           dw      0                                               ;directory entries to search
  1069 000001F0 0000                    wwOverhead              dw      0                                               ;overhead sectors
  1070 000001F2 0000                    wwSectorEntries         dw      0                                               ;directory entries per sector
  1071 000001F4 0000                    wwLogicalSector         dw      0                                               ;current logical sector
  1072                                  wwReadCountCommand      equ     $                                               ;read count and command
  1073 000001F6 00                      wbReadCount             db      0                                               ;sectors to read
  1074 000001F7 02                      cbReadCommand           db      EBIOSFNREADSECTOR                               ;BIOS read disk fn code
  1075                                  wwDriveHead             equ     $                                               ;drive, head (word)
  1076 000001F8 00                      wbDrive                 db      0                                               ;drive
  1077 000001F9 00                      wbHead                  db      0                                               ;head
  1078                                  wwSectorTrack           equ     $                                               ;sector, track (word)
  1079 000001FA 00                                              db      0                                               ;sector
  1080 000001FB 00                      wbTrack                 db      0                                               ;track
  1081 000001FC 00<rept>                                        times   510-($-$$) db 0h                                ;zero fill to end of sector
  1082 000001FE 55AA                                            db      055h,0AAh                                       ;end of sector signature
  1083                                  %endif
  1084                                  %ifdef BUILDPREP
  1085                                  ;=======================================================================================================================
  1086                                  ;
  1087                                  ;       Diskette Preparation Code
  1088                                  ;
  1089                                  ;       This routine writes the OS boot sector code to a formatted floppy diskette. The diskette parameter table,
  1090                                  ;       which is located in the first 30 bytes of the boot sector is first read from the diskette and overlayed onto
  1091                                  ;       the OS bootstrap code so that the diskette format parameters are preserved.
  1092                                  ;
  1093                                  ;=======================================================================================================================
  1094                                  ;
  1095                                  ;       Query the user to insert a flopppy diskette and press enter or cancel.
  1096                                  ;
  1097                                  Prep                    mov     si,czPrepMsg10                                  ;starting message address
  1098                                                          call    BootPrint                                       ;display message
  1099                                  ;
  1100                                  ;       Exit if the Escape key is pressed or loop until Enter is pressed.
  1101                                  ;
  1102                                  .10                     mov     ah,EBIOSFNKEYSTATUS                             ;BIOS keyboard status function
  1103                                                          int     EBIOSINTKEYBOARD                                ;get keyboard status
  1104                                                          jnz     .20                                             ;continue if key pressed
  1105                                                          sti                                                     ;enable interrupts
  1106                                                          hlt                                                     ;wait for interrupt
  1107                                                          jmp     .10                                             ;repeat
  1108                                  .20                     cmp     al,EASCIIRETURN                                 ;Enter key pressed?
  1109                                                          je      .30                                             ;yes, branch
  1110                                                          cmp     al,EASCIIESCAPE                                 ;Escape key pressed?
  1111                                                          jne     .10                                             ;no, repeat
  1112                                                          jmp     .120                                            ;yes, exit program
  1113                                  ;
  1114                                  ;       Display writing-sector message and patch the JMP instruction.
  1115                                  ;
  1116                                  .30                     mov     si,czPrepMsg12                                  ;writing-sector message address
  1117                                                          call    BootPrint                                       ;display message
  1118                                                          mov     bx,Boot+1                                       ;address of JMP instruction operand
  1119                                                          mov     ax,01Bh                                         ;address past disk parameter table
  1120                                                          mov     [bx],ax                                         ;update the JMP instruction
  1121                                  ;
  1122                                  ;       Try to read the boot sector.
  1123                                  ;
  1124                                                          mov     cx,EBOOTMAXTRIES                                ;try up to five times
  1125                                  .40                     push    cx                                              ;save remaining tries
  1126                                                          mov     bx,wcPrepInBuf                                  ;input buffer address
  1127                                                          mov     dx,0                                            ;head zero, drive zero
  1128                                                          mov     cx,1                                            ;track zero, sector one
  1129                                                          mov     al,1                                            ;one sector
  1130                                                          mov     ah,EBIOSFNREADSECTOR                            ;read function
  1131                                                          int     EBIOSINTDISKETTE                                ;attempt the read
  1132                                                          pop     cx                                              ;restore remaining retries
  1133                                                          jnc     .50                                             ;skip ahead if successful
  1134                                                          loop    .40                                             ;try again
  1135                                                          mov     si,czPrepMsg20                                  ;read-error message address
  1136                                                          jmp     .70                                             ;branch to error routine
  1137                                  ;
  1138                                  ;       Copy diskette parms from input buffer to output buffer.
  1139                                  ;
  1140                                  .50                     mov     si,wcPrepInBuf                                  ;input buffer address
  1141                                                          add     si,11                                           ;skip over JMP and system ID
  1142                                                          mov     di,Boot                                         ;output buffer address
  1143                                                          add     di,11                                           ;skip over JMP and system ID
  1144                                                          mov     cx,19                                           ;length of diskette parameters
  1145                                                          cld                                                     ;forward string copies
  1146                                                          rep     movsb                                           ;copy diskette parameters
  1147                                  ;
  1148                                  ;       Try to write boot sector to diskette.
  1149                                  ;
  1150                                                          mov     cx,EBOOTMAXTRIES                                ;try up to five times
  1151                                  .60                     push    cx                                              ;save remaining tries
  1152                                                          mov     bx,Boot                                         ;output buffer address
  1153                                                          mov     dx,0                                            ;head zero, drive zero
  1154                                                          mov     cx,1                                            ;track zero, sector one
  1155                                                          mov     al,1                                            ;one sector
  1156                                                          mov     ah,EBIOSFNWRITESECTOR                           ;write function
  1157                                                          int     EBIOSINTDISKETTE                                ;attempt the write
  1158                                                          pop     cx                                              ;restore remaining retries
  1159                                                          jnc     .100                                            ;skip ahead if successful
  1160                                                          loop    .60                                             ;try again
  1161                                                          mov     si,czPrepMsg30                                  ;write-error message address
  1162                                  ;
  1163                                  ;       Convert the error code to ASCII and display the error message.
  1164                                  ;
  1165                                  .70                     push    ax                                              ;save error code
  1166                                                          mov     al,ah                                           ;copy error code
  1167                                                          mov     ah,0                                            ;AX = error code
  1168                                                          mov     dl,10h                                          ;hexadecimal divisor
  1169                                                          idiv    dl                                              ;AL = hi-order, AH = lo-order
  1170                                                          or      ax,03030h                                       ;add ASCII zone digits
  1171                                                          cmp     ah,03Ah                                         ;AH ASCII numeral?
  1172                                                          jb      .80                                             ;yes, continue
  1173                                                          add     ah,7                                            ;no, make ASCII 'A'-'F'
  1174                                  .80                     cmp     al,03Ah                                         ;ASCII numeral?
  1175                                                          jb      .90                                             ;yes, continue
  1176                                                          add     al,7                                            ;no, make ASCII
  1177                                  .90                     mov     [si+17],ax                                      ;put ASCII error code in message
  1178                                                          call    BootPrint                                       ;write error message
  1179                                                          pop     ax                                              ;restore error code
  1180                                  ;
  1181                                  ;       Display the completion message.
  1182                                  ;
  1183                                  .100                    mov     si,czPrepMsgOK                                  ;assume successful completion
  1184                                                          mov     al,ah                                           ;BIOS return code
  1185                                                          cmp     al,0                                            ;success?
  1186                                                          je      .110                                            ;yes, continue
  1187                                                          mov     si,czPrepMsgErr1                                ;disk parameter error message
  1188                                                          cmp     al,1                                            ;disk parameter error?
  1189                                                          je      .110                                            ;yes, continue
  1190                                                          mov     si,czPrepMsgErr2                                ;address mark not found message
  1191                                                          cmp     al,2                                            ;address mark not found?
  1192                                                          je      .110                                            ;yes, continue
  1193                                                          mov     si,czPrepMsgErr3                                ;protected disk message
  1194                                                          cmp     al,3                                            ;protected disk?
  1195                                                          je      .110                                            ;yes, continue
  1196                                                          mov     si,czPrepMsgErr6                                ;diskette removed message
  1197                                                          cmp     al,6                                            ;diskette removed?
  1198                                                          je      .110                                            ;yes, continue
  1199                                                          mov     si,czPrepMsgErr80                               ;drive timed out message
  1200                                                          cmp     al,80h                                          ;drive timed out?
  1201                                                          je      .110                                            ;yes, continue
  1202                                                          mov     si,czPrepMsgErrXX                               ;unknown error message
  1203                                  .110                    call    BootPrint                                       ;display result message
  1204                                  .120                    mov     ax,04C00H                                       ;terminate with zero result code
  1205                                                          int     021h                                            ;terminate DOS program
  1206                                                          ret                                                     ;return (should not execute)
  1207                                  ;-----------------------------------------------------------------------------------------------------------------------
  1208                                  ;
  1209                                  ;       Diskette Preparation Messages
  1210                                  ;
  1211                                  ;-----------------------------------------------------------------------------------------------------------------------
  1212                                  czPrepMsg10             db      13,10,"OS Boot-Diskette Preparation Program"
  1213                                                          db      13,10,"Copyright (C) 2010-2019 David J. Walling"
  1214                                                          db      13,10
  1215                                                          db      13,10,"This program overwrites the boot sector of a diskette with startup code that"
  1216                                                          db      13,10,"will load the operating system into memory when the computer is restarted."
  1217                                                          db      13,10,"To proceed, place a formatted diskette into drive A: and press the Enter key."
  1218                                                          db      13,10,"To exit this program without preparing a diskette, press the Escape key."
  1219                                                          db      13,10,0
  1220                                  czPrepMsg12             db      13,10,"Writing the boot sector to the diskette ..."
  1221                                                          db      13,10,0
  1222                                  czPrepMsg20             db      13,10,"The error-code .. was returned from the BIOS while reading from the disk."
  1223                                                          db      13,10,0
  1224                                  czPrepMsg30             db      13,10,"The error-code .. was returned from the BIOS while writing to the disk."
  1225                                                          db      13,10,0
  1226                                  czPrepMsgOK             db      13,10,"The boot-sector was written to the diskette. Before booting your computer with"
  1227                                                          db      13,10,"this diskette, make sure that the file OS.COM is copied onto the diskette."
  1228                                                          db      13,10,0
  1229                                  czPrepMsgErr1           db      13,10,"(01) Invalid Disk Parameter"
  1230                                                          db      13,10,"This is an internal error caused by an invalid value being passed to a system"
  1231                                                          db      13,10,"function. The OSBOOT.COM file may be corrupt. Copy or download the file again"
  1232                                                          db      13,10,"and retry."
  1233                                                          db      13,10,0
  1234                                  czPrepMsgErr2           db      13,10,"(02) Address Mark Not Found"
  1235                                                          db      13,10,"This error indicates a physical problem with the floppy diskette. Please retry"
  1236                                                          db      13,10,"using another diskette."
  1237                                                          db      13,10,0
  1238                                  czPrepMsgErr3           db      13,10,"(03) Protected Disk"
  1239                                                          db      13,10,"This error is usually caused by attempting to write to a write-protected disk."
  1240                                                          db      13,10,"Check the 'write-protect' setting on the disk or retry using using another disk."
  1241                                                          db      13,10,0
  1242                                  czPrepMsgErr6           db      13,10,"(06) Diskette Removed"
  1243                                                          db      13,10,"This error may indicate that the floppy diskette has been removed from the"
  1244                                                          db      13,10,"diskette drive. On some systems, this code may also occur if the diskette is"
  1245                                                          db      13,10,"'write protected.' Please verify that the diskette is not write-protected and"
  1246                                                          db      13,10,"is properly inserted in the diskette drive."
  1247                                                          db      13,10,0
  1248                                  czPrepMsgErr80          db      13,10,"(80) Drive Timed Out"
  1249                                                          db      13,10,"This error usually indicates that no diskette is in the diskette drive. Please"
  1250                                                          db      13,10,"make sure that the diskette is properly seated in the drive and retry."
  1251                                                          db      13,10,0
  1252                                  czPrepMsgErrXX          db      13,10,"(??) Unknown Error"
  1253                                                          db      13,10,"The error-code returned by the BIOS is not a recognized error. Please consult"
  1254                                                          db      13,10,"your computer's technical reference for a description of this error code."
  1255                                                          db      13,10,0
  1256                                  wcPrepInBuf             equ     $
  1257                                  %endif
  1258                                  %ifdef BUILDDISK
  1259                                  ;=======================================================================================================================
  1260                                  ;
  1261                                  ;       File Allocation Tables
  1262                                  ;
  1263                                  ;       The disk contains two copies of the File Allocation Table (FAT). On our disk, each FAT copy is 1200h bytes in
  1264                                  ;       length. Each FAT entry contains the logical number of the next cluster. The first two entries are reserved. Our
  1265                                  ;       OS.COM file here is 5400h bytes in length. The first 400h bytes are the 16-bit loader code. The remaining 5000h
  1266                                  ;       bytes are the 32-bit kernel code. Our disk parameter table defines a cluster as containing one sector and each
  1267                                  ;       sector having 200h bytes. Therefore, our FAT table must reserve 42 clusters for OS.COM. The clusters used by
  1268                                  ;       OS.COM, then, will be cluster 2 through 43. The entry for cluster 43 is set to "0fffh" to indicate that it is
  1269                                  ;       the last cluster in the chain.
  1270                                  ;
  1271                                  ;       Every three bytes encode two FAT entries as follows:
  1272                                  ;
  1273                                  ;       db      0abh,0cdh,0efh  ;even cluster: 0dabh, odd cluster: 0efch
  1274                                  ;
  1275                                  ;=======================================================================================================================
  1276                                  ;-----------------------------------------------------------------------------------------------------------------------
  1277                                  ;
  1278                                  ;       FAT copy 1                                                              @disk: 000200   @mem: n/a
  1279                                  ;
  1280                                  ;-----------------------------------------------------------------------------------------------------------------------
  1281                                  section                 fat1                                                    ;first copy of FAT
  1282                                                          db      0F0h,0FFh,0FFh, 003h,040h,000h
  1283                                                          db      005h,060h,000h, 007h,080h,000h
  1284                                                          db      009h,0A0h,000h, 00Bh,0C0h,000h
  1285                                                          db      00Dh,0E0h,000h, 00Fh,000h,001h
  1286                                                          db      011h,020h,001h, 013h,040h,001h
  1287                                                          db      015h,060h,001h, 017h,080h,001h
  1288                                                          db      019h,0A0h,001h, 01Bh,0C0h,001h
  1289                                                          db      01Dh,0E0h,001h, 01Fh,000h,002h
  1290                                                          db      021h,020h,002h, 023h,040h,002h
  1291                                                          db      025h,060h,002h, 027h,080h,002h
  1292                                                          db      029h,0A0h,002h, 02Bh,0F0h,0FFh
  1293                                                          times   (9*512)-($-$$) db 0                             ;zero fill to end of section
  1294                                  ;-----------------------------------------------------------------------------------------------------------------------
  1295                                  ;
  1296                                  ;       FAT copy 2                                                              @disk: 001400   @mem: n/a
  1297                                  ;
  1298                                  ;-----------------------------------------------------------------------------------------------------------------------
  1299                                  section                 fat2                                                    ;second copy of FAT
  1300                                                          db      0F0h,0FFh,0FFh, 003h,040h,000h
  1301                                                          db      005h,060h,000h, 007h,080h,000h
  1302                                                          db      009h,0A0h,000h, 00Bh,0C0h,000h
  1303                                                          db      00Dh,0E0h,000h, 00Fh,000h,001h
  1304                                                          db      011h,020h,001h, 013h,040h,001h
  1305                                                          db      015h,060h,001h, 017h,080h,001h
  1306                                                          db      019h,0A0h,001h, 01Bh,0C0h,001h
  1307                                                          db      01Dh,0E0h,001h, 01Fh,000h,002h
  1308                                                          db      021h,020h,002h, 023h,040h,002h
  1309                                                          db      025h,060h,002h, 027h,080h,002h
  1310                                                          db      029h,0A0h,002h, 02Bh,0F0h,0FFh
  1311                                                          times   (9*512)-($-$$) db 0                             ;zero fill to end of section
  1312                                  ;-----------------------------------------------------------------------------------------------------------------------
  1313                                  ;
  1314                                  ;       Diskette Directory                                                      @disk: 002600   @mem: n/a
  1315                                  ;
  1316                                  ;       The disk contains one copy of the diskette directory. Each directory entry is 32 bytes long. Our directory
  1317                                  ;       contains only one entry. Unused entries are set to all nulls. The directory immediately follows the second FAT
  1318                                  ;       copy.
  1319                                  ;
  1320                                  ;-----------------------------------------------------------------------------------------------------------------------
  1321                                  section                 dir                                                     ;diskette directory
  1322                                                          db      "OS      COM"                                   ;file name (must contain spaces)
  1323                                                          db      020h                                            ;attribute (archive bit set)
  1324                                                          times   10 db 0                                         ;unused
  1325                                                          dw      0h                                              ;time
  1326                                                          db      01000001b                                       ;mmm = 10 MOD 8 = 2; ddddd = 1
  1327                                                          db      01001001b                                       ;yyyyyyy = 2016-1980 = 36 = 24h; m/8 = 1
  1328                                                          dw      2                                               ;first cluster
  1329                                                          dd      05400h                                          ;file size
  1330                                                          times   (EBOOTDIRENTRIES*32)-($-$$) db 0h               ;zero fill to end of section
  1331                                  %endif
  1332                                  %ifdef BUILDCOM
  1333                                  ;=======================================================================================================================
  1334                                  ;
  1335                                  ;       OS.COM
  1336                                  ;
  1337                                  ;       The operating system file is assembled at the start of the data area of the floppy disk image, which
  1338                                  ;       immediately follows the directory. This corresponds to logical cluster 2, even though the physical address of
  1339                                  ;       this sector on the disk varies depending on the disk type. The os.com file consists of two parts, the OS loader
  1340                                  ;       and the OS kernel. The Loader is 16-bit code that receives control directly from the boot sector code after the
  1341                                  ;       OS.COM file is loaded into memory. The kernel is 32-bit code that receives control after the Loader has
  1342                                  ;       initialized protected-mode tables and 32-bit interrupt handlers and switched the CPU into protected mode.
  1343                                  ;
  1344                                  ;       Our loader addressability is set up according to the following diagram.
  1345                                  ;
  1346                                  ;       SS -----------> 007b00  +-----------------------------------------------+ SS:0000
  1347                                  ;                               |  Boot Stack & Boot PSP (Unused)               |
  1348                                  ;                               |  256 = 100h bytes                             |
  1349                                  ;       SS:SP --------> 007c00  +-----------------------------------------------+ SS:0100  07b0:0100
  1350                                  ;                               |  Boot Sector (vstart=0100h)                   |
  1351                                  ;                               |  1 sector = 512 = 200h bytes                  |
  1352                                  ;                       007e00  +-----------------------------------------------+
  1353                                  ;                               |  File Allocation Table (FAT) I/O Buffer       |
  1354                                  ;                               |  9 x 512-byte sectors = 4,608 = 1200h bytes   |
  1355                                  ;                               |                                               |
  1356                                  ;       CS,DS,ES -----> 008f00  |  Loader PSP (Unused)                          | DS:0000
  1357                                  ;                               |                                               |
  1358                                  ;       CS:IP --------> 009000  +-----------------------------------------------+ DS:0100  08f0:0100
  1359                                  ;                               |  Loader Code                                  |
  1360                                  ;                               |  2 sectors = 1024 = 400h bytes                |
  1361                                  ;                       009400  +-----------------------------------------------+ DS:0500
  1362                                  ;
  1363                                  ;=======================================================================================================================
  1364                                  ;-----------------------------------------------------------------------------------------------------------------------
  1365                                  ;
  1366                                  ;       OS Loader                                                               @disk: 004200   @mem: 009000
  1367                                  ;
  1368                                  ;       This code is the operating system loader. It resides on the boot disk at the start of the data area, following
  1369                                  ;       the directory. The loader occupies several clusters that are mapped in the file allocation tables above.
  1370                                  ;       The loader executes 16-bit instructions in real mode. It performs several initialization functions such as
  1371                                  ;       determining whether the CPU and other resources are sufficient to run the operating system. If all minimum
  1372                                  ;       resources are present, the loader initializes protected mode tables, places the CPU into protected mode and
  1373                                  ;       starts the console task. Since the loader was called either from the bootstrap or as a .com file on the boot
  1374                                  ;       disk, we can assume that the initial IP is 0x100 and not perform any absolute address fix-ups on our segment
  1375                                  ;       registers.
  1376                                  ;
  1377                                  ;-----------------------------------------------------------------------------------------------------------------------
  1378                                                          cpu     8086                                            ;assume minimal CPU
  1379                                  section                 loader  vstart=0100h                                    ;use .COM compatible addressing
  1380                                                          bits    16                                              ;this is 16-bit code
  1381                                  Loader                  push    cs                                              ;use the code segment
  1382                                                          pop     ds                                              ;...as our data segment
  1383                                                          push    cs                                              ;use the code segment
  1384                                                          pop     es                                              ;...as our extra segment
  1385                                  ;
  1386                                  ;       Write a message to the console so we know we have our addressability established.
  1387                                  ;
  1388                                                          mov     si,czStartingMsg                                ;starting message
  1389                                                          call    PutTTYString                                    ;display loader message
  1390                                  ;
  1391                                  ;       Determine the CPU type, generally. Exit if the CPU is not at least an 80386.
  1392                                  ;
  1393                                                          call    GetCPUType                                      ;AL = cpu type
  1394                                                          mov     si,czCPUErrorMsg                                ;loader error message
  1395                                                          cmp     al,3                                            ;80386+?
  1396                                                          jb      LoaderExit                                      ;no, exit with error message
  1397                                                          cpu     386                                             ;allow 80386 instructions
  1398                                                          mov     si,czCPUOKMsg                                   ;cpu ok message
  1399                                                          call    PutTTYString                                    ;display message
  1400                                  ;
  1401                                  ;       Fixup the GDT descriptor for the current (loader) code segment.
  1402                                  ;
  1403                                                          mov     si,EKRNCODESRCADR                               ;GDT offset
  1404                                                          mov     ax,cs                                           ;AX:SI = gdt source
  1405                                                          rol     ax,4                                            ;AX = phys addr bits 11-0,15-12
  1406                                                          mov     cl,al                                           ;CL = phys addr bits 3-0,15-12
  1407                                                          and     al,0F0h                                         ;AL = phys addr bits 11-0
  1408                                                          and     cl,00Fh                                         ;CL = phys addr bits 15-12
  1409                                                          mov     word [si+EGDTLOADERCODE+2],ax                   ;lo-order loader code (0-15)
  1410                                                          mov     byte [si+EGDTLOADERCODE+4],cl                   ;lo-order loader code (16-23)
  1411                                                          mov     si,czGDTOKMsg                                   ;GDT prepared message
  1412                                                          call    PutTTYString                                    ;display message
  1413                                  ;
  1414                                  ;       Move the 32-bit kernel to its appropriate memory location.
  1415                                  ;
  1416                                                          push    EKRNCODESEG                                     ;use kernel code segment ...
  1417                                                          pop     es                                              ;... as target segment
  1418                                                          xor     di,di                                           ;ES:DI = target address
  1419                                                          mov     si,EKRNCODESRCADR                               ;DS:SI = source address
  1420                                                          mov     cx,EKRNCODELEN                                  ;CX = kernel size
  1421                                                          cld                                                     ;forward strings
  1422                                                          rep     movsb                                           ;copy kernel image
  1423                                                          mov     si,czKernelLoadedMsg                            ;kernel moved message
  1424                                                          call    PutTTYString                                    ;display message
  1425                                  ;
  1426                                  ;       Switch to protected mode.
  1427                                  ;
  1428                                                          xor     si,si                                           ;ES:SI = gdt addr
  1429                                                          mov     ss,si                                           ;protected mode ss
  1430                                                          mov     sp,EKRNCODEBASE                                 ;initial stack immediate before code
  1431                                                          mov     ah,EBIOSFNINITPROTMODE                          ;initialize protected mode fn.
  1432                                                          mov     bx,02028h                                       ;BH,BL = IRQ int bases
  1433                                                          mov     dx,001Fh                                        ;outer delay loop count
  1434                                  .10                     mov     cx,0FFFFh                                       ;inner delay loop count
  1435                                                          loop    $                                               ;wait out pending interrupts
  1436                                                          dec     dx                                              ;restore outer loop count
  1437                                                          jnz     .10                                             ;continue outer loop
  1438                                                          int     EBIOSINTMISC                                    ;call BIOS to set protected mode
  1439                                  ;
  1440                                  ;       Enable hardware and maskable interrupts.
  1441                                  ;
  1442                                                          xor     al,al                                           ;enable all registers code
  1443                                                          out     EPICPORTPRI1,al                                 ;enable all primary 8259A ints
  1444                                                          out     EPICPORTSEC1,al                                 ;enable all secondary 8259A ints
  1445                                                          sti                                                     ;enable maskable interrupts
  1446                                  ;
  1447                                  ;       Load the Task State Segment (TSS) and Local Descriptor Table (LDT) registers and jump to the initial task.
  1448                                  ;
  1449                                                          ltr     [cs:cwLoaderTSS]                                ;load task register
  1450                                                          lldt    [cs:cwLoaderLDT]                                ;load local descriptor table register
  1451                                                          jmp     EGDTCONSOLETSS:0                                ;jump to task state segment selector
  1452                                  ;-----------------------------------------------------------------------------------------------------------------------
  1453                                  ;
  1454                                  ;       Routine:        LoaderExit
  1455                                  ;
  1456                                  ;       Description:    This routine displays the message at DS:SI, waits for a keypress and resets the system.
  1457                                  ;
  1458                                  ;       In:             DS:SI   string address
  1459                                  ;
  1460                                  ;-----------------------------------------------------------------------------------------------------------------------
  1461                                  LoaderExit              call    PutTTYString                                    ;display error message
  1462                                  ;
  1463                                  ;       Now we want to wait for a keypress. We can use a keyboard interrupt function for this (INT 16h, AH=0).
  1464                                  ;       However, some hypervisor BIOS implementations have been seen to implement the "wait" as simply a fast
  1465                                  ;       iteration of the keyboard status function call (INT 16h, AH=1), causing a max CPU condition. So, instead,
  1466                                  ;       we will use the keyboard status call and iterate over a halt (HLT) instruction until a key is pressed.
  1467                                  ;       The STI instruction enables maskable interrupts, including the keyboard. The CPU assures that the
  1468                                  ;       instruction immediately following STI will be executed before any interrupt is serviced.
  1469                                  ;
  1470                                  .30                     mov     ah,EBIOSFNKEYSTATUS                             ;keyboard status function
  1471                                                          int     EBIOSINTKEYBOARD                                ;call BIOS keyboard interrupt
  1472                                                          jnz     .40                                             ;exit if key pressed
  1473                                                          sti                                                     ;enable maskable interrupts
  1474                                                          hlt                                                     ;wait for interrupt
  1475                                                          jmp     .30                                             ;repeat until keypress
  1476                                  ;
  1477                                  ;       Now that a key has been pressed, we signal the system to restart by driving the B0 line on the 8042
  1478                                  ;       keyboard controller low (OUT 64h,0feh). The restart may take some microseconds to kick in, so we issue
  1479                                  ;       HLT until the system resets.
  1480                                  ;
  1481                                  .40                     mov     al,EKEYBCMDRESET                                ;8042 pulse output port pin
  1482                                                          out     EKEYBPORTSTAT,al                                ;drive B0 low to restart
  1483                                  .50                     sti                                                     ;enable maskable interrupts
  1484                                                          hlt                                                     ;stop until reset, int, nmi
  1485                                                          jmp     .50                                             ;loop until restart kicks in
  1486                                  ;-----------------------------------------------------------------------------------------------------------------------
  1487                                  ;
  1488                                  ;       Routine:        GetCPUType
  1489                                  ;
  1490                                  ;       Description:    The loader needs only to determine that the cpu is at least an 80386 or an equivalent. Note that
  1491                                  ;                       the CPUID instruction was not introduced until the SL-enhanced 80486 and Pentium processors, so
  1492                                  ;                       to distinguish whether we have at least an 80386, other means must be used.
  1493                                  ;
  1494                                  ;       Out:            AX      0 = 808x, v20, etc.
  1495                                  ;                               1 = 80186
  1496                                  ;                               2 = 80286
  1497                                  ;                               3 = 80386
  1498                                  ;
  1499                                  ;-----------------------------------------------------------------------------------------------------------------------
  1500                                  GetCPUType              mov     al,1                                            ;AL = 1
  1501                                                          mov     cl,32                                           ;shift count
  1502                                                          shr     al,cl                                           ;try a 32-bit shift
  1503                                                          or      al,al                                           ;did the shift happen?
  1504                                                          jz      .10                                             ;yes, cpu is 808x, v20, etc.
  1505                                                          cpu     186
  1506                                                          push    sp                                              ;save stack pointer
  1507                                                          pop     cx                                              ;...into cx
  1508                                                          cmp     cx,sp                                           ;did sp decrement before push?
  1509                                                          jne     .10                                             ;yes, cpu is 80186
  1510                                                          cpu     286
  1511                                                          inc     ax                                              ;AX = 2
  1512                                                          sgdt    [cbLoaderGDT]                                   ;store gdt reg in work area
  1513                                                          mov     cl,[cbLoaderGDTHiByte]                          ;CL = hi-order byte
  1514                                                          inc     cl                                              ;was hi-byte of GDTR 0xff?
  1515                                                          jz      .10                                             ;yes, cpu is 80286
  1516                                                          inc     ax                                              ;AX = 3
  1517                                  .10                     ret                                                     ;return
  1518                                  ;-----------------------------------------------------------------------------------------------------------------------
  1519                                  ;
  1520                                  ;       Routine:        PutTTYString
  1521                                  ;
  1522                                  ;       Description:    This routine sends a NUL-terminated string of characters to the TTY output device. We use the
  1523                                  ;                       TTY output function of the BIOS video interrupt, passing the address of the string in DS:SI
  1524                                  ;                       and the BIOS teletype function code in AH. After a return from the BIOS interrupt, we repeat
  1525                                  ;                       for the next string character until a NUL is found. Note that we clear the direction flag (DF)
  1526                                  ;                       with CLD before the first LODSB. The direction flag is not guaranteed to be preserved between
  1527                                  ;                       calls within the OS. However, the "int" instruction does store the EFLAGS register on the
  1528                                  ;                       stack and restores it on return. Therefore, clearing the direction flag before subsequent calls
  1529                                  ;                       to LODSB is not needed.
  1530                                  ;
  1531                                  ;       In:             DS:SI   address of string
  1532                                  ;
  1533                                  ;       Out:            DF      0
  1534                                  ;                       ZF      1
  1535                                  ;                       AL      0
  1536                                  ;
  1537                                  ;-----------------------------------------------------------------------------------------------------------------------
  1538                                  PutTTYString            cld                                                     ;forward strings
  1539                                  .10                     lodsb                                                   ;load next byte at DS:SI in AL
  1540                                                          test    al,al                                           ;end of string?
  1541                                                          jz      .20                                             ;... yes, exit our loop
  1542                                                          mov     ah,EBIOSFNTTYOUTPUT                             ;BIOS teletype function
  1543                                                          int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
  1544                                                          jmp     .10                                             ;repeat until done
  1545                                  .20                     ret                                                     ;return
  1546                                  ;-----------------------------------------------------------------------------------------------------------------------
  1547                                  ;
  1548                                  ;       Loader Data
  1549                                  ;
  1550                                  ;       The loader data is updated to include constants defining the initial (Loader) TSS and LDT selectors in the
  1551                                  ;       GDT, a work area to build the GDTR, and additional text messages.
  1552                                  ;
  1553                                  ;-----------------------------------------------------------------------------------------------------------------------
  1554                                                          align   2
  1555                                  cwLoaderLDT             dw      EGDTLOADERLDT                                   ;loader local descriptor table selector
  1556                                  cwLoaderTSS             dw      EGDTLOADERTSS                                   ;loader task state segment selector
  1557                                  cbLoaderGDT             times   5 db 0                                          ;6-byte GDTR work area
  1558                                  cbLoaderGDTHiByte       db      0                                               ;hi-order byte
  1559                                  czCPUErrorMsg           db      "The operating system requires an i386 or later processor.",13,10
  1560                                                          db      "Please press any key to restart the computer.",13,10,0
  1561                                  czCPUOKMsg              db      "CPU OK",13,10,0                                ;CPU level ok message
  1562                                  czGDTOKMsg              db      "GDT prepared",13,10,0                          ;global descriptor table ok message
  1563                                  czKernelLoadedMsg       db      "Kernel loaded",13,10,0                         ;kernel loaded message
  1564                                  czStartingMsg           db      "Starting OS",13,10,0                           ;starting message
  1565                                                          times   1024-($-$$) db 0h                               ;zero fill to end of sector
  1566                                  ;=======================================================================================================================
  1567                                  ;
  1568                                  ;       OS Kernel                                                               @disk: 004600   @mem: 001000
  1569                                  ;
  1570                                  ;       This code is the operating system kernel. It resides on the boot disk image as part of the OS.COM file,
  1571                                  ;       following the 16-bit loader code above. The Kernel executes only 32-bit code in protected mode and contains one
  1572                                  ;       task, the Console, which performs a loop accepting user input from external devices (keyboard, etc.), processes
  1573                                  ;       commands and displays ouput to video memory. The Kernel also includes a library of system functions accessible
  1574                                  ;       through software interrupt 58 (30h). Finally, the Kernel provides CPU and hardware interrupt handlers.
  1575                                  ;
  1576                                  ;=======================================================================================================================
  1577                                  ;=======================================================================================================================
  1578                                  ;
  1579                                  ;       Kernel Tables
  1580                                  ;
  1581                                  ;=======================================================================================================================
  1582                                  ;-----------------------------------------------------------------------------------------------------------------------
  1583                                  ;
  1584                                  ;       Global Descriptor Table                                                 @disk: 004600   @mem: 001000
  1585                                  ;
  1586                                  ;       The Global Descriptor Table (GDT) consists of eight-byte descriptors that define reserved memory areas. The
  1587                                  ;       first descriptor must be all nulls.
  1588                                  ;
  1589                                  ;       6   5         4         3         2         1         0
  1590                                  ;       3210987654321098765432109876543210987654321098765432109876543210
  1591                                  ;       ----------------------------------------------------------------
  1592                                  ;       h......hffffmmmma......ab......................bn..............n
  1593                                  ;
  1594                                  ;       h......h                                                                hi-order base address (bits 24-31)
  1595                                  ;               ffff                                                            flags
  1596                                  ;                   mmmm                                                        hi-order limit (bits 16-19)
  1597                                  ;                       a......a                                                access
  1598                                  ;                               b......................b                        lo-order base address (bits 0-23)
  1599                                  ;                                                       n..............n        lo-order limit (bits 0-15)
  1600                                  ;
  1601                                  ;       00000000                                                                all areas have base addresses below 2^24
  1602                                  ;               0...                                                            single-byte size granularity
  1603                                  ;               1...                                                            4-kilobyte size granularity
  1604                                  ;               .0..                                                            16-bit default for code segments
  1605                                  ;               .1..                                                            32-bit default for code segments
  1606                                  ;               ..0.                                                            intel-reserved; should be zero
  1607                                  ;               ...0                                                            available for operating system use
  1608                                  ;                   0000                                                        segment is less than 2^16 in size
  1609                                  ;                   1111                                                        segment is greater than 2^24-2 in size
  1610                                  ;                       1.......                                                segment is present in memory
  1611                                  ;                       .00.....                                                segment is of privilege level 0
  1612                                  ;                       ...0....                                                segment is of system or gate type
  1613                                  ;                       ...00010                                                local decriptor table (LDT)
  1614                                  ;                       ...01001                                                task state segment (TSS) available
  1615                                  ;                       ...01011                                                task state segment (TSS) busy
  1616                                  ;                       ...10...                                                data segment
  1617                                  ;                       ...10011                                                writable data (accessed)
  1618                                  ;                       ...11...                                                code segment
  1619                                  ;                       ...11011                                                readable non-conforming code (accessed)
  1620                                  ;
  1621                                  ;-----------------------------------------------------------------------------------------------------------------------
  1622                                  section                 gdt                                                     ;global descriptor table
  1623                                                          dq      0000000000000000h                               ;00 required null selector
  1624                                                          dq      00409300100007FFh                               ;08 2KB  writable data  (GDT alias)
  1625                                                          dq      00409300180007FFh                               ;10 2KB  writable data  (IDT alias)
  1626                                                          dq      00CF93000000FFFFh                               ;18 4GB  writable data  (kernel)     DS:
  1627                                                          dq      0040930B80000FFFh                               ;20 4KB  writable data  (CGA)        ES:
  1628                                                          dq      0040930000000FFFh                               ;28 4KB  writable stack (Loader)     SS:
  1629                                                          dq      00009B000000FFFFh                               ;30 64KB readable code  (loader)     CS:
  1630                                                          dq      00009BFF0000FFFFh                               ;38 64KB readable code  (BIOS)
  1631                                                          dq      004093000400FFFFh                               ;40 64KB writable data  (BIOS)
  1632                                                          dq      00409B0020001FFFh                               ;48 8KB  readable code  (kernel)
  1633                                                          dq      004082000F00007Fh                               ;50 80B  writable LDT   (loader)
  1634                                                          dq      004089000F80007Fh                               ;58 80B  writable TSS   (loader)
  1635                                                          dq      004082004700007Fh                               ;60 80B  writable LDT   (console)
  1636                                                          dq      004089004780007Fh                               ;88 80B  writable TSS   (console)
  1637                                                          times   2048-($-$$) db 0h                               ;zero fill to end of section
  1638                                  ;-----------------------------------------------------------------------------------------------------------------------
  1639                                  ;
  1640                                  ;       Interrupt Descriptor Table                                              @disk: 004e00   @mem: 001800
  1641                                  ;
  1642                                  ;       The Interrupt Descriptor Table (IDT) consists of one eight-byte entry (descriptor) for each interrupt. The
  1643                                  ;       descriptors here are of two kinds, interrupt gates and trap gates. The "mint" and "mtrap" macros define the
  1644                                  ;       descriptors, taking only the name of the entry point for the code handling the interrupt.
  1645                                  ;
  1646                                  ;       6   5         4         3         2         1         0
  1647                                  ;       3210987654321098765432109876543210987654321098765432109876543210
  1648                                  ;       ----------------------------------------------------------------
  1649                                  ;       h..............hPzzStttt00000000S..............Sl..............l
  1650                                  ;
  1651                                  ;       h...h   high-order offset (bits 16-31)
  1652                                  ;       P       present (0=unused interrupt)
  1653                                  ;       zz      descriptor privilege level
  1654                                  ;       S       storage segment (must be zero for IDT)
  1655                                  ;       tttt    type: 0101=task, 1110=int, 1111=trap
  1656                                  ;       S...S   handling code selector in GDT
  1657                                  ;       l...l   lo-order offset (bits 0-15)
  1658                                  ;
  1659                                  ;-----------------------------------------------------------------------------------------------------------------------
  1660                                  section                 idt                                                     ;interrupt descriptor table
  1661                                                          mtrap   dividebyzero                                    ;00 divide by zero
  1662                                                          mtrap   singlestep                                      ;01 single step
  1663                                                          mtrap   nmi                                             ;02 non-maskable
  1664                                                          mtrap   break                                           ;03 break
  1665                                                          mtrap   into                                            ;04 into
  1666                                                          mtrap   bounds                                          ;05 bounds
  1667                                                          mtrap   badopcode                                       ;06 bad op code
  1668                                                          mtrap   nocoproc                                        ;07 no coprocessor
  1669                                                          mtrap   doublefault                                     ;08 double-fault
  1670                                                          mtrap   operand                                         ;09 operand
  1671                                                          mtrap   badtss                                          ;0a bad TSS
  1672                                                          mtrap   notpresent                                      ;0b not-present
  1673                                                          mtrap   stacklimit                                      ;0c stack limit
  1674                                                          mtrap   protection                                      ;0d general protection fault
  1675                                                          mtrap   int14                                           ;0e (reserved)
  1676                                                          mtrap   int15                                           ;0f (reserved)
  1677                                                          mtrap   coproccalc                                      ;10 (reserved)
  1678                                                          mtrap   int17                                           ;11 (reserved)
  1679                                                          mtrap   int18                                           ;12 (reserved)
  1680                                                          mtrap   int19                                           ;13 (reserved)
  1681                                                          mtrap   int20                                           ;14 (reserved)
  1682                                                          mtrap   int21                                           ;15 (reserved)
  1683                                                          mtrap   int22                                           ;16 (reserved)
  1684                                                          mtrap   int23                                           ;17 (reserved)
  1685                                                          mtrap   int24                                           ;18 (reserved)
  1686                                                          mtrap   int25                                           ;19 (reserved)
  1687                                                          mtrap   int26                                           ;1a (reserved)
  1688                                                          mtrap   int27                                           ;1b (reserved)
  1689                                                          mtrap   int28                                           ;1c (reserved)
  1690                                                          mtrap   int29                                           ;1d (reserved)
  1691                                                          mtrap   int30                                           ;1e (reserved)
  1692                                                          mtrap   int31                                           ;1f (reserved)
  1693                                                          mint    clocktick                                       ;20 IRQ0 clock tick
  1694                                                          mint    keyboard                                        ;21 IRQ1 keyboard
  1695                                                          mint    iochannel                                       ;22 IRQ2 second 8259A cascade
  1696                                                          mint    com2                                            ;23 IRQ3 com2
  1697                                                          mint    com1                                            ;24 IRQ4 com1
  1698                                                          mint    lpt2                                            ;25 IRQ5 lpt2
  1699                                                          mint    diskette                                        ;26 IRQ6 diskette
  1700                                                          mint    lpt1                                            ;27 IRQ7 lpt1
  1701                                                          mint    rtclock                                         ;28 IRQ8 real-time clock
  1702                                                          mint    retrace                                         ;29 IRQ9 CGA vertical retrace
  1703                                                          mint    irq10                                           ;2a IRQA (reserved)
  1704                                                          mint    irq11                                           ;2b IRQB (reserved)
  1705                                                          mint    ps2mouse                                        ;2c IRQC ps/2 mouse
  1706                                                          mint    coprocessor                                     ;2d IRQD coprocessor
  1707                                                          mint    fixeddisk                                       ;2e IRQE fixed disk
  1708                                                          mint    irq15                                           ;2f IRQF (reserved)
  1709                                                          mtrap   svc                                             ;30 OS services
  1710                                                          times   2048-($-$$) db 0h                               ;zero fill to end of section
  1711                                  ;=======================================================================================================================
  1712                                  ;
  1713                                  ;       Interrupt Handlers                                                      @disk: 005600   @mem:  002000
  1714                                  ;
  1715                                  ;       Interrupt handlers are 32-bit routines that receive control either in response to events or by direct
  1716                                  ;       invocation from other kernel code. The interrupt handlers are of three basic types. CPU interrupts occur when a
  1717                                  ;       CPU exception is detected. Hardware interrupts occur when an external device (timer, keyboard, disk, etc.)
  1718                                  ;       signals the CPU on an interrupt request line (IRQ). Software interrupts occur when directly called by other code
  1719                                  ;       using the INT instruction. Each interrupt handler routine is defined by using our "menter" macro, which simply
  1720                                  ;       establishes a label defining the offset address of the entry point from the start of the kernel section. This
  1721                                  ;       label is referenced in the "mint" and "mtrap" macros found in the IDT to specify the address of the handlers.
  1722                                  ;
  1723                                  ;=======================================================================================================================
  1724                                  section                 kernel  vstart=0h                                       ;data offsets relative to 0
  1725                                                          cpu     386                                             ;allow 80386 instructions
  1726                                                          bits    32                                              ;this is 32-bit code
  1727                                  ;=======================================================================================================================
  1728                                  ;
  1729                                  ;       CPU Interrupt Handlers
  1730                                  ;
  1731                                  ;       The first 32 entries in the Interrupt Descriptor Table are reserved for use by CPU interrupts. The handling
  1732                                  ;       of these interrupts is expanded here to display the contents of registers at the time of the interrupt.
  1733                                  ;
  1734                                  ;=======================================================================================================================
  1735                                  ;-----------------------------------------------------------------------------------------------------------------------
  1736                                  ;
  1737                                  ;       INT0    Divide By Zero
  1738                                  ;
  1739                                  ;-----------------------------------------------------------------------------------------------------------------------
  1740                                                          menter  dividebyzero                                    ;divide by zero
  1741                                                          push    0                                               ;store interrupt nbr
  1742                                                          push    czIntDivideByZero                               ;store message offset
  1743                                                          jmp     ReportInterrupt                                 ;report interrupt
  1744                                  ;-----------------------------------------------------------------------------------------------------------------------
  1745                                  ;
  1746                                  ;       INT1    Single Step
  1747                                  ;
  1748                                  ;-----------------------------------------------------------------------------------------------------------------------
  1749                                                          menter  singlestep                                      ;single step
  1750                                                          push    1                                               ;store interrupt nbr
  1751                                                          push    czIntSingleStep                                 ;store message offset
  1752                                                          jmp     ReportInterrupt                                 ;report interrupt
  1753                                  ;-----------------------------------------------------------------------------------------------------------------------
  1754                                  ;
  1755                                  ;       INT2    Non-Maskable Interrupt
  1756                                  ;
  1757                                  ;-----------------------------------------------------------------------------------------------------------------------
  1758                                                          menter  nmi                                             ;non-maskable
  1759                                                          push    2                                               ;store interrupt nbr
  1760                                                          push    czIntNonMaskable                                ;store message offset
  1761                                                          jmp     ReportInterrupt                                 ;report interrupt
  1762                                  ;-----------------------------------------------------------------------------------------------------------------------
  1763                                  ;
  1764                                  ;       INT3    Break
  1765                                  ;
  1766                                  ;-----------------------------------------------------------------------------------------------------------------------
  1767                                                          menter  break                                           ;break
  1768                                                          push    3                                               ;store interrupt nbr
  1769                                                          push    czIntBreak                                      ;store message offset
  1770                                                          jmp     ReportInterrupt                                 ;report interrupt
  1771                                  ;-----------------------------------------------------------------------------------------------------------------------
  1772                                  ;
  1773                                  ;       INT4    Into
  1774                                  ;
  1775                                  ;-----------------------------------------------------------------------------------------------------------------------
  1776                                                          menter  into                                            ;into
  1777                                                          push    4                                               ;store interrupt nbr
  1778                                                          push    czIntInto                                       ;store message offset
  1779                                                          jmp     ReportInterrupt                                 ;report interrupt
  1780                                  ;-----------------------------------------------------------------------------------------------------------------------
  1781                                  ;
  1782                                  ;       INT5    Bounds
  1783                                  ;
  1784                                  ;-----------------------------------------------------------------------------------------------------------------------
  1785                                                          menter  bounds                                          ;bounds
  1786                                                          push    5                                               ;store interrupt nbr
  1787                                                          push    czIntBounds                                     ;store message offset
  1788                                                          jmp     ReportInterrupt                                 ;report interrupt
  1789                                  ;-----------------------------------------------------------------------------------------------------------------------
  1790                                  ;
  1791                                  ;       INT6    Bad Operation Code
  1792                                  ;
  1793                                  ;-----------------------------------------------------------------------------------------------------------------------
  1794                                                          menter  badopcode                                       ;bad opcode interrupt
  1795                                                          push    6                                               ;store interrupt nbr
  1796                                                          push    czIntBadOpCode                                  ;store message offset
  1797                                                          jmp     ReportInterrupt                                 ;report interrupt
  1798                                  ;-----------------------------------------------------------------------------------------------------------------------
  1799                                  ;
  1800                                  ;       INT7    No Coprocessor
  1801                                  ;
  1802                                  ;-----------------------------------------------------------------------------------------------------------------------
  1803                                                          menter  nocoproc                                        ;no coprocessor interrupt
  1804                                                          push    7                                               ;store interrupt nbr
  1805                                                          push    czIntNoCoprocessor                              ;store message offset
  1806                                                          jmp     ReportInterrupt                                 ;report interrupt
  1807                                  ;-----------------------------------------------------------------------------------------------------------------------
  1808                                  ;
  1809                                  ;       INT8    Double Fault
  1810                                  ;
  1811                                  ;-----------------------------------------------------------------------------------------------------------------------
  1812                                                          menter  doublefault                                     ;doublefault interrupt
  1813                                                          push    8                                               ;store interrupt nbr
  1814                                                          push    czIntDoubleFault                                ;store message offset
  1815                                                          jmp     ReportInterrupt                                 ;report interrupt
  1816                                  ;-----------------------------------------------------------------------------------------------------------------------
  1817                                  ;
  1818                                  ;       INT9    Operand
  1819                                  ;
  1820                                  ;-----------------------------------------------------------------------------------------------------------------------
  1821                                                          menter  operand                                         ;operand interrupt
  1822                                                          push    9                                               ;store interrupt nbr
  1823                                                          push    czIntOperand                                    ;store message offset
  1824                                                          jmp     ReportInterrupt                                 ;report interrupt
  1825                                  ;-----------------------------------------------------------------------------------------------------------------------
  1826                                  ;
  1827                                  ;       INT10   Bad Task State Segment
  1828                                  ;
  1829                                  ;-----------------------------------------------------------------------------------------------------------------------
  1830                                                          menter  badtss                                          ;bad TSS interrupt
  1831                                                          push    10                                              ;store interrupt nbr
  1832                                                          push    czIntBadTSS                                     ;store message offset
  1833                                                          jmp     ReportInterrupt                                 ;report interrupt
  1834                                  ;-----------------------------------------------------------------------------------------------------------------------
  1835                                  ;
  1836                                  ;       INT11   Not Present
  1837                                  ;
  1838                                  ;-----------------------------------------------------------------------------------------------------------------------
  1839                                                          menter  notpresent                                      ;not present interrupt
  1840                                                          push    11                                              ;store interrupt nbr
  1841                                                          push    czIntNotPresent                                 ;store message offset
  1842                                                          jmp     ReportInterrupt                                 ;report interrupt
  1843                                  ;-----------------------------------------------------------------------------------------------------------------------
  1844                                  ;
  1845                                  ;       INT12   Stack Limit
  1846                                  ;
  1847                                  ;-----------------------------------------------------------------------------------------------------------------------
  1848                                                          menter  stacklimit                                      ;stack limit interrupt
  1849                                                          push    12                                              ;store interrupt nbr
  1850                                                          push    czIntStackLimit                                 ;store message offset
  1851                                                          jmp     ReportInterrupt                                 ;report interrupt
  1852                                  ;-----------------------------------------------------------------------------------------------------------------------
  1853                                  ;
  1854                                  ;       INT13   General Protection Fault
  1855                                  ;
  1856                                  ;-----------------------------------------------------------------------------------------------------------------------
  1857                                                          menter  protection                                      ;protection fault interrupt
  1858                                                          push    13                                              ;store interrupt nbr
  1859                                                          push    czIntProtection                                 ;store message offset
  1860                                                          jmp     ReportInterrupt                                 ;report interrupt
  1861                                  ;-----------------------------------------------------------------------------------------------------------------------
  1862                                  ;
  1863                                  ;       INT14   Reserved
  1864                                  ;
  1865                                  ;-----------------------------------------------------------------------------------------------------------------------
  1866                                                          menter  int14                                           ;(reserved)
  1867                                                          push    14                                              ;store interrupt nbr
  1868                                                          push    czIntReserved                                   ;store message offset
  1869                                                          jmp     ReportInterrupt                                 ;report interrupt
  1870                                  ;-----------------------------------------------------------------------------------------------------------------------
  1871                                  ;
  1872                                  ;       INT15   Reserved
  1873                                  ;
  1874                                  ;-----------------------------------------------------------------------------------------------------------------------
  1875                                                          menter  int15                                           ;(reserved)
  1876                                                          push    15                                              ;store interrupt nbr
  1877                                                          push    czIntReserved                                   ;store message offset
  1878                                                          jmp     ReportInterrupt                                 ;report interrupt
  1879                                  ;-----------------------------------------------------------------------------------------------------------------------
  1880                                  ;
  1881                                  ;       INT16   Coprocessor Calculation
  1882                                  ;
  1883                                  ;-----------------------------------------------------------------------------------------------------------------------
  1884                                                          menter  coproccalc                                      ;coprocessor calculation
  1885                                                          push    16                                              ;store interrupt nbr
  1886                                                          push    czIntCoprocessorCalc                            ;store message offset
  1887                                                          jmp     ReportInterrupt                                 ;report interrupt
  1888                                  ;-----------------------------------------------------------------------------------------------------------------------
  1889                                  ;
  1890                                  ;       INT17   Reserved
  1891                                  ;
  1892                                  ;-----------------------------------------------------------------------------------------------------------------------
  1893                                                          menter  int17                                           ;(reserved)
  1894                                                          push    17                                              ;store interrupt nbr
  1895                                                          push    czIntReserved                                   ;store message offset
  1896                                                          jmp     ReportInterrupt                                 ;report interrupt
  1897                                  ;-----------------------------------------------------------------------------------------------------------------------
  1898                                  ;
  1899                                  ;       INT18   Reserved
  1900                                  ;
  1901                                  ;-----------------------------------------------------------------------------------------------------------------------
  1902                                                          menter  int18                                           ;(reserved)
  1903                                                          push    18                                              ;store interrupt nbr
  1904                                                          push    czIntReserved                                   ;store message offset
  1905                                                          jmp     ReportInterrupt                                 ;report interrupt
  1906                                  ;-----------------------------------------------------------------------------------------------------------------------
  1907                                  ;
  1908                                  ;       INT19   Reserved
  1909                                  ;
  1910                                  ;-----------------------------------------------------------------------------------------------------------------------
  1911                                                          menter  int19                                           ;(reserved)
  1912                                                          push    19                                              ;store interrupt nbr
  1913                                                          push    czIntReserved                                   ;store message offset
  1914                                                          jmp     ReportInterrupt                                 ;report interrupt
  1915                                  ;-----------------------------------------------------------------------------------------------------------------------
  1916                                  ;
  1917                                  ;       INT20   Reserved
  1918                                  ;
  1919                                  ;-----------------------------------------------------------------------------------------------------------------------
  1920                                                          menter  int20                                           ;(reserved)
  1921                                                          push    20                                              ;store interrupt nbr
  1922                                                          push    czIntReserved                                   ;store message offset
  1923                                                          jmp     ReportInterrupt                                 ;report interrupt
  1924                                  ;-----------------------------------------------------------------------------------------------------------------------
  1925                                  ;
  1926                                  ;       INT21   Reserved
  1927                                  ;
  1928                                  ;-----------------------------------------------------------------------------------------------------------------------
  1929                                                          menter  int21                                           ;(reserved)
  1930                                                          push    21                                              ;store interrupt nbr
  1931                                                          push    czIntReserved                                   ;store message offset
  1932                                                          jmp     ReportInterrupt                                 ;report interrupt
  1933                                  ;-----------------------------------------------------------------------------------------------------------------------
  1934                                  ;
  1935                                  ;       INT22   Reserved
  1936                                  ;
  1937                                  ;-----------------------------------------------------------------------------------------------------------------------
  1938                                                          menter  int22                                           ;(reserved)
  1939                                                          push    22                                              ;store interrupt nbr
  1940                                                          push    czIntReserved                                   ;store message offset
  1941                                                          jmp     ReportInterrupt                                 ;report interrupt
  1942                                  ;-----------------------------------------------------------------------------------------------------------------------
  1943                                  ;
  1944                                  ;       INT23   Reserved
  1945                                  ;
  1946                                  ;-----------------------------------------------------------------------------------------------------------------------
  1947                                                          menter  int23                                           ;(reserved)
  1948                                                          push    23                                              ;store interrupt nbr
  1949                                                          push    czIntReserved                                   ;store message offset
  1950                                                          jmp     ReportInterrupt                                 ;report interrupt
  1951                                  ;-----------------------------------------------------------------------------------------------------------------------
  1952                                  ;
  1953                                  ;       INT24   Reserved
  1954                                  ;
  1955                                  ;-----------------------------------------------------------------------------------------------------------------------
  1956                                                          menter  int24                                           ;(reserved)
  1957                                                          push    24                                              ;store interrupt nbr
  1958                                                          push    czIntReserved                                   ;store message offset
  1959                                                          jmp     ReportInterrupt                                 ;report interrupt
  1960                                  ;-----------------------------------------------------------------------------------------------------------------------
  1961                                  ;
  1962                                  ;       INT25   Reserved
  1963                                  ;
  1964                                  ;-----------------------------------------------------------------------------------------------------------------------
  1965                                                          menter  int25                                           ;(reserved)
  1966                                                          push    25                                              ;store interrupt nbr
  1967                                                          push    czIntReserved                                   ;store message offset
  1968                                                          jmp     ReportInterrupt                                 ;report interrupt
  1969                                  ;-----------------------------------------------------------------------------------------------------------------------
  1970                                  ;
  1971                                  ;       INT26   Reserved
  1972                                  ;
  1973                                  ;-----------------------------------------------------------------------------------------------------------------------
  1974                                                          menter  int26                                           ;(reserved)
  1975                                                          push    26                                              ;store interrupt nbr
  1976                                                          push    czIntReserved                                   ;store message offset
  1977                                                          jmp     ReportInterrupt                                 ;report interrupt
  1978                                  ;-----------------------------------------------------------------------------------------------------------------------
  1979                                  ;
  1980                                  ;       INT27   Reserved
  1981                                  ;
  1982                                  ;-----------------------------------------------------------------------------------------------------------------------
  1983                                                          menter  int27                                           ;(reserved)
  1984                                                          push    27                                              ;store interrupt nbr
  1985                                                          push    czIntReserved                                   ;store message offset
  1986                                                          jmp     ReportInterrupt                                 ;report interrupt
  1987                                  ;-----------------------------------------------------------------------------------------------------------------------
  1988                                  ;
  1989                                  ;       INT28   Reserved
  1990                                  ;
  1991                                  ;-----------------------------------------------------------------------------------------------------------------------
  1992                                                          menter  int28                                           ;(reserved)
  1993                                                          push    28                                              ;store interrupt nbr
  1994                                                          push    czIntReserved                                   ;store message offset
  1995                                                          jmp     ReportInterrupt                                 ;report interrupt
  1996                                  ;-----------------------------------------------------------------------------------------------------------------------
  1997                                  ;
  1998                                  ;       INT29   Reserved
  1999                                  ;
  2000                                  ;-----------------------------------------------------------------------------------------------------------------------
  2001                                                          menter  int29                                           ;(reserved)
  2002                                                          push    29                                              ;store interrupt nbr
  2003                                                          push    czIntReserved                                   ;store message offset
  2004                                                          jmp     ReportInterrupt                                 ;report interrupt
  2005                                  ;-----------------------------------------------------------------------------------------------------------------------
  2006                                  ;
  2007                                  ;       INT30   Reserved
  2008                                  ;
  2009                                  ;-----------------------------------------------------------------------------------------------------------------------
  2010                                                          menter  int30                                           ;(reserved)
  2011                                                          push    30                                              ;store interrupt nbr
  2012                                                          push    czIntReserved                                   ;store message offset
  2013                                                          jmp     ReportInterrupt                                 ;report interrupt
  2014                                  ;-----------------------------------------------------------------------------------------------------------------------
  2015                                  ;
  2016                                  ;       INT31   Reserved
  2017                                  ;
  2018                                  ;-----------------------------------------------------------------------------------------------------------------------
  2019                                                          menter  int31                                           ;(reserved)
  2020                                                          push    31                                              ;store interrupt nbr
  2021                                                          push    czIntReserved                                   ;store message offset
  2022                                                          jmp     ReportInterrupt                                 ;report interrupt
  2023                                  ;-----------------------------------------------------------------------------------------------------------------------
  2024                                  ;
  2025                                  ;       Routine:        ReportInterrupt
  2026                                  ;
  2027                                  ;       Description:    This routine will be used to respond to processor interrupts that are not otherwise handled.
  2028                                  ;                       At this stage, we simply restore the stack and return from the interrupt.
  2029                                  ;
  2030                                  ;       In:             [ESP+16]        EFLAGS                                  stored by interrupt call
  2031                                  ;                       [ESP+12]        CS                                      stored by interrupt call
  2032                                  ;                       [ESP+8]         EIP                                     stored by interrupt call
  2033                                  ;                       [ESP+4]         interrupt number (0-31)                 stored by push instruction
  2034                                  ;                       [ESP+0]         error message address                   stored by push instructions
  2035                                  ;
  2036                                  ;       Out:            N/A             This routine does not exit.
  2037                                  ;
  2038                                  ;-----------------------------------------------------------------------------------------------------------------------
  2039                                  ReportInterrupt         push    ds                                              ;save DS at time of interrupt
  2040                                                          push    es                                              ;save ES at time of interrupt
  2041                                                          pushad                                                  ;save EAX,ECX,EDX,EBX,EBP,ESP,ESI,EDI
  2042                                                          mov     ebp,esp                                         ;EBP --> [EDI]
  2043                                  ;
  2044                                  ;       Addressability to registers at the time of the interrupt is now established as:
  2045                                  ;
  2046                                  ;                       [EBP+56]        EFLAGS
  2047                                  ;                       [EBP+52]        CS
  2048                                  ;                       [EBP+48]        EIP
  2049                                  ;                       [EBP+44]        interrupt number (0-31)
  2050                                  ;                       [EBP+40]        error message address
  2051                                  ;                       [EBP+36]        DS
  2052                                  ;                       [EBP+32]        ES
  2053                                  ;                       [EBP+28]        EAX
  2054                                  ;                       [EBP+24]        ECX
  2055                                  ;                       [EBP+20]        EDX
  2056                                  ;                       [EBP+16]        EBX
  2057                                  ;                       [EBP+12]        ESP
  2058                                  ;                       [EBP+8]         EBP
  2059                                  ;                       [EBP+4]         ESI
  2060                                  ;                       [EBP+0]         EDI
  2061                                  ;
  2062                                                          push    cs                                              ;load code selector ...
  2063                                                          pop     ds                                              ;... into DS
  2064                                                          push    EGDTCGA                                         ;load CGA memory selector ...
  2065                                                          pop     es                                              ;... into ES
  2066                                  ;
  2067                                  ;       Display the interrupt report boundary box.
  2068                                  ;
  2069                                                          mov     cl,13                                           ;column
  2070                                                          mov     ch,6                                            ;row
  2071                                                          mov     dl,50                                           ;width
  2072                                                          mov     dh,8                                            ;height
  2073                                                          mov     bh,07h                                          ;attribute
  2074                                                          call    DrawTextDialogBox                               ;draw text dialog box
  2075                                  ;
  2076                                  ;       Display the report header.
  2077                                  ;
  2078                                                          mov     cl,15                                           ;column
  2079                                                          mov     ch,7                                            ;row
  2080                                                          mov     esi,czIntHeader                                 ;interrupt message header
  2081                                                          call    SetConsoleString                                ;draw text string
  2082                                  ;
  2083                                  ;       Display the interrupt description label.
  2084                                  ;
  2085                                                          mov     cl,15                                           ;column
  2086                                                          mov     ch,8                                            ;row
  2087                                                          mov     esi,czIntLabel                                  ;interrupt message description lead
  2088                                                          call    SetConsoleString                                ;draw text string
  2089                                  ;
  2090                                  ;       Display the interrupt number.
  2091                                  ;
  2092                                                          mov     eax,[ebp+44]                                    ;interrupt number
  2093                                                          mov     cl,26                                           ;column
  2094                                                          mov     ch,8                                            ;row
  2095                                                          call    PutConsoleHexByte                               ;draw ASCII hex byte
  2096                                  ;
  2097                                  ;       Display the interrupt name.
  2098                                  ;
  2099                                                          mov     cl,29                                           ;column
  2100                                                          mov     ch,8                                            ;row
  2101                                                          mov     esi,[ebp+40]                                    ;interrupt-specific message
  2102                                                          call    SetConsoleString                                ;display interrupt description
  2103                                  ;
  2104                                  ;       Display the register values header.
  2105                                  ;
  2106                                                          mov     cl,15                                           ;column
  2107                                                          mov     ch,10                                           ;row
  2108                                                          mov     esi,czIntRegsHeader                             ;interrupt registers header
  2109                                                          call    SetConsoleString                                ;draw text string
  2110                                  ;
  2111                                  ;       Display the EAX register label and value.
  2112                                  ;
  2113                                                          mov     cl,15                                           ;column
  2114                                                          mov     ch,11                                           ;row
  2115                                                          mov     esi,czIntEAX                                    ;register EAX label
  2116                                                          call    SetConsoleString                                ;draw label
  2117                                                          mov     eax,[ebp+28]                                    ;EAX value at interrupt
  2118                                                          mov     cl,19                                           ;column
  2119                                                          mov     ch,11                                           ;row
  2120                                                          call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2121                                  ;
  2122                                  ;       Display the ECX register label and value.
  2123                                  ;
  2124                                                          mov     cl,15                                           ;column
  2125                                                          mov     ch,12                                           ;row
  2126                                                          mov     esi,czIntECX                                    ;label
  2127                                                          call    SetConsoleString                                ;draw label
  2128                                                          mov     eax,[ebp+24]                                    ;ECX value at interrupt
  2129                                                          mov     cl,19                                           ;column
  2130                                                          mov     ch,12                                           ;row
  2131                                                          call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2132                                  ;
  2133                                  ;       Display the EDX register label and value.
  2134                                  ;
  2135                                                          mov     cl,15                                           ;column
  2136                                                          mov     ch,13                                           ;row
  2137                                                          mov     esi,czIntEDX                                    ;label
  2138                                                          call    SetConsoleString                                ;draw label
  2139                                                          mov     eax,[ebp+20]                                    ;EDX value at interrupt
  2140                                                          mov     cl,19                                           ;column
  2141                                                          mov     ch,13                                           ;row
  2142                                                          call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2143                                  ;
  2144                                  ;       Display the EBX register label and value.
  2145                                  ;
  2146                                                          mov     cl,15                                           ;column
  2147                                                          mov     ch,14                                           ;row
  2148                                                          mov     esi,czIntEBX                                    ;label
  2149                                                          call    SetConsoleString                                ;draw label
  2150                                                          mov     eax,[ebp+16]                                    ;EBX value at interrupt
  2151                                                          mov     cl,19                                           ;column
  2152                                                          mov     ch,14                                           ;row
  2153                                                          call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2154                                  ;
  2155                                  ;       Display the ESI register label and value.
  2156                                  ;
  2157                                                          mov     cl,29                                           ;column
  2158                                                          mov     ch,11                                           ;row
  2159                                                          mov     esi,czIntESI                                    ;label
  2160                                                          call    SetConsoleString                                ;draw label
  2161                                                          mov     eax,[ebp+4]                                     ;ESI
  2162                                                          mov     cl,33                                           ;column
  2163                                                          mov     ch,11                                           ;row
  2164                                                          call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2165                                  ;
  2166                                  ;       Display the EDI register label and value.
  2167                                  ;
  2168                                                          mov     cl,29                                           ;column
  2169                                                          mov     ch,12                                           ;row
  2170                                                          mov     esi,czIntEDI                                    ;label
  2171                                                          call    SetConsoleString                                ;draw label
  2172                                                          mov     eax,[ebp+0]                                     ;EDI
  2173                                                          mov     cl,33                                           ;column
  2174                                                          mov     ch,12                                           ;row
  2175                                                          call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2176                                  ;
  2177                                  ;       Display the EBP register label and value.
  2178                                  ;
  2179                                                          mov     cl,29                                           ;column
  2180                                                          mov     ch,13                                           ;row
  2181                                                          mov     esi,czIntEBP                                    ;label
  2182                                                          call    SetConsoleString                                ;draw label
  2183                                                          mov     eax,[ebp+8]                                     ;EBP
  2184                                                          mov     cl,33                                           ;column
  2185                                                          mov     ch,13                                           ;row
  2186                                                          call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2187                                  ;
  2188                                  ;       Display the DS register label and value.
  2189                                  ;
  2190                                                          mov     cl,42                                           ;column
  2191                                                          mov     ch,11                                           ;row
  2192                                                          mov     esi,czIntDS                                     ;label
  2193                                                          call    SetConsoleString                                ;draw label
  2194                                                          xor     eax,eax                                         ;zero register
  2195                                                          mov     ax,[ebp+36]                                     ;DS
  2196                                                          mov     cl,46                                           ;column
  2197                                                          mov     ch,11                                           ;row
  2198                                                          call    PutConsoleHexWord                               ;draw ASCII hex word
  2199                                  ;
  2200                                  ;       Display the ES register label and value.
  2201                                  ;
  2202                                                          mov     cl,42                                           ;column
  2203                                                          mov     ch,12                                           ;row
  2204                                                          mov     esi,czIntES                                     ;label
  2205                                                          call    SetConsoleString                                ;draw label
  2206                                                          xor     eax,eax                                         ;zero register
  2207                                                          mov     ax,[ebp+32]                                     ;ES
  2208                                                          mov     cl,46                                           ;column
  2209                                                          mov     ch,12                                           ;row
  2210                                                          call    PutConsoleHexWord                               ;draw ASCII hex word
  2211                                  ;
  2212                                  ;       Display the SS register label and value.
  2213                                  ;
  2214                                                          mov     cl,42                                           ;column
  2215                                                          mov     ch,13                                           ;row
  2216                                                          mov     esi,czIntSS                                     ;label
  2217                                                          call    SetConsoleString                                ;draw label
  2218                                                          xor     eax,eax                                         ;zero register
  2219                                                          mov     ax,ss                                           ;SS
  2220                                                          mov     cl,46                                           ;column
  2221                                                          mov     ch,13                                           ;row
  2222                                                          call    PutConsoleHexWord                               ;draw ASCII hex word
  2223                                  ;
  2224                                  ;       Display the CS register lable and value.
  2225                                  ;
  2226                                                          mov     cl,42                                           ;column
  2227                                                          mov     ch,14                                           ;row
  2228                                                          mov     esi,czIntCS                                     ;label
  2229                                                          call    SetConsoleString                                ;draw label
  2230                                                          xor     eax,eax                                         ;zero register
  2231                                                          mov     ax,[ebp+52]                                     ;CS
  2232                                                          mov     cl,46                                           ;column
  2233                                                          mov     ch,14                                           ;row
  2234                                                          call    PutConsoleHexWord                               ;draw ASCII hex word
  2235                                  ;
  2236                                  ;       Display the EFLAGS register label and value.
  2237                                  ;
  2238                                                          mov     cl,51                                           ;column
  2239                                                          mov     ch,11                                           ;row
  2240                                                          mov     esi,czIntEFLAGS                                 ;label
  2241                                                          call    SetConsoleString                                ;draw label
  2242                                                          mov     eax,[ebp+56]                                    ;EFLAGS
  2243                                                          mov     cl,55                                           ;column
  2244                                                          mov     ch,11                                           ;row
  2245                                                          call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2246                                  ;
  2247                                  ;       Display the ESP register label and value.
  2248                                  ;
  2249                                                          mov     cl,51                                           ;column
  2250                                                          mov     ch,13                                           ;row
  2251                                                          mov     esi,czIntESP                                    ;label
  2252                                                          call    SetConsoleString                                ;draw label
  2253                                                          mov     eax,[ebp+12]                                    ;ESP
  2254                                                          mov     cl,55                                           ;column
  2255                                                          mov     ch,13                                           ;row
  2256                                                          call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2257                                  ;
  2258                                  ;       Display the EIP register label and value.
  2259                                  ;
  2260                                                          mov     cl,51                                           ;column
  2261                                                          mov     ch,14                                           ;row
  2262                                                          mov     esi,czIntEIP                                    ;label
  2263                                                          call    SetConsoleString                                ;draw label
  2264                                                          mov     eax,[ebp+48]                                    ;EIP lo-order 32-bits
  2265                                                          mov     cl,55                                           ;column
  2266                                                          mov     ch,14                                           ;row
  2267                                                          call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2268                                  ;
  2269                                  ;       Halt and loop until reset.
  2270                                  ;
  2271                                  .10                     sti                                                     ;enable maskable interrupts
  2272                                                          hlt                                                     ;halt processor
  2273                                                          jmp     .10                                             ;resume on interrupt
  2274                                  ;-----------------------------------------------------------------------------------------------------------------------
  2275                                  ;
  2276                                  ;       Processor Interrupt Name Strings
  2277                                  ;
  2278                                  ;-----------------------------------------------------------------------------------------------------------------------
  2279                                  czIntDivideByZero       db      "Division by zero",0
  2280                                  czIntSingleStep         db      "Single step",0
  2281                                  czIntNonMaskable        db      "Non-maskable interrupt",0
  2282                                  czIntBreak              db      "Break",0
  2283                                  czIntInto               db      "Into",0
  2284                                  czIntBounds             db      "Bounds",0
  2285                                  czIntBadOpCode          db      "Bad Operation Code",0
  2286                                  czIntNoCoprocessor      db      "No Coprocessor",0
  2287                                  czIntDoubleFault        db      "Double Fault",0
  2288                                  czIntOperand            db      "Operand",0
  2289                                  czIntBadTSS             db      "Bad Task State Segment",0
  2290                                  czIntNotPresent         db      "Not Present",0
  2291                                  czIntStackLimit         db      "Stack Limit",0
  2292                                  czIntProtection         db      "General Protection Fault",0
  2293                                  czIntCoprocessorCalc    db      "Coprocessor Calculation",0
  2294                                  czIntReserved           db      "Reserved",0
  2295                                  ;-----------------------------------------------------------------------------------------------------------------------
  2296                                  ;
  2297                                  ;       Processor Interrupt Handling Strings
  2298                                  ;
  2299                                  ;-----------------------------------------------------------------------------------------------------------------------
  2300                                  czIntHeader             db      "An unhandled processor interrupt has occurred:",0
  2301                                  czIntLabel              db      "Interrupt #",0
  2302                                  czIntRegsHeader         db      "Registers at the time of the interrupt:",0
  2303                                  czIntEAX                db      "EAX:",0
  2304                                  czIntECX                db      "ECX:",0
  2305                                  czIntEDX                db      "EDX:",0
  2306                                  czIntEBX                db      "EBX:",0
  2307                                  czIntESI                db      "ESI:",0
  2308                                  czIntEDI                db      "EDI:",0
  2309                                  czIntEBP                db      "EBP:",0
  2310                                  czIntESP                db      "ESP:",0
  2311                                  czIntDS                 db      " DS:",0
  2312                                  czIntES                 db      " ES:",0
  2313                                  czIntSS                 db      " SS:",0
  2314                                  czIntCS                 db      " CS:",0
  2315                                  czIntEFLAGS             db      "FLG:",0
  2316                                  czIntEIP                db      "EIP:",0
  2317                                  ;-----------------------------------------------------------------------------------------------------------------------
  2318                                  ;
  2319                                  ;       Routine:        DrawTextDialogBox
  2320                                  ;
  2321                                  ;       Description:    This routine opens a text-mode dialog box with an ASCII border.
  2322                                  ;
  2323                                  ;       In:             CL      upper left column (0-79)
  2324                                  ;                       CH      upper left row (0-24)
  2325                                  ;                       DL      column width, excluding border
  2326                                  ;                       DH      row height, excluding border
  2327                                  ;                       BH      color attribute
  2328                                  ;
  2329                                  ;-----------------------------------------------------------------------------------------------------------------------
  2330                                  DrawTextDialogBox       push    ecx                                             ;save non-volatile regs
  2331                                                          push    esi                                             ;
  2332                                                          push    edi                                             ;
  2333                                                          push    es                                              ;
  2334                                                          push    EGDTCGA                                         ;load CGA selector ...
  2335                                                          pop     es                                              ;... into ES
  2336                                  ;
  2337                                  ;       Compute target display offset.
  2338                                  ;
  2339                                                          xor     eax,eax                                         ;zero register
  2340                                                          mov     al,ch                                           ;row
  2341                                                          mov     ah,ECONROWBYTES                                 ;mulitplicand
  2342                                                          mul     ah                                              ;row offset
  2343                                                          add     al,cl                                           ;add column
  2344                                                          adc     ah,0                                            ;add overflow
  2345                                                          add     al,cl                                           ;add column
  2346                                                          adc     ah,0                                            ;add overflow
  2347                                                          mov     edi,eax                                         ;target row offset
  2348                                  ;
  2349                                  ;       Display top border row.
  2350                                  ;
  2351                                                          push    edi                                             ;save target row offset
  2352                                                          mov     ah,bh                                           ;attribute
  2353                                                          mov     al,EASCIIBORDSGLUPRLFT                          ;upper-left single border
  2354                                                          stosw                                                   ;display character and attribute
  2355                                                          mov     al,EASCIIBORDSGLHORZ                            ;horizontal single border
  2356                                                          xor     ecx,ecx                                         ;zero register
  2357                                                          mov     cl,dl                                           ;width, excluding border
  2358                                                          rep     stosw                                           ;display horizontal border
  2359                                                          mov     al,EASCIIBORDSGLUPRRGT                          ;upper-right single border
  2360                                                          stosw                                                   ;display character and attribute
  2361                                                          pop     edi                                             ;restore target row offset
  2362                                                          add     edi,ECONROWBYTES                                ;next row
  2363                                  ;
  2364                                  ;       Display dialog box body rows.
  2365                                  ;
  2366                                                          xor     ecx,ecx                                         ;zero register
  2367                                                          mov     cl,dh                                           ;height, excluding border
  2368                                  .10                     push    ecx                                             ;save remaining rows
  2369                                                          push    edi                                             ;save target row offset
  2370                                                          mov     ah,bh                                           ;attribute
  2371                                                          mov     al,EASCIIBORDSGLVERT                            ;vertical single border
  2372                                                          stosw                                                   ;display character and attribute
  2373                                                          mov     al,EASCIISPACE                                  ;space
  2374                                                          xor     ecx,ecx                                         ;zero register
  2375                                                          mov     cl,dl                                           ;width, excluding border
  2376                                                          rep     stosw                                           ;display row
  2377                                                          mov     al,EASCIIBORDSGLVERT                            ;vertical single border
  2378                                                          stosw                                                   ;display character and attribute
  2379                                                          pop     edi                                             ;restore target row offset
  2380                                                          add     edi,ECONROWBYTES                                ;next row
  2381                                                          pop     ecx                                             ;remaining rows
  2382                                                          loop    .10                                             ;next row
  2383                                  ;
  2384                                  ;       Display bottom border row.
  2385                                  ;
  2386                                                          push    edi                                             ;save target row offset
  2387                                                          mov     ah,bh                                           ;attribute
  2388                                                          mov     al,EASCIIBORDSGLLWRLFT                          ;lower-left single border
  2389                                                          stosw                                                   ;display character and attribute
  2390                                                          mov     al,EASCIIBORDSGLHORZ                            ;horizontal single border
  2391                                                          xor     ecx,ecx                                         ;zero register
  2392                                                          mov     cl,dl                                           ;width, excluding border
  2393                                                          rep     stosw                                           ;display horizontal border
  2394                                                          mov     al,EASCIIBORDSGLLWRRGT                          ;lower-right single border
  2395                                                          stosw                                                   ;display character and attribute
  2396                                                          pop     edi                                             ;restore target row offset
  2397                                                          add     edi,ECONROWBYTES                                ;next row
  2398                                  ;
  2399                                  ;       Restore and return.
  2400                                  ;
  2401                                                          pop     es                                              ;restore non-volatile regs
  2402                                                          pop     edi                                             ;
  2403                                                          pop     esi                                             ;
  2404                                                          pop     ecx                                             ;
  2405                                                          ret                                                     ;return
  2406                                  ;=======================================================================================================================
  2407                                  ;
  2408                                  ;       Hardware Device Interupts
  2409                                  ;
  2410                                  ;       The next 16 interrupts are defined as our hardware interrupts. These interrupts vectors (20h-2Fh) are mapped to
  2411                                  ;       the hardware interrupts IRQ0-IRQF by the BIOS when the call to the BIOS is made invoking BIOS function 89h
  2412                                  ;       (BX=2028h).
  2413                                  ;
  2414                                  ;=======================================================================================================================
  2415                                  ;-----------------------------------------------------------------------------------------------------------------------
  2416                                  ;
  2417                                  ;       IRQ0    Clock Tick Interrupt
  2418                                  ;
  2419                                  ;       PC compatible systems contain or emulate the function of the Intel 8253 Programmable Interval Timer (PIT).
  2420                                  ;       Channel 0 of this chip decrements an internal counter to zero and then issues a hardware interrupt. The default
  2421                                  ;       rate at which IRQ0 occurs is approximately 18.2 times per second or, more accurately, 1,573,040 times per day.
  2422                                  ;
  2423                                  ;       Every time IRQ0 occurs, a counter at 40:6c is incremented. When the number of ticks reaches the maximum for one
  2424                                  ;       day, the counter is set to zero and the number of days counter at 40:70 is incremented.
  2425                                  ;
  2426                                  ;       This handler also decrements the floppy drive motor count at 40:40 if it is not zero. When this count reaches
  2427                                  ;       zero, the floppy disk motors are turned off.
  2428                                  ;
  2429                                  ;-----------------------------------------------------------------------------------------------------------------------
  2430                                                          menter  clocktick                                       ;clock tick interrupt
  2431                                                          push    eax                                             ;save non-volatile regs
  2432                                                          push    edx                                             ;
  2433                                                          push    ds                                              ;
  2434                                  ;
  2435                                  ;       End the interrupt.
  2436                                  ;
  2437                                                          call    PutPrimaryEndOfInt                              ;send EOI to primary PIC
  2438                                  ;
  2439                                  ;       Update the clock tick count and the elapsed days as needed.
  2440                                  ;
  2441                                                          push    EGDTOSDATA                                      ;load OS data selector ...
  2442                                                          pop     ds                                              ;... into data segment register
  2443                                                          mov     eax,[wdClockTicks]                              ;EAX = clock ticks
  2444                                                          inc     eax                                             ;increment clock ticks
  2445                                                          cmp     eax,EPITDAYTICKS                                ;clock ticks per day?
  2446                                                          jb      irq0.10                                         ;no, skip ahead
  2447                                                          inc     byte [wbClockDays]                              ;increment clock days
  2448                                                          xor     eax,eax                                         ;reset clock ticks
  2449                                  irq0.10                 mov     dword [wdClockTicks],eax                        ;save clock ticks
  2450                                  ;
  2451                                  ;       Decrement floppy disk motor timeout.
  2452                                  ;
  2453                                                          cmp     byte [wbFDCMotor],0                             ;floppy motor timeout?
  2454                                                          je      irq0.20                                         ;yes, skip ahead
  2455                                                          dec     byte [wbFDCMotor]                               ;decrement motor timeout
  2456                                                          jnz     irq0.20                                         ;skip ahead if non-zero
  2457                                  ;
  2458                                  ;       Turn off the floppy disk motor if appropriate.
  2459                                  ;
  2460                                                          sti                                                     ;enable maskable interrupts
  2461                                  irq0.15                 mov     dh,EFDCPORTHI                                   ;FDC controller port hi
  2462                                                          mov     dl,EFDCPORTLOSTAT                               ;FDC main status register
  2463                                                          in      al,dx                                           ;FDC main status byte
  2464                                                          test    al,EFDCSTATBUSY                                 ;test FDC main status for busy
  2465                                                          jnz     irq0.15                                         ;wait while busy
  2466                                                          mov     al,EFDCMOTOROFF                                 ;motor-off / enable/ DMA setting
  2467                                                          mov     byte [wbFDCControl],al                          ;save motor-off setting
  2468                                                          mov     dh,EFDCPORTHI                                   ;FDC port hi
  2469                                                          mov     dl,EFDCPORTLOOUT                                ;FDC digital output register
  2470                                                          out     dx,al                                           ;turn motor off
  2471                                  ;
  2472                                  ;       Enable maskable interrupts.
  2473                                  ;
  2474                                  irq0.20                 sti                                                     ;enable maskable interrupts
  2475                                  ;
  2476                                  ;       Restore and return.
  2477                                  ;
  2478                                                          pop     ds                                              ;restore modified regs
  2479                                                          pop     edx                                             ;
  2480                                                          pop     eax                                             ;
  2481                                                          iretd                                                   ;return
  2482                                  ;-----------------------------------------------------------------------------------------------------------------------
  2483                                  ;
  2484                                  ;       IRQ1    Keyboard Interrupt
  2485                                  ;
  2486                                  ;       This handler is called when an IRQ1 hardware interrupt occurs, caused by a keyboard event. The scan-code(s)
  2487                                  ;       corresponding to the keyboard event are read and message events are appended to the message queue. Since this
  2488                                  ;       code is called in response to a hardware interrupt, no task switch occurs. We need to preseve the state of
  2489                                  ;       ALL modified registers upon return.
  2490                                  ;
  2491                                  ;       Make/Break                      Base            Shift           Message
  2492                                  ;                                                                       KEYDOWN         KEYUP           CHAR
  2493                                  ;                                                                       Norm/Shift      Norm/Shift      Norm/Shift
  2494                                  ;                                                                       AX   AX         AX   AX         AX   AX
  2495                                  ;       01/81                           Escape                          011B/011B       811B/811B       011B/011B
  2496                                  ;       02/82                           1               !               0231/0221       8231/8221       0231/0221
  2497                                  ;       03/83                           2               @               0332/0340       8332/8340       0332/0340
  2498                                  ;       04/84                           3               #               0433/0423       8433/8423       0433/0423
  2499                                  ;       05/85                           4               $               0534/0524       8534/8524       0534/0524
  2500                                  ;       06/86                           5               %               0635/0625       8635/8625       0635/0625
  2501                                  ;       07/87                           6               ^               0736/075E       8736/875E       0736/075E
  2502                                  ;       08/88                           7               &               0837/0826       8837/8826       0837/0826
  2503                                  ;       09/89                           8               *               0938/092A       8938/892A       0938/092A
  2504                                  ;       0A/8A                           9               (               0A39/0A28       8A39/8A28       0A39/9A28
  2505                                  ;       0B/8B                           0               )               0B30/0B29       8B30/8B29       0B30/0B29
  2506                                  ;       0C/8C                           -               _               0C2D/0C5F       8C2D/8C5F       0C2D/0C5F
  2507                                  ;       0D/8D                           =               +               0D3D/0D2B       8D3D/8D2B       0D3D/0D2B
  2508                                  ;       0E/8E                           Backspace                       0E08/0E08       8E08/8E08       0E08/0E08
  2509                                  ;       0F/8F                           Tab                             0F09/0F09       8F09/8F09       0F09/0F09
  2510                                  ;       10/90                           q               Q               1071/1051       9071/9051       1071/1051
  2511                                  ;       11/91                           w               W               1177/1157       9177/9157       1177/1157
  2512                                  ;       12/92                           e               E               1265/1245       9265/9245       1265/1245
  2513                                  ;       13/93                           r               R               1372/1352       9372/9352       1371/1352
  2514                                  ;       14/94                           t               T               1474/1454       9474/9454       1474/1454
  2515                                  ;       15/95                           y               Y               1579/1559       9579/9559       1579/1559
  2516                                  ;       16/96                           u               U               1675/1655       9675/9655       1675/1655
  2517                                  ;       17/97                           i               I               1769/1749       9769/9749       1769/1749
  2518                                  ;       18/98                           o               O               186F/184F       986F/984F       186F/184F
  2519                                  ;       19/99                           p               P               1970/1950       9970/9950       1970/1950
  2520                                  ;       1A/9A                           [               {               1A5B/1A7B       9A5B/9A7B       1A58/1A7B
  2521                                  ;       1B/9B                           ]               }               1B5D/1B7D       9B5D/9B7D       1B5D/1B7D
  2522                                  ;       1C/9C                           Enter                           1C00/1C00       9C00/9C00
  2523                                  ;       1D/9D                           Left Ctrl                       1D00/1D00       9D00/9D00
  2524                                  ;       1E/9E                           a               A               1E61/1E41       9E61/9E41       1E61/1E41
  2525                                  ;       1F/9F                           s               S               1F73/1F53       9F73/9F53       1F73/1F53
  2526                                  ;       20/A0                           d               D               2064/2044       A064/A044       2064/2044
  2527                                  ;       21/A1                           f               F               2166/2146       A166/A146       2166/2146
  2528                                  ;       22/A2                           g               G               2267/2247       A267/A247       2267/2247
  2529                                  ;       23/A3                           h               H               2368/2348       A368/A348       2368/2348
  2530                                  ;       24/A4                           j               J               246A/244A       A46A/A44A       246A/244A
  2531                                  ;       25/A5                           k               K               256B/254B       A56B/A54B       256B/254B
  2532                                  ;       26/A6                           l               L               266C/264C       A66C/A64C       266C/264C
  2533                                  ;       27/A7                           ;               :               273B/273A       A73B/A73A       273B/273A
  2534                                  ;       28/A8                           '               "               2827/2822       A827/A822       2827/2822
  2535                                  ;       29/A9                           `               ~               2960/297E       A960/A97E       2960/297E
  2536                                  ;       2A/AA                           Left Shift                      2A00/2A00       AA00/AA00
  2537                                  ;       2B/AB                           \               |               2B5C/2B7C       AB5C/AB7C       2B5C/2B7C
  2538                                  ;       2C/AC                           z               Z               2C7A/2C5A       AC7A/AC5A       2C7A/2C5A
  2539                                  ;       2D/AD                           x               X               2D78/2D58       AD78/AD58       2D78/2D58
  2540                                  ;       2E/AE                           c               C               2E63/2E43       AE63/AE43       2E63/2E43
  2541                                  ;       2F/AF                           v               V               2F76/2F56       AF76/AF56       2F76/2F56
  2542                                  ;       30/B0                           b               B               3062/3042       B062/B042       3062/3042
  2543                                  ;       31/B1                           n               N               316E/314E       B16E/B14E       316E/314E
  2544                                  ;       32/B2                           m               M               326D/324D       B26D/B24D       326D/324D
  2545                                  ;       33/B3                           ,               <               332C/333C       B32C/B33C       332C/333C
  2546                                  ;       34/B4                           .               >               342E/343E       B42E/B43E       342E/343E
  2547                                  ;       35/B5                           /               ?               352F/353F       B52F/B53F       352F/353F
  2548                                  ;       36/B6                           Right Shift                     3600/3600       B600/B600
  2549                                  ;       37/B7                           Keypad *                        372A/372A       B72A/B72A       372A/372A
  2550                                  ;       38/B8                           Left Alt                        3800/3800       B800/B800
  2551                                  ;       39/B9                           Spacebar                        3920/3920       B920/B920       3920/3920
  2552                                  ;       3A/BA                           Caps Lock                       3A00/3A00       BA00/BA00
  2553                                  ;       3B/BB                           F1                              3B00/3B00       BB00/BB00
  2554                                  ;       3C/BC                           F2                              3C00/3C00       BC00/BC00
  2555                                  ;       3D/BD                           F3                              3D00/3D00       BD00/BD00
  2556                                  ;       3E/BE                           F4                              3E00/3E00       BE00/BE00
  2557                                  ;       3F/BF                           F5                              3F00/3F00       BF00/BF00
  2558                                  ;       40/C0                           F6                              4000/4000       C000/C000
  2559                                  ;       41/C1                           F7                              4100/4100       C100/C100
  2560                                  ;       42/C2                           F8                              4200/4200       C200/C200
  2561                                  ;       43/C3                           F9                              4300/4300       C300/C300
  2562                                  ;       44/C4                           F10                             4400/4400       C400/C400
  2563                                  ;       45/C5                           Num-Lock                        4500/4500       C500/C500
  2564                                  ;       46/C6                           Scroll-Lock                     4600/4600       C600/C600
  2565                                  ;       47/C7                           Keypad-7                        4700/4700       C700/C700
  2566                                  ;       47/C7                           Num-Lock Keypad-7               4737/4737       C737/C737       4737/4737
  2567                                  ;       48/C8                           Keypad-8                        4800/4800       C800/C800
  2568                                  ;       48/C8                           Num-Lock Keypad-8               4838/4838       C838/C838       4838/4838
  2569                                  ;       49/C9                           Keypad-9                        4900/4900       C900/C900
  2570                                  ;       49/C9                           Num-Lock Keypad-9               4939/4939       C939/C939       4939/4939
  2571                                  ;       4A/CA                           Keypad-Minus                    4A2D/4A2D       CA2D/CA2D       4A2D/4A2D
  2572                                  ;       4B/CB                           Keypad-4                        4B00/4B00       CB00/CB00
  2573                                  ;       4B/CB                           Num-Lock Keypad-4               4B34/4B34       CB34/CB34       4B34/4B34
  2574                                  ;       4C/CC                           Keypad-5                        4C00/4C00       CC00/CC00
  2575                                  ;       4C/CC                           Num-Lock Keypad-5               4C35/4C35       CC35/CC35       4C35/4C35
  2576                                  ;       4D/CD                           Keypad-6                        4D00/4D00       CD00/CD00
  2577                                  ;       4D/CD                           Num-Lock Keypad-6               4D36/4D36       CD36/CD36       4D36/4D36
  2578                                  ;       4E/CE                           Keypad-Plus                     4E2B/4E2B       CE2B/CE2B       4E2B/4E2B
  2579                                  ;       4F/CF                           Keypad-1                        4F00/4F00       CF00/CF00
  2580                                  ;       4F/CF                           Num-Lock Keypad-1               4F31/4F31       CF31/CF31       4F31/4F31
  2581                                  ;       50/D0                           Keypad-2                        5000/5000       D000/D000
  2582                                  ;       50/D0                           Num-Lock Keypad-2               5032/5032       D032/D032       5032/5032
  2583                                  ;       51/D1                           Keypad-3                        5100/5100       D100/D100
  2584                                  ;       51/D1                           Num-Lock Keypad-3               5133/5133       D133/D133       5133/5133
  2585                                  ;       52/D2                           Keypad-0                        5200/5200       D200/D200
  2586                                  ;       52/D2                           Num-Lock Keypad-0               5230/5230       D230/D230       5230/5230
  2587                                  ;       53/D3                           Keypad-Period                   537F/537F       D37F/D37F       537F/537F
  2588                                  ;       53/D3                           Num-Lock Keypad-Period          532E/532E       D32E/D32E       532E/532E
  2589                                  ;       54/D4                           Alt-PrntScrn                    5400/5400       D400/D400
  2590                                  ;       57/D7                           F11                             5700/5700       D700/D700
  2591                                  ;       58/D8                           F12                             5800/5800       D800/D800
  2592                                  ;
  2593                                  ;       E0 5B/E0 DB                     Left-Windows                    5B00/5B00       DB00/DB00
  2594                                  ;       E0 5C/E0 DC                     Right-Windows                   5C00/5C00       DC00/DC00
  2595                                  ;       E0 5D/E0 DD                     Right-Click                     5D00/5D00       DD00/DD00
  2596                                  ;
  2597                                  ;       E1 1D 45/E1 9D C5               Pause-Break                    *6500/6500      *E500/E500
  2598                                  ;       E1 1D 45/E1 9D C5               Shift Pause-Break              *6500/6500      *E500/E500
  2599                                  ;       E1 1D 45/E1 9D C5               Alt Pause-Break                *6500/6500      *E500/E500
  2600                                  ;
  2601                                  ;       E0 46/E0 C6                     Ctrl Pause-Break               *6600/6600      *E600/E600
  2602                                  ;
  2603                                  ;       E0 47/E0 C7                     Home                           *6700/6700      *E700/E700
  2604                                  ;       E0 47/E0 AA                     Num-Lock Home                  *6700/6700      *E700/E700
  2605                                  ;       E0 47/E0 2A                     Left-Shift Home                *6700/6700      *E700/E700
  2606                                  ;       E0 47/E0 36                     Right-Shift Home               *6700/6700      *E700/E700
  2607                                  ;
  2608                                  ;       E0 48/E0 C8                     Up-Arrow                       *6800/6800      *E800/E800
  2609                                  ;       E0 48/E0 AA                     Num-Lock Up-Arrow              *6800/6800      *E800/E800
  2610                                  ;       E0 48/E0 2A                     Left-Shift Up-Arrow            *6800/6800      *E800/E800
  2611                                  ;       E0 48/E0 36                     Right-Shift Up-Arrow           *6800/6800      *E800/E800
  2612                                  ;
  2613                                  ;       E0 49/E0 C9                     Page-Up                        *6900/6900      *E900/E900
  2614                                  ;       E0 49/E0 AA                     Num-Lock Page-Up               *6900/6900      *E900/E900
  2615                                  ;       E0 49/E0 2A                     left-Shift Page-Up             *6900/6900      *E900/E900
  2616                                  ;       E0 49/E0 36                     Right-Shift Page-Up            *6900/6900      *E900/E900
  2617                                  ;
  2618                                  ;       E0 4B/E0 CB                     Left-Arrow                     *6B00/6B00      *EB00/EB00
  2619                                  ;       E0 4B/E0 AA                     Num-Lock Left-Arrow            *6B00/6B00      *EB00/EB00
  2620                                  ;       E0 4B/E0 2A                     Left-Shift Left-Arrow          *6B00/6B00      *EB00/EB00
  2621                                  ;       E0 4B/E0 36                     Right-Shift Left-Arrow         *6B00/6B00      *EB00/EB00
  2622                                  ;
  2623                                  ;       E0 4D/E0 CD                     Right-Arrow                    *6D00/6D00      *ED00/ED00
  2624                                  ;       E0 4D/E0 AA                     Num-Lock Right-Arrow           *6D00/6D00      *ED00/ED00
  2625                                  ;       E0 4D/E0 2A                     Left-Shift Right-Arrow         *6D00/6D00      *ED00/ED00
  2626                                  ;       E0 4D/E0 36                     Right-Shift Right-Arrow        *6D00/6D00      *ED00/ED00
  2627                                  ;
  2628                                  ;       E0 4F/E0 CF                     End                            *6F00/6F00      *EF00/EF00
  2629                                  ;       E0 4F/E0 AA                     Num-Lock End                   *6F00/6F00      *EF00/EF00
  2630                                  ;       E0 4F/E0 2A                     Left-Shift End                 *6F00/6F00      *EF00/EF00
  2631                                  ;       E0 4F/E0 36                     Right-Shift End                *6F00/6F00      *EF00/EF00
  2632                                  ;
  2633                                  ;       E0 50/E0 D0                     Down-Arrow                     *7000/7000      *F000/F000
  2634                                  ;       E0 50/E0 AA                     Num-Lock Down-Arrow            *7000/7000      *F000/F000
  2635                                  ;       E0 50/E0 2A                     Left-Shift Down-Arrow          *7000/7000      *F000/F000
  2636                                  ;       E0 50/E0 36                     Right-Shift Down-Arrow         *7000/7000      *F000/F000
  2637                                  ;
  2638                                  ;       E0 51/E0 D1                     Page-Down                      *7100/7100      *F100/F100
  2639                                  ;       E0 51/E0 AA                     Num-Lock Page-Down             *7100/7100      *F100/F100
  2640                                  ;       E0 51/E0 2A                     Left-Shift Page-Down           *7100/7100      *F100/F100
  2641                                  ;       E0 51/E0 36                     Right-Shift Page-Down          *7100/7100      *F100/F100
  2642                                  ;
  2643                                  ;       E0 52/E0 D2                     Insert                         *7200/7200      *F200/F200
  2644                                  ;       E0 52/E0 AA                     Num-Lock Insert                *7200/7200      *F200/F200
  2645                                  ;       E0 52/E0 2A                     Left-Shift Insert              *7200/7200      *F200/F200
  2646                                  ;       E0 52/E0 36                     Right-Shift Insert             *7200/7200      *F200/F200
  2647                                  ;
  2648                                  ;       E0 53/E0 D3                     Delete                         *737F/737F      *F37F/F37F      *737F/737F
  2649                                  ;       E0 53/E0 AA                     Num-Lock Delete                *737F/737F      *F37F/F37F      *737F/737F
  2650                                  ;       E0 53/E0 2A                     Left-Shift Delete              *737F/737F      *F37F/F37F      *737F/737F
  2651                                  ;       E0 53/E0 36                     Right-Shift Delete             *737F/737F      *F37F/F37F      *737F/737F
  2652                                  ;
  2653                                  ;       E0 35/E0 B5                     Keypad-Slash                   *752F/752F      *F52F/F52F      *752F/752F
  2654                                  ;       E0 35/E0 AA                     Num-Lock Keypad-Slash          *752F/752F      *F52F/F52F      *752F/752F
  2655                                  ;       E0 35/E0 2A                     Left-Shift Keypad-Slash        *752F/752F      *F52F/F52F      *752F/752F
  2656                                  ;       E0 35/E0 36                     Right-Shift Keypad-Slash       *752F/752F      *F52F/F52F      *752F/752F
  2657                                  ;
  2658                                  ;       E0 37/E0 B7 E0 AA               PrntScrn                       *7700/7700      *F700/F700
  2659                                  ;       E0 37/E0 B7 E0 B7               Shift/Ctrl PrntScrn            *7700/7700      *F700/F700
  2660                                  ;
  2661                                  ;       E0 38/E0 B8                     Right Alt                      *7800/7800      *F800/F800
  2662                                  ;       E0 1C/E0 9C                     Keypad Enter                   *7C00/7C00      *FC00/FC00
  2663                                  ;       E0 1D/E0 9D                     Right Ctrl                     *7D00/7D00      *FD00/FD00
  2664                                  ;
  2665                                  ;       *OS Custom Scan Code in Messages
  2666                                  ;
  2667                                  ;-----------------------------------------------------------------------------------------------------------------------
  2668                                                          menter  keyboard                                        ;keyboard interrrupt
  2669                                                          push    eax                                             ;save non-volatile regs
  2670                                                          push    ebx                                             ;
  2671                                                          push    ecx                                             ;
  2672                                                          push    edx                                             ;
  2673                                                          push    esi                                             ;
  2674                                                          push    ds                                              ;
  2675                                  ;
  2676                                  ;       End the interrupt.
  2677                                  ;
  2678                                                          call    PutPrimaryEndOfInt                              ;send EOI to primary PIC
  2679                                  ;
  2680                                  ;       Reset codes and flags.
  2681                                  ;
  2682                                                          push    EGDTOSDATA                                      ;load OS data selector ...
  2683                                                          pop     ds                                              ;... into data segment register
  2684                                                          mov     esi,wsKeybData                                  ;keyboard data addr
  2685                                                          mov     al,[esi+KEYBDATA.scan]                          ;load previous scan code
  2686                                                          mov     [esi+KEYBDATA.last],al                          ;... into previous scan code field
  2687                                                          xor     al,al                                           ;zero reg
  2688                                                          mov     [esi+KEYBDATA.char],al                          ;zero ASCII char code
  2689                                                          mov     [esi+KEYBDATA.scan],al                          ;zero ASCII scan code
  2690                                                          mov     [esi+KEYBDATA.scan0],al                         ;zero scan code buffer 0
  2691                                                          mov     [esi+KEYBDATA.scan1],al                         ;zero scan code buffer 1
  2692                                                          mov     [esi+KEYBDATA.scan2],al                         ;zero scan code buffer 2
  2693                                                          mov     [esi+KEYBDATA.scan3],al                         ;zero scan code buffer 3
  2694                                                          mov     al,EKEYFTIMEOUT                                 ;timeout indicator
  2695                                                          not     al                                              ;status flag mask
  2696                                                          and     byte [esi+KEYBDATA.status],al                   ;clear timeout indicator
  2697                                  ;
  2698                                  ;       Hold shift and lock settings. Get first scan code. Ignore ACK and NAK from the controller.
  2699                                  ;
  2700                                                          mov     bl,[esi+KEYBDATA.shift]                         ;shift flags
  2701                                                          mov     bh,[esi+KEYBDATA.lock]                          ;locl flags
  2702                                                          call    WaitForKeyOutBuffer                             ;controller timeout?
  2703                                                          jz      irq1.timeout                                    ;yes, skip ahead
  2704                                                          in      al,EKEYBPORTDATA                                ;read scan code
  2705                                                          cmp     al,0FAh                                         ;keyboard ACK?
  2706                                                          je      irq1.exit                                       ;yes, branch
  2707                                                          cmp     al,0FCh                                         ;keyboard NAK?
  2708                                                          je      irq1.exit                                       ;yes, branch
  2709                                                          mov     [esi+KEYBDATA.scan0],al                         ;save scan code 0
  2710                                  ;
  2711                                  ;       If the 1st scan code is e1, take the 2nd and 3rd scan code. Use the 3rd scan code.
  2712                                  ;
  2713                                                          cmp     al,EKEYBCODEEXT1                                ;extended scan code 1? (e1)
  2714                                                          jne     irq1.notext1                                    ;no, branch
  2715                                                          call    WaitForKeyOutBuffer                             ;controller timeout?
  2716                                                          jz      irq1.timeout                                    ;yes, skip ahead
  2717                                                          in      al,EKEYBPORTDATA                                ;read scan code
  2718                                                          mov     [esi+KEYBDATA.scan1],al                         ;save scan code 1 (1d)
  2719                                                          call    WaitForKeyOutBuffer                             ;controller timeout?
  2720                                                          jz      irq1.timeout                                    ;yes, skip ahead
  2721                                                          in      al,EKEYBPORTDATA                                ;read scan code
  2722                                                          mov     [esi+KEYBDATA.scan2],al                         ;save scan code 2 (45/c5)
  2723                                                          movzx   eax,al                                          ;expand scan code to index
  2724                                                          mov     al,[cs:tscan2ext+eax]                           ;translate scan code
  2725                                                          mov     [esi+KEYBDATA.scan],al                          ;save final scan code
  2726                                                          jmp     irq1.putkeydown                                 ;put key-down message
  2727                                  ;
  2728                                  ;       Handle keyboard read timeout. This should not occur under normal circumstances. Its occurrence suggests an error
  2729                                  ;       in the keyboard scan code handling. An error indicator will be shown in the OIA.
  2730                                  ;
  2731                                  irq1.timeout            mov     al,EKEYFTIMEOUT                                 ;keyboard controller timeout flag
  2732                                                          or      [esi+KEYBDATA.status],al                        ;set controller status
  2733                                                          jmp     irq1.putoia                                     ;continue
  2734                                  ;
  2735                                  ;       If the 1st scan code is e0, take the 2nd scan code. If the 2nd scan code is b7 get the 2nd pair.
  2736                                  ;
  2737                                  irq1.notext1            cmp     al,EKEYBCODEEXT0                                ;extended scan code 0?
  2738                                                          jne     irq1.notext0                                    ;no, branch
  2739                                                          call    WaitForKeyOutBuffer                             ;controller timeout?
  2740                                                          jz      irq1.timeout                                    ;yes, skip ahead
  2741                                                          in      al,EKEYBPORTDATA                                ;read scan code
  2742                                                          mov     [esi+KEYBDATA.scan1],al                         ;save scan code 1
  2743                                                          cmp     al,EKEYBPADASTERISKUP                           ;print-screen (b7)?
  2744                                                          jne     irq1.notprntscrn                                ;no, branch.
  2745                                  ;
  2746                                  ;       Get the second pair of scan-codes. Only the Print Screen key should generate a second pair.
  2747                                  ;
  2748                                                          call    WaitForKeyOutBuffer                             ;controller timeout?
  2749                                                          jz      irq1.timeout                                    ;yes, skip ahead
  2750                                                          in      al,EKEYBPORTDATA                                ;read scan code 2
  2751                                                          mov     [esi+KEYBDATA.scan2],al                         ;save scan code 2
  2752                                                          call    WaitForKeyOutBuffer                             ;controller timeout?
  2753                                                          jz      irq1.timeout                                    ;yes, skip ahead
  2754                                                          in      al,EKEYBPORTDATA                                ;read scan code 3
  2755                                                          mov     [esi+KEYBDATA.scan3],al                         ;save scan code 3
  2756                                                          mov     al,0F7h                                         ;print-screen up
  2757                                                          mov     [esi+KEYBDATA.scan],al                          ;save final scan code
  2758                                                          jmp     irq1.putkeydown                                 ;put key-down message and update OIA
  2759                                  ;
  2760                                  ;       Where needed, use the last scan code and resume above.
  2761                                  ;
  2762                                  irq1.uselastscan        mov     al,[esi+KEYBDATA.last]                          ;previous scan code
  2763                                                          or      al,EKEYBUP                                      ;set break bit
  2764                                                          mov     [esi+KEYBDATA.scan],al                          ;save as final scan code
  2765                                                          jmp     irq1.checkchar                                  ;continue
  2766                                  ;
  2767                                  ;       Some num-lock + extended key combinations return a shift or num-lock make code. Here we need to rely on the
  2768                                  ;       previous scan code to determine what key is in break mode.
  2769                                  ;
  2770                                  irq1.notprntscrn        cmp     al,EKEYBSHIFTLDOWN                              ;left-shift down (2a)? left-shift
  2771                                                          je      irq1.uselastscan                                ;yes, use last scan
  2772                                                          cmp     al,EKEYBSHIFTLUP                                ;left-shift up (aa)? num-lock
  2773                                                          je      irq1.uselastscan                                ;yes, use last scan
  2774                                                          cmp     al,EKEYBSHIFTRDOWN                              ;right-shift down (36)? right-shift
  2775                                                          je      irq1.uselastscan
  2776                                  ;
  2777                                  ;       All remaining extended codes can be translated. Additionally, some extended scan codes set or reset shift flags
  2778                                  ;       or toggle locks.
  2779                                  ;
  2780                                                          movzx   eax,al                                          ;extend scan code to table index
  2781                                                          mov     al,[cs:tscan2ext+eax]                           ;translate to alternate scan code
  2782                                                          mov     [esi+KEYBDATA.scan],al                          ;save final scan code
  2783                                                          mov     ah,EKEYFCTRLRIGHT                               ;right control flag
  2784                                                          cmp     al,EKEYBCTRLRUP                                 ;right control up?
  2785                                                          je      irq1.shiftclear                                 ;yes, reset flag
  2786                                                          cmp     al,EKEYBCTRLRDOWN                               ;right control down?
  2787                                                          je      irq1.shiftset                                   ;yes, set flag
  2788                                                          mov     ah,EKEYFALTRIGHT                                ;right alt flag
  2789                                                          cmp     al,EKEYBALTRUP                                  ;alt key up code?
  2790                                                          je      irq1.shiftclear                                 ;yes, reset flag
  2791                                                          cmp     al,EKEYBALTRDOWN                                ;alt key down code?
  2792                                                          je      irq1.shiftset                                   ;yes, set flag
  2793                                                          mov     ah,EKEYFWINLEFT                                 ;left win flag
  2794                                                          cmp     al,EKEYBWINLUP                                  ;left win up?
  2795                                                          je      irq1.shiftclear                                 ;yes, reset flag
  2796                                                          cmp     al,EKEYBWINLDOWN                                ;left win down?
  2797                                                          je      irq1.shiftset                                   ;yes, set flag
  2798                                                          mov     ah,EKEYFWINRIGHT                                ;right win flag
  2799                                                          cmp     al,EKEYBWINRUP                                  ;right win up?
  2800                                                          je      irq1.shiftclear                                 ;yes, reset flag
  2801                                                          cmp     al,EKEYBWINRDOWN                                ;right win down?
  2802                                                          je      irq1.shiftset                                   ;yes, set flag
  2803                                                          mov     ah,EKEYFLOCKINSERT                              ;insert flag
  2804                                                          cmp     al,EKEYBINSERTDOWN                              ;translated insert scan code?
  2805                                                          je      irq1.locktoggle                                 ;yes, branch
  2806                                  ;
  2807                                  ;       Extended scan codes for Delete and num-pad slash generate ASCII character codes.
  2808                                  ;
  2809                                  irq1.checkchar          and     al,EKEYBMAKECODEMASK                            ;mask out break bit
  2810                                                          mov     dl,EASCIIDELETE                                 ;ASCII delete
  2811                                                          cmp     al,EKEYBDELETEDOWN                              ;delete down?
  2812                                                          je      irq1.savechar                                   ;yes, branch
  2813                                                          mov     dl,EASCIISLASH                                  ;ASCII slash
  2814                                                          cmp     al,EKEYBPADSLASHDOWN                            ;keypad-slash down?
  2815                                                          jne     irq1.putkeydown                                 ;no, put key-down msg and update OIA
  2816                                  irq1.savechar           mov     [esi+KEYBDATA.char],dl                          ;store ASCII code
  2817                                                          jmp     irq1.putmessage                                 ;put char, key-down msg and upate OIA
  2818                                  ;
  2819                                  ;       Flip lock toggles if a toggle key (caps-lock, num-lock, scroll-lock, insert)
  2820                                  ;
  2821                                  irq1.locktoggle         xor     bh,ah                                           ;toggle lock flag
  2822                                                          mov     [esi+KEYBDATA.lock],bh                          ;save lock flags
  2823                                                          call    SetKeyboardLamps                                ;update keyboard lamps
  2824                                                          jmp     irq1.putoia                                     ;update OIA
  2825                                  ;
  2826                                  ;       Set/reset shift flags if a shift key (shift, alt, ctrl, windows)
  2827                                  ;
  2828                                  irq1.shiftset           or      bl,ah                                           ;set shift flag
  2829                                                          jmp     short irq1.shift                                ;skip ahead
  2830                                  irq1.shiftclear         not     ah                                              ;convert flag to mask
  2831                                                          and     bl,ah                                           ;reset shift flag
  2832                                  irq1.shift              mov     [esi+KEYBDATA.shift],bl                         ;save shift flags
  2833                                                          jmp     irq1.putoia                                     ;update OIA
  2834                                  ;
  2835                                  ;       Check for shift and lock keys first. Note: When num-lock is set, holding shift while pressing a num-pad causes
  2836                                  ;       a shift break (aa/b6) to be sent ahead of the num-pad key make code.
  2837                                  ;
  2838                                  irq1.notext0            mov     [esi+KEYBDATA.scan],al                          ;save final scan code
  2839                                                          mov     ah,EKEYFSHIFTLEFT                               ;left shift flag
  2840                                                          cmp     al,EKEYBSHIFTLUP                                ;left shift key up code?
  2841                                                          je      irq1.shiftclear                                 ;yes, reset flag
  2842                                                          cmp     al,EKEYBSHIFTLDOWN                              ;left shift key down code?
  2843                                                          je      irq1.shiftset                                   ;yes, set flag
  2844                                                          mov     ah,EKEYFSHIFTRIGHT                              ;right shift flag
  2845                                                          cmp     al,EKEYBSHIFTRUP                                ;right shift key up code?
  2846                                                          je      irq1.shiftclear                                 ;yes, reset flag
  2847                                                          cmp     al,EKEYBSHIFTRDOWN                              ;right shift key down code?
  2848                                                          je      irq1.shiftset                                   ;yes, set flag
  2849                                                          mov     ah,EKEYFCTRLLEFT                                ;left control flag
  2850                                                          cmp     al,EKEYBCTRLLUP                                 ;control key up code?
  2851                                                          je      irq1.shiftclear                                 ;yes, reset flag
  2852                                                          cmp     al,EKEYBCTRLLDOWN                               ;control key down code?
  2853                                                          je      irq1.shiftset                                   ;yes, set flag
  2854                                                          mov     ah,EKEYFALTLEFT                                 ;left alt flag
  2855                                                          cmp     al,EKEYBALTLUP                                  ;alt key up code?
  2856                                                          je      irq1.shiftclear                                 ;yes, reset flag
  2857                                                          cmp     al,EKEYBALTLDOWN                                ;alt key down code?
  2858                                                          je      irq1.shiftset                                   ;yes, set flag
  2859                                  ;
  2860                                  ;       Handle lock keys.
  2861                                  ;
  2862                                                          mov     ah,EKEYFLOCKCAPS                                ;caps-lock flag
  2863                                                          cmp     al,EKEYBCAPSDOWN                                ;caps-lock key down code?
  2864                                                          je      irq1.locktoggle                                 ;yes, toggle lamps and flags
  2865                                                          mov     ah,EKEYFLOCKNUM                                 ;num-lock flag
  2866                                                          cmp     al,EKEYBNUMDOWN                                 ;num-lock key down code?
  2867                                                          je      irq1.locktoggle                                 ;yes, toggle lamps and flags
  2868                                                          mov     ah,EKEYFLOCKSCROLL                              ;scroll-lock flag
  2869                                                          cmp     al,EKEYBSCROLLDOWN                              ;scroll-lock key down code?
  2870                                                          je      irq1.locktoggle                                 ;yes, toggle lamps and flags
  2871                                                          test    byte [esi+KEYBDATA.lock],EKEYFLOCKNUM           ;num-lock?
  2872                                                          jnz     irq1.translate                                  ;yes, branch
  2873                                                          mov     ah,EKEYFLOCKINSERT                              ;insert lock flag
  2874                                                          cmp     al,EKEYBPADINSERTDOWN                           ;keypad-insert down?
  2875                                                          je      irq1.locktoggle                                 ;yes, toggle lamps and flags
  2876                                  ;
  2877                                  ;       Get base or shifted ASCII char.
  2878                                  ;
  2879                                  irq1.translate          and     al,EKEYBMAKECODEMASK                            ;make code
  2880                                                          movzx   eax,al                                          ;table index
  2881                                                          mov     edx,tscan2ascii                                 ;base table
  2882                                                          test    byte [esi+KEYBDATA.shift],EKEYFSHIFT            ;left or right shift?
  2883                                                          jz      irq1.getchar                                    ;no, branch
  2884                                                          mov     edx,tscan2shift                                 ;shift rable
  2885                                  irq1.getchar            mov     al,[cs:edx+eax]                                 ;ASCII code
  2886                                  ;
  2887                                  ;       Check if caps-lock and alphabetic.
  2888                                  ;
  2889                                                          test    byte [esi+KEYBDATA.lock],EKEYFLOCKCAPS          ;caps-lock?
  2890                                                          jz      irq1.checknum                                   ;no, branch
  2891                                                          cmp     al,EASCIIUPPERA                                 ;caps range (low)
  2892                                                          jb      irq1.checknum                                   ;branch if non-alpha
  2893                                                          cmp     al,EASCIIUPPERZ                                 ;caps range (high)
  2894                                                          jbe     irq1.swapcase                                   ;branch if alpha
  2895                                                          cmp     al,EASCIILOWERA                                 ;base range (low)
  2896                                                          jb      irq1.checknum                                   ;branch if non-alpha
  2897                                                          cmp     al,EASCIILOWERZ                                 ;base range (high)
  2898                                                          ja      irq1.checknum                                   ;branch if alpha
  2899                                  ;
  2900                                  ;       If caps-lock is enabled and the ASCII char is alphabetic, swap the ASCII case bit.
  2901                                  ;
  2902                                  irq1.swapcase           xor     al,020h                                         ;swap case bit
  2903                                                          mov     [esi+KEYBDATA.char],al                          ;save ASCII char code
  2904                                                          jmp     irq1.putmessage                                 ;put char, key-down msgs; update OIA
  2905                                  ;
  2906                                  ;       Check if num-lock and keypad numeral.
  2907                                  ;
  2908                                  irq1.checknum           test    byte [esi+KEYBDATA.lock],EKEYFLOCKNUM           ;num-lock?
  2909                                                          jz      irq1.notnum                                     ;no, branch
  2910                                                          mov     dl,[esi+KEYBDATA.scan]                          ;scan code
  2911                                                          and     dl,EKEYBMAKECODEMASK                            ;make code
  2912                                                          cmp     dl,EKEYBPAD7DOWN                                ;keypad numeral range (low)
  2913                                                          jb      irq1.notnum                                     ;branch if non-numeral
  2914                                                          cmp     dl,EKEYBPADDELETEDOWN                           ;keypad numeral range (high)
  2915                                                          ja      irq1.notnum                                     ;branch if non-numeral
  2916                                                          sub     dl,EKEYBPAD7DOWN                                ;lookup table index
  2917                                                          movzx   edx,dl                                          ;extend to register
  2918                                                          mov     al,[cs:tscankeypad+edx]                         ;translate to numeral equivalent
  2919                                  irq1.notnum             mov     [esi+KEYBDATA.char],al                          ;save ASCII character code
  2920                                  ;
  2921                                  ;       Put messages into the message queue.
  2922                                  ;
  2923                                  irq1.putmessage         mov     al,[esi+KEYBDATA.char]                          ;ASCII code
  2924                                                          mov     ah,[esi+KEYBDATA.scan]                          ;final scan code
  2925                                                          test    al,al                                           ;printable char?
  2926                                                          jz      irq1.putkeydown                                 ;no, skip ahead
  2927                                                          mov     edx,EMSGKEYCHAR                                 ;key-character event
  2928                                                          and     eax,0FFFFh                                      ;clear high-order word
  2929                                                          or      edx,eax                                         ;msg id and codes
  2930                                                          xor     ecx,ecx                                         ;null param
  2931                                                          call    PutMessage                                      ;put message to console
  2932                                  irq1.putkeydown         mov     al,[esi+KEYBDATA.char]                          ;ASCII char
  2933                                                          mov     ah,[esi+KEYBDATA.scan]                          ;final scan code
  2934                                                          mov     edx,EMSGKEYDOWN                                 ;assume key-down event
  2935                                                          test    ah,EKEYBUP                                      ;release scan-code?
  2936                                                          jz      irq1.makecode                                   ;no, skip ahead
  2937                                                          mov     edx,EMSGKEYUP                                   ;key-up event
  2938                                  irq1.makecode           and     eax,0FFFFh                                      ;clear high-order word
  2939                                                          or      edx,eax                                         ;msg id and codes
  2940                                                          xor     ecx,ecx                                         ;null param
  2941                                                          call    PutMessage                                      ;put message to console
  2942                                  ;
  2943                                  ;       Update operator information area. Enable maskable ints.
  2944                                  ;
  2945                                  irq1.putoia             call    PutConsoleOIA                                   ;OIA shift indicators
  2946                                  irq1.exit               sti                                                     ;enable maskable interrupts
  2947                                  ;
  2948                                  ;       Restore and return.
  2949                                  ;
  2950                                                          pop     ds                                              ;restore non-volatile regs
  2951                                                          pop     esi                                             ;
  2952                                                          pop     edx                                             ;
  2953                                                          pop     ecx                                             ;
  2954                                                          pop     ebx                                             ;
  2955                                                          pop     eax                                             ;
  2956                                                          iretd                                                   ;return
  2957                                  ;-----------------------------------------------------------------------------------------------------------------------
  2958                                  ;       Scan-Code to ASCII Translation Tables
  2959                                  ;-----------------------------------------------------------------------------------------------------------------------
  2960                                  ;
  2961                                  ;       Keypad directional to numeral
  2962                                  ;
  2963                                  tscankeypad             db      037h,038h,039h,02Dh,034h,035h,036h,02Bh         ;47-4e  789-456+
  2964                                                          db      031h,032h,033h,030h,02Eh                        ;4f-53  1230.
  2965                                  ;
  2966                                  ;       Scan Code to Extended Scan Code
  2967                                  ;
  2968                                  tscan2ext               db      000h,000h,000h,000h,000h,000h,000h,000h         ;00-07
  2969                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;08-0f
  2970                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;10-17
  2971                                                          db      000h,000h,000h,000h,07Ch,07Dh,000h,000h         ;18-1f  1c->7c,1d->7d
  2972                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;20-27
  2973                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;28-2f
  2974                                                          db      000h,000h,000h,000h,000h,075h,000h,077h         ;30-37  35->75,37->77
  2975                                                          db      078h,000h,000h,000h,000h,000h,000h,000h         ;38-3f  38->78
  2976                                                          db      000h,000h,000h,000h,000h,065h,066h,067h         ;40-47  45->65,46-66,47->67
  2977                                                          db      068h,069h,04Ah,06Bh,04Ch,06Dh,04Eh,06Fh         ;48-4f  48->68,49->69,4b->6b,4d->6d,4f->6f
  2978                                                          db      070h,071h,072h,073h,000h,000h,000h,000h         ;50-57  50->70,51->71,52->72,53->73
  2979                                                          db      000h,000h,000h,05Bh,05Ch,05Dh,000h,000h         ;58-5f  5b->5b,5c->5c,5d->5d
  2980                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;60-67
  2981                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;68-6f
  2982                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;70-77
  2983                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;78-7f
  2984                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;80-87
  2985                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;88-8f
  2986                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;90-97
  2987                                                          db      000h,000h,000h,000h,0FCh,0FDh,000h,000h         ;98-9f  9c->fc,9d->fd
  2988                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;a0-a7
  2989                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;a8-af
  2990                                                          db      000h,000h,000h,000h,000h,0F5h,000h,0F7h         ;b0-b7  b5->f5,b7->f7
  2991                                                          db      0F8h,000h,000h,000h,000h,000h,000h,000h         ;b8-bf  b8->f8
  2992                                                          db      000h,000h,000h,000h,000h,0E5h,0E6h,0E7h         ;c0-c7  c5->e5,c6->e6,c7->e7
  2993                                                          db      0E8h,0E9h,0CAh,0EBh,0CCh,0EDh,0CEh,0EFh         ;c8-cf  c8->e8,c9->e9,cb->eb,cd->ed,cf->ef
  2994                                                          db      0F0h,0F1h,0F2h,0F3h,000h,000h,000h,000h         ;d0-d7  d0->f0,d1->f1,d2->f2,d3->f3
  2995                                                          db      000h,000h,000h,0DBh,0DCh,0DDh,0DEh,000h         ;d8-df  db->db,dc->dc,de->de
  2996                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;e0-e7
  2997                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;e8-ef
  2998                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;f0-f7
  2999                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;f8-ff
  3000                                  ;
  3001                                  ;       Scan Code to Base ASCII
  3002                                  ;
  3003                                  tscan2ascii             db      000h,01Bh,031h,032h,033h,034h,035h,036h         ;00-07
  3004                                                          db      037h,038h,039h,030h,02Dh,03Dh,008h,009h         ;08-0f
  3005                                                          db      071h,077h,065h,072h,074h,079h,075h,069h         ;10-17
  3006                                                          db      06Fh,070h,05Bh,05Dh,000h,000h,061h,073h         ;18-1f
  3007                                                          db      064h,066h,067h,068h,06Ah,06Bh,06Ch,03Bh         ;20-27
  3008                                                          db      027h,060h,000h,05Ch,07Ah,078h,063h,076h         ;28-2f
  3009                                                          db      062h,06Eh,06Dh,02Ch,02Eh,02Fh,000h,02Ah         ;30-37
  3010                                                          db      000h,020h,000h,000h,000h,000h,000h,000h         ;38-3f
  3011                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;40-47
  3012                                                          db      000h,000h,02Dh,000h,000h,000h,02Bh,000h         ;48-4f
  3013                                                          db      000h,000h,000h,07Fh,000h,000h,000h,000h         ;50-57
  3014                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;58-5f
  3015                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;60-67
  3016                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;68-6f
  3017                                                          db      000h,000h,000h,07Fh,000h,02Fh,000h,000h         ;70-77
  3018                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;78-7f
  3019                                  ;
  3020                                  ;       Scan Code to Shifted ASCII
  3021                                  ;
  3022                                  tscan2shift             db      000h,01Bh,021h,040h,023h,024h,025h,05Eh         ;80-87
  3023                                                          db      026h,02Ah,028h,029h,05Fh,02Bh,008h,009h         ;88-8f
  3024                                                          db      051h,057h,045h,052h,054h,059h,055h,049h         ;90-97
  3025                                                          db      04Fh,050h,07Bh,07Dh,000h,000h,041h,053h         ;98-9f
  3026                                                          db      044h,046h,047h,048h,04Ah,04Bh,04Ch,03Ah         ;a0-a7
  3027                                                          db      022h,07Eh,000h,07Ch,05Ah,058h,043h,056h         ;a8-af
  3028                                                          db      042h,04Eh,04Dh,03Ch,03Eh,03Fh,000h,02Ah         ;b0-b7
  3029                                                          db      000h,020h,000h,000h,000h,000h,000h,000h         ;b8-bf
  3030                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;c0-c7
  3031                                                          db      000h,000h,02Dh,000h,000h,000h,02Bh,000h         ;c8-cf
  3032                                                          db      000h,000h,000h,07Fh,000h,000h,000h,000h         ;d0-d7
  3033                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;d8-df
  3034                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;e0-e7
  3035                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;e8-ef
  3036                                                          db      000h,000h,000h,07Fh,000h,02Fh,000h,000h         ;f0-f7
  3037                                                          db      000h,000h,000h,000h,000h,000h,000h,000h         ;f8-ff
  3038                                  ;-----------------------------------------------------------------------------------------------------------------------
  3039                                  ;
  3040                                  ;       IRQ2    Secondary 8259A Cascade Hardware Interrupt
  3041                                  ;
  3042                                  ;-----------------------------------------------------------------------------------------------------------------------
  3043                                                          menter  iochannel                                       ;secondary 8259A cascade
  3044                                                          push    eax                                             ;save modified regs
  3045                                                          jmp     hwint                                           ;end interrupt and return
  3046                                  ;-----------------------------------------------------------------------------------------------------------------------
  3047                                  ;
  3048                                  ;       IRQ3    Communication Port 2 Hardware Interrupt
  3049                                  ;
  3050                                  ;-----------------------------------------------------------------------------------------------------------------------
  3051                                                          menter  com2                                            ;serial port 2 interrupt
  3052                                                          push    eax                                             ;save modified regs
  3053                                                          jmp     hwint                                           ;end interrupt and return
  3054                                  ;-----------------------------------------------------------------------------------------------------------------------
  3055                                  ;
  3056                                  ;       IRQ4    Communication Port 1 Hardware Interrupt
  3057                                  ;
  3058                                  ;-----------------------------------------------------------------------------------------------------------------------
  3059                                                          menter  com1                                            ;serial port 1 interrupt
  3060                                                          push    eax                                             ;save modified regs
  3061                                                          jmp     hwint                                           ;end interrupt and return
  3062                                  ;-----------------------------------------------------------------------------------------------------------------------
  3063                                  ;
  3064                                  ;       IRQ5    Parallel Port 2 Hardware Interrupt
  3065                                  ;
  3066                                  ;-----------------------------------------------------------------------------------------------------------------------
  3067                                                          menter  lpt2                                            ;parallel port 2 interrupt
  3068                                                          push    eax                                             ;save modified regs
  3069                                                          jmp     hwint                                           ;end interrupt and return
  3070                                  ;-----------------------------------------------------------------------------------------------------------------------
  3071                                  ;
  3072                                  ;       IRQ6    Diskette Hardware Interrupt
  3073                                  ;
  3074                                  ;-----------------------------------------------------------------------------------------------------------------------
  3075                                                          menter  diskette                                        ;floppy disk interrupt
  3076                                                          push    eax                                             ;save non-volatile regs
  3077                                                          push    ds                                              ;
  3078                                                          call    PutPrimaryEndOfInt                              ;end the interrupt
  3079                                                          push    EGDTOSDATA                                      ;load OS data selector ...
  3080                                                          pop     ds                                              ;... into DS register
  3081                                                          mov     al,[wbFDCStatus]                                ;AL = FDC calibration status
  3082                                                          or      al,10000000b                                    ;set IRQ flag
  3083                                                          mov     [wbFDCStatus],al                                ;update FDC calibration status
  3084                                                          sti                                                     ;enable maskable interrupts
  3085                                                          pop     ds                                              ;restore non-volatile regs
  3086                                                          pop     eax                                             ;
  3087                                                          iretd                                                   ;return from interrupt
  3088                                  ;-----------------------------------------------------------------------------------------------------------------------
  3089                                  ;
  3090                                  ;       IRQ7    Parallel Port 1 Hardware Interrupt
  3091                                  ;
  3092                                  ;-----------------------------------------------------------------------------------------------------------------------
  3093                                                          menter  lpt1                                            ;parallel port 1 interrupt
  3094                                                          push    eax                                             ;save modified regs
  3095                                                          jmp     hwint                                           ;end interrupt and return
  3096                                  ;-----------------------------------------------------------------------------------------------------------------------
  3097                                  ;
  3098                                  ;       IRQ8    Real-time Clock Hardware Interrupt
  3099                                  ;
  3100                                  ;-----------------------------------------------------------------------------------------------------------------------
  3101                                                          menter  rtclock                                         ;real-time clock interrupt
  3102                                                          push    eax                                             ;save modified regs
  3103                                                          jmp     hwwint                                          ;end interrupt and return
  3104                                  ;-----------------------------------------------------------------------------------------------------------------------
  3105                                  ;
  3106                                  ;       IRQ9    CGA Vertical Retrace Hardware Interrupt
  3107                                  ;
  3108                                  ;-----------------------------------------------------------------------------------------------------------------------
  3109                                                          menter  retrace                                         ;CGA vertical retrace interrupt
  3110                                                          push    eax                                             ;save modified regs
  3111                                                          jmp     hwwint                                          ;end interrupt and return
  3112                                  ;-----------------------------------------------------------------------------------------------------------------------
  3113                                  ;
  3114                                  ;       IRQ10   Reserved Hardware Interrupt
  3115                                  ;
  3116                                  ;-----------------------------------------------------------------------------------------------------------------------
  3117                                                          menter  irq10                                           ;reserved
  3118                                                          push    eax                                             ;save modified regs
  3119                                                          jmp     hwwint                                          ;end interrupt and return
  3120                                  ;-----------------------------------------------------------------------------------------------------------------------
  3121                                  ;
  3122                                  ;       IRQ11   Reserved Hardware Interrupt
  3123                                  ;
  3124                                  ;-----------------------------------------------------------------------------------------------------------------------
  3125                                                          menter  irq11                                           ;reserved
  3126                                                          push    eax                                             ;save modified regs
  3127                                                          jmp     hwwint                                          ;end interrupt and return
  3128                                  ;-----------------------------------------------------------------------------------------------------------------------
  3129                                  ;
  3130                                  ;       IRQ12   PS/2 Mouse Hardware Interrupt
  3131                                  ;
  3132                                  ;-----------------------------------------------------------------------------------------------------------------------
  3133                                                          menter  ps2mouse                                        ;PS/2 mouse interrupt
  3134                                                          push    eax                                             ;save modified regs
  3135                                                          jmp     hwwint                                          ;end interrupt and return
  3136                                  ;-----------------------------------------------------------------------------------------------------------------------
  3137                                  ;
  3138                                  ;       IRQ13   Coprocessor Hardware Interrupt
  3139                                  ;
  3140                                  ;-----------------------------------------------------------------------------------------------------------------------
  3141                                                          menter  coprocessor                                     ;coprocessor interrupt
  3142                                                          push    eax                                             ;save modified regs
  3143                                                          jmp     hwwint                                          ;end interrupt and return
  3144                                  ;-----------------------------------------------------------------------------------------------------------------------
  3145                                  ;
  3146                                  ;       IRQ14   Fixed Disk Hardware Interrupt
  3147                                  ;
  3148                                  ;-----------------------------------------------------------------------------------------------------------------------
  3149                                                          menter  fixeddisk                                       ;fixed disk interrupt
  3150                                                          push    eax                                             ;save modified regs
  3151                                                          jmp     hwwint                                          ;end interrupt and return
  3152                                  ;-----------------------------------------------------------------------------------------------------------------------
  3153                                  ;
  3154                                  ;       IRQ15   Reserved Hardware Interrupt
  3155                                  ;
  3156                                  ;-----------------------------------------------------------------------------------------------------------------------
  3157                                                          menter  irq15                                           ;reserved
  3158                                                          push    eax                                             ;save modified regs
  3159                                                          jmp     hwwint                                          ;end interrupt and return
  3160                                  ;-----------------------------------------------------------------------------------------------------------------------
  3161                                  ;
  3162                                  ;       Exit from hardware interrupt
  3163                                  ;
  3164                                  ;-----------------------------------------------------------------------------------------------------------------------
  3165                                  hwwint                  call    PutSecondaryEndOfInt                            ;send EOI to secondary PIC
  3166                                                          jmp     hwint90                                         ;skip ahead
  3167                                  hwint                   call    PutPrimaryEndOfInt                              ;send EOI to primary PIC
  3168                                  hwint90                 sti                                                     ;enable maskable interrupts
  3169                                                          pop     eax                                             ;restore modified regs
  3170                                                          iretd                                                   ;return from interrupt
  3171                                  ;-----------------------------------------------------------------------------------------------------------------------
  3172                                  ;
  3173                                  ;       INT 30h Operating System Software Service Interrupt
  3174                                  ;
  3175                                  ;       Interrupt 30h is used by our operating system as an entry point for many commonly-used subroutines reusable by
  3176                                  ;       any task. These routines include low-level i/o functions that shield applications from having to handle
  3177                                  ;       device-specific communications. On entry to this interrupt, AL contains a function number that is used to load
  3178                                  ;       the entry address of the specific function from a table.
  3179                                  ;
  3180                                  ;-----------------------------------------------------------------------------------------------------------------------
  3181                                                          menter  svc
  3182                                                          cmp     al,maxtsvc                                      ;is our function out of range?
  3183                                                          jae     svc90                                           ;yes, skip ahead
  3184                                                          movzx   eax,al                                          ;function
  3185                                                          shl     eax,2                                           ;offset into table
  3186                                                          call    dword [cs:tsvc+eax]                             ;far call to indirect address
  3187                                  svc90                   iretd                                                   ;return from interrupt
  3188                                  ;-----------------------------------------------------------------------------------------------------------------------
  3189                                  ;
  3190                                  ;       Service Request Table
  3191                                  ;
  3192                                  ;
  3193                                  ;       These tsvce macros expand to define an address vector table for the service request interrupt (int 30h).
  3194                                  ;
  3195                                  ;-----------------------------------------------------------------------------------------------------------------------
  3196                                  tsvc                    tsvce   AllocateMemory                                  ;allocate memory block
  3197                                                          tsvce   CompareMemory                                   ;compare memory
  3198                                                          tsvce   DecimalToUnsigned                               ;convert decimal string to unsigned integer
  3199                                                          tsvce   FreeMemory                                      ;free memory block
  3200                                                          tsvce   GetConsoleMessage                               ;get message
  3201                                                          tsvce   HexadecimalToUnsigned                           ;convert hexadecimal string to unsigned integer
  3202                                                          tsvce   PlaceCursor                                     ;place the cursor at the current loc
  3203                                                          tsvce   PutConsoleOIA                                   ;display the operator information area
  3204                                                          tsvce   ResetSystem                                     ;reset system using 8042 chip
  3205                                                          tsvce   SetKeyboardLamps                                ;turn keboard LEDs on or off
  3206                                                          tsvce   UnsignedToHexadecimal                           ;convert unsigned integer to hexadecimal string
  3207                                                          tsvce   UpperCaseString                                 ;upper-case string
  3208                                                          tsvce   Yield                                           ;yield to system
  3209                                  maxtsvc                 equ     ($-tsvc)/4                                      ;function out of range
  3210                                  ;-----------------------------------------------------------------------------------------------------------------------
  3211                                  ;
  3212                                  ;       Service Request Macros
  3213                                  ;
  3214                                  ;       These macros provide positional parameterization of service request calls.
  3215                                  ;
  3216                                  ;-----------------------------------------------------------------------------------------------------------------------
  3217                                  %macro                  allocateMemory 1
  3218                                                          mov     ecx,%1                                          ;bytes to allocate
  3219                                                          mov     al,eAllocateMemory                              ;allocate memory fn.
  3220                                                          int     _svc                                            ;invoke OS service
  3221                                  %endmacro
  3222                                  %macro                  compareMemory 0
  3223                                                          mov     al,eCompareMemory                               ;function code
  3224                                                          int     _svc                                            ;invoke OS service
  3225                                  %endmacro
  3226                                  %macro                  decimalToUnsigned 0
  3227                                                          mov     al,eDecimalToUnsigned                           ;function code
  3228                                                          int     _svc                                            ;invoke OS servie
  3229                                  %endmacro
  3230                                  %macro                  freeMemory 1
  3231                                                          mov     edx,%1                                          ;address of memory block
  3232                                                          mov     al,eFreeMemory                                  ;function code
  3233                                                          int     _svc                                            ;invoke OS service
  3234                                  %endmacro
  3235                                  %macro                  getConsoleMessage 0
  3236                                                          mov     al,eGetConsoleMessage                           ;function code
  3237                                                          int     _svc                                            ;invoke OS service
  3238                                  %endmacro
  3239                                  %macro                  hexadecimalToUnsigned 0
  3240                                                          mov     al,eHexadecimalToUnsigned                       ;function code
  3241                                                          int     _svc                                            ;invoke OS service
  3242                                  %endmacro
  3243                                  %macro                  placeCursor 0
  3244                                                          mov     al,ePlaceCursor                                 ;function code
  3245                                                          int     _svc                                            ;invoke OS service
  3246                                  %endmacro
  3247                                  %macro                  putConsoleOIA 0
  3248                                                          mov     al,ePutConsoleOIA                               ;function code
  3249                                                          int     _svc                                            ;invoke OS service
  3250                                  %endmacro
  3251                                  %macro                  resetSystem 0
  3252                                                          mov     al,eResetSystem                                 ;function code
  3253                                                          int     _svc                                            ;invoke OS service
  3254                                  %endmacro
  3255                                  %macro                  setKeyboardLamps 0
  3256                                                          mov     al,eSetKeyboardLamps                            ;function code
  3257                                                          int     _svc                                            ;invoke OS service
  3258                                  %endmacro
  3259                                  %macro                  unsignedToHexadecimal 0
  3260                                                          mov     al,eUnsignedToHexadecimal                       ;function code
  3261                                                          int     _svc                                            ;invoke OS service
  3262                                  %endmacro
  3263                                  %macro                  upperCaseString 0
  3264                                                          mov     al,eUpperCaseString                             ;function code
  3265                                                          int     _svc                                            ;invoke OS service
  3266                                  %endmacro
  3267                                  %macro                  yield 0
  3268                                                          mov     al,eYield                                       ;function code
  3269                                                          int     _svc                                            ;invoke OS service
  3270                                  %endmacro
  3271                                  ;=======================================================================================================================
  3272                                  ;
  3273                                  ;       Kernel Function Library
  3274                                  ;
  3275                                  ;=======================================================================================================================
  3276                                  ;=======================================================================================================================
  3277                                  ;
  3278                                  ;       Memory Helper Routines
  3279                                  ;
  3280                                  ;       AllocateMemory
  3281                                  ;       FreeMemory
  3282                                  ;
  3283                                  ;=======================================================================================================================
  3284                                  ;-----------------------------------------------------------------------------------------------------------------------
  3285                                  ;
  3286                                  ;       Routine:        AllocateMemory
  3287                                  ;
  3288                                  ;       Description:    This routine allocates a memory block for the given task.
  3289                                  ;
  3290                                  ;       In:             ECX     bytes of memory to allocate
  3291                                  ;
  3292                                  ;       Out:            EAX     !0      address of user portion of newly allocated memory block
  3293                                  ;                               0       unable to allocate memory
  3294                                  ;
  3295                                  ;-----------------------------------------------------------------------------------------------------------------------
  3296                                  AllocateMemory          push    ebx                                             ;save non-volatile regs
  3297                                                          push    ecx                                             ;
  3298                                                          push    esi                                             ;
  3299                                                          push    ds                                              ;
  3300                                  ;
  3301                                  ;       Address kernel memory structures
  3302                                  ;
  3303                                                          push    EGDTOSDATA                                      ;load OS data GDT selector ...
  3304                                                          pop     ds                                              ;... into data segment reg
  3305                                                          mov     esi,wsConsoleMemRoot                            ;memory root structure address
  3306                                  ;
  3307                                  ;       Set requested size to minimum block size if requested size is too small.
  3308                                  ;
  3309                                                          cmp     ecx,EMEMMINSIZE                                 ;is requested size too small?
  3310                                                          jae     .10                                             ;no, branch
  3311                                                          mov     ecx,EMEMMINSIZE                                 ;set requested size to minimum
  3312                                  .10                     add     ecx,EMEMBLOCKLEN                                ;add header block length
  3313                                  ;
  3314                                  ;       Find the first free memory block large enough to satisfy the request.
  3315                                  ;
  3316                                                          mov     eax,[esi+MEMROOT.firstfree]                     ;first free block ptr
  3317                                  .20                     test    eax,eax                                         ;end of free block chain?
  3318                                                          jz      .220                                            ;yes, branch
  3319                                                          cmp     ecx,[eax+MEMBLOCK.bytes]                        ;free block big enough?
  3320                                                          jbe     .30                                             ;yes, branch
  3321                                                          mov     eax,[eax+MEMBLOCK.nextblock]                    ;next free block addr
  3322                                                          jmp     .20                                             ;continue
  3323                                  ;-----------------------------------------------------------------------------------------------------------------------
  3324                                  ;
  3325                                  ;       Address the previous and next free memory blocks.
  3326                                  ;
  3327                                  .30                     mov     ebx,[eax+MEMBLOCK.previousblock]                ;previous free block addr
  3328                                                          mov     edx,[eax+MEMBLOCK.nextblock]                    ;next free block addr
  3329                                  ;
  3330                                  ;       Remove the free memory block from the forward free memory block chain.
  3331                                  ;
  3332                                                          test    ebx,ebx                                         ;any previous free memory block?
  3333                                                          jz      .40                                             ;no, branch
  3334                                                          mov     [ebx+MEMBLOCK.nextblock],edx                    ;remove free block from forwrad chain
  3335                                                          jmp     .50                                             ;continue
  3336                                  .40                     mov     [esi+MEMROOT.firstfree],edx                     ;next free is now also the first free
  3337                                  ;
  3338                                  ;       Remove the free memory block from the reverse free memory block chain.
  3339                                  ;
  3340                                  .50                     test    edx,edx                                         ;any next free memory block?
  3341                                                          jz      .60                                             ;no, branch
  3342                                                          mov     [edx+MEMBLOCK.previousblock],ebx                ;remove free block from reverse chain
  3343                                                          jmp     .70                                             ;continue
  3344                                  .60                     mov     [esi+MEMROOT.lastfree],ebx                      ;previous free is now also the last free
  3345                                  ;-----------------------------------------------------------------------------------------------------------------------
  3346                                  ;
  3347                                  ;       Determine if the free memory block can be split.
  3348                                  ;
  3349                                  .70                     mov     ebx,[eax+MEMBLOCK.bytes]                        ;size of free memory block
  3350                                                          sub     ebx,ecx                                         ;subtract requested memory size
  3351                                                          cmp     ebx,EMEMMINSIZE                                 ;remaining block can stand alone?
  3352                                                          jb      .150                                            ;no, branch
  3353                                  ;
  3354                                  ;       We know that our block can be split to create a new free memory block. We update the size of our free memory
  3355                                  ;       block to the requested memory size. We update the next contiguous block pointer to point just past the end
  3356                                  ;       of the requested memory size.
  3357                                  ;
  3358                                                          mov     [eax+MEMBLOCK.bytes],ecx                        ;shorten memory block size
  3359                                                          mov     edx,eax                                         ;memory block address
  3360                                                          add     edx,ecx                                         ;address new new next contig block
  3361                                                          mov     ecx,[eax+MEMBLOCK.nextcontig]                   ;next contig block address
  3362                                                          mov     [eax+MEMBLOCK.nextcontig],edx                   ;update next contig block address
  3363                                  ;
  3364                                  ;       If there is a next contiguous block, we update that memory block's previous contig pointer to point to the new
  3365                                  ;       free block we are splitting off. If there is no next contiguous block, we update the last contig block pointer.
  3366                                  ;
  3367                                                          jecxz   .80                                             ;no next contig, branch
  3368                                                          mov     [ecx+MEMBLOCK.previouscontig],edx               ;update previous contig pointer
  3369                                                          jmp     .90                                             ;continue
  3370                                  .80                     mov     [esi+MEMROOT.lastcontig],edx                    ;update last contig pointer
  3371                                  ;
  3372                                  ;       Now that the contig block pointers have been updated, we initialize the new free block members.
  3373                                  ;
  3374                                  .90                     mov     [edx+MEMBLOCK.bytes],ebx                        ;set the block size
  3375                                                          mov     [edx+MEMBLOCK.nextcontig],ecx                   ;set the next contig block addr
  3376                                                          mov     [edx+MEMBLOCK.previouscontig],eax               ;set the previous contig block addr
  3377                                                          mov     ebx,EMEMFREECODE                                ;free memory signature
  3378                                                          mov     [edx+MEMBLOCK.signature],ebx                    ;set the block signature
  3379                                                          xor     ebx,ebx                                         ;zero register
  3380                                                          mov     [edx+MEMBLOCK.reserved],ebx                     ;set reserved
  3381                                                          mov     [edx+MEMBLOCK.owner],ebx                        ;set the owner
  3382                                  ;
  3383                                  ;       Find the proper location in the free block chain for the new free block
  3384                                  ;
  3385                                                          mov     ebx,[edx+MEMBLOCK.bytes]                        ;free block size
  3386                                                          mov     ecx,[esi+MEMROOT.firstfree]                     ;first free block addr
  3387                                  .100                    jecxz   .110                                            ;branch if at end of chain
  3388                                                          cmp     ebx,[ecx+MEMBLOCK.bytes]                        ;new block smaller or equal?
  3389                                                          jbe     .110                                            ;yes, branch
  3390                                                          mov     ecx,[ecx+MEMBLOCK.nextblock]                    ;next free block addr
  3391                                                          jmp     .100                                            ;continue
  3392                                  ;
  3393                                  ;       Having found the proper location for our new free block, we store the address of the following free block, or
  3394                                  ;       zero if our new free block is larger than any other, as our next free block. Then, we take the address of our
  3395                                  ;       next block's previous block or the global last-free block as our new previous block and update the previous
  3396                                  ;       block of hte next block, if there is one.
  3397                                  ;
  3398                                  .110                    mov     [edx+MEMBLOCK.nextblock],ecx                    ;set the new free block's next ptr
  3399                                                          mov     ebx,[esi+MEMROOT.lastfree]                      ;last free block addr
  3400                                                          jecxz   .120                                            ;branch if no next block
  3401                                                          mov     ebx,[ecx+MEMBLOCK.previousblock]                ;next block's previous block
  3402                                                          mov     [ecx+MEMBLOCK.previousblock],edx                ;set the next block's previous block
  3403                                                          jmp     .130                                            ;continue
  3404                                  .120                    mov     [esi+MEMROOT.lastfree],edx                      ;set the new last free block
  3405                                  ;
  3406                                  ;       Store our previous block pointer. If we have a previous free block, update that block's next block pointer to
  3407                                  ;       point to the new block. Since the new block may now be the first or last user block, we update the first and/or
  3408                                  ;       last user block pointers if necessary.
  3409                                  ;
  3410                                  .130                    mov     [edx+MEMBLOCK.previousblock],ebx                ;set the previous block pointer
  3411                                                          test    ebx,ebx                                         ;is there a previous block?
  3412                                                          jz      .140                                            ;no, branch
  3413                                                          mov     [ebx+MEMBLOCK.nextblock],edx                    ;set the previous block's next ptr
  3414                                                          jmp     .150                                            ;continue
  3415                                  .140                    mov     [esi+MEMROOT.firstfree],edx                     ;set the new first free ptr
  3416                                  ;
  3417                                  ;       Update the newly allocated block's owner and signature.
  3418                                  ;
  3419                                  .150                    mov     edx,EMEMUSERCODE                                ;user memory signature
  3420                                                          mov     [eax+MEMBLOCK.signature],edx                    ;set the block signature
  3421                                                          xor     edx,edx                                         ;zero register
  3422                                                          str     dx                                              ;load the task state register
  3423                                                          mov     [eax+MEMBLOCK.owner],edx                        ;set the block owner
  3424                                  ;
  3425                                  ;       Remove the allocated block from the free block chain and insert it into the user block chain.
  3426                                  ;
  3427                                                          mov     ecx,[esi+MEMROOT.firsttask]                     ;first task block
  3428                                  .160                    jecxz   .180                                            ;branch if at end of chain
  3429                                                          cmp     edx,[ecx+MEMBLOCK.owner]                        ;does this block belong to the task?
  3430                                                          jb      .180                                            ;branch if block belongs to next task
  3431                                                          je      .170                                            ;branch if block belongs to this task
  3432                                                          mov     ecx,[ecx+MEMBLOCK.nextblock]                    ;next task block
  3433                                                          jmp     .160                                            ;continue
  3434                                  ;
  3435                                  ;       We have found the start of our task's user block chain or the start of the next task's user block chain. If we
  3436                                  ;       have found the next task's chain, then we have no other user memory for this task and we can simply add the
  3437                                  ;       block here. If we are at the start of our task's user block chain, then we need to further seek for the proper
  3438                                  ;       place to insert the block.
  3439                                  ;
  3440                                  .170                    mov     edx,[eax+MEMBLOCK.bytes]                        ;size of block in bytes
  3441                                                          cmp     edx,[ecx+MEMBLOCK.bytes]                        ;less or equal to chain block?
  3442                                                          jbe     .180                                            ;yes, branch
  3443                                                          mov     ecx,[ecx+MEMBLOCK.nextblock]                    ;next chain block address
  3444                                                          test    ecx,ecx                                         ;end of chain?
  3445                                                          jz      .180                                            ;yes, branch
  3446                                                          mov     edx,[eax+MEMBLOCK.owner]                        ;owning task
  3447                                                          cmp     edx,[ecx+MEMBLOCK.owner]                        ;same task?
  3448                                                          je      .170                                            ;yes, continue search
  3449                                  ;
  3450                                  ;       We have found the proper place in our task's user-block chain to insert our new user block. It may also be the
  3451                                  ;       end of the user-block chain. To insert our new user block, first we update the next-block pointer. Then, we load
  3452                                  ;       the next-block's previous-block pointer or the global last-user block pointer if we have no next-block. If we
  3453                                  ;       do have a previous-block, we update that block's next-block pointer.
  3454                                  ;
  3455                                  .180                    mov     [eax+MEMBLOCK.nextblock],ecx                    ;set the next task block
  3456                                                          mov     ebx,[esi+MEMROOT.lasttask]                      ;last task block
  3457                                                          jecxz   .190                                            ;branch if no next-task block
  3458                                                          mov     ebx,[ecx+MEMBLOCK.previousblock]                ;next-task's previous-task block
  3459                                                          mov     [ecx+MEMBLOCK.previousblock],eax                ;update next-task block's previous-task
  3460                                                          jmp     .200                                            ;continue
  3461                                  .190                    mov     [esi+MEMROOT.lasttask],eax                      ;new block is the last user-block
  3462                                  ;
  3463                                  ;       Now wes tore our previous-block pointer and, if we have a previous-free block, we update that block's next-
  3464                                  ;       block pointer to point to our block. Since our block may now be the first or last user-block, we update the
  3465                                  ;       global first and/or last user-block pointers if necessary.
  3466                                  ;
  3467                                  .200                    mov     [eax+MEMBLOCK.previousblock],ebx                ;set the previous task block
  3468                                                          test    ebx,ebx                                         ;do we have a previous task block?
  3469                                                          jz      .210                                            ;no, branch
  3470                                                          mov     [ebx+MEMBLOCK.nextblock],eax                    ;set previous-block's next-task block
  3471                                                          jmp     .220                                            ;continue
  3472                                  .210                    mov     [esi+MEMROOT.firsttask],eax                     ;new block is the first user-block
  3473                                  ;
  3474                                  ;       Restore registers and return to caller.
  3475                                  ;
  3476                                  .220                    pop     ds                                              ;restore non-volatie regs
  3477                                                          pop     esi                                             ;
  3478                                                          pop     ecx                                             ;
  3479                                                          pop     ebx                                             ;
  3480                                                          ret                                                     ;return
  3481                                  ;-----------------------------------------------------------------------------------------------------------------------
  3482                                  ;
  3483                                  ;       Routine:        FreeMemory
  3484                                  ;
  3485                                  ;       Description:    This routine frees a memory block for the given task. The address provided in EDX points to the
  3486                                  ;                       memory block header. The memory block must be USER memory, not a FREE memory block. If the block
  3487                                  ;                       is adjacent to a contiguous FREE memory block, then the blocks are merged. The residual FREE
  3488                                  ;                       memory is repositioned in the FREE memory block chain according to size. The user portion of the
  3489                                  ;                       block, following the block header, is reset (wiped) with the memory wipe value.
  3490                                  ;
  3491                                  ;       In:             EDX     memory block to free, relative to EGDTOSDATA
  3492                                  ;
  3493                                  ;       Out:            EAX     -1      invalid memory block
  3494                                  ;                               0       memory block freed
  3495                                  ;
  3496                                  ;-----------------------------------------------------------------------------------------------------------------------
  3497                                  FreeMemory              push    ebx                                             ;save non-volatile regs
  3498                                                          push    ecx                                             ;
  3499                                                          push    esi                                             ;
  3500                                                          push    edi                                             ;
  3501                                                          push    ds                                              ;
  3502                                                          push    es                                              ;
  3503                                  ;
  3504                                  ;       Address the root memory structure
  3505                                  ;
  3506                                                          push    EGDTOSDATA                                      ;load OS data selector ...
  3507                                                          pop     es                                              ;... into extra segment reg
  3508                                                          push    EGDTOSDATA                                      ;load OS data selector ...
  3509                                                          pop     ds                                              ;... into data segment reg
  3510                                                          mov     esi,wsConsoleMemRoot                            ;memory root structure
  3511                                                          mov     edi,edx                                         ;memory block address
  3512                                  ;
  3513                                  ;       If the block is FREE, return success. Otherwise, if it is not USER, return with error.
  3514                                  ;
  3515                                                          xor     eax,eax                                         ;indicate success
  3516                                                          cmp     dword [edi+MEMBLOCK.signature],EMEMFREECODE     ;is the block FREE?
  3517                                                          je      .240                                            ;yes, branch
  3518                                                          dec     eax                                             ;indicate failure
  3519                                                          cmp     dword [edi+MEMBLOCK.signature],EMEMUSERCODE     ;is the block USER?
  3520                                                          jne     .240                                            ;no, branch
  3521                                  ;-----------------------------------------------------------------------------------------------------------------------
  3522                                  ;
  3523                                  ;       Unlink the USER memory block.
  3524                                  ;
  3525                                  ;-----------------------------------------------------------------------------------------------------------------------
  3526                                  ;
  3527                                  ;       Set the block signature. Reset owner.
  3528                                  ;
  3529                                                          mov     dword [edi+MEMBLOCK.signature],EMEMFREECODE     ;set FREE block signature
  3530                                                          xor     eax,eax                                         ;zero register
  3531                                                          mov     [edi+MEMBLOCK.owner],eax                        ;zero block owner
  3532                                  ;
  3533                                  ;       Wipe user area.
  3534                                  ;
  3535                                                          push    edi                                             ;save block address
  3536                                                          mov     ecx,[edi+MEMBLOCK.bytes]                        ;block size
  3537                                                          sub     ecx,EMEMBLOCKLEN                                ;subtract header size
  3538                                                          add     edi,EMEMBLOCKLEN                                ;point to user area
  3539                                                          mov     al,EMEMWIPEBYTE                                 ;memory wipe byte
  3540                                                          rep     stosb                                           ;clear memory
  3541                                                          pop     edi                                             ;restore block address
  3542                                  ;
  3543                                  ;       Address the preceding and following USER memory blocks
  3544                                  ;
  3545                                                          mov     ebx,[edi+MEMBLOCK.previousblock]                ;previous block pointer
  3546                                                          mov     ecx,[edi+MEMBLOCK.nextblock]                    ;next block pointer
  3547                                  ;
  3548                                  ;       If a USER block precedes this block, update that block's next pointer. Otherwise, update the first task
  3549                                  ;       pointer to point to the USER block following this block.
  3550                                  ;
  3551                                                          test    ebx,ebx                                         ;is there a previous block?
  3552                                                          jz      .10                                             ;no, branch
  3553                                                          mov     [ebx+MEMBLOCK.nextblock],ecx                    ;update previous block's next pointer
  3554                                                          jmp     .20                                             ;continue
  3555                                  .10                     mov     [esi+MEMROOT.firsttask],ecx                     ;update first USER pointer
  3556                                  ;
  3557                                  ;       If a USER block follows this block, update that block's previous pointer. Otherwise, update the last task
  3558                                  ;       pointer to point to the USER block preceding this block.
  3559                                  ;
  3560                                  .20                     jecxz   .30                                             ;branch if no next block
  3561                                                          mov     [ecx+MEMBLOCK.previousblock],ebx                ;update next block's previous pointer
  3562                                                          jmp     .40                                             ;continue
  3563                                  .30                     mov     [esi+MEMROOT.lasttask],ebx                      ;update last USER pointer
  3564                                  ;-----------------------------------------------------------------------------------------------------------------------
  3565                                  ;
  3566                                  ;       Merge with a previous contiguous FREE memory block.
  3567                                  ;
  3568                                  ;-----------------------------------------------------------------------------------------------------------------------
  3569                                  ;
  3570                                  ;       Address the preceding and following contiguous memory blocks.
  3571                                  ;
  3572                                  .40                     mov     ebx,[edi+MEMBLOCK.previouscontig]               ;previous contiguous block ptr
  3573                                                          mov     ecx,[edi+MEMBLOCK.nextcontig]                   ;next contiguous block ptr
  3574                                  ;
  3575                                  ;       Verify we have a previous contiguous FREE block.
  3576                                  ;
  3577                                                          test    ebx,ebx                                         ;is there a previous block?
  3578                                                          jz      .100                                            ;no, branch
  3579                                                          cmp     dword [ebx+MEMBLOCK.signature],EMEMFREECODE     ;is the previous block FREE?
  3580                                                          jne     .100                                            ;no, branch
  3581                                  ;
  3582                                  ;       Update adjacent block's contiguous pointers.
  3583                                  ;
  3584                                                          mov     [ebx+MEMBLOCK.nextcontig],ecx                   ;update previous contig's next contig
  3585                                                          jecxz   .50                                             ;branch if no next contiguous block
  3586                                                          mov     [ecx+MEMBLOCK.previouscontig],ebx               ;update next congit's previous contig
  3587                                                          jmp     .60                                             ;continue
  3588                                  .50                     mov     [esi+MEMROOT.lastcontig],ebx                    ;update last contig pointer
  3589                                  ;
  3590                                  ;       Update the size of the merged FREE block.
  3591                                  ;
  3592                                  .60                     mov     eax,[edi+MEMBLOCK.bytes]                        ;current block size
  3593                                                          add     [ebx+MEMBLOCK.bytes],eax                        ;update previous block's size
  3594                                  ;
  3595                                  ;       Having merged our new free block into the previous free block, make the previous free block the current block
  3596                                  ;
  3597                                                          mov     ecx,EMEMBLOCKLEN                                ;block header length
  3598                                                          mov     al,EMEMWIPEBYTE                                 ;memory wipe byte
  3599                                                          rep     stosb                                           ;clear memory header
  3600                                                          mov     edi,ebx                                         ;current block is now previous block
  3601                                  ;-----------------------------------------------------------------------------------------------------------------------
  3602                                  ;
  3603                                  ;       Unlink the previous contiguous FREE memory block
  3604                                  ;
  3605                                  ;-----------------------------------------------------------------------------------------------------------------------
  3606                                  ;
  3607                                  ;       Address the preceding and following USER memory blocks
  3608                                  ;
  3609                                                          mov     ebx,[edi+MEMBLOCK.previousblock]                ;previous block pointer
  3610                                                          mov     ecx,[edi+MEMBLOCK.nextblock]                    ;next block pointer
  3611                                  ;
  3612                                  ;       Update the previous block's next-block pointer if there is a previous block. Otherwise, update the first free
  3613                                  ;       block pointer.
  3614                                  ;
  3615                                                          test    ebx,ebx                                         ;is there a previous block?
  3616                                                          jz      .70                                             ;no, branch
  3617                                                          mov     [ebx+MEMBLOCK.nextblock],ecx                    ;update previous block's next pointer
  3618                                                          jmp     .80                                             ;branch
  3619                                  .70                     mov     [esi+MEMROOT.firstfree],ecx                     ;update first FREE block pointer
  3620                                  ;
  3621                                  ;       Update the next block's previous-block pointer if there is a next block. Otherwise, update the last free block
  3622                                  ;       pointer.
  3623                                  ;
  3624                                  .80                     jecxz   .90                                             ;branch if no next block
  3625                                                          mov     [ecx+MEMBLOCK.previousblock],ebx                ;update next block's previous pointer
  3626                                                          jmp     .100                                            ;continue
  3627                                  .90                     mov     [esi+MEMROOT.lastfree],ebx                      ;update last FREE block pointer
  3628                                  ;-----------------------------------------------------------------------------------------------------------------------
  3629                                  ;
  3630                                  ;       Merge with a following contiguous FREE memory block.
  3631                                  ;
  3632                                  ;-----------------------------------------------------------------------------------------------------------------------
  3633                                  ;
  3634                                  ;       Verify we have a following contiguous FREE block.
  3635                                  ;
  3636                                  .100                    mov     ecx,[edi+MEMBLOCK.nextcontig]                   ;next contiguous block ptr
  3637                                                          jecxz   .170                                            ;branch if no next contiguous block
  3638                                                          cmp     dword [ecx+MEMBLOCK.signature],EMEMFREECODE     ;is the next-contiguous block free?
  3639                                                          jne     .170                                            ;no, branch
  3640                                  ;
  3641                                  ;       Add the size of the following adjacent FREE block to this block's size.
  3642                                  ;
  3643                                                          mov     eax,[ecx+MEMBLOCK.bytes]                        ;next contiguous (free) block size
  3644                                                          add     [edi+MEMBLOCK.bytes],eax                        ;add size to this block's size
  3645                                  ;
  3646                                  ;       Unlink the following contiguous FREE block from the contiguous block chain.
  3647                                  ;
  3648                                                          mov     eax,[ecx+MEMBLOCK.nextcontig]                   ;following block's next-contig ptr
  3649                                                          mov     [edi+MEMBLOCK.nextcontig],eax                   ;update this block's next-contig ptr
  3650                                                          test    eax,eax                                         ;does a block follow the next contig blk
  3651                                                          jz      .110                                            ;no, branch
  3652                                                          mov     [eax+MEMBLOCK.previouscontig],edi               ;update following block's prev contig
  3653                                                          jmp     .120                                            ;continue
  3654                                  .110                    mov     [esi+MEMROOT.lastcontig],edi                    ;update last contig block ptr
  3655                                  ;-----------------------------------------------------------------------------------------------------------------------
  3656                                  ;
  3657                                  ;       Unlink the following contiguous FREE memory block
  3658                                  ;
  3659                                  ;-----------------------------------------------------------------------------------------------------------------------
  3660                                  ;
  3661                                  ;       Unlink the following adjacent FREE block from the FREE block chain.
  3662                                  ;
  3663                                  .120                    push    edi                                             ;save this block
  3664                                                          mov     edi,ecx                                         ;next contiguous block
  3665                                                          push    ecx                                             ;save next contiguous block
  3666                                  ;
  3667                                  ;       Address the preceding and following USER memory blocks
  3668                                  ;
  3669                                                          mov     ebx,[edi+MEMBLOCK.previousblock]                ;next contig's previous block pointer
  3670                                                          mov     ecx,[edi+MEMBLOCK.nextblock]                    ;next contig's next block pointer
  3671                                  ;
  3672                                  ;       Update the previous block's next-block pointer if there is a previous block. Otherwise, update the first free
  3673                                  ;       block pointer.
  3674                                  ;
  3675                                                          test    ebx,ebx                                         ;is there a previous block?
  3676                                                          jz      .130                                            ;no, branch
  3677                                                          mov     [ebx+MEMBLOCK.nextblock],ecx                    ;update next contig's prev blk next-ptr
  3678                                                          jmp     .140                                            ;branch
  3679                                  .130                    mov     [esi+MEMROOT.firstfree],ecx                     ;update first FREE block pointer
  3680                                  ;
  3681                                  ;       Update the next block's previous-block pointer if there is a next block. Otherwise, update the last free block
  3682                                  ;       pointer.
  3683                                  ;
  3684                                  .140                    jecxz   .150                                            ;branch if no next block
  3685                                                          mov     [ecx+MEMBLOCK.previousblock],ebx                ;update next contig's next blk prev-ptr
  3686                                                          jmp     .160                                            ;continue
  3687                                  .150                    mov     [esi+MEMROOT.lastfree],ebx                      ;update last FREE block pointer
  3688                                  ;
  3689                                  ;       Clear next contiguous block's header
  3690                                  ;
  3691                                  .160                    pop     edi                                             ;next congiguous block pointer
  3692                                                          mov     ecx,EMEMBLOCKLEN                                ;memory block header length
  3693                                                          mov     al,EMEMWIPEBYTE                                 ;memory wipe byte
  3694                                                          rep     stosb                                           ;clear memory header
  3695                                                          pop     edi                                             ;this block's pointer
  3696                                  ;-----------------------------------------------------------------------------------------------------------------------
  3697                                  ;
  3698                                  ;       Insert the final FREE block back into the block chain.
  3699                                  ;
  3700                                  ;-----------------------------------------------------------------------------------------------------------------------
  3701                                  ;
  3702                                  ;       Walk the FREE memory chain until a block is found that is larger than or equal in size to the block being
  3703                                  ;       inserted. The block being inserted will be inserted before that block or after the last block found if none
  3704                                  ;       all are smaller in size.
  3705                                  ;
  3706                                  .170                    mov     ebx,[edi+MEMBLOCK.bytes]                        ;size of block
  3707                                                          mov     ecx,[esi+MEMROOT.firstfree]                     ;first free block ptr
  3708                                  .180                    jecxz   .190                                            ;exit if no ptr
  3709                                                          cmp     ebx,[ecx+MEMBLOCK.bytes]                        ;next block bigger?
  3710                                                          jb      .190                                            ;yes, branch
  3711                                                          mov     ecx,[ecx+MEMBLOCK.nextblock]                    ;next free memory block
  3712                                                          jmp     .180                                            ;continue
  3713                                  ;
  3714                                  ;       Set the next-block pointer. Determine the previous-block, which may be the last FREE block if we found no
  3715                                  ;       larger free block. Update the next block's previous block pointer.
  3716                                  ;
  3717                                  .190                    mov     [edi+MEMBLOCK.nextblock],ecx                    ;set the next block ptr
  3718                                                          mov     ebx,[esi+MEMROOT.lastfree]                      ;assume all blocks smaller
  3719                                                          jecxz   .200                                            ;branch if no block found
  3720                                                          mov     ebx,[ecx+MEMBLOCK.previousblock]                ;next block's previous block ptr
  3721                                                          mov     [ecx+MEMBLOCK.previousblock],edi                ;update next block's previous ptr
  3722                                                          jmp     .210                                            ;continue
  3723                                  .200                    mov     [esi+MEMROOT.lastfree],edi                      ;this block is now the last free
  3724                                  ;
  3725                                  ;       Set our previous block pointer to either the previous pointer of the found block or the last free block.
  3726                                  ;       If there is no previous block pointer, then this block now the first FREE block. Otherwise update that block's
  3727                                  ;       next pointer.
  3728                                  ;
  3729                                  .210                    mov     [edi+MEMBLOCK.previousblock],ebx                ;set the previous block ptr
  3730                                                          test    ebx,ebx                                         ;do we have a previous block?
  3731                                                          jz      .220                                            ;no, branch
  3732                                                          mov     [ebx+MEMBLOCK.nextblock],edi                    ;update previous block's next block ptr
  3733                                                          jmp     .230                                            ;continue
  3734                                  .220                    mov     [esi+MEMROOT.firstfree],edi                     ;update first free ptr
  3735                                  ;
  3736                                  ;       The memory free has completed.
  3737                                  ;
  3738                                  .230                    xor     eax,eax                                         ;indicate success
  3739                                  ;
  3740                                  ;       Restore and return.
  3741                                  ;
  3742                                  .240                    pop     es                                              ;restore non-volatile regs
  3743                                                          pop     ds                                              ;
  3744                                                          pop     edi                                             ;
  3745                                                          pop     esi                                             ;
  3746                                                          pop     ecx                                             ;
  3747                                                          pop     ebx                                             ;
  3748                                                          ret                                                     ;return
  3749                                  ;=======================================================================================================================
  3750                                  ;
  3751                                  ;       String Helper Routines
  3752                                  ;
  3753                                  ;       CompareMemory
  3754                                  ;       UpperCaseString
  3755                                  ;
  3756                                  ;=======================================================================================================================
  3757                                  ;-----------------------------------------------------------------------------------------------------------------------
  3758                                  ;
  3759                                  ;       Routine:        CompareMemory
  3760                                  ;
  3761                                  ;       Description:    This routine compares two byte arrays.
  3762                                  ;
  3763                                  ;       In:             DS:EDX  first source address
  3764                                  ;                       DS:EBX  second source address
  3765                                  ;                       ECX     comparison length
  3766                                  ;
  3767                                  ;       Out:            EDX     first source address
  3768                                  ;                       EBX     second source address
  3769                                  ;                       ECX     0       array 1 = array 2
  3770                                  ;                               <0      array 1 < array 2
  3771                                  ;                               >0      array 1 > array 2
  3772                                  ;
  3773                                  ;-----------------------------------------------------------------------------------------------------------------------
  3774                                  CompareMemory           push    esi                                             ;save non-volatile regs
  3775                                                          push    edi                                             ;
  3776                                                          push    es                                              ;
  3777                                                          push    ds                                              ;copy DS
  3778                                                          pop     es                                              ;... to ES
  3779                                                          mov     esi,edx                                         ;first source address
  3780                                                          mov     edi,ebx                                         ;second source address
  3781                                                          cld                                                     ;forward strings
  3782                                                          rep     cmpsb                                           ;compare bytes
  3783                                                          mov     al,0                                            ;default result
  3784                                                          jz      .10                                             ;branch if arrays equal
  3785                                                          mov     al,1                                            ;positive result
  3786                                                          jnc     .10                                             ;branch if target > source
  3787                                                          mov     al,-1                                           ;negative result
  3788                                  .10                     movsx   ecx,al                                          ;extend sign
  3789                                                          pop     es                                              ;restore non-volatile regs
  3790                                                          pop     edi                                             ;
  3791                                                          pop     esi                                             ;
  3792                                                          ret                                                     ;return
  3793                                  ;-----------------------------------------------------------------------------------------------------------------------
  3794                                  ;
  3795                                  ;       Routine:        UpperCaseString
  3796                                  ;
  3797                                  ;       Description:    This routine places all characters in the given string to upper case.
  3798                                  ;
  3799                                  ;       In:             DS:EDX  string address
  3800                                  ;
  3801                                  ;       Out:            EDX     string address
  3802                                  ;
  3803                                  ;-----------------------------------------------------------------------------------------------------------------------
  3804                                  UpperCaseString         push    esi                                             ;save non-volatile regs
  3805                                                          mov     esi,edx                                         ;string address
  3806                                                          cld                                                     ;forward strings
  3807                                  .10                     lodsb                                                   ;string character
  3808                                                          test    al,al                                           ;null?
  3809                                                          jz      .20                                             ;yes, skip ahead
  3810                                                          cmp     al,EASCIILOWERA                                 ;lower-case? (lower bounds)
  3811                                                          jb      .10                                             ;no, continue
  3812                                                          cmp     al,EASCIILOWERZ                                 ;lower-case? (upper bounds)
  3813                                                          ja      .10                                             ;no, continue
  3814                                                          and     al,EASCIICASEMASK                               ;mask for upper case
  3815                                                          mov     [esi-1],al                                      ;upper character
  3816                                                          jmp     .10                                             ;continue
  3817                                  .20                     pop     esi                                             ;restore non-volatile regs
  3818                                                          ret                                                     ;return
  3819                                  ;=======================================================================================================================
  3820                                  ;
  3821                                  ;       Console Helper Routines
  3822                                  ;
  3823                                  ;       GetConsoleMessage
  3824                                  ;       PutConsoleHexByte
  3825                                  ;       PutConsoleHexDword
  3826                                  ;       PutConsoleHexWord
  3827                                  ;       PutConsoleOIA
  3828                                  ;       Yield
  3829                                  ;
  3830                                  ;=======================================================================================================================
  3831                                  ;-----------------------------------------------------------------------------------------------------------------------
  3832                                  ;
  3833                                  ;       Routine:        GetConsoleMessage
  3834                                  ;
  3835                                  ;       Description:    This routine waits for the next message to be queued.
  3836                                  ;
  3837                                  ;       Out:            EAX     message params
  3838                                  ;
  3839                                  ;-----------------------------------------------------------------------------------------------------------------------
  3840                                  GetConsoleMessage.10    call    Yield                                           ;pass control or halt
  3841                                  GetConsoleMessage       call    GetMessage                                      ;get the next message
  3842                                                          test    eax,eax                                         ;do we have a message?
  3843                                                          jz      GetConsoleMessage.10                            ;no, continue
  3844                                                          ret                                                     ;return
  3845                                  ;-----------------------------------------------------------------------------------------------------------------------
  3846                                  ;
  3847                                  ;       Routine:        PutConsoleHexByte
  3848                                  ;
  3849                                  ;       Description:    This routine writes two ASCII characters to the console representing a byte value.
  3850                                  ;
  3851                                  ;       In:             AL      byte value
  3852                                  ;                       CL      column
  3853                                  ;                       CH      row
  3854                                  ;                       DS      OS data selector
  3855                                  ;                       ES      CGA selector
  3856                                  ;
  3857                                  ;-----------------------------------------------------------------------------------------------------------------------
  3858                                  PutConsoleHexByte       push    eax                                             ;save non-volatile regs
  3859                                                          shr     al,4                                            ;hi-order nybble
  3860                                                          call    .10                                             ;make ASCII and store
  3861                                                          pop     eax                                             ;byte value
  3862                                                          and     al,0Fh                                          ;lo-order nybble
  3863                                  .10                     or      al,EASCIIZERO                                   ;apply ASCII zone
  3864                                                          cmp     al,EASCIININE                                   ;numeric?
  3865                                                          jbe     .20                                             ;yes, skip ahead
  3866                                                          add     al,7                                            ;add ASCII offset for alpha
  3867                                  .20                     call    SetConsoleChar                                  ;display ASCII character
  3868                                                          ret                                                     ;return
  3869                                  ;-----------------------------------------------------------------------------------------------------------------------
  3870                                  ;
  3871                                  ;       Routine:        PutConsoleHexDword
  3872                                  ;
  3873                                  ;       Description:    This routine writes eight ASCII characters to the console representing a doubleword value.
  3874                                  ;
  3875                                  ;       In:             EAX     value
  3876                                  ;                       CL      column
  3877                                  ;                       CH      row
  3878                                  ;                       DS      OS data selector
  3879                                  ;                       ES      CGA selector
  3880                                  ;
  3881                                  ;-----------------------------------------------------------------------------------------------------------------------
  3882                                  PutConsoleHexDword      push    eax                                             ;save value
  3883                                                          shr     eax,16                                          ;high-order word
  3884                                                          call    PutConsoleHexWord                               ;display high-order word
  3885                                                          pop     eax                                             ;restore value
  3886                                                          call    PutConsoleHexWord                               ;display low-order word
  3887                                                          ret                                                     ;return
  3888                                  ;-----------------------------------------------------------------------------------------------------------------------
  3889                                  ;
  3890                                  ;       Routine:        PutConsoleHexWord
  3891                                  ;
  3892                                  ;       Description:    This routine writes four ASCII characters to the console representing a word value.
  3893                                  ;
  3894                                  ;       In:             EAX     value
  3895                                  ;                       CL      column
  3896                                  ;                       CH      row
  3897                                  ;                       DS      OS data selector
  3898                                  ;                       ES      CGA selector
  3899                                  ;
  3900                                  ;-----------------------------------------------------------------------------------------------------------------------
  3901                                  PutConsoleHexWord       push    eax                                             ;save value
  3902                                                          shr     eax,8                                           ;high-order byte
  3903                                                          call    PutConsoleHexByte                               ;display high-order byte
  3904                                                          pop     eax                                             ;restore value
  3905                                                          call    PutConsoleHexByte                               ;display low-order byte
  3906                                                          ret                                                     ;return
  3907                                  ;-----------------------------------------------------------------------------------------------------------------------
  3908                                  ;
  3909                                  ;       Routine:        PutConsoleOIA
  3910                                  ;
  3911                                  ;       Description:    This routine updates the Operator Information Area (OIA).
  3912                                  ;
  3913                                  ;       In:             DS      OS data selector
  3914                                  ;
  3915                                  ;       0         1         2         3         4         5         6         7
  3916                                  ;       01234567890123456789012345678901234567890123456789012345678901234567890123456789
  3917                                  ;       00112233  WSCA  XXAA                    C                         ASCW    ^CNS !
  3918                                  ;
  3919                                  ;-----------------------------------------------------------------------------------------------------------------------
  3920                                  PutConsoleOIA           push    ebx                                             ;save non-volatile regs
  3921                                                          push    ecx                                             ;
  3922                                                          push    esi                                             ;
  3923                                                          push    es                                              ;
  3924                                  ;
  3925                                  ;       Address OS data and video memory
  3926                                  ;
  3927                                                          push    EGDTCGA                                         ;load CGA selector ...
  3928                                                          pop     es                                              ;... into extra segment register
  3929                                  ;
  3930                                  ;       Display up to six keyboard scan codes
  3931                                  ;
  3932                                                          mov     esi,wsKeybData                                  ;keyboard data addr
  3933                                                          lea     esi,[esi+KEYBDATA.scan0]                        ;scan code 0
  3934                                                          xor     ebx,ebx                                         ;zero register
  3935                                                          mov     bh,ECONOIAROW                                   ;OIA row
  3936                                                          xor     ecx,ecx                                         ;zero register
  3937                                                          mov     cl,4                                            ;maximum scan code count
  3938                                  .10                     push    ecx                                             ;save remaining count
  3939                                                          mov     ecx,ebx                                         ;row, column
  3940                                                          lodsb                                                   ;read scan code
  3941                                                          test    al,al                                           ;scan code present?
  3942                                                          jz      .20                                             ;no, skip ahead
  3943                                                          call    PutConsoleHexByte                               ;display scan code
  3944                                                          jmp     .30                                             ;continue
  3945                                  .20                     mov     al,' '                                          ;ASCII space
  3946                                                          call    SetConsoleChar                                  ;display space
  3947                                                          mov     al,' '                                          ;ASCII space
  3948                                                          call    SetConsoleChar                                  ;display space
  3949                                  .30                     add     bl,2                                            ;next column (+2)
  3950                                                          pop     ecx                                             ;restore remaining
  3951                                                          loop    .10                                             ;next code
  3952                                  ;
  3953                                  ;       Display left shift, control, alt indicators
  3954                                  ;
  3955                                                          mov     esi,wsKeybData                                  ;keyboard data
  3956                                                          mov     ch,ECONOIAROW                                   ;OIA row
  3957                                                          mov     al,EASCIISPACE                                  ;ASCII space
  3958                                                          test    byte [esi+KEYBDATA.shift],EKEYFWINLEFT          ;left-windows?
  3959                                                          jz      .35                                             ;no, branch
  3960                                                          mov     al,'W'                                          ;yes, indicate with 'W'
  3961                                  .35                     mov     cl,10                                           ;indicator column
  3962                                                          call    SetConsoleChar                                  ;display ASCII indicator
  3963                                                          mov     al,EASCIISPACE                                  ;space is default character
  3964                                                          test    byte [esi+KEYBDATA.shift],EKEYFSHIFTLEFT        ;left-shift?
  3965                                                          jz      .40                                             ;no, skip ahead
  3966                                                          mov     al,'S'                                          ;yes, indicate with 'S'
  3967                                  .40                     mov     cl,11                                           ;indicator column
  3968                                                          call    SetConsoleChar                                  ;display ASCII character
  3969                                                          mov     al,EASCIISPACE                                  ;ASCII space
  3970                                                          test    byte [esi+KEYBDATA.shift],EKEYFCTRLLEFT         ;left-ctrl?
  3971                                                          jz      .50                                             ;no, skip ahead
  3972                                                          mov     al,'C'                                          ;yes, indicate with 'C'
  3973                                  .50                     mov     cl,12                                           ;indicator column
  3974                                                          call    SetConsoleChar                                  ;display ASCII character
  3975                                                          mov     al,EASCIISPACE                                  ;ASCII space
  3976                                                          test    byte [esi+KEYBDATA.shift],EKEYFALTLEFT          ;left-alt?
  3977                                                          jz      .60                                             ;no, skip ahead
  3978                                                          mov     al,'A'                                          ;yes, indicate with 'A'
  3979                                  .60                     mov     cl,13                                           ;indicator column
  3980                                                          call    SetConsoleChar                                  ;display ASCII character
  3981                                  ;
  3982                                  ;       We do not display left or right shift make or break codes even if they are stored as the final
  3983                                  ;       scan code because these are immediately sent after num-pad digits if both num-lock and scroll
  3984                                  ;       are enabled. We don not display the scan code and char code if the scan code is null.
  3985                                  ;
  3986                                                          mov     al,[esi+KEYBDATA.scan]                          ;final scan code
  3987                                                          test    al,al                                           ;null?
  3988                                                          jz      .65                                             ;yes, branch
  3989                                                          cmp     al,EKEYBSHIFTLDOWN                              ;left shift make?
  3990                                                          je      .65                                             ;yes, branch
  3991                                                          cmp     al,EKEYBSHIFTLUP                                ;left shift break?
  3992                                                          je      .65                                             ;yes, branch
  3993                                                          cmp     al,EKEYBSHIFTRDOWN                              ;right shift make?
  3994                                                          je      .65                                             ;yes, branch
  3995                                                          cmp     al,EKEYBSHIFTRUP                                ;right shift break?
  3996                                                          je      .65                                             ;yes, branch
  3997                                  ;
  3998                                  ;       Display scan code returned in messages.
  3999                                  ;
  4000                                                          mov     cl,16                                           ;column
  4001                                                          call    PutConsoleHexByte                               ;store hex byte
  4002                                                          mov     al,[esi+KEYBDATA.char]                          ;ASCII char
  4003                                                          mov     cl,18                                           ;column
  4004                                                          call    PutConsoleHexByte                               ;store hex byte
  4005                                  ;
  4006                                  ;       Display ASCII character.
  4007                                  ;
  4008                                  .65                     mov     al,[esi+KEYBDATA.char]                          ;ASCII char
  4009                                                          cmp     al,EASCIISPACE                                  ;printable? (lower-bounds)
  4010                                                          jb      .70                                             ;no, skip ahead
  4011                                                          cmp     al,EASCIITILDE                                  ;printable? (upper-bounds)
  4012                                                          jbe     .80                                             ;yes, branch
  4013                                  .70                     mov     al,EASCIISPACE                                  ;use space for non-printables
  4014                                  .80                     mov     ch,bh                                           ;OIA row
  4015                                                          mov     cl,40                                           ;character display column
  4016                                                          call    SetConsoleChar                                  ;display ASCII character
  4017                                  ;
  4018                                  ;       Display right alt, control, shift indicators
  4019                                  ;
  4020                                                          mov     al,EASCIISPACE                                  ;ASCII space
  4021                                                          test    byte [esi+KEYBDATA.shift],EKEYFALTRIGHT         ;right-alt?
  4022                                                          jz      .90                                             ;no, skip ahead
  4023                                                          mov     al,'A'                                          ;yes, indicate with 'A'
  4024                                  .90                     mov     cl,66                                           ;indicator column
  4025                                                          call    SetConsoleChar                                  ;display ASCII character
  4026                                                          mov     al,EASCIISPACE                                  ;ASCII space
  4027                                                          test    byte [esi+KEYBDATA.shift],EKEYFCTRLRIGHT        ;right-ctrl?
  4028                                                          jz      .100                                            ;no, skip ahead
  4029                                                          mov     al,'C'                                          ;yes, indicate with 'C'
  4030                                  .100                    mov     cl,67                                           ;indicator column
  4031                                                          call    SetConsoleChar                                  ;display ASCII character
  4032                                                          mov     al,EASCIISPACE                                  ;ASCII space
  4033                                                          test    byte [esi+KEYBDATA.shift],EKEYFSHIFTRIGHT       ;right-shift
  4034                                                          jz      .110                                            ;no, skip ahead
  4035                                                          mov     al,'S'                                          ;yes, indicate with 'S'
  4036                                  .110                    mov     cl,68                                           ;indicator column
  4037                                                          call    SetConsoleChar                                  ;display ASCII character
  4038                                                          mov     al,EASCIISPACE                                  ;ASCII space
  4039                                                          test    byte [esi+KEYBDATA.shift],EKEYFWINRIGHT         ;right-windows?
  4040                                                          jz      .115                                            ;no, branch
  4041                                                          mov     al,'W'                                          ;yes, indicate wiht 'W'
  4042                                  .115                    mov     cl,69                                           ;indicator column
  4043                                                          call    SetConsoleChar                                  ;display ASCII character
  4044                                  ;
  4045                                  ;       Display Insert, Caps, Scroll and Num-Lock indicators.
  4046                                  ;
  4047                                                          mov     al,EASCIISPACE                                  ;ASCII space
  4048                                                          test    byte [esi+KEYBDATA.lock],EKEYFLOCKINSERT        ;insert mode?
  4049                                                          jz      .120                                            ;no, branch
  4050                                                          mov     al,EASCIICARET                                  ;indicate with a caret '^'
  4051                                  .120                    mov     cl,74                                           ;indicoator column
  4052                                                          call    SetConsoleChar                                  ;display ASCII character
  4053                                                          mov     al,EASCIISPACE                                  ;ASCII space
  4054                                                          test    byte [esi+KEYBDATA.lock],EKEYFLOCKSCROLL        ;scroll-lock?
  4055                                                          jz      .130                                            ;no, skip ahead
  4056                                                          mov     al,'S'                                          ;yes, indicate with 'S'
  4057                                  .130                    mov     cl,75                                           ;indicator column
  4058                                                          call    SetConsoleChar                                  ;display ASCII character
  4059                                                          mov     al,EASCIISPACE                                  ;ASCII space
  4060                                                          test    byte [esi+KEYBDATA.lock],EKEYFLOCKNUM           ;num-lock?
  4061                                                          jz      .140                                            ;no, skip ahead
  4062                                                          mov     al,'N'                                          ;yes, indicate with 'N'
  4063                                  .140                    mov     cl,76                                           ;indicator column
  4064                                                          call    SetConsoleChar                                  ;display ASCII character
  4065                                                          mov     al,EASCIISPACE                                  ;ASCII space
  4066                                                          test    byte [esi+KEYBDATA.lock],EKEYFLOCKCAPS          ;caps-lock?
  4067                                                          jz      .150                                            ;no, skip ahead
  4068                                                          mov     al,'C'                                          ;yes, indicate with 'C'
  4069                                  .150                    mov     cl,77                                           ;indicator column
  4070                                                          call    SetConsoleChar                                  ;display ASCII character
  4071                                  ;
  4072                                  ;       Display timeout flag.
  4073                                  ;
  4074                                                          mov     al,EASCIISPACE                                  ;ASCII space
  4075                                                          test    byte [esi+KEYBDATA.status],EKEYFTIMEOUT         ;keyboard timeout?
  4076                                                          jz      .155                                            ;no, branch
  4077                                                          mov     al,'!'                                          ;ASCII indicator
  4078                                  .155                    mov     cl,79                                           ;indicator column
  4079                                                          call    SetConsoleChar                                  ;display ASCII character
  4080                                  ;
  4081                                  ;       Restore and return.
  4082                                  ;
  4083                                  .160                    pop     es                                              ;restore non-volatile regs
  4084                                                          pop     esi                                             ;
  4085                                                          pop     ecx                                             ;
  4086                                                          pop     ebx                                             ;
  4087                                                          ret                                                     ;return
  4088                                  ;-----------------------------------------------------------------------------------------------------------------------
  4089                                  ;
  4090                                  ;       Routine:        Yield
  4091                                  ;
  4092                                  ;       Description:    This routine passes control to the next ready task or enter halt.
  4093                                  ;
  4094                                  ;-----------------------------------------------------------------------------------------------------------------------
  4095                                  Yield                   sti                                                     ;enable maskagle interrupts
  4096                                                          hlt                                                     ;halt until external interrupt
  4097                                                          ret                                                     ;return
  4098                                  ;=======================================================================================================================
  4099                                  ;
  4100                                  ;       Data-Type Conversion Helper Routines
  4101                                  ;
  4102                                  ;       DecimalToUnsigned
  4103                                  ;       HexadecimalToUnsigned
  4104                                  ;       UnsignedToHexadecimal
  4105                                  ;
  4106                                  ;=======================================================================================================================
  4107                                  ;-----------------------------------------------------------------------------------------------------------------------
  4108                                  ;
  4109                                  ;       Routine:        DecimalToUnsigned
  4110                                  ;
  4111                                  ;       Description:    This routine returns an unsigned integer of the value of the input ASCIIZ decimal string.
  4112                                  ;
  4113                                  ;       Input:          DS:EDX  null-terminated decimal string address
  4114                                  ;
  4115                                  ;       Output:         EAX     unsigned integer value
  4116                                  ;
  4117                                  ;-----------------------------------------------------------------------------------------------------------------------
  4118                                  DecimalToUnsigned       push    esi                                             ;save non-volatile regs
  4119                                                          mov     esi,edx                                         ;source address
  4120                                                          xor     edx,edx                                         ;zero total
  4121                                  .10                     lodsb                                                   ;source byte
  4122                                                          cmp     al,','                                          ;comma?
  4123                                                          je      .10                                             ;yes, ignore
  4124                                                          test    al,al                                           ;end of string?
  4125                                                          jz      .30                                             ;yes, done
  4126                                                          cmp     al,'.'                                          ;decimal point?
  4127                                                          je      .30                                             ;yes, done
  4128                                                          cmp     al,'0'                                          ;numeral?
  4129                                                          jb      .20                                             ;no, invalid string
  4130                                                          cmp     al,'9'                                          ;numeral?
  4131                                                          ja      .20                                             ;no, invalid string
  4132                                                          and     al,00Fh                                         ;mask ASCII zone
  4133                                                          push    eax                                             ;save numeral
  4134                                                          shl     edx,1                                           ;total * 2
  4135                                                          mov     eax,edx                                         ;total * 2
  4136                                                          shl     edx,2                                           ;total * 8
  4137                                                          add     edx,eax                                         ;total * 10
  4138                                                          pop     eax                                             ;restore numeral
  4139                                                          add     edx,eax                                         ;accumulate decimal digit
  4140                                                          xor     eax,eax                                         ;zero register
  4141                                                          jmp     .10                                             ;next
  4142                                  .20                     xor     edx,edx                                         ;zero result on error
  4143                                  .30                     mov     eax,edx                                         ;result
  4144                                                          pop     esi                                             ;restore non-volatile regs
  4145                                                          ret                                                     ;return
  4146                                  ;-----------------------------------------------------------------------------------------------------------------------
  4147                                  ;
  4148                                  ;       Routine:        HexadecimalToUnsigned
  4149                                  ;
  4150                                  ;       Description:    This routine returns an unsigned integer of the value of the input ASCIIZ hexadecimal string.
  4151                                  ;
  4152                                  ;       Input:          DS:EDX  null-terminated hexadecimal string address
  4153                                  ;
  4154                                  ;       Output:         EAX     unsigned integer value
  4155                                  ;
  4156                                  ;-----------------------------------------------------------------------------------------------------------------------
  4157                                  HexadecimalToUnsigned   push    esi                                             ;save non-volatile regs
  4158                                                          mov     esi,edx                                         ;source address
  4159                                                          xor     edx,edx                                         ;zero register
  4160                                  .10                     lodsb                                                   ;source byte
  4161                                                          test    al,al                                           ;end of string?
  4162                                                          jz      .30                                             ;yes, branch
  4163                                                          cmp     al,'9'                                          ;hexadecimal?
  4164                                                          jna     .20                                             ;no, skip ahead
  4165                                                          sub     al,037h                                         ;'A' = 41h, less 37h = 0Ah
  4166                                  .20                     and     eax,00Fh                                        ;remove ascii zone
  4167                                                          shl     edx,4                                           ;previous total x 16
  4168                                                          add     edx,eax                                         ;add prior value x 16
  4169                                                          jmp     .10                                             ;next
  4170                                  .30                     mov     eax,edx                                         ;result
  4171                                                          pop     esi                                             ;restore non-volatile regs
  4172                                                          ret                                                     ;return
  4173                                  ;-----------------------------------------------------------------------------------------------------------------------
  4174                                  ;
  4175                                  ;       Routine:        UnsignedToHexadecimal
  4176                                  ;
  4177                                  ;       Description:    This routine creates an ASCIIZ string representing the hexadecimal value of binary input
  4178                                  ;
  4179                                  ;       Input:          DS:EDX  output buffer address
  4180                                  ;                       ECX     32-bit binary
  4181                                  ;
  4182                                  ;-----------------------------------------------------------------------------------------------------------------------
  4183                                  UnsignedToHexadecimal   push    edi                                             ;store non-volatile regs
  4184                                                          mov     edi,edx                                         ;output buffer address
  4185                                                          mov     edx,ecx                                         ;32-bit unsigned
  4186                                                          xor     ecx,ecx                                         ;zero register
  4187                                                          mov     cl,8                                            ;nybble count
  4188                                  .10                     rol     edx,4                                           ;next hi-order nybble in bits 0-3
  4189                                                          mov     al,dl                                           ;????bbbb
  4190                                                          and     al,00Fh                                         ;mask out bits 4-7
  4191                                                          or      al,EASCIIZERO                                   ;mask in ascii zone
  4192                                                          cmp     al,EASCIININE                                   ;A through F?
  4193                                                          jbe     .20                                             ;no, skip ahead
  4194                                                          add     al,7                                            ;41h through 46h
  4195                                  .20                     stosb                                                   ;store hexnum
  4196                                                          loop    .10                                             ;next nybble
  4197                                                          xor     al,al                                           ;zero reg
  4198                                                          stosb                                                   ;null terminate
  4199                                                          pop     edi                                             ;restore non-volatile regs
  4200                                                          ret                                                     ;return
  4201                                  ;=======================================================================================================================
  4202                                  ;
  4203                                  ;       Message Queue Helper Routines
  4204                                  ;
  4205                                  ;       GetMessage
  4206                                  ;       PutMessage
  4207                                  ;
  4208                                  ;=======================================================================================================================
  4209                                  ;-----------------------------------------------------------------------------------------------------------------------
  4210                                  ;
  4211                                  ;       Routine:        GetMessage
  4212                                  ;
  4213                                  ;       Description:    This routine reads and removes a message from the message queue.
  4214                                  ;
  4215                                  ;       Out:            EAX     lo-order message data
  4216                                  ;                       EDX     hi-order message data
  4217                                  ;
  4218                                  ;                       CY      0 = message read
  4219                                  ;                               1 = no message to read
  4220                                  ;
  4221                                  ;-----------------------------------------------------------------------------------------------------------------------
  4222                                  GetMessage              push    ebx                                             ;save non-volatile regs
  4223                                                          push    ecx                                             ;
  4224                                                          push    ds                                              ;
  4225                                                          push    ELDTMQ                                          ;load message queue selector ...
  4226                                                          pop     ds                                              ;... into data segment register
  4227                                                          mov     ebx,[MQHead]                                    ;head ptr
  4228                                                          mov     eax,[ebx]                                       ;lo-order 32 bits
  4229                                                          mov     edx,[ebx+4]                                     ;hi-order 32 bits
  4230                                                          or      eax,edx                                         ;is queue empty?
  4231                                                          stc                                                     ;assume queue is emtpy
  4232                                                          jz      .20                                             ;yes, skip ahead
  4233                                                          xor     ecx,ecx                                         ;store zero
  4234                                                          mov     [ebx],ecx                                       ;... in lo-order dword
  4235                                                          mov     [ebx+4],ecx                                     ;... in hi-order dword
  4236                                                          add     ebx,8                                           ;next queue element
  4237                                                          and     ebx,03FCh                                       ;at end of queue?
  4238                                                          jnz     .10                                             ;no, skip ahead
  4239                                                          mov     bl,8                                            ;reset to 1st entry
  4240                                  .10                     mov     [MQHead],ebx                                    ;save new head ptr
  4241                                                          clc                                                     ;indicate message read
  4242                                  .20                     pop     ds                                              ;restore non-volatile regs
  4243                                                          pop     ecx                                             ;
  4244                                                          pop     ebx                                             ;
  4245                                                          ret                                                     ;return
  4246                                  ;-----------------------------------------------------------------------------------------------------------------------
  4247                                  ;
  4248                                  ;       Routine:        PutMessage
  4249                                  ;
  4250                                  ;       Description:    This routine adds a message to the message queue.
  4251                                  ;
  4252                                  ;       In:             ECX     hi-order data word
  4253                                  ;                       EDX     lo-order data word
  4254                                  ;
  4255                                  ;       Out:            CY      0 = success
  4256                                  ;                               1 = fail: queue is full
  4257                                  ;
  4258                                  ;-----------------------------------------------------------------------------------------------------------------------
  4259                                  PutMessage              push    ds                                              ;save non-volatile regs
  4260                                                          push    ELDTMQ                                          ;load task message queue selector ...
  4261                                                          pop     ds                                              ;... into data segment register
  4262                                                          mov     eax,[MQTail]                                    ;tail ptr
  4263                                                          cmp     dword [eax],0                                   ;is queue full?
  4264                                                          stc                                                     ;assume failure
  4265                                                          jne     .20                                             ;yes, cannot store
  4266                                                          mov     [eax],edx                                       ;store lo-order data
  4267                                                          mov     [eax+4],ecx                                     ;store hi-order data
  4268                                                          add     eax,8                                           ;next queue element adr
  4269                                                          and     eax,03FCh                                       ;at end of queue?
  4270                                                          jnz     .10                                             ;no, skip ahead
  4271                                                          mov     al,8                                            ;reset to top of queue
  4272                                  .10                     mov     [MQTail],eax                                    ;save new tail ptr
  4273                                                          clc                                                     ;indicate success
  4274                                  .20                     pop     ds                                              ;restore non-volatile regs
  4275                                                          ret                                                     ;return
  4276                                  ;=======================================================================================================================
  4277                                  ;
  4278                                  ;       Memory-Mapped Video Routines
  4279                                  ;
  4280                                  ;       These routines read and/or write directly to CGA video memory (B800:0)
  4281                                  ;
  4282                                  ;       SetConsoleChar
  4283                                  ;       SetConsoleString
  4284                                  ;
  4285                                  ;=======================================================================================================================
  4286                                  ;-----------------------------------------------------------------------------------------------------------------------
  4287                                  ;
  4288                                  ;       Routine:        SetConsoleChar
  4289                                  ;
  4290                                  ;       Description:    This routine outputs an ASCII character at the given row and column.
  4291                                  ;
  4292                                  ;       In:             AL      ASCII character
  4293                                  ;                       CL      column
  4294                                  ;                       CH      row
  4295                                  ;                       ES      CGA selector
  4296                                  ;
  4297                                  ;       Out:            EAX     last target address written (ES:)
  4298                                  ;                       CL      column + 1
  4299                                  ;
  4300                                  ;-----------------------------------------------------------------------------------------------------------------------
  4301                                  SetConsoleChar          mov     dl,al                                           ;ASCII character
  4302                                                          movzx   eax,ch                                          ;row
  4303                                                          mov     ah,ECONCOLS                                     ;cols/row
  4304                                                          mul     ah                                              ;row * cols/row
  4305                                                          add     al,cl                                           ;add column
  4306                                                          adc     ah,0                                            ;handle carry
  4307                                                          shl     eax,1                                           ;screen offset
  4308                                                          mov     [es:eax],dl                                     ;store character
  4309                                                          inc     cl                                              ;next column
  4310                                                          ret                                                     ;return
  4311                                  ;-----------------------------------------------------------------------------------------------------------------------
  4312                                  ;
  4313                                  ;       Routine:        SetConsoleString
  4314                                  ;
  4315                                  ;       Description:    This routine outputs a sequence of ASCII character at the given row and column.
  4316                                  ;
  4317                                  ;       In:             ESI     source offset (DS:)
  4318                                  ;                       CL      column
  4319                                  ;                       CH      row
  4320                                  ;                       ES      CGA selector
  4321                                  ;
  4322                                  ;-----------------------------------------------------------------------------------------------------------------------
  4323                                  SetConsoleString        push    esi                                             ;save non-volatile regs
  4324                                                          cld                                                     ;forward strings
  4325                                  .10                     lodsb                                                   ;next ASCII character
  4326                                                          test    al,al                                           ;end of string?
  4327                                                          jz      .20                                             ;yes, branch
  4328                                                          call    SetConsoleChar                                  ;store character
  4329                                                          jmp     .10                                             ;continue
  4330                                  .20                     pop     esi                                             ;restore non-volatile regs
  4331                                                          ret                                                     ;return
  4332                                  ;=======================================================================================================================
  4333                                  ;
  4334                                  ;       Input/Output Routines
  4335                                  ;
  4336                                  ;       These routines read and/or write directly to ports.
  4337                                  ;
  4338                                  ;       PlaceCursor
  4339                                  ;       PutPrimaryEndOfInt
  4340                                  ;       PutSecondaryEndOfInt
  4341                                  ;       ResetSystem
  4342                                  ;       SetKeyboardLamps
  4343                                  ;       WaitForKeyInBuffer
  4344                                  ;       WaitForKeyOutBuffer
  4345                                  ;
  4346                                  ;=======================================================================================================================
  4347                                  ;-----------------------------------------------------------------------------------------------------------------------
  4348                                  ;
  4349                                  ;       Routine:        PlaceCursor
  4350                                  ;
  4351                                  ;       Description:    This routine positions the cursor on the console.
  4352                                  ;
  4353                                  ;       In:             DS      OS data selector
  4354                                  ;
  4355                                  ;-----------------------------------------------------------------------------------------------------------------------
  4356                                  PlaceCursor             push    ecx                                             ;save non-volatile regs
  4357                                                          mov     al,[wbConsoleRow]                               ;AL = row
  4358                                                          mov     ah,ECONCOLS                                     ;AH = cols/row
  4359                                                          mul     ah                                              ;row offset
  4360                                                          add     al,[wbConsoleColumn]                            ;add column
  4361                                                          adc     ah,0                                            ;add overflow
  4362                                                          mov     ecx,eax                                         ;screen offset
  4363                                                          mov     dl,ECRTPORTLO                                   ;crt controller port lo
  4364                                                          mov     dh,ECRTPORTHI                                   ;crt controller port hi
  4365                                                          mov     al,ECRTCURLOCHI                                 ;crt cursor loc reg hi
  4366                                                          out     dx,al                                           ;select register
  4367                                                          inc     edx                                             ;data port
  4368                                                          mov     al,ch                                           ;hi-order cursor loc
  4369                                                          out     dx,al                                           ;store hi-order loc
  4370                                                          dec     edx                                             ;register select port
  4371                                                          mov     al,ECRTCURLOCLO                                 ;crt cursor loc reg lo
  4372                                                          out     dx,al                                           ;select register
  4373                                                          inc     edx                                             ;data port
  4374                                                          mov     al,cl                                           ;lo-order cursor loc
  4375                                                          out     dx,al                                           ;store lo-order loc
  4376                                                          pop     ecx                                             ;restore non-volatile regs
  4377                                                          ret                                                     ;return
  4378                                  ;-----------------------------------------------------------------------------------------------------------------------
  4379                                  ;
  4380                                  ;       Routine:        PutPrimaryEndOfInt
  4381                                  ;
  4382                                  ;       Description:    This routine sends a non-specific end-of-interrupt signal to the primary PIC.
  4383                                  ;
  4384                                  ;-----------------------------------------------------------------------------------------------------------------------
  4385                                  PutPrimaryEndOfInt      mov     al,EPICEOI                                      ;non-specific end-of-interrupt
  4386                                                          out     EPICPORTPRI,al                                  ;send EOI to primary PIC
  4387                                                          ret                                                     ;return
  4388                                  ;-----------------------------------------------------------------------------------------------------------------------
  4389                                  ;
  4390                                  ;       Routine:        PutSecondaryEndOfInt
  4391                                  ;
  4392                                  ;       Description:    This routine sends a non-specific end-of-interrupt signal to the secondary PIC.
  4393                                  ;
  4394                                  ;-----------------------------------------------------------------------------------------------------------------------
  4395                                  PutSecondaryEndOfInt    mov     al,EPICEOI                                      ;non-specific end-of-interrupt
  4396                                                          out     EPICPORTSEC,al                                  ;send EOI to secondary PIC
  4397                                                          ret                                                     ;return
  4398                                  ;-----------------------------------------------------------------------------------------------------------------------
  4399                                  ;
  4400                                  ;       Routine:        ResetSystem
  4401                                  ;
  4402                                  ;       Description:    This routine restarts the system using the 8042 controller.
  4403                                  ;
  4404                                  ;       Out:            N/A     This routine does not return.
  4405                                  ;
  4406                                  ;-----------------------------------------------------------------------------------------------------------------------
  4407                                  ResetSystem             mov     ecx,001fffffh                                   ;delay to clear ints
  4408                                                          loop    $                                               ;clear interrupts
  4409                                                          mov     al,EKEYBCMDRESET                                ;mask out bit zero
  4410                                                          out     EKEYBPORTSTAT,al                                ;drive bit zero low
  4411                                  .10                     sti                                                     ;enable maskable interrupts
  4412                                                          hlt                                                     ;halt until interrupt
  4413                                                          jmp     .10                                             ;repeat until reset kicks in
  4414                                  ;-----------------------------------------------------------------------------------------------------------------------
  4415                                  ;
  4416                                  ;       Routine:        SetKeyboardLamps
  4417                                  ;
  4418                                  ;       Description:    This routine sends the set/reset mode indicators command to the keyboard device.
  4419                                  ;
  4420                                  ;       In:             BH      00000CNS (C:Caps Lock,N:Num Lock,S:Scroll Lock)
  4421                                  ;
  4422                                  ;-----------------------------------------------------------------------------------------------------------------------
  4423                                  SetKeyboardLamps        push    ebx                                             ;save non-volatile regs
  4424                                                          push    esi                                             ;
  4425                                                          mov     esi,wsKeybData                                  ;keyboard data addr
  4426                                                          mov     bh,[esi+KEYBDATA.lock]                          ;lock flags
  4427                                                          call    WaitForKeyInBuffer                              ;wait for input buffer ready
  4428                                                          mov     al,EKEYBCMDLAMPS                                ;set/reset lamps command
  4429                                                          out     EKEYBPORTDATA,al                                ;send command to 8042
  4430                                                          call    WaitForKeyOutBuffer                             ;wait for 8042 result
  4431                                                          in      al,EKEYBPORTDATA                                ;read 8042 'ACK' (0fah)
  4432                                                          call    WaitForKeyInBuffer                              ;wait for input buffer ready
  4433                                                          mov     al,bh                                           ;set/reset lamps value
  4434                                                          and     al,7                                            ;mask for lamp switches
  4435                                                          out     EKEYBPORTDATA,al                                ;send lamps value
  4436                                                          call    WaitForKeyOutBuffer                             ;wait for 8042 result
  4437                                                          in      al,EKEYBPORTDATA                                ;read 8042 'ACK' (0fah)
  4438                                                          pop     esi                                             ;restore non-volatile regs
  4439                                                          pop     ebx                                             ;
  4440                                                          ret                                                     ;return
  4441                                  ;-----------------------------------------------------------------------------------------------------------------------
  4442                                  ;
  4443                                  ;       Routine:        WaitForKeyInBuffer
  4444                                  ;
  4445                                  ;       Description:    This routine waits for keyboard input buffer to be ready for input.
  4446                                  ;
  4447                                  ;       Out:            ZF      1 = Input buffer ready
  4448                                  ;                               0 = Input buffer not ready after timeout
  4449                                  ;
  4450                                  ;-----------------------------------------------------------------------------------------------------------------------
  4451                                  WaitForKeyInBuffer      push    ecx                                             ;save non-volatile regs
  4452                                                          mov     ecx,EKEYBWAITLOOP                               ;keyboard controller timeout
  4453                                  .10                     in      al,EKEYBPORTSTAT                                ;keyboard status byte
  4454                                                          test    al,EKEYBBITIN                                   ;is input buffer still full?
  4455                                                          loopnz  .10                                             ;yes, repeat till timeout
  4456                                                          pop     ecx                                             ;restore non-volatile regs
  4457                                                          ret                                                     ;return
  4458                                  ;-----------------------------------------------------------------------------------------------------------------------
  4459                                  ;
  4460                                  ;       Routine:        WaitForKeyOutBuffer
  4461                                  ;
  4462                                  ;       Description:    This routine waits for keyboard output buffer to have data to read.
  4463                                  ;
  4464                                  ;       Out:            ZF      1 = Output buffer has data from controller
  4465                                  ;                               0 = Output buffer empty after timeout
  4466                                  ;
  4467                                  ;-----------------------------------------------------------------------------------------------------------------------
  4468                                  WaitForKeyOutBuffer     push    ecx                                             ;save non-volatile regs
  4469                                                          mov     ecx,EKEYBWAITLOOP                               ;keyboard controller timeout
  4470                                  .10                     in      al,EKEYBPORTSTAT                                ;keyboard status byte
  4471                                                          test    al,EKEYBBITOUT                                  ;output buffer status bit
  4472                                                          loopz   .10                                             ;loop until output buffer bit
  4473                                                          pop     ecx                                             ;restore non-volatile regs
  4474                                                          ret                                                     ;return
  4475                                  ;-----------------------------------------------------------------------------------------------------------------------
  4476                                  ;
  4477                                  ;       End of the Kernel Function Library
  4478                                  ;
  4479                                  ;-----------------------------------------------------------------------------------------------------------------------
  4480                                                          times   8192-($-$$) db 0h                               ;zero fill to end of section
  4481                                  ;=======================================================================================================================
  4482                                  ;
  4483                                  ;       Console Task
  4484                                  ;
  4485                                  ;       The only task defined in the kernel is the console task. This task consists of code, data, stack, and task state
  4486                                  ;       segments and a local descriptor table. The console task accepts and echos user keyboard input to the console
  4487                                  ;       screen and responds to user commands.
  4488                                  ;
  4489                                  ;=======================================================================================================================
  4490                                  ;-----------------------------------------------------------------------------------------------------------------------
  4491                                  ;
  4492                                  ;       Console Stack                                                           @disk: 007600   @mem:  004000
  4493                                  ;
  4494                                  ;       This is the stack for the console task. It supports 448 nested calls.
  4495                                  ;
  4496                                  ;-----------------------------------------------------------------------------------------------------------------------
  4497                                  section                 constack                                                ;console task stack
  4498                                                          times   1792-($-$$) db 0h                               ;zero fill to end of section
  4499                                  ;-----------------------------------------------------------------------------------------------------------------------
  4500                                  ;
  4501                                  ;       Console Local Descriptor Table                                          @disk: 007d00   @mem:  004700
  4502                                  ;
  4503                                  ;       This is the LDT for the console task. It defines the stack, code, data and queue segments as well as data
  4504                                  ;       aliases for the TSS LDT. Data aliases allow inspection and altering of the TSS and LDT. This LDT can hold up to
  4505                                  ;       16 descriptors. Six are initially defined.
  4506                                  ;
  4507                                  ;-----------------------------------------------------------------------------------------------------------------------
  4508                                  section                 conldt                                                  ;console local descriptors
  4509                                                          dq      004093004780007Fh                               ;04 TSS alias
  4510                                                          dq      004093004700007Fh                               ;0c LDT alias
  4511                                                          dq      00409300400006FFh                               ;14 stack
  4512                                                          dq      00CF93000000FFFFh                               ;1c data
  4513                                                          dq      00409B0050000FFFh                               ;24 code
  4514                                                          dq      00409300480007FFh                               ;2c message queue
  4515                                                          times   128-($-$$) db 0h                                ;zero fill to end of section
  4516                                  ;-----------------------------------------------------------------------------------------------------------------------
  4517                                  ;
  4518                                  ;       Console Task State Segment                                              @disk: 007d80   @mem:  004780
  4519                                  ;
  4520                                  ;       This is the TSS for the console task. All rings share the same stack. DS and ES are set to the console data
  4521                                  ;       segment. CS to console code.
  4522                                  ;
  4523                                  ;-----------------------------------------------------------------------------------------------------------------------
  4524                                  section                 contss                                                  ;console task state segment
  4525                                                          dd      0                                               ;00 back-link tss
  4526                                                          dd      0700h                                           ;04 esp ring 0
  4527                                                          dd      0014h                                           ;08 ss ring 0
  4528                                                          dd      0700h                                           ;0c esp ring 1
  4529                                                          dd      0014h                                           ;10 es ring 1
  4530                                                          dd      0700h                                           ;14 esp ring 2
  4531                                                          dd      0014h                                           ;18 ss ring 2
  4532                                                          dd      0                                               ;1c cr ring 3
  4533                                                          dd      0                                               ;20 eip
  4534                                                          dd      0200h                                           ;24 eflags
  4535                                                          dd      0                                               ;28 eax
  4536                                                          dd      0                                               ;2c ecx
  4537                                                          dd      0                                               ;30 edx
  4538                                                          dd      0                                               ;34 ebx
  4539                                                          dd      0700h                                           ;38 esp ring 3
  4540                                                          dd      0                                               ;3c ebp
  4541                                                          dd      0                                               ;40 esi
  4542                                                          dd      0                                               ;44 edi
  4543                                                          dd      001Ch                                           ;48 es
  4544                                                          dd      0024h                                           ;4c cs
  4545                                                          dd      0014h                                           ;50 ss ring 3
  4546                                                          dd      001Ch                                           ;54 ds
  4547                                                          dd      0                                               ;58 fs
  4548                                                          dd      0                                               ;5c gs
  4549                                                          dd      EGDTCONSOLELDT                                  ;60 ldt selector in gdt
  4550                                                          times   128-($-$$) db 0h                                ;zero fill to end of section
  4551                                  ;-----------------------------------------------------------------------------------------------------------------------
  4552                                  ;
  4553                                  ;       Console Message Queue                                                   @disk: 007e00   @mem: 004800
  4554                                  ;
  4555                                  ;       The console message queue is 2048 bytes of memory organized as a queue of 510 double words (4 bytes each) and
  4556                                  ;       two double word values that act as indices. The queue is a FIFO that is fed by the keyboard hardware interrupt
  4557                                  ;       handler and consumed by a service routine called from a task. Each queue entry defines an input (keystroke)
  4558                                  ;       event.
  4559                                  ;
  4560                                  ;-----------------------------------------------------------------------------------------------------------------------
  4561                                  section                 conmque                                                 ;console message queue
  4562                                                          dd      8                                               ;head pointer
  4563                                                          dd      8                                               ;tail pointer
  4564                                                          times   510 dd 0                                        ;queue elements
  4565                                  ;-----------------------------------------------------------------------------------------------------------------------
  4566                                  ;
  4567                                  ;       Console Code                                                            @disk: 008600   @mem: 005000
  4568                                  ;
  4569                                  ;       This is the code for the console task. The task is defined in the GDT in two descriptors, the Local Descriptor
  4570                                  ;       Table (LDT) at 0050h and the Task State Segment (TSS) at 0058h. Jumping to or calling a TSS selector causes a
  4571                                  ;       task switch, giving control to the code for the task at the CS:IP defined in the TSS for the current ring level.
  4572                                  ;       The initial CS:IP in the Console TSS is 24h:0, where 24h is a selector in the LDT. This selector points to the
  4573                                  ;       concode section, loaded into memory 5000h by the Loader. The console task is dedicated to accepting user key-
  4574                                  ;       board input, echoing to the console screen and responding to user commands.
  4575                                  ;
  4576                                  ;       When control reaches this section, our addressability is set up according to the following diagram.
  4577                                  ;
  4578                                  ;       DS,ES --------> 000000  +-----------------------------------------------+ DS,ES:0000
  4579                                  ;                               |  Real Mode Interrupt Vectors                  |
  4580                                  ;                       000400  +-----------------------------------------------+ DS,ES:0400
  4581                                  ;                               |  Reserved BIOS Memory Area                    |
  4582                                  ;                       000800  +-----------------------------------------------+ DS,ES:0800
  4583                                  ;                               |  Shared Kernel Memory Area                    |
  4584                                  ;                       001000  +-----------------------------------------------+               <-- GDTR
  4585                                  ;                               |  Global Descriptor Table (GDT)                |
  4586                                  ;                       001800  +-----------------------------------------------+               <-- IDTR
  4587                                  ;                               |  Interrupt Descriptor Table (IDT)             |
  4588                                  ;                       002000  +-----------------------------------------------+
  4589                                  ;                               |  Interrupt Handlers                           |
  4590                                  ;                               |  Kernel Function Library                      |
  4591                                  ;       SS -----------> 004000  +===============================================+ SS:0000
  4592                                  ;                               |  Console Task Stack Area                      |
  4593                                  ;       SS:SP --------> 004700  +-----------------------------------------------+ SS:0700       <-- LDTR = GDT.SEL 0050h
  4594                                  ;                               |  Console Task Local Descriptor Table (LDT)    |
  4595                                  ;                       004780  +-----------------------------------------------+               <-- TR  = GDT.SEL 0058h
  4596                                  ;                               |  Console Task Task State Segment (TSS)        |
  4597                                  ;                       004800  +-----------------------------------------------+
  4598                                  ;                               |  Console Task Message Queue                   |
  4599                                  ;       CS:IP --------> 005000  +-----------------------------------------------+ CS:0000
  4600                                  ;                               |  Console Task Code                            |
  4601                                  ;                               |  Console Task Constants                       |
  4602                                  ;                       006000  +===============================================+
  4603                                  ;
  4604                                  ;-----------------------------------------------------------------------------------------------------------------------
  4605                                  ;=======================================================================================================================
  4606                                  ;
  4607                                  ;       Console Task Routines
  4608                                  ;
  4609                                  ;       ConCode                 Console task entry point
  4610                                  ;       ConClearPanel           Clear the panel area of video memory to spaces
  4611                                  ;       ConDrawFields           Draw the panel fields to video memory
  4612                                  ;       ConDrawField            Draw a panel field to video memory
  4613                                  ;       ConPutCursor            Place the cursor at the current index into the current field
  4614                                  ;       ConHandlerMain          Handle attention keys on the main panel
  4615                                  ;       ConHandlerView          Handle attention keys on the memory panel
  4616                                  ;       ConTakeToken            Extract the next token from a buffer
  4617                                  ;       ConDetermineCommand     Determine if a buffer value is a command
  4618                                  ;       ConGo                   Handle the go command
  4619                                  ;       ConFree                 Handle the free command
  4620                                  ;       ConInt6                 Handle the Int6 command
  4621                                  ;       ConReset                Handle the reset command
  4622                                  ;       ConView                 Handle the view command
  4623                                  ;       ConClearField           Clear a panel field to nulls
  4624                                  ;       ConMain                 Handle the main command
  4625                                  ;       ConMalloc               Handle the malloc command
  4626                                  ;
  4627                                  ;=======================================================================================================================
  4628                                  section                 concode vstart=05000h                                   ;labels relative to 5000h
  4629                                  ;
  4630                                  ;       Initialize console work areas to low values.
  4631                                  ;
  4632                                  ConCode                 mov     edi,ECONDATA                                    ;OS console data address
  4633                                                          xor     al,al                                           ;initialization value
  4634                                                          mov     ecx,ECONDATALEN                                 ;size of OS console data
  4635                                                          cld                                                     ;forward strings
  4636                                                          rep     stosb                                           ;initialize data
  4637                                  ;
  4638                                  ;       Initialize the Operator Information Area (OIA).
  4639                                  ;
  4640                                                          push    es                                              ;save extra segment
  4641                                                          push    EGDTCGA                                         ;load CGA video selector...
  4642                                                          pop     es                                              ;...into extra segment reg
  4643                                                          mov     edi,ECONROWS*ECONROWBYTES                       ;target offset
  4644                                                          mov     eax,ECONOIADWORD                                ;OIA attribute and space
  4645                                                          mov     ecx,ECONROWDWORDS                               ;double-words per row
  4646                                                          rep     stosd                                           ;reset OIA
  4647                                                          pop     es                                              ;restore extra segment
  4648                                  ;
  4649                                  ;       Set num-lock and update lamps
  4650                                  ;       Display the initial OIA
  4651                                  ;
  4652                                                          or      byte [wsKeybData+KEYBDATA.lock],EKEYFLOCKNUM    ;BIOS boots with num-lock on
  4653                                                          setKeyboardLamps
  4654                                                          putConsoleOIA
  4655                                  ;
  4656                                  ;       Set the current panel to Main, clear and redraw all fields.
  4657                                  ;
  4658                                                          call    ConMain                                         ;initialize panel
  4659                                  ;
  4660                                  ;       Place the cursor at the current field index.
  4661                                  ;
  4662                                  .10                     call    ConPutCursor                                    ;place the cursor
  4663                                  ;
  4664                                  ;       Get the next key-down message.
  4665                                  ;
  4666                                  .20                     getConsoleMessage                                       ;get a console message
  4667                                  ;
  4668                                                          mov     edx,eax                                         ;message and params
  4669                                                          and     edx,0FFFF0000h                                  ;mask for message
  4670                                                          cmp     edx,EMSGKEYDOWN                                 ;keydown message?
  4671                                                          jne     .20                                             ;no, next message
  4672                                  ;
  4673                                  ;       Give the message to the panel event-handler first.
  4674                                  ;
  4675                                                          mov     ecx,[wdConsoleHandler]                          ;handler addr?
  4676                                                          jecxz   .30                                             ;no, branch
  4677                                                          call    ecx                                             ;event handled?
  4678                                                          jc     .20                                              ;yes, next message
  4679                                  ;
  4680                                  ;       To handle the event here, we need a current field that has a buffer.
  4681                                  ;
  4682                                  .30                     mov     ebx,[wdConsoleField]                            ;field addr
  4683                                                          test    ebx,ebx                                         ;field addr?
  4684                                                          jz      .20                                             ;no, next message
  4685                                                          mov     ecx,[ebx]                                       ;buffer addr?
  4686                                                          jecxz   .20                                             ;no, next message
  4687                                                          movzx   edx,byte [ebx+7]                                ;field index
  4688                                  ;
  4689                                  ;       Handle tab down and shift-tab down to navigate panel fields.
  4690                                  ;
  4691                                                          cmp     ah,EKEYBTABDOWN                                 ;tab down?
  4692                                                          jne     .100                                            ;no, branch
  4693                                                          test    byte [wsKeybData+KEYBDATA.shift],EKEYFSHIFT     ;shift?
  4694                                                          jz      .80                                             ;no, tab forward
  4695                                  ;
  4696                                  ;       Handle backward-tab.
  4697                                  ;
  4698                                  .40                     cmp     ebx,[wdConsolePanel]                            ;at first field?
  4699                                                          jna     .50                                             ;yes, branch
  4700                                                          lea     ebx,[ebx-12]                                    ;previous field
  4701                                                          jmp     .70                                             ;branch
  4702                                  .50                     mov     ebx,[wdConsolePanel]                            ;sanity check
  4703                                                          cmp     dword [ebx+12],0                                ;last field?
  4704                                                          je      .20                                             ;yes, next message (only 1 field)
  4705                                  .60                     lea     ebx,[ebx+12]                                    ;next field
  4706                                                          cmp     dword [ebx+12],0                                ;last field?
  4707                                                          jne     .60                                             ;no, continue
  4708                                  .70                     cmp     ebx,[wdConsoleField]                            ;back to current field?
  4709                                                          je      .20                                             ;yes, next message
  4710                                                          test    byte [ebx+11],80h                               ;input field?
  4711                                                          jz      .40                                             ;no, next field
  4712                                                          mov     [wdConsoleField],ebx                            ;set current field
  4713                                                          jmp     .10                                             ;place cursor and get message
  4714                                  ;
  4715                                  ;       Handle forward-tab.
  4716                                  .80                     lea     ebx,[ebx+12]                                    ;next field addr
  4717                                                          cmp     dword [ebx],0                                   ;end of panel?
  4718                                                          jne     .90                                             ;no, branch
  4719                                                          mov     ebx,[wdConsolePanel]                            ;start of panel
  4720                                  .90                     cmp     ebx,[wdConsoleField]                            ;back to current field?
  4721                                                          je      .20                                             ;yes, next message
  4722                                                          test    byte [ebx+11],80h                               ;input field?
  4723                                                          jz      .80                                             ;no, next field
  4724                                                          mov     [wdConsoleField],ebx                            ;set current field
  4725                                                          jmp     .10                                             ;place cursor and get message
  4726                                  ;
  4727                                  ;       Handle left or up arrow.
  4728                                  ;
  4729                                  .100                    cmp     ah,EKEYBLEFTARROWDOWN                           ;left-arrow down?
  4730                                                          je      .110                                            ;yes, branch
  4731                                                          cmp     ah,EKEYBUPARROWDOWN                             ;up-arrow down?
  4732                                                          jne     .120                                            ;no, branch
  4733                                  .110                    test    dl,dl                                           ;index is zero?
  4734                                                          jz      .20                                             ;yes, next message
  4735                                                          dec     byte [ebx+7]                                    ;decrement index
  4736                                                          jmp     .10                                             ;put cursor and next message
  4737                                  ;
  4738                                  ;       Handle right or down arrow.
  4739                                  ;
  4740                                  .120                    cmp     ah,EKEYBRIGHTARROWDOWN                          ;right-arrow down?
  4741                                                          je      .130                                            ;yes, branch
  4742                                                          cmp     ah,EKEYBDOWNARROWDOWN                           ;down-arrow down?
  4743                                                          jne     .140                                            ;no, branch
  4744                                  .130                    cmp     byte [ecx+edx],0                                ;end of input?
  4745                                                          je      .20                                             ;yes, next message
  4746                                                          inc     dl                                              ;increment index
  4747                                                          cmp     dl,byte [ebx+6]                                 ;end of field?
  4748                                                          jnb     .20                                             ;yes, next message
  4749                                                          mov     [ebx+7],dl                                      ;save new index
  4750                                                          jmp     .10                                             ;put cursor and next message
  4751                                  ;
  4752                                  ;       Handle backspace
  4753                                  ;
  4754                                  .140                    cmp     ah,EKEYBBACKSPACE                               ;backspace?
  4755                                                          jne     .160                                            ;no, branch
  4756                                                          test    dl,dl                                           ;index is zero?
  4757                                                          jz      .20                                             ;yes, next message
  4758                                                          dec     byte [ebx+7]                                    ;decrement index
  4759                                                          mov     edi,ecx                                         ;buffer addr
  4760                                                          lea     edi,[edi+edx-1]                                 ;end of buffer
  4761                                                          mov     esi,edi                                         ;end of buffer
  4762                                                          inc     esi                                             ;source address
  4763                                                          cld                                                     ;forward strings
  4764                                  .150                    lodsb                                                   ;character
  4765                                                          stosb                                                   ;save over previous
  4766                                                          test    al,al                                           ;end of input?
  4767                                                          jnz     .150                                            ;no, continue
  4768                                                          jmp     .170                                            ;draw field, put cursor, next message
  4769                                  ;
  4770                                  ;       Handle printables
  4771                                  ;
  4772                                  .160                    cmp     al,EASCIISPACE                                  ;printable range? (low)
  4773                                                          jb      .20                                             ;no, next message
  4774                                                          cmp     al,EASCIITILDE                                  ;printable range? (high)
  4775                                                          ja      .20                                             ;no, next message
  4776                                                          mov     [ecx+edx],al                                    ;store char in buffer
  4777                                                          inc     dl                                              ;advance index
  4778                                                          cmp     dl,[ebx+6]                                      ;end of field?
  4779                                                          jnb     .170                                            ;yes, branch
  4780                                                          mov     [ebx+7],dl                                      ;save new index
  4781                                  .170                    call    ConDrawField                                    ;redraw field
  4782                                                          jmp     .10                                             ;put cursor and get message
  4783                                  ;-----------------------------------------------------------------------------------------------------------------------
  4784                                  ;
  4785                                  ;       Routine:        ConClearPanel
  4786                                  ;
  4787                                  ;       Description:    This routine clears the console panel video memory. The panel field buffer values
  4788                                  ;                       are not disturbed.
  4789                                  ;
  4790                                  ;-----------------------------------------------------------------------------------------------------------------------
  4791                                  ConClearPanel           push    ecx                                             ;save non-volatile regs
  4792                                                          push    edi                                             ;
  4793                                                          push    es                                              ;
  4794                                  ;
  4795                                  ;       Clear panel rows.
  4796                                  ;
  4797                                                          push    EGDTCGA                                         ;load CGA video selector...
  4798                                                          pop     es                                              ;...into extra segment reg
  4799                                                          xor     edi,edi                                         ;target offset
  4800                                                          mov     eax,ECONCLEARDWORD                              ;initialization value
  4801                                                          mov     ecx,ECONROWS*ECONROWDWORDS                      ;double-words to clear
  4802                                                          cld                                                     ;forward strings
  4803                                                          rep     stosd                                           ;reset screen body
  4804                                  ;
  4805                                  ;       Restore and return.
  4806                                  ;
  4807                                                          pop     es                                              ;restore non-volatile regs
  4808                                                          pop     edi                                             ;
  4809                                                          pop     ecx                                             ;
  4810                                                          ret                                                     ;return
  4811                                  ;-----------------------------------------------------------------------------------------------------------------------
  4812                                  ;
  4813                                  ;       Routine:        ConDrawFields
  4814                                  ;
  4815                                  ;       Description:    This routine draws the panel fields. If there is no active input field, the first input
  4816                                  ;                       field of the panel is set as the active field.
  4817                                  ;
  4818                                  ;-----------------------------------------------------------------------------------------------------------------------
  4819                                  ConDrawFields           push    ebx                                             ;save non-volatile regs
  4820                                  ;
  4821                                  ;       Exit if no panel
  4822                                  ;
  4823                                                          mov     ebx,[wdConsolePanel]                            ;panel definition addr
  4824                                                          test    ebx,ebx                                         ;have panel?
  4825                                                          jz      .30                                             ;no, branch
  4826                                  ;
  4827                                  ;       Loop until end of panel
  4828                                  ;
  4829                                  .10                     cmp     dword [ebx],0                                   ;end of panel?
  4830                                                          je      .30                                             ;yes, branch
  4831                                  ;
  4832                                  ;       If input field and we have no active field, set as active field
  4833                                  ;
  4834                                                          test    byte [ebx+11],80h                               ;input field?
  4835                                                          jz      .20                                             ;no, branch
  4836                                                          cmp     dword [wdConsoleField],0                        ;have active field?
  4837                                                          jne     .20                                             ;yes, branch
  4838                                                          mov     [wdConsoleField],ebx                            ;set active field
  4839                                  ;
  4840                                  ;       Draw the field and loop to the next field.
  4841                                  ;
  4842                                  .20                     call    ConDrawField                                    ;draw field
  4843                                                          lea     ebx,[ebx+12]                                    ;next field addr
  4844                                                          jmp     .10                                             ;next field
  4845                                  ;
  4846                                  ;       Restore and return.
  4847                                  ;
  4848                                  .30                     pop     ebx                                             ;restore non-volatile regs
  4849                                                          ret                                                     ;return
  4850                                  ;-----------------------------------------------------------------------------------------------------------------------
  4851                                  ;
  4852                                  ;       Routine:        ConDrawField
  4853                                  ;
  4854                                  ;       Description:    This routine draws the contents of a panel field.
  4855                                  ;
  4856                                  ;       In:             DS:EBX  field definition address
  4857                                  ;                               [ebx+0]         field buffer address
  4858                                  ;                               [ebx+4]         row (0-23)
  4859                                  ;                               [ebx+5]         column (0,79)
  4860                                  ;                               [ebx+6]         size (0-255)
  4861                                  ;                               [ebx+7]         cursor index (0-255)
  4862                                  ;                               [ebx+8]         1st selected index (0-255)
  4863                                  ;                               [ebx+9]         last selected index (0-255)
  4864                                  ;                               [ebx+10]        attribute
  4865                                  ;                               [ebx+11]        flags
  4866                                  ;                                               80h = input field
  4867                                  ;
  4868                                  ;-----------------------------------------------------------------------------------------------------------------------
  4869                                  ConDrawField            push    ecx                                             ;save non-volatile regs
  4870                                                          push    esi                                             ;
  4871                                                          push    edi                                             ;
  4872                                                          push    es                                              ;
  4873                                  ;
  4874                                  ;       Exit if no field or zero size.
  4875                                  ;
  4876                                                          test    ebx,ebx                                         ;have field?
  4877                                                          jz      .30                                             ;no, exit
  4878                                                          movzx   ecx,byte [ebx+6]                                ;have size?
  4879                                                          jecxz   .30                                             ;no, exit
  4880                                  ;
  4881                                  ;       Address video memory.
  4882                                  ;
  4883                                                          push    EGDTCGA                                         ;load CGA video selector...
  4884                                                          pop     es                                              ;...into extra segment reg
  4885                                  ;
  4886                                  ;       Compute the target offset.
  4887                                  ;
  4888                                                          movzx   eax,byte [ebx+4]                                ;row
  4889                                                          mov     ah,ECONCOLS                                     ;columns per row
  4890                                                          mul     ah                                              ;row offset
  4891                                                          add     al,byte [ebx+5]                                 ;add column
  4892                                                          adc     ah,0                                            ;handle overflow
  4893                                                          shl     eax,1                                           ;two-bytes per column
  4894                                                          mov     edi,eax                                         ;target offset
  4895                                  ;
  4896                                  ;       Display field characters.
  4897                                  ;
  4898                                                          mov     ah,[ebx+10]                                     ;attribute
  4899                                                          cld                                                     ;forward strings
  4900                                                          mov     esi,[ebx]                                       ;field buffer addr
  4901                                                          test    esi,esi                                         ;have field buffer?
  4902                                                          jz      .20                                             ;no, exit
  4903                                  .10                     lodsb                                                   ;field character
  4904                                                          test    al,al                                           ;end of value?
  4905                                                          jz      .20                                             ;yes, branch
  4906                                                          stosw                                                   ;store character with attribute
  4907                                                          dec     ecx                                             ;decrement remaining size
  4908                                                          jecxz   .30                                             ;exit if field full
  4909                                                          jmp     .10                                             ;next character
  4910                                  ;
  4911                                  ;       Clear the remaining field.
  4912                                  ;
  4913                                  .20                     mov     al,EASCIISPACE                                  ;ASCII space
  4914                                                          rep     stosw                                           ;store space with attribute
  4915                                  ;
  4916                                  ;       Restore and return.
  4917                                  ;
  4918                                  .30                     pop     es                                              ;restore non-volatile regs
  4919                                                          pop     edi                                             ;
  4920                                                          pop     esi                                             ;
  4921                                                          pop     ecx                                             ;
  4922                                                          ret                                                     ;return
  4923                                  ;-----------------------------------------------------------------------------------------------------------------------
  4924                                  ;
  4925                                  ;       Routine:        ConPutCursor
  4926                                  ;
  4927                                  ;       Description:    This routine places the cursor at the current index into the current field.
  4928                                  ;
  4929                                  ;-----------------------------------------------------------------------------------------------------------------------
  4930                                  ConPutCursor            push    ecx                                             ;save non-volatile regs
  4931                                                          mov     ecx,[wdConsoleField]                            ;current field?
  4932                                                          jecxz   .10                                             ;no, branch
  4933                                                          mov     al,[ecx+4]                                      ;field row
  4934                                                          mov     [wbConsoleRow],al                               ;set current row
  4935                                                          mov     al,[ecx+5]                                      ;field column
  4936                                                          add     al,[ecx+7]                                      ;field offset
  4937                                                          mov     [wbConsoleColumn],al                            ;set curren tcol
  4938                                                          placeCursor                                             ;place the cursor
  4939                                  .10                     pop     ecx                                             ;restore non-volatile regs
  4940                                                          ret                                                     ;return
  4941                                  ;-----------------------------------------------------------------------------------------------------------------------
  4942                                  ;
  4943                                  ;       Routine:        ConHandlerMain
  4944                                  ;
  4945                                  ;       Description:    This routine is called to handle user input in the main console panel when a field is exited.
  4946                                  ;                       The event handler must set the carry flag if the event is not completely handled. In this case
  4947                                  ;                       the event will be forwarded to the current field.
  4948                                  ;
  4949                                  ;       In:             EAX     Message params
  4950                                  ;                       EDX     Message class
  4951                                  ;
  4952                                  ;       Out:            CY      1: Event handling complete
  4953                                  ;                               0: Event handling not complete
  4954                                  ;
  4955                                  ;-----------------------------------------------------------------------------------------------------------------------
  4956                                  ConHandlerMain          push    ebx                                             ;save non-volatile regs
  4957                                  ;
  4958                                  ;       Handle enter and keypad-enter.
  4959                                  ;
  4960                                                          cmp     ah,EKEYBENTERDOWN                               ;enter down?
  4961                                                          je      .10                                             ;yes, branch
  4962                                                          cmp     ah,EKEYBPADENTERDOWN                            ;keypad-enter down?
  4963                                                          je      .10                                             ;yes, branch
  4964                                                          clc                                                     ;event not handled
  4965                                                          jmp     .90                                             ;branch
  4966                                  ;
  4967                                  ;       Take the first token entered.
  4968                                  ;
  4969                                  .10                     mov     edx,wzConsoleInBuffer                           ;console input buffer addr
  4970                                                          mov     ebx,wzConsoleToken                              ;token buffer
  4971                                                          call    ConTakeToken                                    ;take first command token
  4972                                  ;
  4973                                  ;       Evaluate token.
  4974                                  ;
  4975                                                          mov     edx,wzConsoleToken                              ;token buffer
  4976                                                          call    ConDetermineCommand                             ;determine if this is a command
  4977                                                          cmp     eax,ECONJMPTBLCNT                               ;command number in range?
  4978                                                          jnb     .20                                             ;no, branch
  4979                                                          shl     eax,2                                           ;convert number to array offset
  4980                                                          mov     edx,tConJmpTbl                                  ;command handler address table base
  4981                                                          mov     eax,[edx+eax]                                   ;command handler address
  4982                                                          call    eax                                             ;handler command
  4983                                  ;
  4984                                  ;       Clear field.
  4985                                  ;
  4986                                  .20                     mov     ebx,czPnlConInp                                 ;main panel input field
  4987                                                          call    ConClearField                                   ;clear the field contents
  4988                                                          call    ConDrawField                                    ;draw the field
  4989                                                          call    ConPutCursor                                    ;place the cursor
  4990                                                          stc                                                     ;event is handled
  4991                                  ;
  4992                                  ;       Restore and return.
  4993                                  ;
  4994                                  .90                     pop     ebx                                             ;restore non-volatile regs
  4995                                                          ret                                                     ;return
  4996                                  ;-----------------------------------------------------------------------------------------------------------------------
  4997                                  ;
  4998                                  ;       Routine:        ConHandlerView
  4999                                  ;
  5000                                  ;       Description:    This routine is called to handle user input in the mem console panel when a field is exited.
  5001                                  ;                       The event handler must set the carry flag if the event is not completely handled. In this case
  5002                                  ;                       the event will be forwarded to the current field.
  5003                                  ;
  5004                                  ;       In:             EAX     message params
  5005                                  ;
  5006                                  ;       Out:            CY      1: Event handling complete
  5007                                  ;                               0: Event handling not complete
  5008                                  ;
  5009                                  ;-----------------------------------------------------------------------------------------------------------------------
  5010                                  ConHandlerView          push    ebx                                             ;save non-volatile regs
  5011                                  ;
  5012                                  ;       Handle panel-specific input:
  5013                                  ;
  5014                                  ;       page-up:                scroll memory address back one page
  5015                                  ;       scroll page-up:         scroll memory address back to XXXX0000
  5016                                  ;       ctrl page-up:           scroll memory address back to XX000000
  5017                                  ;       alt page-up:            scroll memory address back to 00000000
  5018                                  ;
  5019                                  ;       page-down:              scroll memory address forward one page
  5020                                  ;       scroll page-down:       scroll memory address forward to XXXX0000
  5021                                  ;       ctrl page-down:         scroll memory address forward to XX000000
  5022                                  ;       alt page-down:          scroll memory address forward to FFFEFFC0
  5023                                  ;
  5024                                  ;       Handle enter and keypad-enter.
  5025                                  ;
  5026                                                          cmp     ah,EKEYBENTERDOWN                               ;enter down?
  5027                                                          je      .10                                             ;yes, branch
  5028                                                          cmp     ah,EKEYBPADENTERDOWN                            ;keypad-enter down?
  5029                                                          je      .10                                             ;yes, branch
  5030                                                          clc                                                     ;event not handled
  5031                                                          jmp     .90                                             ;branch
  5032                                  ;
  5033                                  ;       Take the first token from the input bufer.
  5034                                  ;
  5035                                  .10                     mov     edx,wzConsoleInBuffer                           ;console input buffer addr
  5036                                                          mov     ebx,wzConsoleToken                              ;token buffer
  5037                                                          call    ConTakeToken                                    ;take first command token
  5038                                  ;
  5039                                  ;       Determine which command was entered.
  5040                                  ;
  5041                                                          mov     edx,wzConsoleToken                              ;token buffer
  5042                                                          call    ConDetermineCommand                             ;determine if this is a command
  5043                                                          cmp     eax,ECONJMPTBLCNT                               ;command number in range?
  5044                                                          jnb     .20                                             ;no, branch
  5045                                  ;
  5046                                  ;       Call the command handler.
  5047                                  ;
  5048                                                          shl     eax,2                                           ;convert number to array offset
  5049                                                          mov     edx,tConJmpTbl                                  ;command handler address table base
  5050                                                          mov     eax,[edx+eax]                                   ;command handler address
  5051                                                          call    eax                                             ;handler command
  5052                                  ;
  5053                                  ;       Clear and redraw the command field; place the cursor.
  5054                                  ;
  5055                                  .20                     mov     ebx,czPnlMenuInp                                ;panel input field
  5056                                                          call    ConClearField                                   ;clear the field
  5057                                                          call    ConDrawField                                    ;draw the field
  5058                                                          call    ConPutCursor                                    ;place the cursor
  5059                                                          stc                                                     ;event is handled
  5060                                  ;
  5061                                  ;       Restore and return.
  5062                                  ;
  5063                                  .90                     pop     ebx                                             ;restore non-volatile regs
  5064                                                          ret                                                     ;return
  5065                                  ;-----------------------------------------------------------------------------------------------------------------------
  5066                                  ;
  5067                                  ;       Routine:        ConTakeToken
  5068                                  ;
  5069                                  ;       Description:    This routine extracts the next token from the given source buffer.
  5070                                  ;
  5071                                  ;       In:             DS:EDX  source buffer address
  5072                                  ;                       DS:EBX  target buffer address
  5073                                  ;
  5074                                  ;       Out:            DS:EDX  source buffer address
  5075                                  ;                       DS:EBX  target buffer address
  5076                                  ;
  5077                                  ;       Command Form:   Line    = *3( *SP 1*ALNUM )
  5078                                  ;
  5079                                  ;-----------------------------------------------------------------------------------------------------------------------
  5080                                  ConTakeToken            push    esi                                             ;save non-volatile regs
  5081                                                          push    edi                                             ;
  5082                                                          push    es                                              ;
  5083                                  ;
  5084                                  ;       Address source and target; null-terminate target buffer.
  5085                                  ;
  5086                                                          push    ds                                              ;load data segment selector ...
  5087                                                          pop     es                                              ;... into extra segment reg
  5088                                                          mov     esi,edx                                         ;source buffer address
  5089                                                          mov     edi,ebx                                         ;target buffer address
  5090                                                          mov     byte [edi],0                                    ;null-terminate target buffer
  5091                                  ;
  5092                                  ;       Trim leading space; exit if no token.
  5093                                  ;
  5094                                                          cld                                                     ;forward strings
  5095                                  .10                     lodsb                                                   ;load byte
  5096                                                          cmp     al,EASCIISPACE                                  ;space?
  5097                                                          je      .10                                             ;yes, continue
  5098                                                          test    al,al                                           ;end of line?
  5099                                                          jz      .40                                             ;yes, branch
  5100                                  ;
  5101                                  ;       Store non-spaces into target buffer.
  5102                                  ;
  5103                                  .20                     stosb                                                   ;store byte
  5104                                                          lodsb                                                   ;load byte
  5105                                                          test    al,al                                           ;end of line?
  5106                                                          jz      .40                                             ;no, continue
  5107                                                          cmp     al,EASCIISPACE                                  ;space?
  5108                                                          jne     .20                                             ;no, continue
  5109                                  ;
  5110                                  ;       Walk over spaces trailing the stored token; point to final space.
  5111                                  ;
  5112                                  .30                     lodsb                                                   ;load byte
  5113                                                          cmp     al,EASCIISPACE                                  ;space?
  5114                                                          je      .30                                             ;yes, continue
  5115                                                          dec     esi                                             ;pre-position
  5116                                  ;
  5117                                  ;       Null-terminate target buffer; advance remaining source bytes.
  5118                                  ;
  5119                                  .40                     mov     byte [edi],0                                    ;terminate buffer
  5120                                                          mov     edi,edx                                         ;source buffer address
  5121                                  .50                     lodsb                                                   ;remaining byte
  5122                                                          stosb                                                   ;move to front of buffer
  5123                                                          test    al,al                                           ;end of line?
  5124                                                          jnz     .50                                             ;no, continue
  5125                                  ;
  5126                                  ;       Restore and return.
  5127                                  ;
  5128                                                          pop     es                                              ;restore non-volatile regs
  5129                                                          pop     edi                                             ;
  5130                                                          pop     esi                                             ;
  5131                                                          ret                                                     ;return
  5132                                  ;-----------------------------------------------------------------------------------------------------------------------
  5133                                  ;
  5134                                  ;       Routine:        ConDetermineCommand
  5135                                  ;
  5136                                  ;       Description:    This routine determines the command number for the command at DS:EDX.
  5137                                  ;
  5138                                  ;       input:          DS:EDX  command address
  5139                                  ;
  5140                                  ;       output:         EAX     !ECONJMPTBLCNT = command nbr
  5141                                  ;                               ECONJMPTBLCNT = no match fond
  5142                                  ;
  5143                                  ;-----------------------------------------------------------------------------------------------------------------------
  5144                                  ConDetermineCommand     push    ebx                                             ;save non-volatile regs
  5145                                                          push    ecx                                             ;
  5146                                                          push    esi                                             ;
  5147                                                          push    edi                                             ;
  5148                                  ;
  5149                                  ;       Upper-case the command; prepare to search command table.
  5150                                  ;
  5151                                                          upperCaseString                                         ;upper-case string at EDX
  5152                                                          mov     esi,tConCmdTbl                                  ;commands table
  5153                                                          xor     edi,edi                                         ;intialize command number
  5154                                                          cld                                                     ;forward strings
  5155                                  ;
  5156                                  ;       Exit if end of table.
  5157                                  ;
  5158                                  .10                     lodsb                                                   ;command length
  5159                                                          movzx   ecx,al                                          ;command length
  5160                                                          jecxz   .20                                             ;branch if end of table
  5161                                  ;
  5162                                  ;       Compare command to table entry; exit if match.
  5163                                  ;
  5164                                                          mov     ebx,esi                                         ;table entry address
  5165                                                          add     esi,ecx                                         ;next table entry address
  5166                                                          compareMemory                                           ;compare byte arrays at EDX, EBX
  5167                                                          jecxz   .20                                             ;branch if equal
  5168                                  ;
  5169                                  ;       Next table element.
  5170                                  ;
  5171                                                          inc     edi                                             ;increment command nbr
  5172                                                          jmp     .10                                             ;repeat
  5173                                  ;
  5174                                  ;       Return command number or ECONJMPTBLCNT.
  5175                                  ;
  5176                                  .20                     mov     eax,edi                                         ;command number
  5177                                  ;
  5178                                  ;       Restore and return.
  5179                                  ;
  5180                                                          pop     edi                                             ;restore non-volatile regs
  5181                                                          pop     esi                                             ;
  5182                                                          pop     ecx                                             ;
  5183                                                          pop     ebx                                             ;
  5184                                                          ret                                                     ;return
  5185                                  ;-----------------------------------------------------------------------------------------------------------------------
  5186                                  ;
  5187                                  ;       Routine:        ConInt6
  5188                                  ;
  5189                                  ;       Description:    This routine issues an interrupt 6 to exercise the interrupt handler.
  5190                                  ;
  5191                                  ;-----------------------------------------------------------------------------------------------------------------------
  5192                                  ConInt6                 ud2                                                     ;raise bad opcode exception
  5193                                                          ret                                                     ;return (not executed)
  5194                                  ;-----------------------------------------------------------------------------------------------------------------------
  5195                                  ;
  5196                                  ;       Routine:        ConReset
  5197                                  ;
  5198                                  ;       Description:    This routine handles the reset command.
  5199                                  ;
  5200                                  ;-----------------------------------------------------------------------------------------------------------------------
  5201                                  ConReset                resetSystem                                             ;issue system reset
  5202                                                          ret                                                     ;return
  5203                                  ;-----------------------------------------------------------------------------------------------------------------------
  5204                                  ;
  5205                                  ;       Routine:        ConClearField
  5206                                  ;
  5207                                  ;       Description:    This routine clears a panel field to nulls.
  5208                                  ;
  5209                                  ;       In:             DS:EBX  panel field address
  5210                                  ;                       ES:     OS data segment
  5211                                  ;
  5212                                  ;-----------------------------------------------------------------------------------------------------------------------
  5213                                  ConClearField           push    ebx                                             ;save non-volatile regs
  5214                                                          push    edi                                             ;
  5215                                  ;
  5216                                  ;       Exit if no field.
  5217                                  ;
  5218                                                          test    ebx,ebx                                         ;have field?
  5219                                                          jz      .10                                             ;no, exit
  5220                                  ;
  5221                                  ;       Reset cursor index to zero; exit if no size or no buffer.
  5222                                  ;
  5223                                                          xor     al,al                                           ;zero register
  5224                                                          mov     byte [ebx+7],al                                 ;zero cursor index
  5225                                                          movzx   ecx,byte [ebx+6]                                ;field size?
  5226                                                          jecxz   .10                                             ;no, exit
  5227                                                          mov     edi,[ebx]                                       ;field bufer
  5228                                                          test    edi,edi                                         ;field buffer?
  5229                                                          jz      .10                                             ;no, exit
  5230                                  ;
  5231                                  ;       Reset field to nulls.
  5232                                  ;
  5233                                                          cld                                                     ;forward strings
  5234                                                          rep     stosb                                           ;clear buffer
  5235                                  ;
  5236                                  ;       Restore and return.
  5237                                  ;
  5238                                  .10                     pop     edi                                             ;restore non-volatile regs
  5239                                                          pop     ebx                                             ;
  5240                                                          ret                                                     ;return
  5241                                  ;-----------------------------------------------------------------------------------------------------------------------
  5242                                  ;
  5243                                  ;       Routine:        ConFree
  5244                                  ;
  5245                                  ;       Description:    This routine handles the FREE command.
  5246                                  ;
  5247                                  ;       Input:          wzConsoleInBuffer contains parameter(s)
  5248                                  ;
  5249                                  ;-----------------------------------------------------------------------------------------------------------------------
  5250                                  ConFree                 push    ebx                                             ;save non-volatile regs
  5251                                                          push    ecx                                             ;
  5252                                                          push    esi                                             ;
  5253                                                          push    edi                                             ;
  5254                                  ;
  5255                                  ;       Get address parameter
  5256                                  ;
  5257                                                          mov     edx,wzConsoleInBuffer                           ;console input buffer address (param)
  5258                                                          mov     ebx,wzConsoleToken                              ;console command token address
  5259                                                          call    ConTakeToken                                    ;take first param as token
  5260                                  ;
  5261                                  ;       Convert input parameter from hexadecimal string to binary
  5262                                  ;
  5263                                                          cmp     byte [wzConsoleToken],0                         ;token found?
  5264                                                          je      .10                                             ;no, branch
  5265                                                          mov     edx,wzConsoleToken                              ;first param as token address
  5266                                                          hexadecimalToUnsigned                                   ;convert string token to unsigned
  5267                                                          test    eax,eax                                         ;valid parameter?
  5268                                                          jz      .10                                             ;no, branch
  5269                                  ;
  5270                                  ;       Free memory block
  5271                                  ;
  5272                                                          freeMemory eax                                          ;free memory
  5273                                                          cmp     eax,-1                                          ;memory freed?
  5274                                                          je      .10                                             ;no, branch
  5275                                  ;
  5276                                  ;       Indicate memory freed
  5277                                  ;
  5278                                  ;                        putConsoleString czOK                                   ;indicate success
  5279                                  ;
  5280                                  ;       Restore and return
  5281                                  ;
  5282                                  .10                     pop     edi                                             ;restore non-volatile regs
  5283                                                          pop     esi                                             ;
  5284                                                          pop     ecx                                             ;
  5285                                                          pop     ebx                                             ;
  5286                                                          ret                                                     ;return
  5287                                  ;-----------------------------------------------------------------------------------------------------------------------
  5288                                  ;
  5289                                  ;       Routine:        ConMain
  5290                                  ;
  5291                                  ;       Description:    This routine sets the current panel to the main panel (CON001).
  5292                                  ;
  5293                                  ;       In:             ES:     OS data segment
  5294                                  ;
  5295                                  ;-----------------------------------------------------------------------------------------------------------------------
  5296                                  ConMain                 push    ecx                                             ;save non-volatile regs
  5297                                                          push    edi                                             ;
  5298                                  ;
  5299                                  ;       Initialize panel storage areas
  5300                                  ;
  5301                                                          mov     edi,wzFldMenuOptn0                              ;first menu option storage
  5302                                                          xor     eax,eax                                         ;zero reg
  5303                                                          mov     al,EASCIIUNDERSCORE                             ;input placeholder
  5304                                                          xor     ecx,ecx                                         ;zero reg
  5305                                                          mov     cl,5                                            ;input field count
  5306                                                          cld                                                     ;forward strings
  5307                                                          rep     stosw                                           ;reset input fields
  5308                                  ;
  5309                                  ;       Initialize current handler, panel, field.
  5310                                  ;
  5311                                                          mov     eax,[cdHandlerMain]                             ;main panel handler CS-relative addr
  5312                                                          mov     [wdConsoleHandler],eax                          ;set panel handler addr
  5313                                                          mov     eax,czPnlCon001                                 ;main panel addr
  5314                                                          mov     [wdConsolePanel],eax                            ;set panel addr
  5315                                                          mov     eax,czPnlConInp                                 ;main panel command field addr
  5316                                                          mov     [wdConsoleField],eax                            ;set active field
  5317                                  ;
  5318                                  ;       Clear panel video memory and draw fields
  5319                                  ;
  5320                                                          call    ConClearPanel                                   ;clear panel
  5321                                                          call    ConDrawFields                                   ;draw fields
  5322                                  ;
  5323                                  ;       Restore and return.
  5324                                  ;
  5325                                                          pop     edi                                             ;restore non-volatile regs
  5326                                                          pop     ecx                                             ;
  5327                                                          ret                                                     ;return
  5328                                  ;-----------------------------------------------------------------------------------------------------------------------
  5329                                  ;
  5330                                  ;       Routine:        ConMalloc
  5331                                  ;
  5332                                  ;       Description:    This routine handles the MALLOC command.
  5333                                  ;
  5334                                  ;       Input:          wzConsoleInBuffer contains parameter(s)
  5335                                  ;
  5336                                  ;-----------------------------------------------------------------------------------------------------------------------
  5337                                  ConMalloc               push    ebx                                             ;save non-volatile regs
  5338                                                          push    ecx                                             ;
  5339                                                          push    esi                                             ;
  5340                                                          push    edi                                             ;
  5341                                  ;
  5342                                  ;       Get size parameter
  5343                                  ;
  5344                                                          mov     edx,wzConsoleInBuffer                           ;console input buffer address (params)
  5345                                                          mov     ebx,wzConsoleToken                              ;console command token address
  5346                                                          call    ConTakeToken                                    ;take first param as token
  5347                                  ;
  5348                                  ;       Convert input parameter from decimal string to binary
  5349                                  ;
  5350                                                          cmp     byte [wzConsoleToken],0                         ;token found?
  5351                                                          je      .10                                             ;no, branch
  5352                                                          mov     edx,wzConsoleToken                              ;first param as token address
  5353                                                          decimalToUnsigned                                       ;convert string token to unsigned
  5354                                                          test    eax,eax                                         ;valid parameter?
  5355                                                          jz      .10                                             ;no, branch
  5356                                  ;
  5357                                  ;       Allocate memory block
  5358                                  ;
  5359                                                          allocateMemory eax                                      ;allocate memory
  5360                                                          test    eax,eax                                         ;memory allocated?
  5361                                                          jz      .10                                             ;no, branch
  5362                                  ;
  5363                                  ;       Report allocated memory block address
  5364                                  ;
  5365                                                          mov     edx,wzConsoleOutBuffer                          ;output buffer address
  5366                                                          mov     ecx,eax                                         ;memory address
  5367                                                          unsignedToHexadecimal                                   ;convert memory address to hex
  5368                                  ;                        putConsoleString wzConsoleOutBuffer                     ;display memory address
  5369                                  ;                        call    ConPutNewLine                                   ;display new line
  5370                                  .10                     pop     edi                                             ;restore non-volatile regs
  5371                                                          pop     esi                                             ;
  5372                                                          pop     ecx                                             ;
  5373                                                          pop     ebx                                             ;
  5374                                                          ret                                                     ;return
  5375                                  ;-----------------------------------------------------------------------------------------------------------------------
  5376                                  ;
  5377                                  ;       Routine:        ConView
  5378                                  ;
  5379                                  ;       Description:    This routine handles the view command.
  5380                                  ;
  5381                                  ;       In:             ES:     OS data segment
  5382                                  ;
  5383                                  ;                       wzConsoleInBuffer contains parameter(s)
  5384                                  ;
  5385                                  ;-----------------------------------------------------------------------------------------------------------------------
  5386                                  ConView                 push    ebx                                             ;save non-volatile regs
  5387                                                          push    ecx                                             ;
  5388                                                          push    esi                                             ;
  5389                                                          push    edi                                             ;
  5390                                  ;
  5391                                  ;       Update the source address if a parameter is given.
  5392                                  ;
  5393                                                          mov     edx,wzConsoleInBuffer                           ;console input buffer address (params)
  5394                                                          mov     ebx,wzConsoleToken                              ;console command token address
  5395                                                          call    ConTakeToken                                    ;take first param as token
  5396                                                          cmp     byte [wzConsoleToken],0                         ;token found?
  5397                                                          je      .10                                             ;no, branch
  5398                                                          mov     edx,wzConsoleToken                              ;first param as token address
  5399                                                          hexadecimalToUnsigned                                   ;convert string token to unsigned
  5400                                                          mov     [wdConsoleMemBase],eax                          ;save console memory address
  5401                                  ;
  5402                                  ;       Initialize panel storage areas.
  5403                                  ;
  5404                                  .10                     mov     edi,wzFldMenuOptn0                              ;first menu option storage
  5405                                                          xor     eax,eax                                         ;zero reg
  5406                                                          mov     al,EASCIIUNDERSCORE                             ;input placeholder
  5407                                                          xor     ecx,ecx                                         ;zero reg
  5408                                                          mov     cl,20                                           ;input field count
  5409                                                          cld                                                     ;forward strings
  5410                                                          rep     stosw                                           ;reset input fields
  5411                                  ;
  5412                                  ;       Setup source address and row count.
  5413                                  ;
  5414                                                          mov     esi,[wdConsoleMemBase]                          ;source memory address
  5415                                                          xor     ecx,ecx                                         ;zero register
  5416                                                          mov     cl,20                                           ;row count
  5417                                                          mov     ebx,wzConsoleMemBuf0                            ;output buffer address
  5418                                  ;
  5419                                  ;       Start the row with the source address in hexadecimal.
  5420                                  ;
  5421                                  .20                     push    ecx                                             ;save remaining rows
  5422                                                          mov     edi,ebx                                         ;output buffer address
  5423                                                          mov     edx,edi                                         ;output buffer address
  5424                                                          mov     ecx,esi                                         ;console memory address
  5425                                                          unsignedToHexadecimal                                   ;convert unsigned address to hex string
  5426                                                          add     edi,8                                           ;end of memory addr hexnum
  5427                                                          mov     al,EASCIISPACE                                  ;ascii space delimiter
  5428                                                          stosb                                                   ;store delimiter
  5429                                  ;
  5430                                  ;       Output 16 ASCII hexadecimal byte values for the row.
  5431                                  ;
  5432                                                          xor     ecx,ecx                                         ;zero register
  5433                                                          mov     cl,16                                           ;loop count
  5434                                  .30                     push    ecx                                             ;save loop count
  5435                                                          mov     al,EASCIISPACE                                  ;ascii space
  5436                                                          stosb                                                   ;store delimiter
  5437                                                          lodsb                                                   ;memory byte
  5438                                                          mov     ah,al                                           ;memory byte
  5439                                                          shr     al,4                                            ;high-order in bits 3-0
  5440                                                          or      al,EASCIIZERO                                   ;apply ascii numeric zone
  5441                                                          cmp     al,EASCIININE                                   ;numeric range?
  5442                                                          jbe     .40                                             ;yes, skip ahead
  5443                                                          add     al,7                                            ;adjust ascii for 'A'-'F'
  5444                                  .40                     stosb                                                   ;store ascii hexadecimal of high-order
  5445                                                          mov     al,ah                                           ;low-order in bits 3-0
  5446                                                          and     al,0fh                                          ;mask out high-order bits
  5447                                                          or      al,EASCIIZERO                                   ;apply ascii numeric zone
  5448                                                          cmp     al,EASCIININE                                   ;numeric range?
  5449                                                          jbe     .50                                             ;yes, skip ahead
  5450                                                          add     al,7                                            ;adjust ascii for 'A'-'F'
  5451                                  .50                     stosb                                                   ;store ascii hexadecimal of low-order
  5452                                                          pop     ecx                                             ;loop count
  5453                                                          loop    .30                                             ;next
  5454                                  ;
  5455                                  ;       Output printable ASCII character section for the row.
  5456                                  ;
  5457                                                          mov     al,EASCIISPACE                                  ;ascii space
  5458                                                          stosb                                                   ;store delimiter
  5459                                                          stosb                                                   ;store delimiter
  5460                                                          sub     esi,16                                          ;reset source pointer
  5461                                                          mov     cl,16                                           ;loop count
  5462                                  .60                     lodsb                                                   ;source byte
  5463                                                          cmp     al,EASCIISPACE                                  ;printable? (low-range test)
  5464                                                          jb      .70                                             ;no, skip ahead
  5465                                                          cmp     al,EASCIITILDE                                  ;printable? (high-range test)
  5466                                                          jbe     .80                                             ;yes, skip ahead
  5467                                  .70                     mov     al,EASCIISPACE                                  ;display space instead of printable
  5468                                  .80                     stosb                                                   ;store printable ascii byte
  5469                                                          loop    .60                                             ;next source byte
  5470                                                          xor     al,al                                           ;zero reg
  5471                                                          stosb                                                   ;null-terminate buffer
  5472                                  ;
  5473                                  ;       Display constructed output buffer and newline.
  5474                                  ;
  5475                                                          add     ebx,76                                          ;next contiguous output buffer addr
  5476                                  ;
  5477                                  ;       Repeat until all lines displayed and preserve source address.
  5478                                  ;
  5479                                                          pop     ecx                                             ;remaining rows
  5480                                                          loop    .20                                             ;next row
  5481                                                          mov     [wdConsoleMemBase],esi                          ;update console memory address
  5482                                  ;
  5483                                  ;       Update the handler, panel and field identifiers.
  5484                                  ;
  5485                                                          mov     eax,[cdHandlerView]                             ;mem panel handler
  5486                                                          mov     [wdConsoleHandler],eax                          ;set panel handler addr
  5487                                                          mov     eax,czPnlMem001                                 ;initial console panel
  5488                                                          mov     [wdConsolePanel],eax                            ;set panel template addr
  5489                                                          mov     eax,czPnlMenuInp                                ;menu panel command field addr
  5490                                                          mov     [wdConsoleField],eax                            ;set active field
  5491                                  ;
  5492                                  ;       Clear and redraw the panel.
  5493                                  ;
  5494                                                          call    ConClearPanel                                   ;clear the panel
  5495                                                          call    ConDrawFields                                   ;draw panel fields
  5496                                  ;
  5497                                  ;       Restore and return.
  5498                                  ;
  5499                                                          pop     edi                                             ;restore non-volatile regs
  5500                                                          pop     esi                                             ;
  5501                                                          pop     ecx                                             ;
  5502                                                          pop     ebx                                             ;
  5503                                                          ret                                                     ;return
  5504                                  ;-----------------------------------------------------------------------------------------------------------------------
  5505                                  ;
  5506                                  ;       Constants
  5507                                  ;
  5508                                  ;-----------------------------------------------------------------------------------------------------------------------
  5509                                  cdHandlerMain           dd      ConHandlerMain - ConCode                        ;main panel code segment offset
  5510                                  cdHandlerView           dd      ConHandlerView - ConCode                        ;view panel code segment offset
  5511                                  ;-----------------------------------------------------------------------------------------------------------------------
  5512                                  ;
  5513                                  ;       Panels
  5514                                  ;
  5515                                  ;       Notes:          1.      Each field MUST have an address of a constant or an input field.
  5516                                  ;                       2.      The constant text or input field MUST be at least the length of the field.
  5517                                  ;                       3.      Field constant text or field values MUST be comprised of printable characters.
  5518                                  ;
  5519                                  ;-----------------------------------------------------------------------------------------------------------------------
  5520                                                                                                                  ;---------------------------------------
  5521                                                                                                                  ;  Main Panel
  5522                                                                                                                  ;---------------------------------------
  5523                                  czPnlCon001             dd      czFldPnlIdCon001                                ;field text
  5524                                                          db      0,0,6,0,0,0,7,0                                 ;row col siz ndx 1st nth atr flg
  5525                                                          dd      czFldTitleCon001
  5526                                                          db      0,33,14,0,0,0,7,0
  5527                                                          dd      czFldDatTmCon001
  5528                                                          db      0,63,17,0,0,0,7,0
  5529                                                          dd      wzFldMenuOptn0
  5530                                                          db      2,1,1,0,0,0,2,80h
  5531                                                          dd      czFldLblMainDevices
  5532                                                          db      2,4,7,0,0,0,7,0
  5533                                                          dd      wzFldMenuOptn1
  5534                                                          db      3,1,1,0,0,0,2,80h
  5535                                                          dd      czFldLblMainMemory
  5536                                                          db      3,4,6,0,0,0,7,0
  5537                                                          dd      wzFldMenuOptn2
  5538                                                          db      4,1,1,0,0,0,2,80h
  5539                                                          dd      czFldLblMainNetwork
  5540                                                          db      4,4,7,0,0,0,7,0
  5541                                                          dd      wzFldMenuOptn3
  5542                                                          db      5,1,1,0,0,0,2,80h
  5543                                                          dd      czFldLblMainStorage
  5544                                                          db      5,4,7,0,0,0,7,0
  5545                                                          dd      wzFldMenuOptn4
  5546                                                          db      6,1,1,0,0,0,2,80h
  5547                                                          dd      czFldLblMainSystem
  5548                                                          db      6,4,6,0,0,0,7,0
  5549                                                          dd      czFldPrmptCon001
  5550                                                          db      23,0,1,0,0,0,7,0
  5551                                  czPnlConInp             dd      wzConsoleInBuffer
  5552                                                          db      23,1,79,0,0,0,7,80h
  5553                                                          dd      0                                               ;end of panel
  5554                                                                                                                  ;---------------------------------------
  5555                                                                                                                  ;  Memory Display Panel
  5556                                                                                                                  ;---------------------------------------
  5557                                  czPnlMem001             dd      czFldPnlIdMem001
  5558                                                          db      0,0,6,0,0,0,7,0
  5559                                                          dd      czFldTitleMem001
  5560                                                          db      0,33,14,0,0,0,7,0
  5561                                                          dd      czFldDatTmCon001
  5562                                                          db      0,63,17,0,0,0,7,0
  5563                                                          dd      wzFldMenuOptn0
  5564                                                          db      2,1,1,0,0,0,2,80h
  5565                                                          dd      wzConsoleMemBuf0
  5566                                                          db      2,4,75,0,0,0,7,0
  5567                                                          dd      wzFldMenuOptn1
  5568                                                          db      3,1,1,0,0,0,2,80h
  5569                                                          dd      wzConsoleMemBuf1
  5570                                                          db      3,4,75,0,0,0,7,0
  5571                                                          dd      wzFldMenuOptn2
  5572                                                          db      4,1,1,0,0,0,2,80h
  5573                                                          dd      wzConsoleMemBuf2
  5574                                                          db      4,4,75,0,0,0,7,0
  5575                                                          dd      wzFldMenuOptn3
  5576                                                          db      5,1,1,0,0,0,2,80h
  5577                                                          dd      wzConsoleMemBuf3
  5578                                                          db      5,4,75,0,0,0,7,0
  5579                                                          dd      wzFldMenuOptn4
  5580                                                          db      6,1,1,0,0,0,2,80h
  5581                                                          dd      wzConsoleMemBuf4
  5582                                                          db      6,4,75,0,0,0,7,0
  5583                                                          dd      wzFldMenuOptn5
  5584                                                          db      7,1,1,0,0,0,2,80h
  5585                                                          dd      wzConsoleMemBuf5
  5586                                                          db      7,4,75,0,0,0,7,0
  5587                                                          dd      wzFldMenuOptn6
  5588                                                          db      8,1,1,0,0,0,2,80h
  5589                                                          dd      wzConsoleMemBuf6
  5590                                                          db      8,4,75,0,0,0,7,0
  5591                                                          dd      wzFldMenuOptn7
  5592                                                          db      9,1,1,0,0,0,2,80h
  5593                                                          dd      wzConsoleMemBuf7
  5594                                                          db      9,4,75,0,0,0,7,0
  5595                                                          dd      wzFldMenuOptn8
  5596                                                          db      10,1,1,0,0,0,2,80h
  5597                                                          dd      wzConsoleMemBuf8
  5598                                                          db      10,4,75,0,0,0,7,0
  5599                                                          dd      wzFldMenuOptn9
  5600                                                          db      11,1,1,0,0,0,2,80h
  5601                                                          dd      wzConsoleMemBuf9
  5602                                                          db      11,4,75,0,0,0,7,0
  5603                                                          dd      wzFldMenuOptnA
  5604                                                          db      12,1,1,0,0,0,2,80h
  5605                                                          dd      wzConsoleMemBufA
  5606                                                          db      12,4,75,0,0,0,7,0
  5607                                                          dd      wzFldMenuOptnB
  5608                                                          db      13,1,1,0,0,0,2,80h
  5609                                                          dd      wzConsoleMemBufB
  5610                                                          db      13,4,75,0,0,0,7,0
  5611                                                          dd      wzFldMenuOptnC
  5612                                                          db      14,1,1,0,0,0,2,80h
  5613                                                          dd      wzConsoleMemBufC
  5614                                                          db      14,4,75,0,0,0,7,0
  5615                                                          dd      wzFldMenuOptnD
  5616                                                          db      15,1,1,0,0,0,2,80h
  5617                                                          dd      wzConsoleMemBufD
  5618                                                          db      15,4,75,0,0,0,7,0
  5619                                                          dd      wzFldMenuOptnE
  5620                                                          db      16,1,1,0,0,0,2,80h
  5621                                                          dd      wzConsoleMemBufE
  5622                                                          db      16,4,75,0,0,0,7,0
  5623                                                          dd      wzFldMenuOptnF
  5624                                                          db      17,1,1,0,0,0,2,80h
  5625                                                          dd      wzConsoleMemBufF
  5626                                                          db      17,4,75,0,0,0,7,0
  5627                                                          dd      wzFldMenuOptn10
  5628                                                          db      18,1,1,0,0,0,2,80h
  5629                                                          dd      wzConsoleMemBuf10
  5630                                                          db      18,4,75,0,0,0,7,0
  5631                                                          dd      wzFldMenuOptn11
  5632                                                          db      19,1,1,0,0,0,2,80h
  5633                                                          dd      wzConsoleMemBuf11
  5634                                                          db      19,4,75,0,0,0,7,0
  5635                                                          dd      wzFldMenuOptn12
  5636                                                          db      20,1,1,0,0,0,2,80h
  5637                                                          dd      wzConsoleMemBuf12
  5638                                                          db      20,4,75,0,0,0,7,0
  5639                                                          dd      wzFldMenuOptn13
  5640                                                          db      21,1,1,0,0,0,2,80h
  5641                                                          dd      wzConsoleMemBuf13
  5642                                                          db      21,4,75,0,0,0,7,0
  5643                                                          dd      czFldPrmptCon001
  5644                                                          db      23,0,1,0,0,0,7,0
  5645                                  czPnlMenuInp            dd      wzConsoleInBuffer
  5646                                                          db      23,1,79,0,0,0,7,80h
  5647                                                          dd      0                                               ;end of panel
  5648                                  ;-----------------------------------------------------------------------------------------------------------------------
  5649                                  ;
  5650                                  ;       Tables
  5651                                  ;
  5652                                  ;-----------------------------------------------------------------------------------------------------------------------
  5653                                                                                                                  ;---------------------------------------
  5654                                                                                                                  ;  Command Jump Table
  5655                                                                                                                  ;---------------------------------------
  5656                                  tConJmpTbl              equ     $                                               ;command jump table
  5657                                                          dd      ConMalloc       - ConCode                       ;malloc command
  5658                                                          dd      ConFree         - ConCode                       ;free command
  5659                                                          dd      ConInt6         - ConCode                       ;int6 command
  5660                                                          dd      ConMain         - ConCode                       ;go command
  5661                                                          dd      ConReset        - ConCode                       ;reset command
  5662                                                          dd      ConView         - ConCode                       ;view command
  5663                                  ECONJMPTBLL             equ     ($-tConJmpTbl)                                  ;table length
  5664                                  ECONJMPTBLCNT           equ     ECONJMPTBLL/4                                   ;table entries
  5665                                                                                                                  ;---------------------------------------
  5666                                                                                                                  ;  Command Name Table
  5667                                                                                                                  ;---------------------------------------
  5668                                  tConCmdTbl              equ     $                                               ;command name table
  5669                                                          db      7,"MALLOC",0                                    ;malloc command
  5670                                                          db      5,"FREE",0                                      ;free command
  5671                                                          db      5,"INT6",0                                      ;int6 command
  5672                                                          db      2,"G",0                                         ;go command
  5673                                                          db      2,"R",0                                         ;reset command
  5674                                                          db      2,"V",0                                         ;view command
  5675                                                          db      0                                               ;end of table
  5676                                  ;-----------------------------------------------------------------------------------------------------------------------
  5677                                  ;
  5678                                  ;       Strings
  5679                                  ;
  5680                                  ;-----------------------------------------------------------------------------------------------------------------------
  5681                                  czFldPnlIdCon001        db      "CON001",0                                      ;main console panel id
  5682                                  czFldTitleCon001        db      "OS Version 1.0",0                              ;main console panel title
  5683                                  czFldDatTmCon001        db      "DD-MMM-YYYY HH:MM",0                           ;panel date and time template
  5684                                  czFldPrmptCon001        db      ":",0                                           ;command prompt
  5685                                  czFldPnlIdMem001        db      "MEM001",0                                      ;memory panel id
  5686                                  czFldTitleMem001        db      "Memory Display",0                              ;memory panel title
  5687                                  czFldMenuOptn001        db      "_",0                                           ;menu option
  5688                                  czFldLblMainDevices     db      "Devices",0                                     ;main panel devices label
  5689                                  czFldLblMainMemory      db      "Memory",0                                      ;main panel memory label
  5690                                  czFldLblMainNetwork     db      "Network",0                                     ;main panel network label
  5691                                  czFldLblMainStorage     db      "Storage",0                                     ;main panel storage label
  5692                                  czFldLblMainSystem      db      "System",0                                      ;main panel system label
  5693                                                          times   4096-($-$$) db 0h                               ;zero fill to end of section
  5694                                  %endif
  5695                                  %ifdef BUILDDISK
  5696                                  ;-----------------------------------------------------------------------------------------------------------------------
  5697                                  ;
  5698                                  ;       Free Disk Space                                                         @disk: 009600   @mem:  n/a
  5699                                  ;
  5700                                  ;       Following the convention introduced by DOS, we use the value 'F6' to indicate unused floppy disk storage.
  5701                                  ;
  5702                                  ;-----------------------------------------------------------------------------------------------------------------------
  5703                                  section                 unused                                                  ;unused disk space
  5704                                                          times   EBOOTDISKBYTES-09600h db 0F6h                   ;fill to end of disk image
  5705                                  %endif
  5706                                  ;=======================================================================================================================
  5707                                  ;
  5708                                  ;       End of Program Code
  5709                                  ;
  5710                                  ;=======================================================================================================================
