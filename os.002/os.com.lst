     1                                  ;=======================================================================================================================
     2                                  ;
     3                                  ;       File:           os.asm
     4                                  ;
     5                                  ;       Project:        os.002
     6                                  ;
     7                                  ;       Description:    This sample program adds code to load the operating system kernel program from the disk image.
     8                                  ;                       The boot sector searches the disk for the loader program, loads it into memory and runs it. The
     9                                  ;                       loader program in this sample simply displays a greeting.
    10                                  ;
    11                                  ;       Revised:        17 June 2019
    12                                  ;
    13                                  ;       Assembly:       nasm os.asm -f bin -o os.dat -l os.dat.lst -DBUILDBOOT
    14                                  ;                       nasm os.asm -f bin -o os.dsk -l os.dsk.lst -DBUILDDISK
    15                                  ;                       nasm os.asm -f bin -o os.com -l os.com.lst -DBUILDCOM
    16                                  ;
    17                                  ;       Assembler:      Netwide Assembler (NASM) 2.13.03, 7 Feb 2018
    18                                  ;
    19                                  ;       Notice:         Copyright (C) 2010-2019 David J. Walling
    20                                  ;
    21                                  ;=======================================================================================================================
    22                                  ;-----------------------------------------------------------------------------------------------------------------------
    23                                  ;
    24                                  ;       Assembly Directives
    25                                  ;
    26                                  ;       Use one of the following as an assembly directive (-D) with NASM.
    27                                  ;
    28                                  ;       BUILDBOOT       Creates os.dat, a 512-byte boot sector as a standalone file.
    29                                  ;       BUILDDISK       Creates os.dsk, a 1.44MB (3.5") floppy disk image file.
    30                                  ;       BUILDCOM        Creates os.com, the OS loader and kernel as a standalone DOS program.
    31                                  ;
    32                                  ;-----------------------------------------------------------------------------------------------------------------------
    33                                  %ifdef BUILDDISK                                                                ;if we are building a disk image ...
    34                                  %define BUILDBOOT                                                               ;... also build the boot sector
    35                                  %define BUILDCOM                                                                ;... and the OS kernel
    36                                  %endif
    37                                  ;-----------------------------------------------------------------------------------------------------------------------
    38                                  ;
    39                                  ;       Conventions
    40                                  ;
    41                                  ;       Alignment:      In this document, columns are numbered beginning with 1. Logical tabs are set after every
    42                                  ;                       eight columns. Tabs are simulated using SPACE characters. Comments that span an entire line
    43                                  ;                       have a semicolon in line 1 and text begins in column 9. Assembly instructions (mnemonics)
    44                                  ;                       begin in column 25. Assembly operands begin in column 33. Inline comments begin in column 81.
    45                                  ;                       Lines should not extend beyond column 120.
    46                                  ;
    47                                  ;       Arguments:      Arguments are passed as registers and generally follow this order: EAX, ECX, EDX, EBX. ECX
    48                                  ;                       may be used as the sole parameter if a test for zero is required. EBX and EBP may be used as
    49                                  ;                       parameters if the routine is considered a "method" of an "object". In this case, EBX or EBP
    50                                  ;                       will address the object storage. If the routine is general-purpose string or character-array
    51                                  ;                       manipulator, ESI and EDI may be used as parameters to address input and/or ouput buffers.
    52                                  ;
    53                                  ;       Code Order:     Routines should appear in the order of their first likely use. Negative relative call or jump
    54                                  ;                       addresses usually, therefore, indicate reuse.
    55                                  ;
    56                                  ;       Comments:       A comment that spans the entire line begins with a semicolon in column 1. A comment that
    57                                  ;                       accompanies code on a line begins with a semicolon in column 81. Register names in comments
    58                                  ;                       are in upper case (EAX, EDI). Hexadecimal values in comments are in lower case (01fh, 0dah).
    59                                  ;                       Routines are preceded with a comment box that includes the routine name, description, and
    60                                  ;                       register contents on entry and exit, if applicable.
    61                                  ;
    62                                  ;       Constants:      Symbolic constants (equates) are named in all-caps beginning with 'E' (EDATAPORT). Constant
    63                                  ;                       stored values are named in camel case, starting with 'c' (cbMaxLines). The 2nd letter of the
    64                                  ;                       constant label indicates the storage type.
    65                                  ;
    66                                  ;                       cq......        constant quad-word (dq)
    67                                  ;                       cd......        constant double-word (dd)
    68                                  ;                       cw......        constant word (dw)
    69                                  ;                       cb......        constant byte (db)
    70                                  ;                       cz......        constant ASCIIZ (null-terminated) string
    71                                  ;                       cs......        constant non-terminated string (sequence of characters)
    72                                  ;
    73                                  ;       Instructions:   32-bit instructions are generally favored. 8-bit instructions and data are preferred for
    74                                  ;                       flags and status fields, etc. 16-bit instructions are avoided wherever possible to limit
    75                                  ;                       the generation of prefix bytes.
    76                                  ;
    77                                  ;       Labels:         Labels within a routine are numeric and begin with a period (.10, .20). Labels within a
    78                                  ;                       routine begin at ".10" and increment by 10.
    79                                  ;
    80                                  ;       Literals:       Literal values defined by external standards should be defined as symbolic constants
    81                                  ;                       (equates). Hexadecimal literals in code are in upper case with a leading '0' and trailing
    82                                  ;                       'h' (01Fh). Binary literal values in source code are encoded with a final 'b' (1010b).
    83                                  ;                       Decimal literal values in source code are strictly numerals (2048). Octal literal values
    84                                  ;                       are avoided. String literals are enclosed in double quotes, e.g. "Loading OS". Single
    85                                  ;                       character literals are enclosed in single quotes, e.g. 'A'.
    86                                  ;
    87                                  ;       Macros:         Macro names are in camel case, beginning with a lower-case letter (getDateString). Macro
    88                                  ;                       names describe an action and begin with a verb.
    89                                  ;
    90                                  ;       Memory Use:     Operating system memory allocation is avoided. Buffers are kept to as small a size as
    91                                  ;                       practicable. Data and code intermingling is avoided.
    92                                  ;
    93                                  ;       Registers:      Register names in comments are in upper case (EAX, EDX). Register names in source code are
    94                                  ;                       in lower case (eax, edx).
    95                                  ;
    96                                  ;       Return Values:  Routines return result values in EAX or ECX or both. Routines should indicate failure by
    97                                  ;                       setting the carry flag to 1. Routines may prefer the use of ECX as a return value if the
    98                                  ;                       value is to be tested for null upon return (using the jecxz instruction).
    99                                  ;
   100                                  ;       Routines:       Routine names are in mixed case and capitalized (GetYear, ReadRealTimeClock). Routine names
   101                                  ;                       begin with a verb (Get, Read, Load). Routines should have a single entry address and a single
   102                                  ;                       exit instruction (ret, iretd, etc.). Routines that serve as wrappers for library functions
   103                                  ;                       carry the same name as the library function but begin with a leading underscore (_) character.
   104                                  ;
   105                                  ;       Structures:     Structure names are in all-caps (DATETIME). Structure names describe a "thing" and so do NOT
   106                                  ;                       begin with a verb.
   107                                  ;
   108                                  ;       Usage:          Registers EBX, ECX, EBP, SS, CS, DS and ES are preserved by routines. Registers ESI and EDI
   109                                  ;                       are preserved unless they are input parameters. Registers EAX and ECX are preferred for
   110                                  ;                       returning response/result values. Registers EBX and EBP are preferred for context (structure)
   111                                  ;                       address parameters. Registers EAX, ECX, EDX and EBX are preferred for integral parameters.
   112                                  ;
   113                                  ;       Variables:      Variables are named in camel case, starting with 'w'. The 2nd letter of the variable label
   114                                  ;                       indicates the storage type.
   115                                  ;
   116                                  ;                       wq......        variable quad-word (resq)
   117                                  ;                       wd......        variable double-word (resd)
   118                                  ;                       ww......        variable word (resw)
   119                                  ;                       wb......        variable byte (resb)
   120                                  ;                       ws......        writable structure
   121                                  ;
   122                                  ;-----------------------------------------------------------------------------------------------------------------------
   123                                  ;=======================================================================================================================
   124                                  ;
   125                                  ;       Equates
   126                                  ;
   127                                  ;       The equate (equ) statement defines a symbolic name for a fixed value so that such a value can be defined and
   128                                  ;       verified once and then used throughout the code. Using symbolic names simplifies searching for where logical
   129                                  ;       values are used. Equate names are in all-caps and begin with the letter 'E'. Equates are grouped into related
   130                                  ;       sets. Equates in this sample program are defined in the following groupings:
   131                                  ;
   132                                  ;       Hardware-Defined Values
   133                                  ;
   134                                  ;       EKEYB...        8042 or "PS/2 Controller" (Keyboard Controller) values
   135                                  ;
   136                                  ;       Firmware-Defined Values
   137                                  ;
   138                                  ;       EBIOS...        Basic Input/Output System (BIOS) values
   139                                  ;
   140                                  ;       Operating System Values
   141                                  ;
   142                                  ;       EBOOT...        Boot sector and loader values
   143                                  ;
   144                                  ;=======================================================================================================================
   145                                  ;-----------------------------------------------------------------------------------------------------------------------
   146                                  ;
   147                                  ;       Hardware-Defined Values
   148                                  ;
   149                                  ;-----------------------------------------------------------------------------------------------------------------------
   150                                  ;-----------------------------------------------------------------------------------------------------------------------
   151                                  ;
   152                                  ;       8042 Keyboard Controller                                                EKEYB...
   153                                  ;
   154                                  ;       The 8042 Keyboard Controller (8042) is a programmable controller that accepts input signals from the keyboard
   155                                  ;       device. It also signals a hardware interrupt to the CPU when the low-order bit of I/O port 64h is set to zero.
   156                                  ;
   157                                  ;-----------------------------------------------------------------------------------------------------------------------
   158                                  EKEYBPORTSTAT           equ     064h                                            ;status port
   159                                  EKEYBCMDRESET           equ     0FEh                                            ;reset bit 0 to restart system
   160                                  ;-----------------------------------------------------------------------------------------------------------------------
   161                                  ;
   162                                  ;       Firmware-Defined Values
   163                                  ;
   164                                  ;-----------------------------------------------------------------------------------------------------------------------
   165                                  ;-----------------------------------------------------------------------------------------------------------------------
   166                                  ;
   167                                  ;       BIOS Interrupts and Functions                                           EBIOS...
   168                                  ;
   169                                  ;       Basic Input/Output System (BIOS) functions are grouped and accessed by issuing an interrupt call. Each
   170                                  ;       BIOS interrupt supports several functions. The function code is typically passed in the AH register.
   171                                  ;
   172                                  ;-----------------------------------------------------------------------------------------------------------------------
   173                                  EBIOSINTVIDEO           equ     010h                                            ;video services interrupt
   174                                  EBIOSFNSETVMODE         equ     000h                                            ;video set mode function
   175                                  EBIOSMODETEXT80         equ     003h                                            ;video mode 80x25 text
   176                                  EBIOSFNTTYOUTPUT        equ     00Eh                                            ;video TTY output function
   177                                  EBIOSINTDISKETTE        equ     013h                                            ;diskette services interrupt
   178                                  EBIOSFNREADSECTOR       equ     002h                                            ;diskette read sector function
   179                                  EBIOSINTKEYBOARD        equ     016h                                            ;keyboard services interrupt
   180                                  EBIOSFNKEYSTATUS        equ     001h                                            ;keyboard status function
   181                                  ;-----------------------------------------------------------------------------------------------------------------------
   182                                  ;
   183                                  ;       Operating System Values
   184                                  ;
   185                                  ;-----------------------------------------------------------------------------------------------------------------------
   186                                  ;-----------------------------------------------------------------------------------------------------------------------
   187                                  ;
   188                                  ;       Boot Sector and Loader Constants                                        EBOOT...
   189                                  ;
   190                                  ;       Equates in this section support the boot sector and the 16-bit operating system loader, which will be
   191                                  ;       responsible for placing the CPU into protected mode and calling the initial operating system task.
   192                                  ;
   193                                  ;-----------------------------------------------------------------------------------------------------------------------
   194                                  EBOOTSTACKTOP           equ     0100h                                           ;boot sector stack top relative to DS
   195                                  EBOOTSECTORBYTES        equ     512                                             ;bytes per sector
   196                                  EBOOTDIRENTRIES         equ     224                                             ;directory entries (1.44MB 3.5" FD)
   197                                  EBOOTDISKSECTORS        equ     2880                                            ;sectors per disk (1.44MB 3.5" FD)
   198                                  EBOOTDISKBYTES          equ     (EBOOTSECTORBYTES*EBOOTDISKSECTORS)             ;bytes per disk
   199                                  EBOOTFATBASE            equ     (EBOOTSTACKTOP+EBOOTSECTORBYTES)                ;offset of FAT I/O buffer rel to DS
   200                                  EBOOTMAXTRIES           equ     5                                               ;max read retries
   201                                  %ifdef BUILDBOOT
   202                                  ;=======================================================================================================================
   203                                  ;
   204                                  ;       Boot Sector                                                             @disk: 000000   @mem: 007c00
   205                                  ;
   206                                  ;       The first sector of the diskette is the boot sector. The BIOS will load the boot sector into memory and pass
   207                                  ;       control to the code at the start of the sector. The boot sector code is responsible for loading the operating
   208                                  ;       system into memory. The boot sector contains a disk parameter table describing the geometry and allocation
   209                                  ;       of the diskette. Following the disk parameter table is code to load the operating system kernel into memory.
   210                                  ;
   211                                  ;       The "cpu" directive limits emitted code to those instructions supported by the most primitive processor
   212                                  ;       we expect to ever execute our code. The "vstart" parameter indicates addressability of symbols so as to
   213                                  ;       emulate the DOS .COM program model. Although the BIOS is expected to load the boot sector at address 7c00,
   214                                  ;       we do not make that assumption. The CPU starts in 16-bit addressing mode. A three-byte jump instruction is
   215                                  ;       immediately followed by the disk parameter table.
   216                                  ;
   217                                  ;=======================================================================================================================
   218                                                          cpu     8086                                            ;assume minimal CPU
   219                                  section                 boot    vstart=0100h                                    ;emulate .COM (CS,DS,ES=PSP) addressing
   220                                                          bits    16                                              ;16-bit code at power-up
   221                                  Boot                    jmp     word Boot.10                                    ;jump over parameter table
   222                                  ;-----------------------------------------------------------------------------------------------------------------------
   223                                  ;
   224                                  ;       Disk Parameter Table
   225                                  ;
   226                                  ;       The disk parameter table informs the BIOS of the floppy disk architecture. Here, we use parameters for the
   227                                  ;       3.5" 1.44MB floppy disk since this format is widely supported by virtual machine hypervisors.
   228                                  ;
   229                                  ;-----------------------------------------------------------------------------------------------------------------------
   230                                                          db      "OS      "                                      ;eight-byte label
   231                                  cwSectorBytes           dw      EBOOTSECTORBYTES                                ;bytes per sector
   232                                  cbClusterSectors        db      1                                               ;sectors per cluster
   233                                  cwReservedSectors       dw      1                                               ;reserved sectors
   234                                  cbFatCount              db      2                                               ;file allocation table copies
   235                                  cwDirEntries            dw      EBOOTDIRENTRIES                                 ;max directory entries
   236                                  cwDiskSectors           dw      EBOOTDISKSECTORS                                ;sectors per disk
   237                                  cbDiskType              db      0F0h                                            ;1.44MB
   238                                  cwFatSectors            dw      9                                               ;sectors per FAT copy
   239                                  cbTrackSectors          equ     $                                               ;sectors per track (as byte)
   240                                  cwTrackSectors          dw      18                                              ;sectors per track (as word)
   241                                  cwDiskSides             dw      2                                               ;sides per disk
   242                                  cwSpecialSectors        dw      0                                               ;special sectors
   243                                  ;
   244                                  ;       BIOS typically loads the boot sector at absolute address 7c00 and sets the stack pointer at 512 bytes past
   245                                  ;       the end of the boot sector. But, since BIOS code varies, we don't make any assumptions as to where our boot
   246                                  ;       sector is loaded. For example, the initial CS:IP could be 0:7c00, 700:c00, 7c0:0, etc. To avoid assumptions,
   247                                  ;       we first normalize CS:IP to get the absolute segment address in BX. The comments below show the effect of this
   248                                  ;       code given several possible starting values for CS:IP.
   249                                  ;
   250                                                                                                                  ;CS:IP   0:7c00 700:c00 7c0:0
   251                                  Boot.10                 call    word .20                                        ;[ESP] =   7c21     c21    21
   252                                  .@20                    equ     $-$$                                            ;.@20 = 021h
   253                                  .20                     pop     ax                                              ;AX =      7c21     c21    21
   254                                                          sub     ax,.@20                                         ;AX =      7c00     c00     0
   255                                                          mov     cl,4                                            ;shift count
   256                                                          shr     ax,cl                                           ;AX =       7c0      c0     0
   257                                                          mov     bx,cs                                           ;BX =         0     700   7c0
   258                                                          add     bx,ax                                           ;BX =       7c0     7c0   7c0
   259                                  ;
   260                                  ;       Now, since we are assembling our boot code to emulate the addressing of a .COM file, we want the DS and ES
   261                                  ;       registers to be set to where a Program Segment Prefix (PSP) would be, exactly 100h (256) bytes prior to
   262                                  ;       the start of our code. This will correspond to our assembled data address offsets. Note that we instructed
   263                                  ;       the assembler to produce addresses for our symbols that are offset from our code by 100h. See the "vstart"
   264                                  ;       parameter for the "section" directive above. We also set SS to the PSP and SP to the address of our i/o
   265                                  ;       buffer. This leaves 256 bytes of usable stack from 7b0:0 to 7b0:100.
   266                                  ;
   267                                  ;       Note that when a value is loaded into the stack segment register (SS) interrupts are disabled until the
   268                                  ;       completion of the following instruction.
   269                                  ;
   270                                                          sub     bx,16                                           ;BX = 07b0
   271                                                          mov     ds,bx                                           ;DS = 07b0 = psp
   272                                                          mov     es,bx                                           ;ES = 07b0 = psp
   273                                                          mov     ss,bx                                           ;SS = 07b0 = psp (ints disabled)
   274                                                          mov     sp,EBOOTSTACKTOP                                ;SP = 0100       (ints enabled)
   275                                  ;
   276                                  ;       Our boot addressability is now set up according to the following diagram.
   277                                  ;
   278                                  ;       DS,ES,SS -----> 007b00  +-----------------------------------------------+ DS:0000
   279                                  ;                               |  Boot Stack & Boot PSP (Unused)               |
   280                                  ;                               |  256 = 100h bytes                             |
   281                                  ;       SS:SP --------> 007c00  +-----------------------------------------------+ DS:0100  07b0:0100
   282                                  ;                               |  Boot Sector (vstart=0100h)                   |
   283                                  ;                               |  1 sector = 512 = 200h bytes                  |
   284                                  ;                       007e00  +-----------------------------------------------+ DS:0300
   285                                  ;                               |  File Allocation Table (FAT) I/O Buffer       |
   286                                  ;                               |  9x512-byte sectors = 4,608 = 1200h bytes     |
   287                                  ;                       009000  +-----------------------------------------------+ DS:1500  08f0:0100
   288                                  ;                               |  Directory Sector Buffer & Kernel Load Area   |
   289                                  ;                               |  2 sectors = 1024 = 400h bytes
   290                                  ;                       009400  +-----------------------------------------------+ DS:1900
   291                                  ;
   292                                  ;       On entry, DL indicates the drive being booted from.
   293                                  ;
   294                                                          mov     [wbDrive],dl                                    ;[wbDrive] = drive being booted from
   295                                  ;
   296                                  ;       Compute directory i/o buffer address.
   297                                  ;
   298                                                          mov     ax,[cwFatSectors]                               ;AX = 0009 = FAT sectors
   299                                                          mul     word [cwSectorBytes]                            ;DX:AX = 0000:1200 = FAT bytes
   300                                                          add     ax,EBOOTFATBASE                                 ;AX = 1500 = end of FAT buffer
   301                                                          mov     [wwDirBuffer],ax                                ;[wwDirBuffer] = 1500
   302                                  ;
   303                                  ;       Compute segment where os.com will be loaded.
   304                                  ;
   305                                                          shr     ax,cl                                           ;AX = 0150
   306                                                          add     ax,bx                                           ;AX = 0150 + 07b0 = 0900
   307                                                          sub     ax,16                                           ;AX = 08f0
   308                                                          mov     [wwLoadSegment],ax                              ;[wwLoadSegment] = 08f0
   309                                  ;
   310                                  ;       Set the video mode to 80 column, 25 row, text.
   311                                  ;
   312                                                          mov     ax,EBIOSFNSETVMODE<<8|EBIOSMODETEXT80           ;set mode function, 80x25 text mode
   313                                                          int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
   314                                  ;
   315                                  ;       Write a message to the console so we know we have our addressability established.
   316                                  ;
   317                                                          mov     si,czLoadMsg                                    ;loading message
   318                                                          call    BootPrint                                       ;display loader message
   319                                  ;
   320                                  ;       Initialize the number of directory sectors to search.
   321                                  ;
   322                                                          mov     ax,[cwDirEntries]                               ;AX = 224 = max dir entries
   323                                                          mov     [wwEntriesLeft],ax                              ;[wwEntriesLeft] = 224
   324                                  ;
   325                                  ;       Compute number of directory sectors and initialize overhead count.
   326                                  ;
   327                                                          mov     cx,ax                                           ;CX = 00e0 = 224 entries
   328                                                          mul     word [cwEntryLen]                               ;DX:AX = 224 * 32 = 7168
   329                                                          div     word [cwSectorBytes]                            ;AX = 7168 / 512 = 14 = dir sectors
   330                                                          mov     [wwOverhead],ax                                 ;[wwOverhead] = 000e
   331                                  ;
   332                                  ;       Compute directory entries per sector.
   333                                  ;
   334                                                          xchg    ax,cx                                           ;DX:AX = 0:00e0, CX = 0000e
   335                                                          div     cx                                              ;AX = 0010 = entries per dir sector
   336                                                          mov     [wwSectorEntries],ax                            ;[wwSectorEntries] = 0010
   337                                  ;
   338                                  ;       Compute first logical directory sector and update overhead count.
   339                                  ;
   340                                                          mov     ax,[cwFatSectors]                               ;AX = 0009 = FAT sectors per copy
   341                                                          mul     byte [cbFatCount]                               ;AX = 0012 = FAT sectors
   342                                                          add     ax,[cwReservedSectors]                          ;AX = 0013 = FAT plus reserved
   343                                                          add     ax,[cwSpecialSectors]                           ;AX = 0013 = FAT + reserved + special
   344                                                          mov     [wwLogicalSector],ax                            ;[wwLogicalSector] = 0013
   345                                                          add     [wwOverhead],ax                                 ;[wwOverhead] = 0021 = res+spec+FAT+dir
   346                                  ;
   347                                  ;       Read directory sector.
   348                                  ;
   349                                  .30                     mov     al,1                                            ;sector count
   350                                                          mov     [wbReadCount],al                                ;[wbReadCount] = 01
   351                                                          mov     bx,[wwDirBuffer]                                ;BX = 1500
   352                                                          call    ReadSector                                      ;read sector into es:bx
   353                                  ;
   354                                  ;       Setup variables to search this directory sector.
   355                                  ;
   356                                                          mov     ax,[wwEntriesLeft]                              ;directory entries to search
   357                                                          cmp     ax,[wwSectorEntries]                            ;need to search more sectors?
   358                                                          jna     .40                                             ;no, continue
   359                                                          mov     ax,[wwSectorEntries]                            ;yes, limit search to sector
   360                                  .40                     sub     [wwEntriesLeft],ax                              ;update entries left to searh
   361                                                          mov     si,cbKernelProgram                              ;program name
   362                                                          mov     di,[wwDirBuffer]                                ;DI = 1500
   363                                  ;
   364                                  ;       Loop through directory sectors searching for kernel program.
   365                                  ;
   366                                  .50                     push    si                                              ;save kernel name address
   367                                                          push    di                                              ;save dir i/o buffer address
   368                                                          mov     cx,11                                           ;length of 8+3 name
   369                                                          cld                                                     ;forward strings
   370                                                          repe    cmpsb                                           ;compare entry name
   371                                                          pop     di                                              ;restore dir i/o buffer address
   372                                                          pop     si                                              ;restore kernel name address
   373                                                          je      .60                                             ;exit loop if found
   374                                                          add     di,[cwEntryLen]                                 ;point to next dir entry
   375                                                          dec     ax                                              ;decrement remaining entries
   376                                                          jnz     .50                                             ;next entry
   377                                  ;
   378                                  ;       Repeat search if we are not at the end of the directory.
   379                                  ;
   380                                                          inc     word [wwLogicalSector]                          ;increment logical sector
   381                                                          cmp     word [wwEntriesLeft],0                          ;done with directory?
   382                                                          jne     .30                                             ;no, get next sector
   383                                                          mov     si,czNoKernel                                   ;missing kernel message
   384                                                          jmp     BootExit                                        ;display message and exit
   385                                  ;
   386                                  ;       If we find the kernel program in the directory, read the FAT.
   387                                  ;
   388                                  .60                     mov     ax,[cwReservedSectors]                          ;AX = 0001
   389                                                          mov     [wwLogicalSector],ax                            ;start past boot sector
   390                                                          mov     ax,[cwFatSectors]                               ;AX = 0009
   391                                                          mov     [wbReadCount],al                                ;[wbReadCount] = 09
   392                                                          mov     bx,EBOOTFATBASE                                 ;BX = 0300
   393                                                          call    ReadSector                                      ;read FAT into buffer
   394                                  ;
   395                                  ;       Get the starting cluster of the kernel program and target address.
   396                                  ;
   397                                                          mov     ax,[di+26]                                      ;AX = starting cluster of file
   398                                                          les     bx,[wwLoadOffset]                               ;ES:BX = kernel load add (08f0:0100)
   399                                  ;
   400                                  ;       Read each program cluster into RAM.
   401                                  ;
   402                                  .70                     push    ax                                              ;save cluster nbr
   403                                                          sub     ax,2                                            ;AX = cluster nbr base 0
   404                                                          mov     cl,[cbClusterSectors]                           ;CL = sectors per cluster
   405                                                          mov     [wbReadCount],cl                                ;save sectors to read
   406                                                          xor     ch,ch                                           ;CX = sectors per cluster
   407                                                          mul     cx                                              ;DX:AX = logical cluster sector
   408                                                          add     ax,[wwOverhead]                                 ;AX = kernel sector nbr
   409                                                          mov     [wwLogicalSector],ax                            ;save logical sector nbr
   410                                                          call    ReadSector                                      ;read sectors into ES:BX
   411                                  ;
   412                                  ;       Update buffer pointer for next cluster.
   413                                  ;
   414                                                          mov     al,[cbClusterSectors]                           ;AL = sectors per cluster
   415                                                          xor     ah,ah                                           ;AX = sectors per cluster
   416                                                          mul     word [cwSectorBytes]                            ;DX:AX = cluster bytes
   417                                                          add     bx,ax                                           ;BX = next cluster target address
   418                                                          pop     ax                                              ;AX = restore cluster nbr
   419                                  ;
   420                                  ;       Compute next cluster number.
   421                                  ;
   422                                                          mov     cx,ax                                           ;CX = cluster nbr
   423                                                          mov     di,ax                                           ;DI = cluster nbr
   424                                                          shr     ax,1                                            ;AX = cluster/2
   425                                                          mov     dx,ax                                           ;DX = cluster/2
   426                                                          add     ax,dx                                           ;AX = 2*(cluster/2)
   427                                                          add     ax,dx                                           ;AX = 3*(cluster/2)
   428                                                          and     di,1                                            ;get low bit
   429                                                          add     di,ax                                           ;add one if cluster is odd
   430                                                          add     di,EBOOTFATBASE                                 ;add FAT buffer address
   431                                                          mov     ax,[di]                                         ;get cluster bytes
   432                                  ;
   433                                  ;       Adjust cluster nbr by 4 bits if cluster is odd; test for end of chain.
   434                                  ;
   435                                                          test    cl,1                                            ;is cluster odd?
   436                                                          jz      .80                                             ;no, skip ahead
   437                                                          mov     cl,4                                            ;shift count
   438                                                          shr     ax,cl                                           ;shift nybble low
   439                                  .80                     and     ax,0FFFh                                        ;mask for 24 bits; next cluster nbr
   440                                                          cmp     ax,0FFFh                                        ;end of chain?
   441                                                          jne     .70                                             ;no, continue
   442                                  ;
   443                                  ;       Transfer control to the operating system program.
   444                                  ;
   445                                                          db      0EAh                                            ;jmp seg:offset
   446                                  wwLoadOffset            dw      0100h                                           ;kernel entry offset
   447                                  wwLoadSegment           dw      08F0h                                           ;kernel entry segment (computed)
   448                                  ;
   449                                  ;       Read [wbReadCount] disk sectors from [wwLogicalSector] into ES:BX.
   450                                  ;
   451                                  ReadSector              mov     ax,[cwTrackSectors]                             ;AX = sectors per track
   452                                                          mul     word [cwDiskSides]                              ;DX:AX = sectors per cylinder
   453                                                          mov     cx,ax                                           ;CX = sectors per cylinder
   454                                                          mov     ax,[wwLogicalSector]                            ;DX:AX = logical sector
   455                                                          div     cx                                              ;AX = cylinder; DX = cyl sector
   456                                                          mov     [wbTrack],al                                    ;[wbTrack] = cylinder
   457                                                          mov     ax,dx                                           ;AX = cyl sector
   458                                                          div     byte [cbTrackSectors]                           ;AH = sector, AL = head
   459                                                          inc     ah                                              ;AH = sector (1,2,3,...)
   460                                                          mov     [wbHead],ax                                     ;[wbHead]= head, [wwSectorTrack]= sector
   461                                  ;
   462                                  ;       Try maxtries times to read sector.
   463                                  ;
   464                                                          mov     cx,EBOOTMAXTRIES                                ;CX = 0005
   465                                  .10                     push    bx                                              ;save buffer address
   466                                                          push    cx                                              ;save retry count
   467                                                          mov     dx,[wwDriveHead]                                ;DH = head, DL = drive
   468                                                          mov     cx,[wwSectorTrack]                              ;CH = track, CL = sector
   469                                                          mov     ax,[wwReadCountCommand]                         ;AH = fn., AL = sector count
   470                                                          int     EBIOSINTDISKETTE                                ;read sector
   471                                                          pop     cx                                              ;restore retry count
   472                                                          pop     bx                                              ;restore buffer address
   473                                                          jnc     BootReturn                                      ;skip ahead if done
   474                                                          loop    .10                                             ;retry
   475                                  ;
   476                                  ;       Handle disk error: convert to ASCII and store in error string.
   477                                  ;
   478                                                          mov     al,ah                                           ;AL = bios error code
   479                                                          xor     ah,ah                                           ;AX = bios error code
   480                                                          mov     dl,16                                           ;divisor for base 16
   481                                                          div     dl                                              ;AL = hi order, AH = lo order
   482                                                          or      ax,03030h                                       ;apply ASCII zone bits
   483                                                          cmp     ah,03Ah                                         ;range test ASCII numeral
   484                                                          jb      .20                                             ;continue if numeral
   485                                                          add     ah,7                                            ;adjust for ASCII 'A'-'F'
   486                                  .20                     cmp     al,03Ah                                         ;range test ASCII numeral
   487                                                          jb      .30                                             ;continue if numeral
   488                                                          add     ah,7                                            ;adjust for ASCII 'A'-'F'
   489                                  .30                     mov     [wzErrorCode],ax                                ;store ASCII error code
   490                                                          mov     si,czErrorMsg                                   ;error message address
   491                                  BootExit                call    BootPrint                                       ;display messge to console
   492                                  ;
   493                                  ;       Wait for a key press.
   494                                  ;
   495                                  .10                     mov     ah,EBIOSFNKEYSTATUS                             ;BIOS keyboard status function
   496                                                          int     EBIOSINTKEYBOARD                                ;get keyboard status
   497                                                          jnz     .20                                             ;continue if key pressed
   498                                                          sti                                                     ;enable maskable interrupts
   499                                                          hlt                                                     ;wait for interrupt
   500                                                          jmp     .10                                             ;repeat
   501                                  ;
   502                                  ;       Reset the system.
   503                                  ;
   504                                  .20                     mov     al,EKEYBCMDRESET                                ;8042 pulse output port pin
   505                                                          out     EKEYBPORTSTAT,al                                ;drive B0 low to restart
   506                                  .30                     sti                                                     ;enable maskable interrupts
   507                                                          hlt                                                     ;stop until reset, int, nmi
   508                                                          jmp     .30                                             ;loop until restart kicks in
   509                                  ;
   510                                  ;       Display text message.
   511                                  ;
   512                                  BootPrint               cld                                                     ;forward strings
   513                                  .10                     lodsb                                                   ;load next byte at DS:SI in AL
   514                                                          test    al,al                                           ;end of string?
   515                                                          jz      BootReturn                                      ;... yes, exit our loop
   516                                                          mov     ah,EBIOSFNTTYOUTPUT                             ;BIOS teletype function
   517                                                          int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
   518                                                          jmp     .10                                             ;repeat until done
   519                                  BootReturn              ret                                                     ;return
   520                                  ;-----------------------------------------------------------------------------------------------------------------------
   521                                  ;
   522                                  ;       Constants
   523                                  ;
   524                                  ;-----------------------------------------------------------------------------------------------------------------------
   525                                                          align   2
   526                                  cwEntryLen              dw      32                                              ;length of directory entry
   527                                  cbKernelProgram         db      "OS      COM"                                   ;kernel program name
   528                                  czLoadMsg               db      "Loading OS",13,10,0                            ;loading message
   529                                  czErrorMsg              db      "Disk error "                                   ;error message
   530                                  wzErrorCode             db      020h,020h,0                                     ;error code and null terminator
   531                                  czNoKernel              db      "OS missing",0                                  ;missing kernel message
   532                                  ;-----------------------------------------------------------------------------------------------------------------------
   533                                  ;
   534                                  ;       Work Areas
   535                                  ;
   536                                  ;-----------------------------------------------------------------------------------------------------------------------
   537                                                          align   2
   538                                  wwDirBuffer             dw      0                                               ;directory i/o buffer address
   539                                  wwEntriesLeft           dw      0                                               ;directory entries to search
   540                                  wwOverhead              dw      0                                               ;overhead sectors
   541                                  wwSectorEntries         dw      0                                               ;directory entries per sector
   542                                  wwLogicalSector         dw      0                                               ;current logical sector
   543                                  wwReadCountCommand      equ     $                                               ;read count and command
   544                                  wbReadCount             db      0                                               ;sectors to read
   545                                  cbReadCommand           db      EBIOSFNREADSECTOR                               ;BIOS read disk fn code
   546                                  wwDriveHead             equ     $                                               ;drive, head (word)
   547                                  wbDrive                 db      0                                               ;drive
   548                                  wbHead                  db      0                                               ;head
   549                                  wwSectorTrack           equ     $                                               ;sector, track (word)
   550                                                          db      0                                               ;sector
   551                                  wbTrack                 db      0                                               ;track
   552                                                          times   510-($-$$) db 0h                                ;zero fill to end of sector
   553                                                          db      055h,0AAh                                       ;end of sector signature
   554                                  %endif
   555                                  %ifdef BUILDDISK
   556                                  ;=======================================================================================================================
   557                                  ;
   558                                  ;       File Allocation Tables
   559                                  ;
   560                                  ;       The disk contains two copies of the File Allocation Table (FAT). On our disk, each FAT copy is 1200h bytes in
   561                                  ;       length. Each FAT entry contains the logical number of the next cluster. The first two entries are reserved. Our
   562                                  ;       OS.COM file here is 400h bytes in length. These 400h bytes contain familiar code that displays a message to the
   563                                  ;       screen. Our disk parameter table defines a cluster as containing one sector and each sector having 200h bytes.
   564                                  ;       Therefore, our FAT table must reserve only two clusters for OS.COM. The clusters used by OS.COM, then, will be
   565                                  ;       clusters 2 and 3. The entry value for cluster 3 is set to "0fffh" to indicate that it is the last cluster in the
   566                                  ;       chain.
   567                                  ;
   568                                  ;       Every three bytes encode two FAT entries as follows:
   569                                  ;
   570                                  ;       db      0abh,0cdh,0efh  ;even cluster: 0dabh, odd cluster: 0efch
   571                                  ;
   572                                  ;=======================================================================================================================
   573                                  ;-----------------------------------------------------------------------------------------------------------------------
   574                                  ;
   575                                  ;       FAT copy 1                                                              @disk: 000200   @mem: n/a
   576                                  ;
   577                                  ;-----------------------------------------------------------------------------------------------------------------------
   578                                  section                 fat1                                                    ;first copy of FAT
   579                                                          db      0F0h,0FFh,0FFh, 003h,0F0h,0FFh
   580                                                          times   (9*512)-($-$$) db 0                             ;zero fill to end of section
   581                                  ;-----------------------------------------------------------------------------------------------------------------------
   582                                  ;
   583                                  ;       FAT copy 2                                                              @disk: 001400   @mem: n/a
   584                                  ;
   585                                  ;-----------------------------------------------------------------------------------------------------------------------
   586                                  section                 fat2                                                    ;second copy of FAT
   587                                                          db      0F0h,0FFh,0FFh, 003h,0F0h,0FFh
   588                                                          times   (9*512)-($-$$) db 0                             ;zero fill to end of section
   589                                  ;-----------------------------------------------------------------------------------------------------------------------
   590                                  ;
   591                                  ;       Diskette Directory                                                      @disk: 002600   @mem: n/a
   592                                  ;
   593                                  ;       The disk contains one copy of the diskette directory. Each directory entry is 32 bytes long. Our directory
   594                                  ;       contains only one entry. Unused entries are set to all nulls. The directory immediately follows the second FAT
   595                                  ;       copy.
   596                                  ;
   597                                  ;-----------------------------------------------------------------------------------------------------------------------
   598                                  section                 dir                                                     ;diskette directory
   599                                                          db      "OS      COM"                                   ;file name (must contain spaces)
   600                                                          db      020h                                            ;attribute (archive bit set)
   601                                                          times   10 db 0                                         ;unused
   602                                                          dw      0h                                              ;time
   603                                                          db      01000001b                                       ;mmm = 10 MOD 8 = 2; ddddd = 1
   604                                                          db      01001001b                                       ;yyyyyyy = 2016-1980 = 36 = 24h; m/8 = 1
   605                                                          dw      2                                               ;first cluster
   606                                                          dd      400h                                            ;file size
   607                                                          times   (EBOOTDIRENTRIES*32)-($-$$) db 0h               ;zero fill to end of section
   608                                  %endif
   609                                  %ifdef BUILDCOM
   610                                  ;=======================================================================================================================
   611                                  ;
   612                                  ;       OS.COM
   613                                  ;
   614                                  ;       The operating system file is assembled at the start of the data area of the floppy disk image, which
   615                                  ;       immediately follows the directory. This corresponds to logical cluster 2, even though the physical address of
   616                                  ;       this sector on the disk varies depending on the disk type. The os.com file consists of two parts, the OS loader
   617                                  ;       and the OS kernel. The Loader is 16-bit code that receives control directly from the boot sector code after the
   618                                  ;       OS.COM file is loaded into memory. The kernel is 32-bit code that receives control after the Loader has
   619                                  ;       initialized protected-mode tables and 32-bit interrupt handlers and switched the CPU into protected mode.
   620                                  ;
   621                                  ;       Our loader addressability is set up according to the following diagram.
   622                                  ;
   623                                  ;       SS -----------> 007b00  +-----------------------------------------------+ SS:0000
   624                                  ;                               |  Boot Stack & Boot PSP (Unused)               |
   625                                  ;                               |  256 = 100h bytes                             |
   626                                  ;       SS:SP --------> 007c00  +-----------------------------------------------+ SS:0100  07b0:0100
   627                                  ;                               |  Boot Sector (vstart=0100h)                   |
   628                                  ;                               |  1 sector = 512 = 200h bytes                  |
   629                                  ;                       007e00  +-----------------------------------------------+
   630                                  ;                               |  File Allocation Table (FAT) I/O Buffer       |
   631                                  ;                               |  9 x 512-byte sectors = 4,608 = 1200h bytes   |
   632                                  ;                               |                                               |
   633                                  ;       CS,DS,ES -----> 008f00  |  Loader PSP (Unused)                          | DS:0000
   634                                  ;                               |                                               |
   635                                  ;       CS:IP --------> 009000  +-----------------------------------------------+ DS:0100  08f0:0100
   636                                  ;                               |  Loader Code                                  |
   637                                  ;                               |  2 sectors = 1024 = 400h bytes                |
   638                                  ;                       009400  +-----------------------------------------------+ DS:0500
   639                                  ;
   640                                  ;=======================================================================================================================
   641                                  ;-----------------------------------------------------------------------------------------------------------------------
   642                                  ;
   643                                  ;       OS Loader                                                               @disk: 004200   @mem: 009000
   644                                  ;
   645                                  ;       This code is the operating system loader. It resides on the boot disk at the start of the data area, following
   646                                  ;       the directory. The loader occupies several clusters that are mapped in the file allocation tables above.
   647                                  ;       The loader executes 16-bit instructions in real mode. It performs several initialization functions such as
   648                                  ;       determining whether the CPU and other resources are sufficient to run the operating system. If all minimum
   649                                  ;       resources are present, the loader initializes protected mode tables, places the CPU into protected mode and
   650                                  ;       starts the console task. Since the loader was called either from the bootstrap or as a .com file on the boot
   651                                  ;       disk, we can assume that the initial IP is 0x100 and not perform any absolute address fix-ups on our segment
   652                                  ;       registers.
   653                                  ;
   654                                  ;-----------------------------------------------------------------------------------------------------------------------
   655                                                          cpu     8086                                            ;assume minimal CPU
   656                                  section                 loader  vstart=0100h                                    ;use .COM compatible addressing
   657                                                          bits    16                                              ;this is 16-bit code
   658 00000000 0E                      Loader                  push    cs                                              ;use the code segment
   659 00000001 1F                                              pop     ds                                              ;...as our data segment
   660 00000002 0E                                              push    cs                                              ;use the code segment
   661 00000003 07                                              pop     es                                              ;...as our extra segment
   662                                  ;
   663                                  ;       Write a message to the console so we know we have our addressability established.
   664                                  ;
   665 00000004 BE[2900]                                        mov     si,czStartingMsg                                ;starting message
   666 00000007 E81200                                          call    PutTTYString                                    ;display loader message
   667                                  ;
   668                                  ;       Now we want to wait for a keypress. We can use a keyboard interrupt function for this (INT 16h, AH=0).
   669                                  ;       However, some hypervisor BIOS implementations have been seen to implement the "wait" as simply a fast
   670                                  ;       iteration of the keyboard status function call (INT 16h, AH=1), causing a max CPU condition. So, instead,
   671                                  ;       we will use the keyboard status call and iterate over a halt (HLT) instruction until a key is pressed.
   672                                  ;       The STI instruction enables maskable interrupts, including the keyboard. The CPU assures that the
   673                                  ;       instruction immediately following STI will be executed before any interrupt is serviced.
   674                                  ;
   675 0000000A B401                    .30                     mov     ah,EBIOSFNKEYSTATUS                             ;keyboard status function
   676 0000000C CD16                                            int     EBIOSINTKEYBOARD                                ;call BIOS keyboard interrupt
   677 0000000E 7504                                            jnz     .40                                             ;exit if key pressed
   678 00000010 FB                                              sti                                                     ;enable maskable interrupts
   679 00000011 F4                                              hlt                                                     ;wait for interrupt
   680 00000012 EBF6                                            jmp     .30                                             ;repeat until keypress
   681                                  ;
   682                                  ;       Now that a key has been pressed, we signal the system to restart by driving the B0 line on the 8042
   683                                  ;       keyboard controller low (OUT 64h,0feh). The restart may take some microseconds to kick in, so we issue
   684                                  ;       HLT until the system resets.
   685                                  ;
   686 00000014 B0FE                    .40                     mov     al,EKEYBCMDRESET                                ;8042 pulse output port pin
   687 00000016 E664                                            out     EKEYBPORTSTAT,al                                ;drive B0 low to restart
   688 00000018 FB                      .50                     sti                                                     ;enable maskable interrupts
   689 00000019 F4                                              hlt                                                     ;stop until reset, int, nmi
   690 0000001A EBFC                                            jmp     .50                                             ;loop until restart kicks in
   691                                  ;-----------------------------------------------------------------------------------------------------------------------
   692                                  ;
   693                                  ;       Routine:        PutTTYString
   694                                  ;
   695                                  ;       Description:    This routine sends a NUL-terminated string of characters to the TTY output device. We use the
   696                                  ;                       TTY output function of the BIOS video interrupt, passing the address of the string in DS:SI
   697                                  ;                       and the BIOS teletype function code in AH. After a return from the BIOS interrupt, we repeat
   698                                  ;                       for the next string character until a NUL is found. Note that we clear the direction flag (DF)
   699                                  ;                       with CLD before the first LODSB. The direction flag is not guaranteed to be preserved between
   700                                  ;                       calls within the OS. However, the "int" instruction does store the EFLAGS register on the
   701                                  ;                       stack and restores it on return. Therefore, clearing the direction flag before subsequent calls
   702                                  ;                       to LODSB is not needed.
   703                                  ;
   704                                  ;       In:             DS:SI   address of string
   705                                  ;
   706                                  ;       Out:            DF      0
   707                                  ;                       ZF      1
   708                                  ;                       AL      0
   709                                  ;
   710                                  ;-----------------------------------------------------------------------------------------------------------------------
   711 0000001C FC                      PutTTYString            cld                                                     ;forward strings
   712 0000001D AC                      .10                     lodsb                                                   ;load next byte at DS:SI in AL
   713 0000001E 84C0                                            test    al,al                                           ;end of string?
   714 00000020 7406                                            jz      .20                                             ;... yes, exit our loop
   715 00000022 B40E                                            mov     ah,EBIOSFNTTYOUTPUT                             ;BIOS teletype function
   716 00000024 CD10                                            int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
   717 00000026 EBF5                                            jmp     .10                                             ;repeat until done
   718 00000028 C3                      .20                     ret                                                     ;return
   719                                  ;-----------------------------------------------------------------------------------------------------------------------
   720                                  ;
   721                                  ;       Loader Data
   722                                  ;
   723                                  ;       Our only "data" is the string displayed when system starts. It ends with ASCII carriage-return (13) and line-
   724                                  ;       feed (10) values. The remainder of the boot sector is filled with NUL. The boot sector finally ends with the
   725                                  ;       required two-byte signature checked by the BIOS. Note that recent versions of NASM will issue a warning if
   726                                  ;       the calculated address for the end-of-sector signature produces a negative value for "1024-($-$$)". This will
   727                                  ;       indicate if we have added too much data and exceeded the length of the sector. Note also that since we are at
   728                                  ;       the end of a "file" (os.com) and not the boot sector, there is no end-of-sector marker (0x55 0xaa) here.
   729                                  ;
   730                                  ;-----------------------------------------------------------------------------------------------------------------------
   731 00000029 5374617274696E6720-     czStartingMsg           db      "Starting OS",13,10,0                           ;starting message
   731 00000032 4F530D0A00         
   732 00000037 00<rept>                                        times   1024-($-$$) db 0h                               ;zero fill to end of sector
   733                                  %endif
   734                                  %ifdef BUILDDISK
   735                                  ;-----------------------------------------------------------------------------------------------------------------------
   736                                  ;
   737                                  ;       Free Disk Space                                                         @disk: 004600   @mem:  n/a
   738                                  ;
   739                                  ;       Following the convention introduced by DOS, we use the value 'F6' to indicate unused floppy disk storage.
   740                                  ;
   741                                  ;-----------------------------------------------------------------------------------------------------------------------
   742                                  section                 unused                                                  ;unused disk space
   743                                                          times   EBOOTDISKBYTES-04600h db 0F6h                   ;fill to end of disk image
   744                                  %endif
   745                                  ;=======================================================================================================================
   746                                  ;
   747                                  ;       End of Program Code
   748                                  ;
   749                                  ;=======================================================================================================================
