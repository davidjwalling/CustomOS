     1                                  ;-----------------------------------------------------------------------------------------------------------------------
     2                                  ;
     3                                  ;	File:		os.asm
     4                                  ;
     5                                  ;	Project:	os.002
     6                                  ;
     7                                  ;	Description:	This sample program adds code to load the operating system kernel program from the disk image.
     8                                  ;			The boot sector now searches the disk for the loader program, loads it into memory and runs it.
     9                                  ;			The loader program in this sample simply displays a greeting.
    10                                  ;
    11                                  ;	Revised:	January 1, 2017
    12                                  ;
    13                                  ;	Assembly:	nasm os.asm -f bin -o os.dat -l os.dat.lst -DBUILDBOOT
    14                                  ;			nasm os.asm -f bin -o os.dsk -l os.dsk.lst -DBUILDDISK
    15                                  ;			nasm os.asm -f bin -o os.com -l os.com.lst -DBUILDCOM
    16                                  ;
    17                                  ;			Copyright (C) 2010-2017 by David J. Walling. All Rights Reserved.
    18                                  ;
    19                                  ;-----------------------------------------------------------------------------------------------------------------------
    20                                  ;-----------------------------------------------------------------------------------------------------------------------
    21                                  ;
    22                                  ;	Assembly Directives
    23                                  ;
    24                                  ;	Use one of the following as an assembly directive (-D) with NASM.
    25                                  ;
    26                                  ;	BUILDBOOT	Creates os.dat, a 512-byte boot sector, as a standalone file.
    27                                  ;	BUILDDISK	Creates os.dsk, a 1.44MB (3.5") floppy disk image file.
    28                                  ;	BUILDCOM	Creates os.com, the OS loader and kernel as a standalone DOS program.
    29                                  ;
    30                                  ;-----------------------------------------------------------------------------------------------------------------------
    31                                  %ifdef BUILDDISK
    32                                  %define BUILDBOOT
    33                                  %define BUILDCOM
    34                                  %endif
    35                                  ;-----------------------------------------------------------------------------------------------------------------------
    36                                  ;
    37                                  ;	Conventions
    38                                  ;
    39                                  ;	Labels:		Labels within a routine are numeric and begin with a period (.10, .20).
    40                                  ;			Labels within a routine begin at ".10" and increment by 10.
    41                                  ;
    42                                  ;	Comments:	A comment that spans the entire line begins with a semicolon in column 1.
    43                                  ;			A comment that accompanies code on a line begins with a semicolon in column 81.
    44                                  ;
    45                                  ;	Alignment:	Assembly instructions (mnemonics) begin in column 25.
    46                                  ;			Assembly operands begin in column 33.
    47                                  ;
    48                                  ;	Routines:	Routine names are in mixed case (GetYear, ReadRealTimeClock)
    49                                  ;			Routine names begin with a verb (Get, Read, etc.)
    50                                  ;
    51                                  ;	Constants:	Symbolic constants (equates) are named in all-caps beginning with 'E' (EDATAPORT).
    52                                  ;			Constant stored values are named in camel case, starting with 'c'.
    53                                  ;			The 2nd letter indicates the storage type.
    54                                  ;			cq......	constant quad-word (dq)
    55                                  ;			cd......	constant double-word (dd)
    56                                  ;			cw......	constant word (dw)
    57                                  ;			cb......	constant byte (db)
    58                                  ;			cz......	constant ASCIIZ (null-terminated) string
    59                                  ;
    60                                  ;	Variables:	Variables are named in camel case, starting with 'w'.
    61                                  ;			The 2nd letter indicates storage type.
    62                                  ;			wq......	variable quad-word (resq)
    63                                  ;			wd......	variable double-word (resd)
    64                                  ;			ww......	variable word (resw)
    65                                  ;			wb......	variable byte (resb)
    66                                  ;
    67                                  ;	Structures:	Structure names are in all-caps (DATETIME).
    68                                  ;
    69                                  ;	Macros:		Macro names are in camel case (getDateString).
    70                                  ;
    71                                  ;	Registers:	Registers EBX, ECX, ESI, EDI, DS and ES are preserved by all OS routines.
    72                                  ;			Register EAX is preferred for returning a response/result value.
    73                                  ;			Register EBX is preferred for passing a context (structure) address parameter.
    74                                  ;			Registers EAX, EDX and EDX are preferred for passing integral parameters.
    75                                  ;
    76                                  ;-----------------------------------------------------------------------------------------------------------------------
    77                                  ;-----------------------------------------------------------------------------------------------------------------------
    78                                  ;
    79                                  ;	Equates
    80                                  ;
    81                                  ;	The equate (equ) statements define symbolic names for fixed values so that these values can be defined and
    82                                  ;	verified once and then used throughout the code. Using symbolic names simplifies searching for where logical
    83                                  ;	values are used. Equate names are in all-caps and are the only symbolic names that begin with the letter 'E'.
    84                                  ;
    85                                  ;	Equates are grouped into related sets below. Hardware-based equates are listed first, followed by BIOS and
    86                                  ;	protocol equates and, lastly, application equates.
    87                                  ;
    88                                  ;-----------------------------------------------------------------------------------------------------------------------
    89                                  ;-----------------------------------------------------------------------------------------------------------------------
    90                                  ;
    91                                  ;	8042 Keyboard Controller						EKEY...
    92                                  ;
    93                                  ;	The 8042 Keyboard Controller (8042) is a programmable controller that accepts input signals from the keyboard
    94                                  ;	device. It also signals a hardware interrupt to the CPU when the low-order bit of I/O port 0x64 is set to zero.
    95                                  ;
    96                                  ;-----------------------------------------------------------------------------------------------------------------------
    97                                  EKEYPORTSTAT		equ	064h						;8042 status port
    98                                  EKEYCMDRESET		equ	0FEh						;8042 drive B0 low to restart
    99                                  ;-----------------------------------------------------------------------------------------------------------------------
   100                                  ;
   101                                  ;	BIOS Interrupts and Functions						EBIOS...
   102                                  ;
   103                                  ;	Basic Input/Output System (BIOS) functions are grouped and accessed by issuing an interrupt call. Each
   104                                  ;	BIOS interrupt supports several funtions. The function code is typically passed in the AH register.
   105                                  ;
   106                                  ;-----------------------------------------------------------------------------------------------------------------------
   107                                  EBIOSINTVIDEO		equ	010h						;BIOS video services interrupt
   108                                  EBIOSFNTTYOUTPUT	equ	00Eh						;BIOS video TTY output function
   109                                  EBIOSINTDISKETTE	equ	013h						;BIOS diskette services interrupt
   110                                  EBIOSINTKEYBOARD	equ	016h						;BIOS keyboard services interrupt
   111                                  EBIOSFNKEYSTATUS	equ	001h						;BIOS keyboard status function
   112                                  ;-----------------------------------------------------------------------------------------------------------------------
   113                                  ;
   114                                  ;	Loader Constants
   115                                  ;
   116                                  ;-----------------------------------------------------------------------------------------------------------------------
   117                                  EFATBUFFER		equ	400h						;FAT I/O address relative to DS:
   118                                  EMAXTRIES		equ	5						;max read retries
   119                                  %ifdef BUILDBOOT
   120                                  ;-----------------------------------------------------------------------------------------------------------------------
   121                                  ;
   122                                  ;	Boot Sector Code							@disk: 000000	@mem: 007c00
   123                                  ;
   124                                  ;	The first sector of the disk is the boot sector. The BIOS will load the boot sector into memory and pass
   125                                  ;	control to the code at the start of the sector. The boot sector code is responsible for loading the operating
   126                                  ;	system into memory. The boot sector contains a disk parameter table describing the geometry and allocation
   127                                  ;	of the disk. Following the disk parameter table is code to load the operating system kernel into memory.
   128                                  ;
   129                                  ;-----------------------------------------------------------------------------------------------------------------------
   130                                  			cpu	8086						;assume minimal CPU
   131                                  section			boot	vstart=0100h					;emulate .COM (CS,DS,ES=PSP) addressing
   132                                  			bits	16						;16-bit code at power-up
   133 00000000 E91B00                  Boot			jmp	word Boot.10					;jump over parameter table
   134                                  ;-----------------------------------------------------------------------------------------------------------------------
   135                                  ;
   136                                  ;	Disk Parameter Table
   137                                  ;
   138                                  ;	The disk parameter table informs the BIOS of the floppy disk architecture. Here, we use parameters for the
   139                                  ;	3.5" 1.44MB floppy disk since this format is widely supported by virtual machine hypervisors.
   140                                  ;
   141                                  ;-----------------------------------------------------------------------------------------------------------------------
   142 00000003 437573746F6D4F53        			db	"CustomOS"					;eight-byte label
   143 0000000B 0002                    cwSectorBytes		dw	512						;bytes per sector
   144 0000000D 01                      cbClusterSectors	db	1						;sectors per cluster
   145 0000000E 0100                    cwReservedSectors	dw	1						;reserved sectors
   146 00000010 02                      cbFatCount		db	2						;file allocation table copies
   147 00000011 E000                    cwDirEntries		dw	224						;max directory entries
   148 00000013 400B                    cwDiskSectors		dw	2880						;sectors per disk
   149 00000015 F0                      cbDiskType		db	0F0h						;1.44MB
   150 00000016 0900                    cwFatSectors		dw	9						;sectors per FAT copy
   151                                  cbTrackSectors		equ	$						;sectors per track (as byte)
   152 00000018 1200                    cwTrackSectors		dw	18						;sectors per track (as word)
   153 0000001A 0200                    cwDiskSides		dw	2						;sides per disk
   154 0000001C 0000                    cwSpecialSectors	dw	0						;special sectors
   155                                  ;
   156                                  ;	BIOS typically loads the boot sector at absolute address 7c00 and sets the stack pointer at 512 bytes past the
   157                                  ;	end of the boot sector. But, since BIOS code varies, we don't make any assumptions as to where our boot sector
   158                                  ;	is loaded. For example, the initial CS:IP could be 0:7c00, 700:c00, 7c0:0, etc. So, to avoid assumptions, we
   159                                  ;	first normalize CS:IP to get the absolute segment address in BX. The comments below show the effect of this code
   160                                  ;	given several possible starting values for CS:IP.
   161                                  ;
   162                                  										;CS:IP	 0:7c00 700:c00 7c0:0
   163 0000001E E80000                  Boot.10			call	word .20					;[ESP] =   7c21     c21    21
   164                                  .@20			equ	$-$$						;.@20 = 021h
   165 00000021 58                      .20			pop	ax						;AX =	   7c21     c21    21
   166 00000022 83E821                  			sub	ax,word .@20					;BX =	   7c00     c00     0
   167 00000025 B104                    			mov	cl,4						;shift count
   168 00000027 D3E8                    			shr	ax,cl						;AX =	    7c0      c0     0
   169 00000029 8CCB                    			mov	bx,cs						;BX =	      0     700   7c0
   170 0000002B 01C3                    			add	bx,ax						;BX =	    7c0     7c0   7c0
   171                                  ;
   172                                  ;	Now, since we are assembling our boot code to emulate the addressing of a .COM file, we need DS and ES
   173                                  ;	registers to be set to where a Program Segment Prefix (PSP) would be, exactly 100h (256) bytes prior to
   174                                  ;	the start of our code. This will correspond to our assembled data address offsets. Note that we instructed
   175                                  ;	the assembler to produce addresses for our symbols that are offset from our code by 100h. See the "vstart"
   176                                  ;	parameter for the "section" directive above. We also set SS to the PSP and SP to the address of our i/o
   177                                  ;	buffer. This leaves 256 bytes of usable stack from 7b0:300 to 7b0:400.
   178                                  ;
   179 0000002D 83EB10                  			sub	bx,byte 16					;BX = 07b0
   180 00000030 8EDB                    			mov	ds,bx						;DS = 07b0 = psp
   181 00000032 8EC3                    			mov	es,bx						;ES = 07b0 = psp
   182 00000034 8ED3                    			mov	ss,bx						;SS = 07b0 = psp
   183 00000036 BC0004                  			mov	sp,EFATBUFFER					;SP = 0400
   184                                  ;
   185                                  ;	Our boot addressability is now set up according to the following diagram.
   186                                  ;
   187                                  ;	DS,ES,SS ----->	007b00	+-----------------------------------------------+
   188                                  ;				|  Program Segment Prefix (PSP)			|
   189                                  ;			007c00	+-----------------------------------------------+
   190                                  ;				|  Boot Sector Code				|
   191                                  ;				|						|
   192                                  ;			007e00	+-----------------------------------------------+
   193                                  ;				|  Boot Stack					|
   194                                  ;	SS:SP -------->	007f00	+-----------------------------------------------+
   195                                  ;				|  FAT I/O Buffer (used in later programs)	|
   196                                  ;				+-----------------------------------------------+
   197                                  ;
   198                                  ;	On entry, DL indicates the drive being booted from.
   199                                  ;
   200 00000039 8816[F601]              			mov	[wbDrive],dl					;[drive] = drive being booted from
   201                                  ;
   202                                  ;	Compute directory i/o buffer address.
   203                                  ;
   204 0000003D A1[1600]                			mov	ax,[cwFatSectors]				;AX = 0009 = FAT sectors
   205 00000040 F726[0B00]              			mul	word [cwSectorBytes]				;DX:AX = 0000:1200 = FAT bytes
   206 00000044 050004                  			add	ax,EFATBUFFER					;AX = 1600 = end of FAT buffer
   207 00000047 A3[EA01]                			mov	[wwDirBuffer],ax				;[dirbuffer] = 1600
   208                                  ;
   209                                  ;	Compute segment where os.com will be loaded.
   210                                  ;
   211 0000004A D3E8                    			shr	ax,cl						;AX = 0160
   212 0000004C 01D8                    			add	ax,bx						;AX = 0160 + 07b0 = 0910
   213 0000004E 83E810                  			sub	ax,byte 16					;AX = 0900
   214 00000051 A3[3A01]                			mov	[wwLoadSegment],ax				;[loadsegment] = 0900
   215                                  ;
   216                                  ;	Write a message to the console so we know we have our addressability established.
   217                                  ;
   218 00000054 BE[BF01]                			mov	si,czLoadMsg					;loading message
   219 00000057 E84B01                  			call	BootPrint					;display loader message
   220                                  ;
   221                                  ;	Initialize the number of directory sectors to search.
   222                                  ;
   223 0000005A A1[1100]                			mov	ax,[cwDirEntries]				;AX = 224 = max dir entries
   224 0000005D A3[EC01]                			mov	[wwEntriesLeft],ax				;[entriesleft] = 224
   225                                  ;
   226                                  ;	Compute number of directory sectors and initialize overhead count.
   227                                  ;
   228 00000060 89C1                    			mov	cx,ax						;CX = 00e0 = 224 entries
   229 00000062 F726[B201]              			mul	word [cwEntryLen]				;DX:AX = 224 * 32 = 7168
   230 00000066 F736[0B00]              			div	word [cwSectorBytes]				;AX = 7168 / 512 = 14 = dir sectors
   231 0000006A A3[EE01]                			mov	[wwOverhead],ax					;[overhead] = 000e
   232                                  ;
   233                                  ;	Compute directory entries per sector.
   234                                  ;
   235 0000006D 91                      			xchg	ax,cx						;DX:AX = 0:00e0, DX = 0000e
   236 0000006E F7F1                    			div	cx						;AX = 0010 = entries per dir sector
   237 00000070 A3[F001]                			mov	[wwSectorEntries],ax				;[sectorentries] = 0010
   238                                  ;
   239                                  ;	Compute first logical directory sector and update overhead count.
   240                                  ;
   241 00000073 A1[1600]                			mov	ax,[cwFatSectors]				;AX = 0009 = FAT sectors per copy
   242 00000076 F626[1000]              			mul	byte [cbFatCount]				;AX = 0012 = FAT sectors
   243 0000007A 0306[0E00]              			add	ax,[cwReservedSectors]				;AX = 0013 = FAT plus reserved
   244 0000007E 0306[1C00]              			add	ax,[cwSpecialSectors]				;AX = 0013 = FAT + reserved + special
   245 00000082 A3[F201]                			mov	[wwLogicalSector],ax				;[logicalsector] = 0013
   246 00000085 0106[EE01]              			add	[wwOverhead],ax					;[overhead] = 0021 = res+spec+FAT+dir
   247                                  ;
   248                                  ;	Read directory sector.
   249                                  ;
   250 00000089 B001                    .30			mov	al,1						;sector count
   251 0000008B A2[F401]                			mov	byte [wbReadCount],al				;[readcount] = 01
   252 0000008E 8B1E[EA01]              			mov	bx,[wwDirBuffer]				;BX = 1600
   253 00000092 E8A700                  			call	ReadSector					;read sector into es:bx
   254                                  ;
   255                                  ;	Setup variables to search this directory sector.
   256                                  ;
   257 00000095 A1[EC01]                			mov	ax,[wwEntriesLeft]				;directory entries to search
   258 00000098 3B06[F001]              			cmp	ax,[wwSectorEntries]				;need to search more sectors?
   259 0000009C 7603                    			jna	.40						;no, continue
   260 0000009E A1[F001]                			mov	ax,[wwSectorEntries]				;yes, limit search to sector
   261 000000A1 2906[EC01]              .40			sub	[wwEntriesLeft],ax				;update entries left to searh
   262 000000A5 BE[B401]                			mov	si,cbKernelProgram				;program name
   263 000000A8 8B3E[EA01]              			mov	di,[wwDirBuffer]				;DI = 1600
   264                                  ;
   265                                  ;	Loop through directory sectors searching for kernel program.
   266                                  ;
   267 000000AC 56                      .50			push	si						;save kernel name address
   268 000000AD 57                      			push	di						;save dir i/o buffer address
   269 000000AE B90B00                  			mov	cx,11						;length of 8+3 name
   270 000000B1 FC                      			cld							;forward strings
   271 000000B2 F3A6                    			repe	cmpsb						;compare entry name
   272 000000B4 5F                      			pop	di						;restore dir i/o buffer address
   273 000000B5 5E                      			pop	si						;restore kernel name address
   274 000000B6 7418                    			je	.60						;exit loop if found
   275 000000B8 033E[B201]              			add	di,[cwEntryLen]					;point to next dir entry
   276 000000BC 48                      			dec	ax						;decrement remaining entries
   277 000000BD 75ED                    			jnz	.50						;next entry
   278                                  ;
   279                                  ;	Repeat search if we are not at the end of the directory.
   280                                  ;
   281 000000BF FF06[F201]              			inc	word [wwLogicalSector]				;increment logical sector
   282 000000C3 833E[EC01]00            			cmp	word [wwEntriesLeft],byte 0			;done with directory?
   283 000000C8 75BF                    			jne	.30						;no, get next sector
   284 000000CA BE[DB01]                			mov	si,czNoKernel					;missing kernel message
   285 000000CD E9C000                  			jmp	BootExit					;display message and exit
   286                                  ;
   287                                  ;	If we find the kernel program in the directory, read the FAT.
   288                                  ;
   289 000000D0 A1[0E00]                .60			mov	ax,[cwReservedSectors]				;AX = 0001
   290 000000D3 A3[F201]                			mov	[wwLogicalSector],ax				;start past boot sector
   291 000000D6 A1[1600]                			mov	ax,[cwFatSectors]				;AX = 0009
   292 000000D9 A2[F401]                			mov	[wbReadCount],al				;[readcount] = 09
   293 000000DC BB0004                  			mov	bx,EFATBUFFER					;BX = 0400
   294 000000DF E85A00                  			call	ReadSector					;read FAT into buffer
   295                                  ;
   296                                  ;	Get the starting cluster of the kernel program and target address.
   297                                  ;
   298 000000E2 8B451A                  			mov	ax,word [di+26]					;AX = starting cluster of file
   299 000000E5 C41E[3801]              			les	bx,[wwLoadOffset]				;ES:BX = kernel load address
   300                                  ;
   301                                  ;	Read each program cluster into RAM.
   302                                  ;
   303 000000E9 50                      .70			push	ax						;save cluster nbr
   304 000000EA 83E802                  			sub	ax,2						;AX = cluster nbr base 0
   305 000000ED 8A0E[0D00]              			mov	cl,[cbClusterSectors]				;CL = sectors per cluster
   306 000000F1 880E[F401]              			mov	[wbReadCount],cl				;save sectors to read
   307 000000F5 30ED                    			xor	ch,ch						;CX = sectors per cluster
   308 000000F7 F7E1                    			mul	cx						;DX:AX = logical cluster sector
   309 000000F9 0306[EE01]              			add	ax,[wwOverhead]					;AX = kernel sector nbr
   310 000000FD A3[F201]                			mov	[wwLogicalSector],ax				;save logical sector nbr
   311 00000100 E83900                  			call	ReadSector					;read sectors into es:bx
   312                                  ;
   313                                  ;	Update buffer pointer for next cluster.
   314                                  ;
   315 00000103 A0[0D00]                			mov	al,[cbClusterSectors]				;AL = sectors per cluster
   316 00000106 30E4                    			xor	ah,ah						;AX = sectors per cluster
   317 00000108 F726[0B00]              			mul	word [cwSectorBytes]				;DX:AX = cluster bytes
   318 0000010C 01C3                    			add	bx,ax						;BX = next cluster target address
   319 0000010E 58                      			pop	ax						;AX = restore cluster nbr
   320                                  ;
   321                                  ;	Compute next cluster number.
   322                                  ;
   323 0000010F 89C1                    			mov	cx,ax						;CX = cluster nbr
   324 00000111 89C7                    			mov	di,ax						;DI = cluster nbr
   325 00000113 D1E8                    			shr	ax,1						;AX = cluster/2
   326 00000115 89C2                    			mov	dx,ax						;DX = cluster/2
   327 00000117 01D0                    			add	ax,dx						;AX = 2*(cluster/2)
   328 00000119 01D0                    			add	ax,dx						;AX = 3*(cluster/2)
   329 0000011B 83E701                  			and	di,byte 1					;get low bit
   330 0000011E 01C7                    			add	di,ax						;add one if cluster is odd
   331 00000120 81C70004                			add	di,EFATBUFFER					;add FAT buffer address
   332 00000124 8B05                    			mov	ax,[di]						;get cluster bytes
   333                                  ;
   334                                  ;	Adjust cluster nbr by 4 bits if cluster is odd; test for end of chain.
   335                                  ;
   336 00000126 F6C101                  			test	cl,1						;is cluster odd?
   337 00000129 7404                    			jz	.80						;no, skip ahead
   338 0000012B B104                    			mov	cl,4						;shift count
   339 0000012D D3E8                    			shr	ax,cl						;shift nybble low
   340 0000012F 25FF0F                  .80			and	ax,0FFFh					;mask for 24 bits; next cluster nbr
   341 00000132 3DFF0F                  			cmp	ax,0FFFh					;end of chain?
   342 00000135 75B2                    			jne	.70						;no, continue
   343                                  ;
   344                                  ;	Transfer control to the operating system program.
   345                                  ;
   346 00000137 EA                      			db	0EAh						;jmp seg:offset
   347 00000138 0001                    wwLoadOffset		dw	0100h						;kernel entry offset
   348 0000013A 0009                    wwLoadSegment		dw	0900h						;kernel entry segment
   349                                  ;
   350                                  ;	Read [readcount] disk sectors from [logicalsector] into ES:BX.
   351                                  ;
   352 0000013C A1[1800]                ReadSector		mov	ax,[cwTrackSectors]				;AX = sectors per track
   353 0000013F F726[1A00]              			mul	word [cwDiskSides]				;DX:AX = sectors per cylinder
   354 00000143 89C1                    			mov	cx,ax						;CX = sectors per cylinder
   355 00000145 A1[F201]                			mov	ax,[wwLogicalSector]				;DX:AX = logical sector
   356 00000148 F7F1                    			div	cx						;AX = cylinder; DX = cyl sector
   357 0000014A A2[F901]                			mov	[wbTrack],al					;[track] = cylinder
   358 0000014D 89D0                    			mov	ax,dx						;AX = cyl sector
   359 0000014F F636[1800]              			div	byte [cbTrackSectors]				;AH = sector, AL = head
   360 00000153 FEC4                    			inc	ah						;AH = sector (1,2,3,...)
   361 00000155 A3[F701]                			mov	[wbHead],ax					;[head]= head, [sector]= sector
   362                                  ;
   363                                  ;	Try maxtries times to read sector.
   364                                  ;
   365 00000158 B90500                  			mov	cx,EMAXTRIES					;CX = 0005
   366 0000015B 53                      .10			push	bx						;save buffer address
   367 0000015C 51                      			push	cx						;save retry count
   368 0000015D 8B16[F601]              			mov	dx,[wwDriveHead]				;DH = head, DL = drive
   369 00000161 8B0E[F801]              			mov	cx,[wwSectorTrack]				;CH = track, CL = sector
   370 00000165 A1[F401]                			mov	ax,[wwReadCountCommand]				;AH = fn., AL = sector count
   371 00000168 CD13                    			int	EBIOSINTDISKETTE				;read sector
   372 0000016A 59                      			pop	cx						;restore retry count
   373 0000016B 5B                      			pop	bx						;restore buffer address
   374 0000016C 7343                    			jnc	BootReturn					;skip ahead if done
   375 0000016E E2EB                    			loop	.10						;retry
   376                                  ;
   377                                  ;	Handle disk error: convert to ASCII and store in error string.
   378                                  ;
   379 00000170 88E0                    			mov	al,ah						;AL = bios error code
   380 00000172 30E4                    			xor	ah,ah						;AX = bios error code
   381 00000174 B210                    			mov	dl,16						;divisor for base 16
   382 00000176 F6F2                    			div	dl						;AL = hi order, AH = lo order
   383 00000178 0D3030                  			or	ax,3030h					;apply ASCII zone bits
   384 0000017B 80FC3A                  			cmp	ah,3Ah						;range test ASCII numeral
   385 0000017E 7203                    			jb	.20						;continue if numeral
   386 00000180 80C407                  			add	ah,7						;adjust for ASCII 'A'-'F'
   387 00000183 3C3A                    .20			cmp	al,3Ah						;range test ASCII numeral
   388 00000185 7203                    			jb	.30						;continue if numeral
   389 00000187 80C407                  			add	ah,7						;adjust for ASCII 'A'-'F'
   390 0000018A A3[D801]                .30			mov	[wzErrorCode],ax				;store ASCII error code
   391 0000018D BE[CD01]                			mov	si,czErrorMsg					;error message address
   392 00000190 E81200                  BootExit		call	BootPrint					;display messge to console
   393 00000193 B401                    .10			mov	ah,EBIOSFNKEYSTATUS				;bios keyboard status function
   394 00000195 CD16                    			int	EBIOSINTKEYBOARD				;get keyboard status
   395 00000197 7504                    			jnz	.20						;continue if key pressed
   396 00000199 FB                      			sti							;enable interrupts
   397 0000019A F4                      			hlt							;wait for interrupt
   398 0000019B EBF6                    			jmp	short .10					;repeat
   399 0000019D B0FE                    .20			mov	al,EKEYCMDRESET					;8042 pulse output port pin
   400 0000019F E664                    			out	EKEYPORTSTAT,al					;drive B0 low to restart
   401 000001A1 FB                      .30			sti							;enable interrupts
   402 000001A2 F4                      			hlt							;stop until reset, int, nmi
   403 000001A3 EBFC                    			jmp	short .30					;loop until restart kicks in
   404                                  ;
   405                                  ;	Display text message.
   406                                  ;
   407 000001A5 FC                      BootPrint		cld							;forward strings
   408 000001A6 AC                      			lodsb							;load next byte at DS:SI in AL
   409 000001A7 84C0                    			test	al,al						;end of string?
   410 000001A9 7406                    			jz	BootReturn					;... yes, exit our loop
   411 000001AB B40E                    			mov	ah,EBIOSFNTTYOUTPUT				;BIOS teletype function
   412 000001AD CD10                    			int	EBIOSINTVIDEO					;call BIOS display interrupt
   413 000001AF EBF4                    			jmp	short BootPrint					;repeat until done
   414 000001B1 C3                      BootReturn		ret							;return to caller
   415                                  ;-----------------------------------------------------------------------------------------------------------------------
   416                                  ;
   417                                  ;	Constants
   418                                  ;
   419                                  ;-----------------------------------------------------------------------------------------------------------------------
   420                                  			align	2
   421 000001B2 2000                    cwEntryLen		dw	32						;length of directory entry
   422 000001B4 4F5320202020202043-     cbKernelProgram		db	"OS      COM"					;kernel program name
   422 000001BD 4F4D               
   423 000001BF 4C6F6164696E67202E-     czLoadMsg		db	"Loading ...",13,10,0				;loading message
   423 000001C8 2E2E0D0A00         
   424 000001CD 4469736B206572726F-     czErrorMsg		db	"Disk error "					;error message
   424 000001D6 7220               
   425 000001D8 202000                  wzErrorCode		db	20h,20h,0					;error code and null terminator
   426 000001DB 4F532E434F4D206D69-     czNoKernel		db	"OS.COM missing",0				;missing kernel message
   426 000001E4 7373696E6700       
   427                                  ;-----------------------------------------------------------------------------------------------------------------------
   428                                  ;
   429                                  ;	Work Areas
   430                                  ;
   431                                  ;-----------------------------------------------------------------------------------------------------------------------
   432                                  			align	2
   433 000001EA 0000                    wwDirBuffer		dw	0						;directory i/o buffer address
   434 000001EC 0000                    wwEntriesLeft		dw	0						;directory entries to search
   435 000001EE 0000                    wwOverhead		dw	0						;overhead sectors
   436 000001F0 0000                    wwSectorEntries		dw	0						;directory entries per sector
   437 000001F2 0000                    wwLogicalSector		dw	0						;current logical sector
   438                                  wwReadCountCommand	equ	$						;read count and command
   439 000001F4 00                      wbReadCount		db	0						;sectors to read
   440 000001F5 02                      cbReadCommand		db	2						;BIOS read disk fn code
   441                                  wwDriveHead		equ	$						;drive, head (word)
   442 000001F6 00                      wbDrive			db	0						;drive
   443 000001F7 00                      wbHead			db	0						;head
   444                                  wwSectorTrack		equ	$						;sector, track (word)
   445 000001F8 00                      			db	0						;sector
   446 000001F9 00                      wbTrack			db	0						;track
   447 000001FA 00<rept>                			times	510-($-$$) db 0h				;zero fill to end of sector
   448 000001FE 55AA                    			db	055h,0AAh					;end of sector signature
   449                                  %endif
   450                                  %ifdef BUILDDISK
   451                                  ;-----------------------------------------------------------------------------------------------------------------------
   452                                  ;
   453                                  ;	File Allocation Tables
   454                                  ;
   455                                  ;	The disk contains two copies of the File Allocation Table (FAT). On our disk, each FAT copy is 1200h bytes in
   456                                  ;	length. Each FAT entry contains the logical number of the next cluster. The first two entries are reserved. Our
   457                                  ;	OS.COM file here is 200h bytes in length. These 200h bytes contain familiar code that displays a message to the
   458                                  ;	screen. Our disk parameter table defines a cluster as containing one sector and each sector having 200h bytes.
   459                                  ;	Therefore, our FAT table must reserve only one cluster for OS.COM. The cluster used by OS.COM, then, will be
   460                                  ;	cluster 2. The entry value for this cluster is set to "0fffh" to indicate that it is the last cluster in the
   461                                  ;	chain.
   462                                  ;
   463                                  ;	Every three bytes encode two FAT entries as follows:
   464                                  ;
   465                                  ;	db	0abh,0cdh,0efh	;even cluster: 0dabh, odd cluster: 0efch
   466                                  ;
   467                                  ;-----------------------------------------------------------------------------------------------------------------------
   468                                  ;-----------------------------------------------------------------------------------------------------------------------
   469                                  ;
   470                                  ;	FAT copy 1								@disk: 000200	@mem: n/a
   471                                  ;
   472                                  ;-----------------------------------------------------------------------------------------------------------------------
   473                                  section			fat1							;first copy of FAT
   474                                  			db	0F0h,0FFh,0FFh,	0FFh,00Fh,000h
   475                                  			times	(9*512)-($-$$) db 0				;zero fill to end of section
   476                                  ;-----------------------------------------------------------------------------------------------------------------------
   477                                  ;
   478                                  ;	FAT copy 2								@disk: 001400	@mem: n/a
   479                                  ;
   480                                  ;-----------------------------------------------------------------------------------------------------------------------
   481                                  section			fat2							;second copy of FAT
   482                                  			db	0F0h,0FFh,0FFh,	0FFh,00Fh,000h
   483                                  			times	(9*512)-($-$$) db 0				;zero fill to end of section
   484                                  ;-----------------------------------------------------------------------------------------------------------------------
   485                                  ;
   486                                  ;	Diskette Directory							@disk: 002600	@mem: n/a
   487                                  ;
   488                                  ;	The disk contains one copy of the diskette directory. Each directory entry is 32 bytes long. Our directory
   489                                  ;	contains only one entry. Unused entries are set to all nulls. The directory immediately follows the second FAT
   490                                  ;	copy.
   491                                  ;
   492                                  ;-----------------------------------------------------------------------------------------------------------------------
   493                                  section			dir							;diskette directory
   494                                  			db	"OS      COM"					;file name (must contain spaces)
   495                                  			db	20h						;attribute (archive bit set)
   496                                  			times	10 db 0;					;unused
   497                                  			dw	0h						;time
   498                                  			db	01000001b					;mmm = 10 MOD 8 = 2; ddddd = 1
   499                                  			db	01001001b					;yyyyyyy = 2016-1980 = 36 = 24h; m/8 = 1
   500                                  			dw	2						;first cluster
   501                                  			dd	200h						;file size
   502                                  			times	(224*32)-($-$$) db 0h				;zero fill to end of section
   503                                  %endif
   504                                  %ifdef BUILDCOM
   505                                  ;-----------------------------------------------------------------------------------------------------------------------
   506                                  ;
   507                                  ;	OS.COM
   508                                  ;
   509                                  ;	The operating system file is assembled at the start of the data area of the floppy disk image, which
   510                                  ;	immediately follows the directory. This corresponds to logical cluster 2, even though the physical address of
   511                                  ;	this sector on the disk varies depending on the disk type. The os.com file consists of two parts, the OS loader
   512                                  ;	and the OS kernel. The Loader is 16-bit code that receives control directly from the boot sector code after the
   513                                  ;	OS.COM file is loaded into memory. The kernel is 32-bit code that receives control after the Loader has
   514                                  ;	initialized protected-mode tables and 32-bit interrupt handlers and switched the CPU into protected mode.
   515                                  ;
   516                                  ;-----------------------------------------------------------------------------------------------------------------------
   517                                  ;-----------------------------------------------------------------------------------------------------------------------
   518                                  ;
   519                                  ;	OS Loader								@disk: 004200	@mem: 009100
   520                                  ;
   521                                  ;	This code is the operating system loader. It resides on the boot disk at the start of the data area, following
   522                                  ;	the directory. The loader occupies several clusters that are mapped in the file allocation tables above. The
   523                                  ;	size of the loader is limited to 65,280 bytes since the bootstrap will copy the loader into memory at 0:9100.
   524                                  ;	The loader executes 16-bit instructions in real mode. It performs several initialization functions such as
   525                                  ;	determining whether the CPU and other resources are sufficient to run the operating system. If all minimum
   526                                  ;	resources are present, the loader initializes protected mode tables, places the CPU into protected mode and
   527                                  ;	starts the kernel task. Since the loader was called either from the bootstrap or as a .com file on the boot
   528                                  ;	disk, we can assume that the initial ip is 0x100 and not perform any absolute address fix-ups on our segment
   529                                  ;	registers.
   530                                  ;
   531                                  ;-----------------------------------------------------------------------------------------------------------------------
   532                                  			cpu	8086						;assume minimal CPU
   533                                  section			loader	vstart=100h					;use .COM compatible addressing
   534                                  			bits	16						;this is 16-bit code
   535                                  Loader			push	cs						;use the code segment
   536                                  			pop	ds						;...as our data segment
   537                                  			push	cs						;use the code segment
   538                                  			pop	es						;...as our extra segment
   539                                  ;
   540                                  ;	Write a message to the console so we know we have our addressability established.
   541                                  ;
   542                                  			mov	si,czStartingMsg				;starting message
   543                                  			call	PutTTYString					;display loader message
   544                                  ;
   545                                  ;	Now we want to wait for a keypress. We can use a keyboard interrupt function for this (INT 16h, AH=0).
   546                                  ;	However, some BIOS implementations, such as VirtualBox, seem to implement the "wait" as simply a fast
   547                                  ;	iteration of the keyboard status function call (INT 16h, AH=1), causing a CPU race condition. So, instead
   548                                  ;	we will use the keyboard status call and iterate over a halt (HLT) instruction until a key is pressed.
   549                                  ;	By convention, we enable maskable interrupts with STI before issuing HLT, so as not to catch fire. j/k.
   550                                  ;
   551                                  .30			mov	ah,EBIOSFNKEYSTATUS				;keyboard status function
   552                                  			int	EBIOSINTKEYBOARD				;call BIOS keyboard interrupt
   553                                  			jnz	.40						;exit if key pressed
   554                                  			sti							;enable interrupts
   555                                  			hlt							;wait for interrupt
   556                                  			jmp	short .30					;repeat until keypress
   557                                  ;
   558                                  ;	Now that a key has been pressed, we signal the system to restart by driving the B0 line on the 8042
   559                                  ;	keyboard controller low (OUT 64h,0feh). The restart may take some microseconds to kick in, so we issue
   560                                  ;	HLT until the system resets.
   561                                  ;
   562                                  .40			mov	al,EKEYCMDRESET					;8042 pulse output port pin
   563                                  			out	EKEYPORTSTAT,al					;drive B0 low to restart
   564                                  .50			sti							;enable interrupts
   565                                  			hlt							;stop until reset, int, nmi
   566                                  			jmp	short .50					;loop until restart kicks in
   567                                  ;-----------------------------------------------------------------------------------------------------------------------
   568                                  ;
   569                                  ;	Routine:	PutTTYString
   570                                  ;
   571                                  ;	Description:	This routine sends a NUL-terminated string of characters to the TTY output device. We use the
   572                                  ;			TTY output function of the BIOS video interrupt, passing the address of the string in DS:SI
   573                                  ;			and the BIOS teletype function code in AH. After a return from the BIOS interrupt, we repeat
   574                                  ;			for the next string character until a NUL is found. Note that we clear the direction flag (DF)
   575                                  ;			with CLD before each LODSB. This is just in case the direction flag is ever returned as set
   576                                  ;			by the video interrupt. This is a precaution since a well-written BIOS should preserve all
   577                                  ;			registers and flags unless used to indicate return status.
   578                                  ;
   579                                  ;	In:		DS:SI	address of string
   580                                  ;
   581                                  ;-----------------------------------------------------------------------------------------------------------------------
   582                                  PutTTYString		cld							;forward strings
   583                                  			lodsb							;load next byte at DS:SI in AL
   584                                  			test	al,al						;end of string?
   585                                  			jz	.10						;... yes, exit our loop
   586                                  			mov	ah,EBIOSFNTTYOUTPUT				;BIOS teletype function
   587                                  			int	EBIOSINTVIDEO					;call BIOS display interrupt
   588                                  			jmp	short PutTTYString				;repeat until done
   589                                  .10			ret							;return to caller
   590                                  ;-----------------------------------------------------------------------------------------------------------------------
   591                                  ;
   592                                  ;	Loader Data
   593                                  ;
   594                                  ;	Our only "data" is the string displayed when system starts. It ends with ASCII carriage-return (13) and line-
   595                                  ;	feed (10) values. The remainder of the sector is filled with the typical bit pattern of unused disk space. The
   596                                  ;	sector finally ends with a conventional two-byte signature. The use of filler helps indicate, when looking at
   597                                  ;	program listings or the assembled sector itself, how much space remains unused in the sector.
   598                                  ;
   599                                  ;-----------------------------------------------------------------------------------------------------------------------
   600                                  czStartingMsg		db	"Starting ...",13,10,0				;loader message
   601                                  			times	510-($-$$) db 0h				;zero fill to end of sector
   602                                  			db	055h,0AAh					;end of sector signature
   603                                  %endif
   604                                  %ifdef BUILDDISK
   605                                  ;-----------------------------------------------------------------------------------------------------------------------
   606                                  ;
   607                                  ;	Free Disk Space								@disk: 004400	@mem:  n/a
   608                                  ;
   609                                  ;-----------------------------------------------------------------------------------------------------------------------
   610                                  section			unused							;unused disk space
   611                                  			times	1474560-17408 db 0F6h				;fill to end of disk image
   612                                  %endif
