     1                                  ;=======================================================================================================================
     2                                  ;
     3                                  ;	File:		os.asm
     4                                  ;
     5                                  ;	Project:	os.012
     6                                  ;
     7                                  ;	Description:	In this samplle, logic is added to allocate and free memory blocks associated with a task.
     8                                  ;
     9                                  ;	Revised:	July 1, 2017
    10                                  ;
    11                                  ;	Assembly:	nasm os.asm -f bin -o os.dat     -l os.dat.lst     -DBUILDBOOT
    12                                  ;			nasm os.asm -f bin -o os.dsk     -l os.dsk.lst     -DBUILDDISK
    13                                  ;			nasm os.asm -f bin -o os.com     -l os.com.lst     -DBUILDCOM
    14                                  ;			nasm os.asm -f bin -o osprep.com -l osprep.com.lst -DBUILDPREP
    15                                  ;
    16                                  ;	Assembler:	Netwide Assembler (NASM) 2.13.01
    17                                  ;
    18                                  ;			Copyright (C) 2010-2017 by David J. Walling. All Rights Reserved.
    19                                  ;
    20                                  ;=======================================================================================================================
    21                                  ;-----------------------------------------------------------------------------------------------------------------------
    22                                  ;
    23                                  ;	Assembly Directives
    24                                  ;
    25                                  ;	Use one of the following as an assembly directive (-D) with NASM.
    26                                  ;
    27                                  ;	BUILDBOOT	Creates os.dat, a 512-byte boot sector as a standalone file.
    28                                  ;	BUILDDISK	Creates os.dsk, a 1.44MB (3.5") floppy disk image file.
    29                                  ;	BUILDCOM	Creates os.com, the OS loader and kernel as a standalone DOS program.
    30                                  ;	BUILDPREP	Creates osprep.com, a DOS program that prepares a floppy disk to boot the OS
    31                                  ;
    32                                  ;-----------------------------------------------------------------------------------------------------------------------
    33                                  %ifdef BUILDDISK
    34                                  %define BUILDBOOT
    35                                  %define BUILDCOM
    36                                  %endif
    37                                  %ifdef BUILDPREP
    38                                  %define BUILDBOOT
    39                                  %endif
    40                                  ;-----------------------------------------------------------------------------------------------------------------------
    41                                  ;
    42                                  ;	Conventions
    43                                  ;
    44                                  ;	Labels:		Labels within a routine are numeric and begin with a period (.10, .20).
    45                                  ;			Labels within a routine begin at ".10" and increment by 10.
    46                                  ;
    47                                  ;	Comments:	A comment that spans the entire line begins with a semicolon in column 1.
    48                                  ;			A comment that accompanies code on a line begins with a semicolon in column 81.
    49                                  ;			Register names in comments are in upper case.
    50                                  ;			Hexadecimal values in comments are in lower case.
    51                                  ;			Routines are preceded with a comment box that includes the routine name, description, and
    52                                  ;			register contents on entry and exit.
    53                                  ;
    54                                  ;	Alignment:	Assembly instructions (mnemonics) begin in column 25.
    55                                  ;			Assembly operands begin in column 33.
    56                                  ;			Lines should not extend beyond column 120.
    57                                  ;
    58                                  ;	Routines:	Routine names are in mixed case (GetYear, ReadRealTimeClock).
    59                                  ;			Routine names begin with a verb (Get, Read, etc.).
    60                                  ;			Routines should have a single entry address and a single exit instruction (ret, iretd, etc.).
    61                                  ;
    62                                  ;	Constants:	Symbolic constants (equates) are named in all-caps beginning with 'E' (EDATAPORT).
    63                                  ;			Constant stored values are named in camel case, starting with 'c'.
    64                                  ;			The 2nd letter of the constant label indicates the storage type.
    65                                  ;
    66                                  ;			cq......	constant quad-word (dq)
    67                                  ;			cd......	constant double-word (dd)
    68                                  ;			cw......	constant word (dw)
    69                                  ;			cb......	constant byte (db)
    70                                  ;			cz......	constant ASCIIZ (null-terminated) string
    71                                  ;
    72                                  ;	Variables:	Variables are named in camel case, starting with 'w'.
    73                                  ;			The 2nd letter of the variable label indicates the storage type.
    74                                  ;
    75                                  ;			wq......	variable quad-word (resq)
    76                                  ;			wd......	variable double-word (resd)
    77                                  ;			ww......	variable word (resw)
    78                                  ;			wb......	variable byte (resb)
    79                                  ;
    80                                  ;	Literals:	Literal values defined by external standards should be defined as symbolic constants (equates).
    81                                  ;			Hexadecimal literals in code are in upper case with a leading '0' and trailing 'h'. e.g. 01Fh.
    82                                  ;			Binary literal values in source code are encoded with a final 'b', e.g. 1010b.
    83                                  ;			Decimal literal values in source code are strictly numerals, e.g. 2048.
    84                                  ;			Octal literal values are avoided.
    85                                  ;			String literals are enclosed in double quotes, e.g. "Loading OS".
    86                                  ;			Single character literals are enclosed in single quotes, e.g. 'A'.
    87                                  ;
    88                                  ;	Structures:	Structure names are in all-caps (DATETIME).
    89                                  ;			Structure names do not begin with a verb.
    90                                  ;
    91                                  ;	Macros:		Macro names are in camel case (getDateString).
    92                                  ;			Macro names do begin with a verb.
    93                                  ;
    94                                  ;	Registers:	Register names in comments are in upper case.
    95                                  ;			Register names in source code are in lower case.
    96                                  ;
    97                                  ;	Usage:		Registers EBX, ECX, ESI, EDI, EBP, SS, CS, DS and ES are preserved by all OS routines.
    98                                  ;			Registers EAX and ECX are preferred for returning response/result values.
    99                                  ;			Register EBX is preferred for passing a context (structure) address parameter.
   100                                  ;			Registers EAX, EDX, ECX and EBX are preferred for passing integral parameters.
   101                                  ;
   102                                  ;-----------------------------------------------------------------------------------------------------------------------
   103                                  ;=======================================================================================================================
   104                                  ;
   105                                  ;	Equates
   106                                  ;
   107                                  ;	The equate (equ) statement defines a symbolic name for a fixed value so that such a value can be defined and
   108                                  ;	verified once and then used throughout the code. Using symbolic names simplifies searching for where logical
   109                                  ;	values are used. Equate names are in all-caps and begin with the letter 'E'. Equates are grouped into related
   110                                  ;	sets. Hardware-based values are listed first, followed by BIOS, protocol and application values.
   111                                  ;
   112                                  ;=======================================================================================================================
   113                                  ;-----------------------------------------------------------------------------------------------------------------------
   114                                  ;
   115                                  ;	8042 Keyboard Controller						EKEYB...
   116                                  ;
   117                                  ;	The 8042 Keyboard Controller (8042) is a programmable controller that accepts input signals from the keyboard
   118                                  ;	device. It also signals a hardware interrupt to the CPU when the low-order bit of I/O port 64h is set to zero.
   119                                  ;
   120                                  ;-----------------------------------------------------------------------------------------------------------------------
   121                                  EKEYBPORTDATA		equ	060h						;data port
   122                                  EKEYBPORTSTAT		equ	064h						;status port
   123                                  EKEYBCMDRESET		equ	0FEh						;reset bit 0 to restart system
   124                                  EKEYBBITOUT		equ	001h						;output buffer status bit
   125                                  EKEYBBITIN		equ	002h						;input buffer status bit
   126                                  EKEYBCMDLAMPS		equ	0EDh						;set/reset lamps command
   127                                  EKEYBWAITLOOP		equ	010000h						;wait loop
   128                                  										;---------------------------------------
   129                                  										;	Keyboard Scan Codes
   130                                  										;---------------------------------------
   131                                  EKEYBCTRLDOWN		equ	01Dh						;control key down
   132                                  EKEYBPAUSEDOWN		equ	01Dh						;pause key down (e1 1d ... )
   133                                  EKEYBSHIFTLDOWN		equ	02Ah						;left shift key down
   134                                  EKEYBPRTSCRDOWN		equ	02Ah						;print-screen key down (e0 2a ...)
   135                                  EKEYBSLASH		equ	035h						;slash
   136                                  EKEYBSHIFTRDOWN		equ	036h						;right shift key down
   137                                  EKEYBALTDOWN		equ	038h						;alt key down
   138                                  EKEYBCAPSDOWN		equ	03Ah						;caps-lock down
   139                                  EKEYBNUMDOWN		equ	045h						;num-lock down
   140                                  EKEYBSCROLLDOWN		equ	046h						;scroll-lock down
   141                                  EKEYBINSERTDOWN		equ	052h						;insert down (e0 52)
   142                                  EKEYBUP			equ	080h						;up
   143                                  EKEYBCTRLUP		equ	09Dh						;control key up
   144                                  EKEYBSHIFTLUP		equ	0AAh						;left shift key up
   145                                  EKEYBSLASHUP		equ	0B5h						;slash key up
   146                                  EKEYBSHIFTRUP		equ	0B6h						;right shift key up
   147                                  EKEYBPRTSCRUP		equ	0B7h						;print-screen key up (e0 b7 ...)
   148                                  EKEYBALTUP		equ	0B8h						;alt key up
   149                                  EKEYBCAPSUP		equ	0BAh						;caps-lock up
   150                                  EKEYBNUMUP		equ	0C5h						;num-lock up
   151                                  EKEYBSCROLLUP		equ	0C6h						;scroll-lock up
   152                                  EKEYBINSERTUP		equ	0D2h						;insert up (e0 d2)
   153                                  EKEYBCODEEXT0		equ	0E0h						;extended scan code 0
   154                                  EKEYBCODEEXT1		equ	0E1h						;extended scan code 1
   155                                  ;-----------------------------------------------------------------------------------------------------------------------
   156                                  ;
   157                                  ;	8253 Programmable Interrupt Timer					EPIT...
   158                                  ;
   159                                  ;	The Intel 8253 Programmable Interrupt Time (PIT) is a chip that produces a hardware interrupt (IRQ0)
   160                                  ;	approximately 18.2 times per second.
   161                                  ;
   162                                  ;-----------------------------------------------------------------------------------------------------------------------
   163                                  EPITDAYTICKS		equ	1800B0h						;ticks per day
   164                                  ;-----------------------------------------------------------------------------------------------------------------------
   165                                  ;
   166                                  ;	8259 Peripheral Interrupt Controller					EPIC...
   167                                  ;
   168                                  ;	The 8259 Peripheral Interrupt Controller (PIC) is a programmable controller that accepts interrupt signals from
   169                                  ;	external devices and signals a hardware interrupt to the CPU.
   170                                  ;
   171                                  ;-----------------------------------------------------------------------------------------------------------------------
   172                                  EPICPORTPRI		equ	020h						;primary control port 0
   173                                  EPICPORTPRI1		equ	021h						;primary control port 1
   174                                  EPICPORTSEC		equ	0A0h						;secondary control port 0
   175                                  EPICPORTSEC1		equ	0A1h						;secondary control port 1
   176                                  EPICEOI			equ	020h						;non-specific EOI code
   177                                  ;-----------------------------------------------------------------------------------------------------------------------
   178                                  ;
   179                                  ;	6845 Cathode Ray Tube (CRT) Controller					ECRT...
   180                                  ;
   181                                  ;	The Motorola 6845 CRT Controller (CRTC) is a programmable controller
   182                                  ;	for CGA, EGA, VGA and compatible video modes.
   183                                  ;
   184                                  ;-----------------------------------------------------------------------------------------------------------------------
   185                                  ECRTPORTHI		equ	003h						;controller port hi
   186                                  ECRTPORTLO		equ	0D4h						;controller port lo
   187                                  ECRTCURLOCHI		equ	00Eh						;cursor loc reg hi
   188                                  ECRTCURLOCLO		equ	00Fh						;cursor loc reg lo
   189                                  ;-----------------------------------------------------------------------------------------------------------------------
   190                                  ;
   191                                  ;	NEC 765 Floppy Disk Controller (FDC)					EFDC...
   192                                  ;
   193                                  ;	The NEC 765 FDC is a programmable controller for floppy disk drives.
   194                                  ;
   195                                  ;-----------------------------------------------------------------------------------------------------------------------
   196                                  EFDCPORTHI		equ	003h						;controller port hi
   197                                  EFDCPORTLOOUT		equ	0F2h						;digital output register lo
   198                                  EFDCPORTLOSTAT		equ	0F4h						;main status register lo
   199                                  EFDCSTATBUSY		equ	010h						;main status is busy
   200                                  EFDCMOTOROFF		equ	00Ch						;motor off / enable / DMA
   201                                  ;-----------------------------------------------------------------------------------------------------------------------
   202                                  ;
   203                                  ;	Motorola MC 146818 Real-Time Clock					ERTC...
   204                                  ;
   205                                  ;	The Motorola MC 146818 was the original real-time clock in PCs.
   206                                  ;
   207                                  ;-----------------------------------------------------------------------------------------------------------------------
   208                                  ERTCREGPORT		equ	70h						;register select port
   209                                  ERTCDATAPORT		equ	71h						;data port
   210                                  ERTCSECONDREG		equ	00h						;second
   211                                  ERTCMINUTEREG		equ	02h						;minute
   212                                  ERTCHOURREG		equ	04h						;hour
   213                                  ERTCWEEKDAYREG		equ	06h						;weekday
   214                                  ERTCDAYREG		equ	07h						;day
   215                                  ERTCMONTHREG		equ	08h						;month
   216                                  ERTCYEARREG		equ	09h						;year of the century
   217                                  ERTCSTATUSREG		equ	0bh						;status
   218                                  ERTCCENTURYREG		equ	32h						;century
   219                                  ERTCBINARYVALS		equ	00000100b					;values are binary
   220                                  ;-----------------------------------------------------------------------------------------------------------------------
   221                                  ;
   222                                  ;	x86 Descriptor Access Codes						EACC...
   223                                  ;
   224                                  ;	The x86 architecture supports the classification of memory areas or segments. Segment attributes are defined by
   225                                  ;	structures known as descriptors. Within a descriptor are access type codes that define the type of the segment.
   226                                  ;
   227                                  ;	0.......	Segment is not present in memory (triggers int 11)
   228                                  ;	1.......	Segment is present in memory
   229                                  ;	.LL.....	Segment is of privilege level LL (0,1,2,3)
   230                                  ;	...0....	Segment is a system segment
   231                                  ;	...00010		Local Descriptor Table
   232                                  ;	...00101		Task Gate
   233                                  ;	...010B1		Task State Segment (B:0=Available,1=Busy)
   234                                  ;	...01100		Call Gate (386)
   235                                  ;	...01110		Interrupt Gate (386)
   236                                  ;	...01111		Trap Gate (386)
   237                                  ;	...1...A	Segment is a code or data (A:1=Accesssed)
   238                                  ;	...10DW.		Data (D:1=Expand Down,W:1=Writable)
   239                                  ;	...11CR.		Code (C:1=Conforming,R:1=Readable)
   240                                  ;
   241                                  ;-----------------------------------------------------------------------------------------------------------------------
   242                                  EACCLDT			equ	10000010b					;local descriptor table
   243                                  EACCTASK		equ	10000101b					;task gate
   244                                  EACCTSS			equ	10001001b					;task-state segment
   245                                  EACCGATE		equ	10001100b					;call gate
   246                                  EACCINT			equ	10001110b					;interrupt gate
   247                                  EACCTRAP		equ	10001111b					;trap gate
   248                                  EACCDATA		equ	10010011b					;upward writable data
   249                                  EACCCODE		equ	10011011b					;non-conforming readable code
   250                                  ;-----------------------------------------------------------------------------------------------------------------------
   251                                  ;
   252                                  ;	BIOS Interrupts and Functions						EBIOS...
   253                                  ;
   254                                  ;	Basic Input/Output System (BIOS) functions are grouped and accessed by issuing an interrupt call. Each
   255                                  ;	BIOS interrupt supports several funtions. The function code is typically passed in the AH register.
   256                                  ;
   257                                  ;-----------------------------------------------------------------------------------------------------------------------
   258                                  EBIOSINTVIDEO		equ	010h						;video services interrupt
   259                                  EBIOSFNSETVMODE		equ	000h						;video set mode function
   260                                  EBIOSMODETEXT80		equ	003h						;video mode 80x25 text
   261                                  EBIOSFNTTYOUTPUT	equ	00Eh						;video TTY output function
   262                                  EBIOSINTDISKETTE	equ	013h						;diskette services interrupt
   263                                  EBIOSINTMISC		equ	015h						;miscellaneous services interrupt
   264                                  EBIOSFNINITPROTMODE	equ	089h						;initialize protected mode fn
   265                                  EBIOSINTKEYBOARD	equ	016h						;keyboard services interrupt
   266                                  EBIOSFNKEYSTATUS	equ	001h						;keyboard status function
   267                                  ;-----------------------------------------------------------------------------------------------------------------------
   268                                  ;
   269                                  ;	ASCII									EASCII...
   270                                  ;
   271                                  ;-----------------------------------------------------------------------------------------------------------------------
   272                                  EASCIIBACKSPACE		equ	008h						;backspace
   273                                  EASCIILINEFEED		equ	00Ah						;line feed
   274                                  EASCIIRETURN		equ	00Dh						;carriage return
   275                                  EASCIIESCAPE		equ	01Bh						;escape
   276                                  EASCIISPACE		equ	020h						;space
   277                                  EASCIIUPPERA		equ	041h						;'A'
   278                                  EASCIIUPPERZ		equ	05Ah						;'Z'
   279                                  EASCIILOWERA		equ	061h						;'a'
   280                                  EASCIILOWERZ		equ	07Ah						;'z'
   281                                  EASCIITILDE		equ	07Eh						;'~'
   282                                  EASCIIBORDSGLVERT	equ	0B3h						;vertical single border
   283                                  EASCIIBORDSGLUPRRGT	equ	0BFh						;upper-right single border
   284                                  EASCIIBORDSGLLWRLFT	equ	0C0h						;lower-left single border
   285                                  EASCIIBORDSGLHORZ	equ	0C4h						;horizontal single border
   286                                  EASCIIBORDSGLLWRRGT	equ	0D9h						;lower-right single border
   287                                  EASCIIBORDSGLUPRLFT	equ	0DAh						;upper-left single border
   288                                  EASCIICASE		equ	00100000b					;case bit
   289                                  EASCIICASEMASK		equ	11011111b					;case mask
   290                                  ;-----------------------------------------------------------------------------------------------------------------------
   291                                  ;
   292                                  ;	Boot Sector and Loader Constants					EBOOT...
   293                                  ;
   294                                  ;	Equates in this section support the boot sector and the 16-bit operating system loader, which will be
   295                                  ;	responsible for placing the CPU into protected mode and calling the initial operating system task.
   296                                  ;
   297                                  ;-----------------------------------------------------------------------------------------------------------------------
   298                                  EBOOTSTACKTOP		equ	0100h						;boot sector stack top relative to DS
   299                                  EBOOTSECTORBYTES	equ	512						;bytes per sector
   300                                  EBOOTDISKSECTORS	equ	2880						;sectors per disk
   301                                  EBOOTDISKBYTES		equ	(EBOOTSECTORBYTES*EBOOTDISKSECTORS)		;bytes per disk
   302                                  EBOOTFATBASE		equ	(EBOOTSTACKTOP+EBOOTSECTORBYTES)		;offset of FAT I/O buffer rel to DS
   303                                  EBOOTMAXTRIES		equ	5						;max read retries
   304                                  ;-----------------------------------------------------------------------------------------------------------------------
   305                                  ;	Global Descriptor Table (GDT) Selectors					ESEL...
   306                                  ;-----------------------------------------------------------------------------------------------------------------------
   307                                  ESELGDT			equ	008h						;gdt alias selector
   308                                  ESELDAT			equ	018h						;kernel data selector
   309                                  ESELCGA			equ	020h						;cga video selector
   310                                  ESELOSCODE		equ	048h						;os kernel code selector
   311                                  ESELLOADERLDT		equ	050h						;loader local descriptor table selector
   312                                  ESELLOADERTSS		equ	058h						;loader task state segment selector
   313                                  ESELCONSOLELDT		equ	060h						;console local descriptor table selector
   314                                  ESELCONSOLETSS		equ	068h						;console task state segment selector
   315                                  ESELBACKGROUNDLDT	equ	070h						;background local descr table selector
   316                                  ESELBACKGROUNDTSS	equ	078h						;background task state segment selector
   317                                  ESELKEYBOARDMQ		equ	080h						;keyboard focus message queue (IRQ1)
   318                                  ;-----------------------------------------------------------------------------------------------------------------------
   319                                  ;	LDT Selectors								ESEL...
   320                                  ;-----------------------------------------------------------------------------------------------------------------------
   321                                  ESELMQ			equ	02Ch						;console task message queue
   322                                  ;-----------------------------------------------------------------------------------------------------------------------
   323                                  ;	Kernel Constants							EKRN...
   324                                  ;-----------------------------------------------------------------------------------------------------------------------
   325                                  EKRNDESLEN		equ	8						;size of descriptor
   326                                  EKRNDATASEG		equ	00000h						;kernel data segment (0000:0800)
   327                                  EKRNCODEADR		equ	01000h						;kernel base address (0000:1000)
   328                                  EKRNCODESEG		equ	(EKRNCODEADR >> 4)				;kernel code segment (0100:0000)
   329                                  ;-----------------------------------------------------------------------------------------------------------------------
   330                                  ;	Keyboard Flags								EKEYF...
   331                                  ;-----------------------------------------------------------------------------------------------------------------------
   332                                  EKEYFCTRLLEFT		equ	00000001b					;left control
   333                                  EKEYFSHIFTLEFT		equ	00000010b					;left shift
   334                                  EKEYFALTLEFT		equ	00000100b					;left alt
   335                                  EKEYFCTRLRIGHT		equ	00001000b					;right control
   336                                  EKEYFSHIFTRIGHT		equ	00010000b					;right shift
   337                                  EKEYFSHIFT		equ	00010010b					;left or right shift
   338                                  EKEYFALTRIGHT		equ	00100000b					;right alt
   339                                  EKEYFLOCKSCROLL		equ	00000001b					;scroll-lock flag
   340                                  EKEYFLOCKNUM		equ	00000010b					;num-lock flag
   341                                  EKEYFLOCKCAPS		equ	00000100b					;cap-lock flag
   342                                  EKEYFTIMEOUT		equ	10000000b					;controller timeout
   343                                  ;-----------------------------------------------------------------------------------------------------------------------
   344                                  ;	Console Constants							ECON...
   345                                  ;-----------------------------------------------------------------------------------------------------------------------
   346                                  ECONCOLS		equ	80						;columns per row
   347                                  ECONROWS		equ	24						;console rows
   348                                  ECONOIAROW		equ	24						;operator information area row
   349                                  ECONCOLBYTES		equ	2						;bytes per column
   350                                  ECONROWBYTES		equ	(ECONCOLS*ECONCOLBYTES)				;bytes per row
   351                                  ECONROWDWORDS		equ	(ECONROWBYTES/4)				;double-words per row
   352                                  ECONCLEARDWORD		equ	007200720h					;attribute and ASCII space
   353                                  ECONOIADWORD		equ	070207020h					;attribute and ASCII space
   354                                  ;-----------------------------------------------------------------------------------------------------------------------
   355                                  ;	Kernel Message Identifiers						EMSG...
   356                                  ;-----------------------------------------------------------------------------------------------------------------------
   357                                  EMSGKEYDOWN		equ	041000000h					;key-down
   358                                  EMSGKEYUP		equ	041010000h					;key-up
   359                                  EMSGKEYCHAR		equ	041020000h					;character
   360                                  ;-----------------------------------------------------------------------------------------------------------------------
   361                                  ;	Background Task Identifiers						EBG...
   362                                  ;-----------------------------------------------------------------------------------------------------------------------
   363                                  EBGTIMELEN		equ	9						;length of time string HH:MM:SS\0
   364                                  ;-----------------------------------------------------------------------------------------------------------------------
   365                                  ;	Memory Constants							EMEM...
   366                                  ;-----------------------------------------------------------------------------------------------------------------------
   367                                  EMEMBASE		equ	10000h						;heap base address
   368                                  EMEMMINSIZE		equ	256						;minimum heap block size (incl. hdr)
   369                                  EMEMFREECODE		equ	"FREE"						;free memory signature
   370                                  EMEMUSERCODE		equ	"USER"						;user memory signature
   371                                  EMEMHEAPSIZE		equ	80000000h					;heap size (temporary)
   372                                  EMEMWIPEBYTE		equ	000h						;byte value to wipe storage
   373                                  ;=======================================================================================================================
   374                                  ;
   375                                  ;	Structures
   376                                  ;
   377                                  ;=======================================================================================================================
   378                                  ;-----------------------------------------------------------------------------------------------------------------------
   379                                  ;
   380                                  ;	DATETIME
   381                                  ;
   382                                  ;	The DATETIME structure stores date and time values from the real-time clock.
   383                                  ;
   384                                  ;-----------------------------------------------------------------------------------------------------------------------
   385                                  struc			DATETIME
   386 00000000 <res 00000001>          .second			resb	1						;seconds
   387 00000001 <res 00000001>          .minute			resb	1						;minutes
   388 00000002 <res 00000001>          .hour			resb	1						;hours
   389 00000003 <res 00000001>          .weekday		resb	1						;day of week
   390 00000004 <res 00000001>          .day			resb	1						;day of month
   391 00000005 <res 00000001>          .month			resb	1						;month of year
   392 00000006 <res 00000001>          .year			resb	1						;year of century
   393 00000007 <res 00000001>          .century		resb	1						;century
   394                                  EDATETIMELEN		equ	($-.second)
   395                                  endstruc
   396                                  ;-----------------------------------------------------------------------------------------------------------------------
   397                                  ;
   398                                  ;	MEMBLOCK
   399                                  ;
   400                                  ;	The MEMBLOCK structure defines a memory block.
   401                                  ;
   402                                  ;-----------------------------------------------------------------------------------------------------------------------
   403                                  struc			MEMBLOCK
   404 00000000 <res 00000004>          .signature		resd	1						;starting signature
   405 00000004 <res 00000004>          .bytes			resd	1						;block size in bytes
   406 00000008 <res 00000004>          .owner			resd	1						;owning task
   407 0000000C <res 00000004>          .reserved		resd	1						;reserved
   408 00000010 <res 00000004>          .nextcontig		resd	1						;next contiguous block
   409 00000014 <res 00000004>          .previouscontig		resd	1						;previous contiguous block
   410 00000018 <res 00000004>          .nextblock		resd	1						;next free/task block
   411 0000001C <res 00000004>          .previousblock		resd	1						;previous free/task block
   412                                  EMEMBLOCKLEN		equ	($-.signature)
   413                                  endstruc
   414                                  ;-----------------------------------------------------------------------------------------------------------------------
   415                                  ;
   416                                  ;	MEMROOT
   417                                  ;
   418                                  ;	The MEMROOT structure defines starting and ending addresses of memory block chains.
   419                                  ;
   420                                  ;-----------------------------------------------------------------------------------------------------------------------
   421                                  struc			MEMROOT
   422 00000000 <res 00000004>          .firstcontig		resd	1						;first contiguous block
   423 00000004 <res 00000004>          .lastcontig		resd	1						;last contiguous block
   424 00000008 <res 00000004>          .firstfree		resd	1						;first free block
   425 0000000C <res 00000004>          .lastfree		resd	1						;last free block
   426 00000010 <res 00000004>          .firsttask		resd	1						;first task block
   427 00000014 <res 00000004>          .lasttask		resd	1						;last task block
   428                                  EMEMROOTLEN		equ	($-.firstcontig)
   429                                  endstruc
   430                                  ;-----------------------------------------------------------------------------------------------------------------------
   431                                  ;
   432                                  ;	MQUEUE
   433                                  ;
   434                                  ;	The MQUEUE structure maps memory used for a message queue.
   435                                  ;
   436                                  ;-----------------------------------------------------------------------------------------------------------------------
   437                                  struc			MQUEUE
   438 00000000 <res 00000004>          MQHead			resd	1						;000 head ptr
   439 00000004 <res 00000004>          MQTail			resd	1						;004 tail ptr
   440 00000008 <res 000003F8>          MQData			resd	254						;message queue
   441                                  endstruc
   442                                  ;-----------------------------------------------------------------------------------------------------------------------
   443                                  ;
   444                                  ;	OSDATA
   445                                  ;
   446                                  ;	The OSDATA structure maps low-memory addresses used by the OS. Some of these addresses are predetermined and
   447                                  ;	used by the BIOS.
   448                                  ;
   449                                  ;-----------------------------------------------------------------------------------------------------------------------
   450                                  struc			OSDATA
   451 00000000 <res 00000400>          			resb	0400h						;000 real mode interrupt vectors
   452 00000400 <res 00000002>          			resw	1						;400 COM1 port address
   453 00000402 <res 00000002>          			resw	1						;402 COM2 port address
   454 00000404 <res 00000002>          			resw	1						;404 COM3 port address
   455 00000406 <res 00000002>          			resw	1						;406 COM4 port address
   456 00000408 <res 00000002>          			resw	1						;408 LPT1 port address
   457 0000040A <res 00000002>          			resw	1						;40a LPT2 port address
   458 0000040C <res 00000002>          			resw	1						;40c LPT3 port address
   459 0000040E <res 00000002>          			resw	1						;40e LPT4 port address
   460 00000410 <res 00000002>          			resb	2						;410 equipment list flags
   461 00000412 <res 00000001>          			resb	1						;412 errors in PCjr infrared keybd link
   462 00000413 <res 00000002>          			resw	1						;413 memory size (kb) INT 12h
   463 00000415 <res 00000001>          			resb	1						;415 mfr error test scratchpad
   464 00000416 <res 00000001>          			resb	1						;416 PS/2 BIOS control flags
   465 00000417 <res 00000001>          			resb	1						;417 keyboard flag byte 0
   466 00000418 <res 00000001>          			resb	1						;418 keyboard flag byte 1
   467 00000419 <res 00000001>          			resb	1						;419 alternate keypad entry
   468 0000041A <res 00000002>          			resw	1						;41a keyboard buffer head offset
   469 0000041C <res 00000002>          			resw	1						;41c keyboard buffer tail offset
   470 0000041E <res 00000020>          			resb	32						;41e keyboard buffer
   471 0000043E <res 00000001>          wbFDCStatus		resb	1						;43e drive recalibration status
   472 0000043F <res 00000001>          wbFDCControl		resb	1						;43f FDC motor status/control byte
   473 00000440 <res 00000001>          wbFDCMotor		resb	1						;440 FDC motor timeout byte
   474 00000441 <res 00000001>          			resb	1						;441 status of last diskette operation
   475 00000442 <res 00000007>          			resb	7						;442 NEC diskette controller status
   476 00000449 <res 00000001>          			resb	1						;449 current video mode
   477 0000044A <res 00000002>          			resw	1						;44a screen columns
   478 0000044C <res 00000002>          			resw	1						;44c video regen buffer size
   479 0000044E <res 00000002>          			resw	1						;44e current video page offset
   480 00000450 <res 00000010>          			resw	8						;450 cursor postions of pages 1-8
   481 00000460 <res 00000001>          			resb	1						;460 cursor ending scanline
   482 00000461 <res 00000001>          			resb	1						;461 cursor start scanline
   483 00000462 <res 00000001>          			resb	1						;462 active display page number
   484 00000463 <res 00000002>          			resw	1						;463 CRTC base port address
   485 00000465 <res 00000001>          			resb	1						;465 CRT mode control register value
   486 00000466 <res 00000001>          			resb	1						;466 CGA current color palette mask
   487 00000467 <res 00000002>          			resw	1						;467 CS:IP for 286 return from PROT MODE
   488 00000469 <res 00000003>          			resb	3						;469 vague
   489 0000046C <res 00000004>          wdClockTicks		resd	1						;46c clock ticks
   490 00000470 <res 00000001>          wbClockDays		resb	1						;470 clock days
   491 00000471 <res 00000001>          			resb	1						;471 bios break flag
   492 00000472 <res 00000002>          			resw	1						;472 soft reset
   493 00000474 <res 00000001>          			resb	1						;474 last hard disk operation status
   494 00000475 <res 00000001>          			resb	1						;475 hard disks attached
   495 00000476 <res 00000001>          			resb	1						;476 XT fised disk drive control byte
   496 00000477 <res 00000001>          			resb	1						;477 port offset to current fixed disk adapter
   497 00000478 <res 00000004>          			resb	4						;478 LPT timeout values
   498 0000047C <res 00000004>          			resb	4						;47c COM timeout values
   499 00000480 <res 00000002>          			resw	1						;480 keyboard buffer start offset
   500 00000482 <res 00000002>          			resw	1						;482 keyboard buffer end offset
   501 00000484 <res 00000001>          			resb	1						;484 Rows on screen less 1 (EGA+)
   502 00000485 <res 00000001>          			resb	1						;485 point height of character matrix (EGA+)
   503 00000486 <res 00000001>          			resb	1						;486 PC Jr initial keybd delay
   504 00000487 <res 00000001>          			resb	1						;487 EGA+ video mode ops
   505 00000488 <res 00000001>          			resb	1						;488 EGA feature bit switches
   506 00000489 <res 00000001>          			resb	1						;489 VGA video display data area
   507 0000048A <res 00000001>          			resb	1						;48a EGA+ display combination code
   508 0000048B <res 00000001>          			resb	1						;48b last diskette data rate selected
   509 0000048C <res 00000001>          			resb	1						;48c hard disk status from controller
   510 0000048D <res 00000001>          			resb	1						;48d hard disk error from controller
   511 0000048E <res 00000001>          			resb	1						;48e hard disk interrupt control flag
   512 0000048F <res 00000001>          			resb	1						;48f combination hard/floppy disk card
   513 00000490 <res 00000004>          			resb	4						;490 drive 0,1,2,3 media state
   514 00000494 <res 00000001>          			resb	1						;494 track currently seeked to on drive 0
   515 00000495 <res 00000001>          			resb	1						;495 track currently seeked to on drive 1
   516 00000496 <res 00000001>          			resb	1						;496 keyboard mode/type
   517 00000497 <res 00000001>          			resb	1						;497 keyboard LED flags
   518 00000498 <res 00000004>          			resd	1						;498 pointer to user wait complete flag
   519 0000049C <res 00000004>          			resd	1						;49c user wait time-out value in microseconds
   520 000004A0 <res 00000001>          			resb	1						;4a0 RTC wait function flag
   521 000004A1 <res 00000001>          			resb	1						;4a1 LANA DMA channel flags
   522 000004A2 <res 00000002>          			resb	2						;4a2 status of LANA 0,1
   523 000004A4 <res 00000004>          			resd	1						;4a4 saved hard disk interrupt vector
   524 000004A8 <res 00000004>          			resd	1						;4a8 BIOS video save/override pointer table addr
   525 000004AC <res 00000008>          			resb	8						;4ac reserved
   526 000004B4 <res 00000001>          			resb	1						;4b4 keyboard NMI control flags
   527 000004B5 <res 00000004>          			resd	1						;4b5 keyboard break pending flags
   528 000004B9 <res 00000001>          			resb	1						;4b9 Port 60 single byte queue
   529 000004BA <res 00000001>          			resb	1						;4ba scan code of last key
   530 000004BB <res 00000001>          			resb	1						;4bb NMI buffer head pointer
   531 000004BC <res 00000001>          			resb	1						;4bc NMI buffer tail pointer
   532 000004BD <res 00000010>          			resb	16						;4bd NMI scan code buffer
   533 000004CD <res 00000001>          			resb	1						;4cd unknown
   534 000004CE <res 00000002>          			resw	1						;4de day counter
   535 000004D0 <res 00000020>          			resb	32						;4d0 unknown
   536 000004F0 <res 00000010>          			resb	16						;4f0 intra-app comm area
   537 00000500 <res 00000001>          			resb	1						;500 print-screen status byte
   538 00000501 <res 00000003>          			resb	3						;501 used by BASIC
   539 00000504 <res 00000001>          			resb	1						;504 DOS single diskette mode
   540 00000505 <res 0000000A>          			resb	10						;505 POST work area
   541 0000050F <res 00000001>          			resb	1						;50f BASIC shell flag
   542 00000510 <res 00000002>          			resw	1						;510 BASIC default DS (DEF SEG)
   543 00000512 <res 00000004>          			resd	1						;512 BASIC INT 1C interrupt handler
   544 00000516 <res 00000004>          			resd	1						;516 BASIC INT 23 interrupt handler
   545 0000051A <res 00000004>          			resd	1						;51a BASIC INT 24 interrupt handler
   546 0000051E <res 00000002>          			resw	1						;51e unknown
   547 00000520 <res 00000002>          			resw	1						;520 DOS dynamic storage
   548 00000522 <res 0000000E>          			resb	14						;522 DOS diskette initialization table (INT 1e)
   549 00000530 <res 00000004>          			resb	4						;530 MODE command
   550 00000534 <res 000001CC>          			resb	460						;534 unused
   551 00000700 <res 00000100>          			resb	256						;700 i/o drivers from io.sys/ibmbio.com
   552                                  ;-----------------------------------------------------------------------------------------------------------------------
   553                                  ;
   554                                  ;	OS Variables								@disk: N/A	@mem: 000800
   555                                  ;
   556                                  ;	Operating system variables are system global. They are defined at low memory address 800h and are typically
   557                                  ;	accessed using GDT selector 18H, which defines a 4GB address space at address 0:0. The variables defined here
   558                                  ;	are organized based on the task that usually accesses them.
   559                                  ;
   560                                  ;-----------------------------------------------------------------------------------------------------------------------
   561                                  ;-----------------------------------------------------------------------------------------------------------------------
   562                                  ;
   563                                  ;	Kernel Variables
   564                                  ;
   565                                  ;	These variables are not task-specific. They are initialized by the OS loader before the system is placed into
   566                                  ;	protected mode. This is necessary because as soon as the system enters protected mode, the timer interrupt
   567                                  ;	(IRQ0) will begin to reference the task selectors queue to implement task switching.
   568                                  ;
   569                                  ;-----------------------------------------------------------------------------------------------------------------------
   570                                  			align	4
   571                                  EKERNELDATA		equ	($)
   572 00000800 <res 00000200>          wwTaskQueue		resw	256						;task selector queue
   573 00000A00 <res 00000004>          wdFarJumpEIP		resd	1						;destination EIP of next task (ignored)
   574 00000A04 <res 00000002>          wwFarJumpSelector	resw	1						;destination task gate
   575 00000A06 <res 00000001>          wbTaskIndex		resb	1						;task selector index
   576 00000A07 <res 00000001>          wbInCriticalSection	resb	1						;task in critical section
   577                                  			align	4
   578 00000A08 <res 00000004>          wfHeapSize		resd	1						;heap size
   579 00000A0C <res 00000018>          wsMemRoot		resb	EMEMROOTLEN					;base memory map
   580                                  EKERNELDATALEN		equ	($-EKERNELDATA)
   581                                  ;-----------------------------------------------------------------------------------------------------------------------
   582                                  ;
   583                                  ;	Console Task Variables
   584                                  ;
   585                                  ;	These variables are exclusve to the console task. These variables are initialized by the console task when
   586                                  ;	the console task starts.
   587                                  ;
   588                                  ;-----------------------------------------------------------------------------------------------------------------------
   589                                  			align	4
   590                                  ECONDATA		equ	($)
   591 00000A24 <res 00000004>          wfConsoleMemAddr	resd	1						;console memory address
   592 00000A28 <res 00000001>          wbConsoleColumn		resb	1						;console column
   593 00000A29 <res 00000001>          wbConsoleRow		resb	1						;console row
   594 00000A2A <res 00000001>          wbConsoleShift		resb	1						;console shift flags
   595 00000A2B <res 00000001>          wbConsoleLock		resb	1						;console lock flags
   596 00000A2C <res 00000001>          wbConsoleStatus		resb	1						;controller status
   597 00000A2D <res 00000001>          wbConsoleScan0		resb	1						;scan code
   598 00000A2E <res 00000001>          wbConsoleScan1		resb	1						;scan code
   599 00000A2F <res 00000001>          wbConsoleScan2		resb	1						;scan code
   600 00000A30 <res 00000001>          wbConsoleScan3		resb	1						;scan code
   601 00000A31 <res 00000001>          wbConsoleScan4		resb	1						;scan code
   602 00000A32 <res 00000001>          wbConsoleScan5		resb	1						;scan code
   603 00000A33 <res 00000001>          wbConsoleChar		resb	1						;ASCII code
   604 00000A34 <res 00000050>          wzConsoleInBuffer	resb	80						;command input buffer
   605 00000A84 <res 00000050>          wzConsoleToken		resb	80						;token buffer
   606 00000AD4 <res 00000050>          wzConsoleOutBuffer	resb	80						;response output buffer
   607 00000B24 <res 00000008>          wsConsoleDateTime	resb	EDATETIMELEN					;date-time buffer
   608                                  ECONDATALEN		equ	($-ECONDATA)					;size of console data area
   609                                  ;-----------------------------------------------------------------------------------------------------------------------
   610                                  ;
   611                                  ;	Background Task Variables
   612                                  ;
   613                                  ;	These variables are exclusve to the background task. These variables are initialized by the background task when
   614                                  ;	the task starts.
   615                                  ;
   616                                  ;-----------------------------------------------------------------------------------------------------------------------
   617                                  			align	4
   618                                  EBGDATA			equ	($)
   619 00000B2C <res 00000008>          wsBgDateTime		resb	EDATETIMELEN					;date-time buffer
   620 00000B34 <res 00000009>          wzBgTime		resb	EBGTIMELEN					;time string buffer
   621 00000B3D <res 00000009>          wzBgTimeCmpr		resb	EBGTIMELEN					;time string comparison buffer
   622                                  EBGDATALEN		equ	($-EBGDATA)
   623                                  ;-----------------------------------------------------------------------------------------------------------------------
   624                                  ;
   625                                  ;	End of OS Variables
   626                                  ;
   627                                  ;-----------------------------------------------------------------------------------------------------------------------
   628                                  endstruc
   629                                  ;-----------------------------------------------------------------------------------------------------------------------
   630                                  ;
   631                                  ;	Macros
   632                                  ;
   633                                  ;	These macros are used to assist in defining descriptor tables and interrupt table offsets.
   634                                  ;
   635                                  ;-----------------------------------------------------------------------------------------------------------------------
   636                                  %macro			mint	1
   637                                  _%1			equ	($-$$) / EKRNDESLEN
   638                                  			dq	((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
   639                                  %endmacro
   640                                  %macro			mtrap	1
   641                                  _%1			equ	($-$$) / EKRNDESLEN
   642                                  			dq	((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
   643                                  %endmacro
   644                                  %macro			menter	1
   645                                  ?%1			equ	($-$$)
   646                                  %endmacro
   647                                  %macro			tsvce	1
   648                                  e%1			equ	($-tsvc)/4
   649                                  			dd	%1
   650                                  %endmacro
   651                                  %ifdef BUILDBOOT
   652                                  ;=======================================================================================================================
   653                                  ;
   654                                  ;	Boot Sector								@disk: 000000	@mem: 007c00
   655                                  ;
   656                                  ;	The first sector of the disk is the boot sector. The BIOS will load the boot sector into memory and pass
   657                                  ;	control to the code at the start of the sector. The boot sector code is responsible for loading the operating
   658                                  ;	system into memory. The boot sector contains a disk parameter table describing the geometry and allocation
   659                                  ;	of the disk. Following the disk parameter table is code to load the operating system kernel into memory.
   660                                  ;
   661                                  ;	The 'cpu' directive limits emitted code to those instructions supported by the most primitive processor
   662                                  ;	we expect to ever execute our code. The 'vstart' parameter indicates addressability of symbols so as to
   663                                  ;	emulating the DOS .COM program model. Although the BIOS is expected to load the boot sector at address 7c00,
   664                                  ;	we do not make that assumption. The CPU starts in 16-bit addressing mode. A three-byte jump instruction is
   665                                  ;	immediately followed by a disk parameter table.
   666                                  ;
   667                                  ;=======================================================================================================================
   668                                  			cpu	8086						;assume minimal CPU
   669                                  section			boot	vstart=0100h					;emulate .COM (CS,DS,ES=PSP) addressing
   670                                  			bits	16						;16-bit code at power-up
   671                                  %ifdef BUILDPREP
   672                                  Boot			jmp	word Prep					;jump to preparation code
   673                                  %else
   674                                  Boot			jmp	word Boot.10					;jump over parameter table
   675                                  %endif
   676                                  ;-----------------------------------------------------------------------------------------------------------------------
   677                                  ;
   678                                  ;	Disk Parameter Table
   679                                  ;
   680                                  ;	The disk parameter table informs the BIOS of the floppy disk architecture. Here, we use parameters for the
   681                                  ;	3.5" 1.44MB floppy disk since this format is widely supported by virtual machine hypervisors.
   682                                  ;
   683                                  ;-----------------------------------------------------------------------------------------------------------------------
   684                                  			db	"CustomOS"					;eight-byte label
   685                                  cwSectorBytes		dw	EBOOTSECTORBYTES				;bytes per sector
   686                                  cbClusterSectors	db	1						;sectors per cluster
   687                                  cwReservedSectors	dw	1						;reserved sectors
   688                                  cbFatCount		db	2						;file allocation table copies
   689                                  cwDirEntries		dw	224						;max directory entries
   690                                  cwDiskSectors		dw	EBOOTDISKSECTORS				;sectors per disk
   691                                  cbDiskType		db	0F0h						;1.44MB
   692                                  cwFatSectors		dw	9						;sectors per FAT copy
   693                                  cbTrackSectors		equ	$						;sectors per track (as byte)
   694                                  cwTrackSectors		dw	18						;sectors per track (as word)
   695                                  cwDiskSides		dw	2						;sides per disk
   696                                  cwSpecialSectors	dw	0						;special sectors
   697                                  ;
   698                                  ;	BIOS typically loads the boot sector at absolute address 7c00 and sets the stack pointer at 512 bytes past the
   699                                  ;	end of the boot sector. But, since BIOS code varies, we don't make any assumptions as to where our boot sector
   700                                  ;	is loaded. For example, the initial CS:IP could be 0:7c00, 700:c00, 7c0:0, etc. So, to avoid assumptions, we
   701                                  ;	first normalize CS:IP to get the absolute segment address in BX. The comments below show the effect of this code
   702                                  ;	given several possible starting values for CS:IP.
   703                                  ;
   704                                  										;CS:IP	 0:7c00 700:c00 7c0:0
   705                                  Boot.10			call	word .20					;[ESP] =   7c21     c21    21
   706                                  .@20			equ	$-$$						;.@20 = 021h
   707                                  .20			pop	ax						;AX =	   7c21     c21    21
   708                                  			sub	ax,.@20						;BX =	   7c00     c00     0
   709                                  			mov	cl,4						;shift count
   710                                  			shr	ax,cl						;AX =	    7c0      c0     0
   711                                  			mov	bx,cs						;BX =	      0     700   7c0
   712                                  			add	bx,ax						;BX =	    7c0     7c0   7c0
   713                                  ;
   714                                  ;	Now, since we are assembling our boot code to emulate the addressing of a .COM file, we want the DS and ES
   715                                  ;	registers to be set to where a Program Segment Prefix (PSP) would be, exactly 100h (256) bytes prior to
   716                                  ;	the start of our code. This will correspond to our assembled data address offsets. Note that we instructed
   717                                  ;	the assembler to produce addresses for our symbols that are offset from our code by 100h. See the "vstart"
   718                                  ;	parameter for the "section" directive above. We also set SS to the PSP and SP to the address of our i/o
   719                                  ;	buffer. This leaves 256 bytes of usable stack from 7b0:300 to 7b0:400.
   720                                  ;
   721                                  			sub	bx,16						;BX = 07b0
   722                                  			mov	ds,bx						;DS = 07b0 = psp
   723                                  			mov	es,bx						;ES = 07b0 = psp
   724                                  			mov	ss,bx						;SS = 07b0 = psp (ints disabled)
   725                                  			mov	sp,EBOOTSTACKTOP				;SP = 0100       (ints enabled)
   726                                  ;
   727                                  ;	Our boot addressability is now set up according to the following diagram.
   728                                  ;
   729                                  ;	DS,ES,SS ----->	007b00	+-----------------------------------------------+ DS:0000
   730                                  ;				|  Boot Stack & Boot PSP (Unused)		|
   731                                  ;				|  256 = 100h bytes				|
   732                                  ;	SS:SP -------->	007c00	+-----------------------------------------------+ DS:0100  07b0:0100
   733                                  ;				|  Boot Sector (vstart=0100h)			|
   734                                  ;				|  1 sector = 512 = 200h bytes			|
   735                                  ;			007e00	+-----------------------------------------------+ DS:0300
   736                                  ;				|  File Allocation Table (FAT) I/O Buffer	|
   737                                  ;				|  9x512-byte sectors = 4,608 = 1200h bytes	|
   738                                  ;			009000	+-----------------------------------------------+ DS:1500  08f0:0100
   739                                  ;				|  Directory Sector Buffer & Kernel Load Area	|
   740                                  ;			009200	+-----------------------------------------------+ DS:1700
   741                                  ;
   742                                  ;	On entry, DL indicates the drive being booted from.
   743                                  ;
   744                                  			mov	[wbDrive],dl					;[drive] = drive being booted from
   745                                  ;
   746                                  ;	Compute directory i/o buffer address.
   747                                  ;
   748                                  			mov	ax,[cwFatSectors]				;AX = 0009 = FAT sectors
   749                                  			mul	word [cwSectorBytes]				;DX:AX = 0000:1200 = FAT bytes
   750                                  			add	ax,EBOOTFATBASE					;AX = 1500 = end of FAT buffer
   751                                  			mov	[wwDirBuffer],ax				;[dirbuffer] = 1500
   752                                  ;
   753                                  ;	Compute segment where os.com will be loaded.
   754                                  ;
   755                                  			shr	ax,cl						;AX = 0150
   756                                  			add	ax,bx						;AX = 0150 + 07b0 = 0900
   757                                  			sub	ax,16						;AX = 08f0
   758                                  			mov	[wwLoadSegment],ax				;[loadsegment] = 08f0
   759                                  ;
   760                                  ;	Set the video mode to 80 column, 25 row, text.
   761                                  ;
   762                                  			mov	ax,EBIOSFNSETVMODE<<8|EBIOSMODETEXT80		;set mode function, 80x25 text mode
   763                                  			int	EBIOSINTVIDEO					;call BIOS display interrupt
   764                                  ;
   765                                  ;	Write a message to the console so we know we have our addressability established.
   766                                  ;
   767                                  			mov	si,czLoadMsg					;loading message
   768                                  			call	BootPrint					;display loader message
   769                                  ;
   770                                  ;	Initialize the number of directory sectors to search.
   771                                  ;
   772                                  			mov	ax,[cwDirEntries]				;AX = 224 = max dir entries
   773                                  			mov	[wwEntriesLeft],ax				;[entriesleft] = 224
   774                                  ;
   775                                  ;	Compute number of directory sectors and initialize overhead count.
   776                                  ;
   777                                  			mov	cx,ax						;CX = 00e0 = 224 entries
   778                                  			mul	word [cwEntryLen]				;DX:AX = 224 * 32 = 7168
   779                                  			div	word [cwSectorBytes]				;AX = 7168 / 512 = 14 = dir sectors
   780                                  			mov	[wwOverhead],ax					;[overhead] = 000e
   781                                  ;
   782                                  ;	Compute directory entries per sector.
   783                                  ;
   784                                  			xchg	ax,cx						;DX:AX = 0:00e0, DX = 0000e
   785                                  			div	cx						;AX = 0010 = entries per dir sector
   786                                  			mov	[wwSectorEntries],ax				;[sectorentries] = 0010
   787                                  ;
   788                                  ;	Compute first logical directory sector and update overhead count.
   789                                  ;
   790                                  			mov	ax,[cwFatSectors]				;AX = 0009 = FAT sectors per copy
   791                                  			mul	byte [cbFatCount]				;AX = 0012 = FAT sectors
   792                                  			add	ax,[cwReservedSectors]				;AX = 0013 = FAT plus reserved
   793                                  			add	ax,[cwSpecialSectors]				;AX = 0013 = FAT + reserved + special
   794                                  			mov	[wwLogicalSector],ax				;[logicalsector] = 0013
   795                                  			add	[wwOverhead],ax					;[overhead] = 0021 = res+spec+FAT+dir
   796                                  ;
   797                                  ;	Read directory sector.
   798                                  ;
   799                                  .30			mov	al,1						;sector count
   800                                  			mov	[wbReadCount],al				;[readcount] = 01
   801                                  			mov	bx,[wwDirBuffer]				;BX = 1500
   802                                  			call	ReadSector					;read sector into es:bx
   803                                  ;
   804                                  ;	Setup variables to search this directory sector.
   805                                  ;
   806                                  			mov	ax,[wwEntriesLeft]				;directory entries to search
   807                                  			cmp	ax,[wwSectorEntries]				;need to search more sectors?
   808                                  			jna	.40						;no, continue
   809                                  			mov	ax,[wwSectorEntries]				;yes, limit search to sector
   810                                  .40			sub	[wwEntriesLeft],ax				;update entries left to searh
   811                                  			mov	si,cbKernelProgram				;program name
   812                                  			mov	di,[wwDirBuffer]				;DI = 1500
   813                                  ;
   814                                  ;	Loop through directory sectors searching for kernel program.
   815                                  ;
   816                                  .50			push	si						;save kernel name address
   817                                  			push	di						;save dir i/o buffer address
   818                                  			mov	cx,11						;length of 8+3 name
   819                                  			cld							;forward strings
   820                                  			repe	cmpsb						;compare entry name
   821                                  			pop	di						;restore dir i/o buffer address
   822                                  			pop	si						;restore kernel name address
   823                                  			je	.60						;exit loop if found
   824                                  			add	di,[cwEntryLen]					;point to next dir entry
   825                                  			dec	ax						;decrement remaining entries
   826                                  			jnz	.50						;next entry
   827                                  ;
   828                                  ;	Repeat search if we are not at the end of the directory.
   829                                  ;
   830                                  			inc	word [wwLogicalSector]				;increment logical sector
   831                                  			cmp	word [wwEntriesLeft],0				;done with directory?
   832                                  			jne	.30						;no, get next sector
   833                                  			mov	si,czNoKernel					;missing kernel message
   834                                  			jmp	BootExit					;display message and exit
   835                                  ;
   836                                  ;	If we find the kernel program in the directory, read the FAT.
   837                                  ;
   838                                  .60			mov	ax,[cwReservedSectors]				;AX = 0001
   839                                  			mov	[wwLogicalSector],ax				;start past boot sector
   840                                  			mov	ax,[cwFatSectors]				;AX = 0009
   841                                  			mov	[wbReadCount],al				;[readcount] = 09
   842                                  			mov	bx,EBOOTFATBASE					;BX = 0300
   843                                  			call	ReadSector					;read FAT into buffer
   844                                  ;
   845                                  ;	Get the starting cluster of the kernel program and target address.
   846                                  ;
   847                                  			mov	ax,[di+26]					;AX = starting cluster of file
   848                                  			les	bx,[wwLoadOffset]				;ES:BX = kernel load add (08F0:0100)
   849                                  ;
   850                                  ;	Read each program cluster into RAM.
   851                                  ;
   852                                  .70			push	ax						;save cluster nbr
   853                                  			sub	ax,2						;AX = cluster nbr base 0
   854                                  			mov	cl,[cbClusterSectors]				;CL = sectors per cluster
   855                                  			mov	[wbReadCount],cl				;save sectors to read
   856                                  			xor	ch,ch						;CX = sectors per cluster
   857                                  			mul	cx						;DX:AX = logical cluster sector
   858                                  			add	ax,[wwOverhead]					;AX = kernel sector nbr
   859                                  			mov	[wwLogicalSector],ax				;save logical sector nbr
   860                                  			call	ReadSector					;read sectors into ES:BX
   861                                  ;
   862                                  ;	Update buffer pointer for next cluster.
   863                                  ;
   864                                  			mov	al,[cbClusterSectors]				;AL = sectors per cluster
   865                                  			xor	ah,ah						;AX = sectors per cluster
   866                                  			mul	word [cwSectorBytes]				;DX:AX = cluster bytes
   867                                  			add	bx,ax						;BX = next cluster target address
   868                                  			pop	ax						;AX = restore cluster nbr
   869                                  ;
   870                                  ;	Compute next cluster number.
   871                                  ;
   872                                  			mov	cx,ax						;CX = cluster nbr
   873                                  			mov	di,ax						;DI = cluster nbr
   874                                  			shr	ax,1						;AX = cluster/2
   875                                  			mov	dx,ax						;DX = cluster/2
   876                                  			add	ax,dx						;AX = 2*(cluster/2)
   877                                  			add	ax,dx						;AX = 3*(cluster/2)
   878                                  			and	di,1						;get low bit
   879                                  			add	di,ax						;add one if cluster is odd
   880                                  			add	di,EBOOTFATBASE					;add FAT buffer address
   881                                  			mov	ax,[di]						;get cluster bytes
   882                                  ;
   883                                  ;	Adjust cluster nbr by 4 bits if cluster is odd; test for end of chain.
   884                                  ;
   885                                  			test	cl,1						;is cluster odd?
   886                                  			jz	.80						;no, skip ahead
   887                                  			mov	cl,4						;shift count
   888                                  			shr	ax,cl						;shift nybble low
   889                                  .80			and	ax,0FFFh					;mask for 24 bits; next cluster nbr
   890                                  			cmp	ax,0FFFh					;end of chain?
   891                                  			jne	.70						;no, continue
   892                                  ;
   893                                  ;	Transfer control to the operating system program.
   894                                  ;
   895                                  			db	0EAh						;jmp seg:offset
   896                                  wwLoadOffset		dw	0100h						;kernel entry offset
   897                                  wwLoadSegment		dw	08F0h						;kernel entry segment (computed)
   898                                  ;
   899                                  ;	Read [readcount] disk sectors from [logicalsector] into ES:BX.
   900                                  ;
   901                                  ReadSector		mov	ax,[cwTrackSectors]				;AX = sectors per track
   902                                  			mul	word [cwDiskSides]				;DX:AX = sectors per cylinder
   903                                  			mov	cx,ax						;CX = sectors per cylinder
   904                                  			mov	ax,[wwLogicalSector]				;DX:AX = logical sector
   905                                  			div	cx						;AX = cylinder; DX = cyl sector
   906                                  			mov	[wbTrack],al					;[track] = cylinder
   907                                  			mov	ax,dx						;AX = cyl sector
   908                                  			div	byte [cbTrackSectors]				;AH = sector, AL = head
   909                                  			inc	ah						;AH = sector (1,2,3,...)
   910                                  			mov	[wbHead],ax					;[head]= head, [sector]= sector
   911                                  ;
   912                                  ;	Try maxtries times to read sector.
   913                                  ;
   914                                  			mov	cx,EBOOTMAXTRIES				;CX = 0005
   915                                  .10			push	bx						;save buffer address
   916                                  			push	cx						;save retry count
   917                                  			mov	dx,[wwDriveHead]				;DH = head, DL = drive
   918                                  			mov	cx,[wwSectorTrack]				;CH = track, CL = sector
   919                                  			mov	ax,[wwReadCountCommand]				;AH = fn., AL = sector count
   920                                  			int	EBIOSINTDISKETTE				;read sector
   921                                  			pop	cx						;restore retry count
   922                                  			pop	bx						;restore buffer address
   923                                  			jnc	BootReturn					;skip ahead if done
   924                                  			loop	.10						;retry
   925                                  ;
   926                                  ;	Handle disk error: convert to ASCII and store in error string.
   927                                  ;
   928                                  			mov	al,ah						;AL = bios error code
   929                                  			xor	ah,ah						;AX = bios error code
   930                                  			mov	dl,16						;divisor for base 16
   931                                  			div	dl						;AL = hi order, AH = lo order
   932                                  			or	ax,03030h					;apply ASCII zone bits
   933                                  			cmp	ah,03Ah						;range test ASCII numeral
   934                                  			jb	.20						;continue if numeral
   935                                  			add	ah,7						;adjust for ASCII 'A'-'F'
   936                                  .20			cmp	al,03Ah						;range test ASCII numeral
   937                                  			jb	.30						;continue if numeral
   938                                  			add	ah,7						;adjust for ASCII 'A'-'F'
   939                                  .30			mov	[wzErrorCode],ax				;store ASCII error code
   940                                  			mov	si,czErrorMsg					;error message address
   941                                  BootExit		call	BootPrint					;display messge to console
   942                                  .10			mov	ah,EBIOSFNKEYSTATUS				;bios keyboard status function
   943                                  			int	EBIOSINTKEYBOARD				;get keyboard status
   944                                  			jnz	.20						;continue if key pressed
   945                                  			sti							;enable maskable interrupts
   946                                  			hlt							;wait for interrupt
   947                                  			jmp	.10						;repeat
   948                                  .20			mov	al,EKEYBCMDRESET				;8042 pulse output port pin
   949                                  			out	EKEYBPORTSTAT,al				;drive B0 low to restart
   950                                  .30			sti							;enable maskable interrupts
   951                                  			hlt							;stop until reset, int, nmi
   952                                  			jmp	.30						;loop until restart kicks in
   953                                  ;
   954                                  ;	Display text message.
   955                                  ;
   956                                  BootPrint		cld							;forward strings
   957                                  			lodsb							;load next byte at DS:SI in AL
   958                                  			test	al,al						;end of string?
   959                                  			jz	BootReturn					;... yes, exit our loop
   960                                  			mov	ah,EBIOSFNTTYOUTPUT				;BIOS teletype function
   961                                  			int	EBIOSINTVIDEO					;call BIOS display interrupt
   962                                  			jmp	BootPrint					;repeat until done
   963                                  BootReturn		ret							;return
   964                                  ;-----------------------------------------------------------------------------------------------------------------------
   965                                  ;
   966                                  ;	Constants
   967                                  ;
   968                                  ;-----------------------------------------------------------------------------------------------------------------------
   969                                  			align	2
   970                                  cwEntryLen		dw	32						;length of directory entry
   971                                  cbKernelProgram		db	"OS      COM"					;kernel program name
   972                                  czLoadMsg		db	"Loading OS",13,10,0				;loading message
   973                                  czErrorMsg		db	"Disk error "					;error message
   974                                  wzErrorCode		db	020h,020h,0					;error code and null terminator
   975                                  czNoKernel		db	"OS missing",0					;missing kernel message
   976                                  ;-----------------------------------------------------------------------------------------------------------------------
   977                                  ;
   978                                  ;	Work Areas
   979                                  ;
   980                                  ;-----------------------------------------------------------------------------------------------------------------------
   981                                  			align	2
   982                                  wwDirBuffer		dw	0						;directory i/o buffer address
   983                                  wwEntriesLeft		dw	0						;directory entries to search
   984                                  wwOverhead		dw	0						;overhead sectors
   985                                  wwSectorEntries		dw	0						;directory entries per sector
   986                                  wwLogicalSector		dw	0						;current logical sector
   987                                  wwReadCountCommand	equ	$						;read count and command
   988                                  wbReadCount		db	0						;sectors to read
   989                                  cbReadCommand		db	2						;BIOS read disk fn code
   990                                  wwDriveHead		equ	$						;drive, head (word)
   991                                  wbDrive			db	0						;drive
   992                                  wbHead			db	0						;head
   993                                  wwSectorTrack		equ	$						;sector, track (word)
   994                                  			db	0						;sector
   995                                  wbTrack			db	0						;track
   996                                  			times	510-($-$$) db 0h				;zero fill to end of sector
   997                                  			db	055h,0AAh					;end of sector signature
   998                                  %endif
   999                                  %ifdef BUILDPREP
  1000                                  ;=======================================================================================================================
  1001                                  ;
  1002                                  ;	Diskette Preparation Code
  1003                                  ;
  1004                                  ;	This routine writes the OS boot sector code to a formatted floppy diskette. The diskette parameter table,
  1005                                  ;	which is located in the first 30 bytes of the boot sector is first read from the diskette and overlayed onto
  1006                                  ;	the OS bootstrap code so that the diskette format parameters are preserved.
  1007                                  ;
  1008                                  ;=======================================================================================================================
  1009                                  ;
  1010                                  ;	Query the user to insert a flopppy diskette and press enter or cancel.
  1011                                  ;
  1012                                  Prep			mov	si,czPrepMsg10					;starting message address
  1013                                  			call	BootPrint					;display message
  1014                                  ;
  1015                                  ;	Exit if the Escape key is pressed or loop until Enter is pressed.
  1016                                  ;
  1017                                  .10			mov	ah,EBIOSFNKEYSTATUS				;BIOS keyboard status function
  1018                                  			int	EBIOSINTKEYBOARD				;get keyboard status
  1019                                  			jnz	.12						;continue if key pressed
  1020                                  			sti							;enable interrupts
  1021                                  			hlt							;wait for interrupt
  1022                                  			jmp	.10						;repeat
  1023                                  .12			cmp	al,EASCIIRETURN					;Enter key pressed?
  1024                                  			je	.15						;yes, branch
  1025                                  			cmp	al,EASCIIESCAPE					;Escape key pressed?
  1026                                  			jne	.10						;no, repeat
  1027                                  			jmp	.90						;yes, exit program
  1028                                  ;
  1029                                  ;	Display writing-sector message and patch the JMP instruction.
  1030                                  ;
  1031                                  .15			mov	si,czPrepMsg12					;writing-sector message address
  1032                                  			call	BootPrint					;display message
  1033                                  			mov	bx,Boot+1					;address of JMP instruction operand
  1034                                  			mov	ax,01Bh						;address past disk parameter table
  1035                                  			mov	[bx],ax						;update the JMP instruction
  1036                                  ;
  1037                                  ;	Try to read the boot sector.
  1038                                  ;
  1039                                  			mov	cx,EBOOTMAXTRIES				;try up to five times
  1040                                  .20			push	cx						;save remaining tries
  1041                                  			mov	bx,wcPrepInBuf					;input buffer address
  1042                                  			mov	dx,0						;head zero, drive zero
  1043                                  			mov	cx,1						;track zero, sector one
  1044                                  			mov	ax,0201h					;read one sector
  1045                                  			int	EBIOSINTDISKETTE				;attempt the read
  1046                                  			pop	cx						;restore remaining retries
  1047                                  			jnc	.30						;skip ahead if successful
  1048                                  			loop	.20						;try again
  1049                                  			mov	si,czPrepMsg20					;read-error message address
  1050                                  			jmp	.50						;branch to error routine
  1051                                  ;
  1052                                  ;	Copy diskette parms from input buffer to output buffer.
  1053                                  ;
  1054                                  .30			mov	si,wcPrepInBuf					;input buffer address
  1055                                  			add	si,11						;skip over JMP and system ID
  1056                                  			mov	di,Boot						;output buffer address
  1057                                  			add	di,11						;skip over JMP and system ID
  1058                                  			mov	cx,19						;length of diskette parameters
  1059                                  			cld							;forward string copies
  1060                                  			rep	movsb						;copy diskette parameters
  1061                                  ;
  1062                                  ;	Try to write boot sector to diskette.
  1063                                  ;
  1064                                  			mov	cx,EBOOTMAXTRIES				;try up to five times
  1065                                  .40			push	cx						;save remaining tries
  1066                                  			mov	bx,Boot						;output buffer address
  1067                                  			mov	dx,0						;head zero, drive zero
  1068                                  			mov	cx,1						;track zero, sector one
  1069                                  			mov	ax,0301h					;write one sector
  1070                                  			int	EBIOSINTDISKETTE				;attempt the write
  1071                                  			pop	cx						;restore remaining retries
  1072                                  			jnc	.80						;skip ahead if successful
  1073                                  			loop	.40						;try again
  1074                                  			mov	si,czPrepMsg30					;write-error message address
  1075                                  ;
  1076                                  ;	Convert the error code to ASCII and display the error message.
  1077                                  ;
  1078                                  .50			push	ax						;save error code
  1079                                  			mov	al,ah						;copy error code
  1080                                  			mov	ah,0						;AX = error code
  1081                                  			mov	dl,10h						;hexadecimal divisor
  1082                                  			idiv	dl						;AL = hi-order, AH = lo-order
  1083                                  			or	ax,03030h					;add ASCII zone digits
  1084                                  			cmp	ah,03Ah						;AH ASCII numeral?
  1085                                  			jb	.60						;yes, continue
  1086                                  			add	ah,7						;no, make ASCII 'A'-'F'
  1087                                  .60			cmp	al,03Ah						;al ASCII numeral?
  1088                                  			jb	.70						;yes, continue
  1089                                  			add	al,7						;no, make ASCII
  1090                                  .70			mov	[si+17],ax					;put ASCII error code in message
  1091                                  			call	BootPrint					;write error message
  1092                                  			pop	ax						;restore error code
  1093                                  ;
  1094                                  ;	Display the completion message.
  1095                                  ;
  1096                                  .80			mov	si,czPrepMsgOK					;assume successful completion
  1097                                  			mov	al,ah						;BIOS return code
  1098                                  			cmp	al,0						;success?
  1099                                  			je	.85						;yes, continue
  1100                                  			mov	si,czPrepMsgErr1				;disk parameter error message
  1101                                  			cmp	al,1						;disk parameter error?
  1102                                  			je	.85						;yes, continue
  1103                                  			mov	si,czPrepMsgErr2				;address mark not found message
  1104                                  			cmp	al,2						;address mark not found?
  1105                                  			je	.85						;yes, continue
  1106                                  			mov	si,czPrepMsgErr3				;protected disk message
  1107                                  			cmp	al,3						;protected disk?
  1108                                  			je	.85						;yes, continue
  1109                                  			mov	si,czPrepMsgErr6				;diskette removed message
  1110                                  			cmp	al,6						;diskette removed?
  1111                                  			je	.85						;yes, continue
  1112                                  			mov	si,czPrepMsgErr80				;drive timed out message
  1113                                  			cmp	al,80H						;drive timed out?
  1114                                  			je	.85						;yes, continue
  1115                                  			mov	si,czPrepMsgErrXX				;unknown error message
  1116                                  .85			call	BootPrint					;display result message
  1117                                  .90			mov	ax,04C00H					;terminate with zero result code
  1118                                  			int	021h						;terminate DOS program
  1119                                  			ret							;return (should not execute)
  1120                                  ;-----------------------------------------------------------------------------------------------------------------------
  1121                                  ;
  1122                                  ;	Diskette Preparation Messages
  1123                                  ;
  1124                                  ;-----------------------------------------------------------------------------------------------------------------------
  1125                                  czPrepMsg10		db	13,10,"CustomOS Boot-Diskette Preparation Program"
  1126                                  			db	13,10,"Copyright (C) 2010-2017 David J. Walling. All rights reserved."
  1127                                  			db	13,10
  1128                                  			db	13,10,"This program overwrites the boot sector of a diskette with startup code that"
  1129                                  			db	13,10,"will load the operating system into memory when the computer is restarted."
  1130                                  			db	13,10,"To proceed, place a formatted diskette into drive A: and press the Enter key."
  1131                                  			db	13,10,"To exit this program without preparing a diskette, press the Escape key."
  1132                                  			db	13,10,0
  1133                                  czPrepMsg12		db	13,10,"Writing the boot sector to the diskette ..."
  1134                                  			db	13,10,0
  1135                                  czPrepMsg20		db	13,10,"The error-code .. was returned from the BIOS while reading from the disk."
  1136                                  			db	13,10,0
  1137                                  czPrepMsg30		db	13,10,"The error-code .. was returned from the BIOS while writing to the disk."
  1138                                  			db	13,10,0
  1139                                  czPrepMsgOK		db	13,10,"The boot-sector was written to the diskette. Before booting your computer with"
  1140                                  			db	13,10,"this diskette, make sure that the file OS.COM is copied onto the diskette."
  1141                                  			db	13,10,0
  1142                                  czPrepMsgErr1		db	13,10,"(01) Invalid Disk Parameter"
  1143                                  			db	13,10,"This is an internal error caused by an invalid value being passed to a system"
  1144                                  			db	13,10,"function. The OSBOOT.COM file may be corrupt. Copy or download the file again"
  1145                                  			db	13,10,"and retry."
  1146                                  			db	13,10,0
  1147                                  czPrepMsgErr2		db	13,10,"(02) Address Mark Not Found"
  1148                                  			db	13,10,"This error indicates a physical problem with the floppy diskette. Please retry"
  1149                                  			db	13,10,"using another diskette."
  1150                                  			db	13,10,0
  1151                                  czPrepMsgErr3		db	13,10,"(03) Protected Disk"
  1152                                  			db	13,10,"This error is usually caused by attempting to write to a write-protected disk."
  1153                                  			db	13,10,"Check the 'write-protect' setting on the disk or retry using using another disk."
  1154                                  			db	13,10,0
  1155                                  czPrepMsgErr6		db	13,10,"(06) Diskette Removed"
  1156                                  			db	13,10,"This error may indicate that the floppy diskette has been removed from the"
  1157                                  			db	13,10,"diskette drive. On some systems, this code may also occur if the diskette is"
  1158                                  			db	13,10,"'write protected.' Please verify that the diskette is not write-protected and"
  1159                                  			db	13,10,"is properly inserted in the diskette drive."
  1160                                  			db	13,10,0
  1161                                  czPrepMsgErr80		db	13,10,"(80) Drive Timed Out"
  1162                                  			db	13,10,"This error usually indicates that no diskette is in the diskette drive. Please"
  1163                                  			db	13,10,"make sure that the diskette is properly seated in the drive and retry."
  1164                                  			db	13,10,0
  1165                                  czPrepMsgErrXX		db	13,10,"(??) Unknown Error"
  1166                                  			db	13,10,"The error-code returned by the BIOS is not a recognized error. Please consult"
  1167                                  			db	13,10,"your computer's technical reference for a description of this error code."
  1168                                  			db	13,10,0
  1169                                  wcPrepInBuf		equ	$
  1170                                  %endif
  1171                                  %ifdef BUILDDISK
  1172                                  ;=======================================================================================================================
  1173                                  ;
  1174                                  ;	File Allocation Tables
  1175                                  ;
  1176                                  ;	The disk contains two copies of the File Allocation Table (FAT). On our disk, each FAT copy is 1200h bytes in
  1177                                  ;	length. Each FAT entry contains the logical number of the next cluster. The first two entries are reserved. Our
  1178                                  ;	OS.COM file will be 7200h bytes in length. The first 200h bytes is the 16-bit loader code. The remaining 7000h
  1179                                  ;	bytes is the 32-bit kernel code. Our disk parameter table defines a cluster as containing one sector and each
  1180                                  ;	sector having 200h bytes. Therefore, our FAT table must reserve 57 clusters for OS.COM. The clusters used by
  1181                                  ;	OS.COM, then, will be cluster 2 through 59. The entry for cluster 59 is set to "0FFFh" to indicate that it is
  1182                                  ;	the last cluster in the chain.
  1183                                  ;
  1184                                  ;	Every three bytes encode two FAT entries as follows:
  1185                                  ;
  1186                                  ;	db	0abh,0cdh,0efh	;even cluster: 0dabh, odd cluster: 0efch
  1187                                  ;
  1188                                  ;=======================================================================================================================
  1189                                  ;-----------------------------------------------------------------------------------------------------------------------
  1190                                  ;
  1191                                  ;	FAT copy 1								@disk: 000200	@mem: n/a
  1192                                  ;
  1193                                  ;-----------------------------------------------------------------------------------------------------------------------
  1194                                  section			fat1							;first copy of FAT
  1195                                  			db	0F0h,0FFh,0FFh,	003h,040h,000h			;clusters 0-3		ff0 fff 003 004
  1196                                  			db	005h,060h,000h,	007h,080h,000h			;custters 4-7   	005 006 007 008
  1197                                  			db	009h,0A0h,000h,	00Bh,0C0h,000h			;clusters 8-11  	009 00a 00b 00c
  1198                                  			db	00Dh,0E0h,000h,	00Fh,000h,001h			;clusters 12-15 	00d 00e 00f 010
  1199                                  			db	011h,020h,001h,	013h,040h,001h			;clusters 16-19 	011 012 013 014
  1200                                  			db	015h,060h,001h,	017h,080h,001h			;clusters 20-23		015 016 017 018
  1201                                  			db	019h,0A0h,001h,	01Bh,0C0h,001h			;clusters 24-27		019 01a 01b 01c
  1202                                  			db	01Dh,0E0h,001h,	01Fh,000h,002h			;clusters 28-31		01d 01e 01f 020
  1203                                  			db	021h,020h,002h,	023h,040h,002h			;clusters 32-35		021 022 023 024
  1204                                  			db	025h,060h,002h,	027h,080h,002h			;clusters 36-39		025 026 027 028
  1205                                  			db	029h,0A0h,002h,	02Bh,0C0h,002h			;clusters 40-43		029 02A 02B 02C
  1206                                  			db	02Dh,0E0h,002h, 02Fh,000h,003h			;clusters 44-47		02D 02E 02F 030
  1207                                  			db	031h,020h,003h, 033h,040h,003h			;clusters 48-51		031 032 033 034
  1208                                  			db	035h,060h,003h, 037h,080h,003h			;clusters 52-55		035 036 037 038
  1209                                  			db	039h,0A0h,003h, 0FFh,00Fh,000h			;clusters 56-59		039 03A FFF 000
  1210                                  			times	(9*512)-($-$$) db 0				;zero fill to end of section
  1211                                  ;-----------------------------------------------------------------------------------------------------------------------
  1212                                  ;
  1213                                  ;	FAT copy 2								@disk: 001400	@mem: n/a
  1214                                  ;
  1215                                  ;-----------------------------------------------------------------------------------------------------------------------
  1216                                  section			fat2							;second copy of FAT
  1217                                  			db	0F0h,0FFh,0FFh,	003h,040h,000h			;clusters 0-3		ff0 fff 003 004
  1218                                  			db	005h,060h,000h,	007h,080h,000h			;custters 4-7   	005 006 007 008
  1219                                  			db	009h,0A0h,000h,	00Bh,0C0h,000h			;clusters 8-11  	009 00a 00b 00c
  1220                                  			db	00Dh,0E0h,000h,	00Fh,000h,001h			;clusters 12-15 	00d 00e 00f 010
  1221                                  			db	011h,020h,001h,	013h,040h,001h			;clusters 16-19 	011 012 013 014
  1222                                  			db	015h,060h,001h,	017h,080h,001h			;clusters 20-23		015 016 017 018
  1223                                  			db	019h,0A0h,001h,	01Bh,0C0h,001h			;clusters 24-27		019 01a 01b 01c
  1224                                  			db	01Dh,0E0h,001h,	01Fh,000h,002h			;clusters 28-31		01d 01e 01f 020
  1225                                  			db	021h,020h,002h,	023h,040h,002h			;clusters 32-35		021 022 023 024
  1226                                  			db	025h,060h,002h,	027h,080h,002h			;clusters 36-39		025 026 027 028
  1227                                  			db	029h,0A0h,002h,	02Bh,0C0h,002h			;clusters 40-43		029 02A 02B 02C
  1228                                  			db	02Dh,0E0h,002h, 02Fh,000h,003h			;clusters 44-47		02D 02E 02F 030
  1229                                  			db	031h,020h,003h, 033h,040h,003h			;clusters 48-51		031 032 033 034
  1230                                  			db	035h,060h,003h, 037h,080h,003h			;clusters 52-55		035 036 037 038
  1231                                  			db	039h,0A0h,003h, 0FFh,00Fh,000h			;clusters 56-59		039 03A FFF 000
  1232                                  			times	(9*512)-($-$$) db 0				;zero fill to end of section
  1233                                  ;-----------------------------------------------------------------------------------------------------------------------
  1234                                  ;
  1235                                  ;	Diskette Directory							@disk: 002600	@mem: n/a
  1236                                  ;
  1237                                  ;	The disk contains one copy of the diskette directory. Each directory entry is 32 bytes long. Our directory
  1238                                  ;	contains only one entry. Unused entries are set to all nulls. The directory immediately follows the second FAT
  1239                                  ;	copy.
  1240                                  ;
  1241                                  ;-----------------------------------------------------------------------------------------------------------------------
  1242                                  section			dir							;diskette directory
  1243                                  			db	"OS      COM"					;file name (must contain spaces)
  1244                                  			db	020h						;attribute (archive bit set)
  1245                                  			times	10 db 0						;unused
  1246                                  			dw	0h						;time
  1247                                  			db	01000001b					;mmm = 10 MOD 8 = 2; ddddd = 1
  1248                                  			db	01001001b					;yyyyyyy = 2016-1980 = 36 = 24h; m/8 = 1
  1249                                  			dw	2						;first cluster
  1250                                  			dd	07200h						;file size
  1251                                  			times	(224*32)-($-$$) db 0h				;zero fill to end of section
  1252                                  %endif
  1253                                  %ifdef BUILDCOM
  1254                                  ;=======================================================================================================================
  1255                                  ;
  1256                                  ;	OS.COM
  1257                                  ;
  1258                                  ;	The operating system file is assembled at the start of the data area of the floppy disk image, which
  1259                                  ;	immediately follows the directory. This corresponds to logical cluster 2, even though the physical address of
  1260                                  ;	this sector on the disk varies depending on the disk type. The os.com file consists of two parts, the OS loader
  1261                                  ;	and the OS kernel. The Loader is 16-bit code that receives control directly from the boot sector code after the
  1262                                  ;	OS.COM file is loaded into memory. The kernel is 32-bit code that receives control after the Loader has
  1263                                  ;	initialized protected-mode tables and 32-bit interrupt handlers and switched the CPU into protected mode.
  1264                                  ;
  1265                                  ;	Our loader addressability is set up according to the following diagram.
  1266                                  ;
  1267                                  ;	SS -----------> 007b00	+-----------------------------------------------+ SS:0000
  1268                                  ;				|  Boot Stack & Boot PSP (Unused)		|
  1269                                  ;				|  256 = 100h bytes				|
  1270                                  ;	SS:SP -------->	007c00	+-----------------------------------------------+ SS:0100  07b0:0100
  1271                                  ;				|  Boot Sector (vstart=0100h)			|
  1272                                  ;				|  1 sector = 512 = 200h bytes			|
  1273                                  ;			007e00	+-----------------------------------------------+
  1274                                  ;				|  File Allocation Table (FAT) I/O Buffer	|
  1275                                  ;				|  9 x 512-byte sectors = 4,608 = 1200h bytes	|
  1276                                  ;				|						|
  1277                                  ;	CS,DS,ES ----->	008f00	|  Loader PSP (Unused)				| DS:0000
  1278                                  ;				|						|
  1279                                  ;	CS:IP -------->	009000	+-----------------------------------------------+ DS:0100  08f0:0100
  1280                                  ;				|  Loader Code					|
  1281                                  ;				|  1 sector = 512 = 200h bytes			|
  1282                                  ;			009200	+-----------------------------------------------+ DS:0300
  1283                                  ;
  1284                                  ;=======================================================================================================================
  1285                                  ;-----------------------------------------------------------------------------------------------------------------------
  1286                                  ;
  1287                                  ;	OS Loader								@disk: 004200	@mem: 009000
  1288                                  ;
  1289                                  ;	This code is the operating system loader. It resides on the boot disk at the start of the data area, following
  1290                                  ;	the directory. The loader occupies several clusters that are mapped in the file allocation tables above.
  1291                                  ;	The loader executes 16-bit instructions in real mode. It performs several initialization functions such as
  1292                                  ;	determining whether the CPU and other resources are sufficient to run the operating system. If all minimum
  1293                                  ;	resources are present, the loader initializes protected mode tables, places the CPU into protected mode and
  1294                                  ;	starts the console task. Since the loader was called either from the bootstrap or as a .com file on the boot
  1295                                  ;	disk, we can assume that the initial ip is 0x100 and not perform any absolute address fix-ups on our segment
  1296                                  ;	registers.
  1297                                  ;
  1298                                  ;-----------------------------------------------------------------------------------------------------------------------
  1299                                  			cpu	8086						;assume minimal CPU
  1300                                  section			loader	vstart=0100h					;use .COM compatible addressing
  1301                                  			bits	16						;this is 16-bit code
  1302 00000000 0E                      Loader			push	cs						;use the code segment
  1303 00000001 1F                      			pop	ds						;...as our data segment
  1304 00000002 0E                      			push	cs						;use the code segment
  1305 00000003 07                      			pop	es						;...as our extra segment
  1306                                  ;
  1307                                  ;	Write a message to the console so we know we have our addressability established.
  1308                                  ;
  1309 00000004 BE[7D01]                			mov	si,czStartingMsg				;starting message
  1310 00000007 E8C900                  			call	PutTTYString					;display loader message
  1311                                  ;
  1312                                  ;	Determine the CPU type, generally. Exit if the CPU is not at least an 80386.
  1313                                  ;
  1314 0000000A E8A600                  			call	GetCPUType					;AL = cpu type
  1315 0000000D BE[EA00]                			mov	si,czCPUErrorMsg				;loader error message
  1316 00000010 3C03                    			cmp	al,3						;80386+?
  1317 00000012 7303E98700              			jb	LoaderExit					;no, exit with error message
  1318                                  			cpu	386						;allow 80386 instructions
  1319 00000017 BE[5501]                			mov	si,czCPUOKMsg					;cpu ok message
  1320 0000001A E8B600                  			call	PutTTYString					;display message
  1321                                  ;
  1322                                  ;	Initialize kernel data areas. The task queue is initialized here because as soon as we enter protected mode,
  1323                                  ;	the timer interrupt code will begin inspecting the task queue to determine if a task switch must be made. To
  1324                                  ;	start with, we set every 16th queue element to reference the background task selector. This will ensure that
  1325                                  ;	the background task, which updates the visible clock on the console, will be called at least once per second.
  1326                                  ;
  1327 0000001D 6A00                    			push	EKRNDATASEG					;load kernel data segment address ...
  1328 0000001F 07                      			pop	es						;... into extra segment reg
  1329 00000020 BF0008                  			mov	di,wwTaskQueue					;task queue address
  1330 00000023 B94000                  			mov	cx,64						;outer loop
  1331 00000026 51                      .10			push	cx						;save remaining outer iterations
  1332 00000027 B90300                  			mov	cx,3						;inner loop
  1333 0000002A B86800                  			mov	ax,ESELCONSOLETSS				;console task state segment selector
  1334 0000002D FC                      			cld							;forward strings
  1335 0000002E F3AB                    			rep	stosw						;store selectors in task queue
  1336 00000030 B87800                  			mov	ax,ESELBACKGROUNDTSS				;background task state segment selector
  1337 00000033 AB                      			stosw							;store selector in task queue
  1338 00000034 59                      			pop	cx						;restore remaining outer iterations
  1339 00000035 E2EF                    			loop	.10						;next
  1340 00000037 31C0                    			xor	ax,ax						;zero register
  1341 00000039 B104                    			mov	cl,4						;remaining words to reset
  1342 0000003B F3AB                    			rep	stosw						;reset remaining kernel data
  1343                                  ;
  1344                                  ;	Fixup the GDT descriptor for the current (loader) code segment.
  1345                                  ;
  1346 0000003D BE0003                  			mov	si,0300h					;GDT offset
  1347 00000040 8CC8                    			mov	ax,cs						;AX:SI = gdt source
  1348 00000042 C1C004                  			rol	ax,4						;AX = phys addr bits 11-0,15-12
  1349 00000045 88C1                    			mov	cl,al						;CL = phys addr bits 3-0,15-12
  1350 00000047 24F0                    			and	al,0F0h						;AL = phys addr bits 11-0
  1351 00000049 80E10F                  			and	cl,00Fh						;CL = phys addr bits 15-12
  1352 0000004C 894432                  			mov	word [si+030h+2],ax				;lo-order loader code (0-15)
  1353 0000004F 884C34                  			mov	byte [si+030h+4],cl				;lo-order loader code (16-23)
  1354 00000052 BE[5E01]                			mov	si,czGDTOKMsg					;GDT prepared message
  1355 00000055 E87B00                  			call	PutTTYString					;display message
  1356                                  ;
  1357                                  ;	Move the 32-bit kernel to its appropriate memory location.
  1358                                  ;
  1359 00000058 680001                  			push	EKRNCODESEG					;use kernel code segment ...
  1360 0000005B 07                      			pop	es						;... as target segment
  1361 0000005C 31FF                    			xor	di,di						;ES:DI = target address
  1362 0000005E BE0003                  			mov	si,0300h					;DS:SI = source address
  1363 00000061 B90070                  			mov	cx,07000h					;CX = kernel size
  1364 00000064 FC                      			cld							;forward strings
  1365 00000065 F3A4                    			rep	movsb						;copy kernel image
  1366 00000067 BE[6D01]                			mov	si,czKernelLoadedMsg				;kernel moved message
  1367 0000006A E86600                  			call	PutTTYString					;display message
  1368                                  ;
  1369                                  ;	Switch to protected mode.
  1370                                  ;
  1371 0000006D 31F6                    			xor	si,si						;ES:SI = gdt addr
  1372 0000006F 8ED6                    			mov	ss,si						;protected mode ss
  1373 00000071 BC0010                  			mov	sp,EKRNCODEADR					;initial stack immediate before code
  1374 00000074 B489                    			mov	ah,EBIOSFNINITPROTMODE				;initialize protected mode fn.
  1375 00000076 BB2820                  			mov	bx,02028h					;BH,BL = IRQ int bases
  1376 00000079 BA1F00                  			mov	dx,001Fh					;outer delay loop count
  1377 0000007C B9FFFF                  .20			mov	cx,0FFFFh					;inner delay loop count
  1378 0000007F E2FE                    			loop	$						;wait out pending interrupts
  1379 00000081 4A                      			dec	dx						;restore outer loop count
  1380 00000082 75F8                    			jnz	.20						;continue outer loop
  1381 00000084 CD15                    			int	EBIOSINTMISC					;call BIOS to set protected mode
  1382                                  ;
  1383                                  ;	Enable hardware and maskable interrupts
  1384                                  ;
  1385 00000086 30C0                    			xor	al,al						;enable all registers code
  1386 00000088 E621                    			out	EPICPORTPRI1,al					;enable all primary 8259A ints
  1387 0000008A E6A1                    			out	EPICPORTSEC1,al					;enable all secondary 8259A ints
  1388 0000008C FB                      			sti							;enable maskable interrupts
  1389                                  ;
  1390                                  ;	Load the Task State Segment (TSS) and Local Descriptor Table (LDT) registers and jump to the initial task.
  1391                                  ;
  1392 0000008D 2E0F001E[E200]          			ltr	[cs:cwLoaderTSS]				;load task register
  1393 00000093 2E0F0016[E000]          			lldt	[cs:cwLoaderLDT]				;load local descriptor table register
  1394 00000099 EA00006800              			jmp	ESELCONSOLETSS:0				;jump to task state segment selector
  1395                                  ;-----------------------------------------------------------------------------------------------------------------------
  1396                                  ;
  1397                                  ;	Routine:	LoaderExit
  1398                                  ;
  1399                                  ;	Description:	This routine displays the message at DS:SI, waits for a keypress and resets the system.
  1400                                  ;
  1401                                  ;	In:		DS:SI	string address
  1402                                  ;
  1403                                  ;-----------------------------------------------------------------------------------------------------------------------
  1404 0000009E E83200                  LoaderExit		call	PutTTYString					;display error message
  1405                                  ;
  1406                                  ;	Now we want to wait for a keypress. We can use a keyboard interrupt function for this (INT 16h, AH=0).
  1407                                  ;	However, some hypervisor BIOS implementations have been seen to implement the "wait" as simply a fast
  1408                                  ;	iteration of the keyboard status function call (INT 16h, AH=1), causing a CPU race condition. So, instead
  1409                                  ;	we will use the keyboard status call and iterate over a halt (HLT) instruction until a key is pressed.
  1410                                  ;	By convention, we enable maskable interrupts with STI before issuing HLT, so as not to catch fire.
  1411                                  ;
  1412 000000A1 B401                    .30			mov	ah,EBIOSFNKEYSTATUS				;keyboard status function
  1413 000000A3 CD16                    			int	EBIOSINTKEYBOARD				;call BIOS keyboard interrupt
  1414 000000A5 7504                    			jnz	.40						;exit if key pressed
  1415 000000A7 FB                      			sti							;enable maskable interrupts
  1416 000000A8 F4                      			hlt							;wait for interrupt
  1417 000000A9 EBF6                    			jmp	.30						;repeat until keypress
  1418                                  ;
  1419                                  ;	Now that a key has been pressed, we signal the system to restart by driving the B0 line on the 8042
  1420                                  ;	keyboard controller low (OUT 64h,0feh). The restart may take some microseconds to kick in, so we issue
  1421                                  ;	HLT until the system resets.
  1422                                  ;
  1423 000000AB B0FE                    .40			mov	al,EKEYBCMDRESET				;8042 pulse output port pin
  1424 000000AD E664                    			out	EKEYBPORTSTAT,al				;drive B0 low to restart
  1425 000000AF FB                      .50			sti							;enable maskable interrupts
  1426 000000B0 F4                      			hlt							;stop until reset, int, nmi
  1427 000000B1 EBFC                    			jmp	.50						;loop until restart kicks in
  1428                                  ;-----------------------------------------------------------------------------------------------------------------------
  1429                                  ;
  1430                                  ;	Routine:	GetCPUType
  1431                                  ;
  1432                                  ;	Description:	The loader needs only to determine that the cpu is at least an 80386 or an equivalent. Note that
  1433                                  ;			the CPUID instruction was not introduced until the SL-enhanced 80486 and Pentium processors, so
  1434                                  ;			to distinguish whether we have at least an 80386, other means must be used.
  1435                                  ;
  1436                                  ;	Out:		AX	0 = 808x, v20, etc.
  1437                                  ;				1 = 80186
  1438                                  ;				2 = 80286
  1439                                  ;				3 = 80386
  1440                                  ;
  1441                                  ;-----------------------------------------------------------------------------------------------------------------------
  1442 000000B3 B001                    GetCPUType		mov	al,1						;AL = 1
  1443 000000B5 B120                    			mov	cl,32						;shift count
  1444 000000B7 D2E8                    			shr	al,cl						;try a 32-bit shift
  1445 000000B9 08C0                    			or	al,al						;did the shift happen?
  1446 000000BB 7415                    			jz	.10						;yes, cpu is 808x, v20, etc.
  1447                                  			cpu	186
  1448 000000BD 54                      			push	sp						;save stack pointer
  1449 000000BE 59                      			pop	cx						;...into cx
  1450 000000BF 39E1                    			cmp	cx,sp						;did sp decrement before push?
  1451 000000C1 750F                    			jne	.10						;yes, cpu is 80186
  1452                                  			cpu	286
  1453 000000C3 40                      			inc	ax						;AX = 2
  1454 000000C4 0F0106[E400]            			sgdt	[cbLoaderGDT]					;store gdt reg in work area
  1455 000000C9 8A0E[E900]              			mov	cl,[cbLoaderGDTHiByte]				;CL = hi-order byte
  1456 000000CD FEC1                    			inc	cl						;was hi-byte of GDTR 0xff?
  1457 000000CF 7401                    			jz	.10						;yes, cpu is 80286
  1458 000000D1 40                      			inc	ax						;AX = 3
  1459 000000D2 C3                      .10			ret							;return
  1460                                  ;-----------------------------------------------------------------------------------------------------------------------
  1461                                  ;
  1462                                  ;	Routine:	PutTTYString
  1463                                  ;
  1464                                  ;	Description:	This routine sends a NUL-terminated string of characters to the TTY output device. We use the
  1465                                  ;			TTY output function of the BIOS video interrupt, passing the address of the string in DS:SI
  1466                                  ;			and the BIOS teletype function code in AH. After a return from the BIOS interrupt, we repeat
  1467                                  ;			for the next string character until a NUL is found. Note that we clear the direction flag (DF)
  1468                                  ;			with CLD before each LODSB. This is just in case the direction flag is ever returned as set
  1469                                  ;			by the video interrupt. This is a precaution since a well-written BIOS should preserve all
  1470                                  ;			registers and flags unless used to indicate return status.
  1471                                  ;
  1472                                  ;	In:		DS:SI	address of string
  1473                                  ;
  1474                                  ;-----------------------------------------------------------------------------------------------------------------------
  1475 000000D3 FC                      PutTTYString		cld							;forward strings
  1476 000000D4 AC                      			lodsb							;load next byte at DS:SI in AL
  1477 000000D5 84C0                    			test	al,al						;end of string?
  1478 000000D7 7406                    			jz	.10						;... yes, exit our loop
  1479 000000D9 B40E                    			mov	ah,EBIOSFNTTYOUTPUT				;BIOS teletype function
  1480 000000DB CD10                    			int	EBIOSINTVIDEO					;call BIOS display interrupt
  1481 000000DD EBF4                    			jmp	PutTTYString					;repeat until done
  1482 000000DF C3                      .10			ret							;return
  1483                                  ;-----------------------------------------------------------------------------------------------------------------------
  1484                                  ;
  1485                                  ;	Loader Data
  1486                                  ;
  1487                                  ;	The loader data is updated to include constants defining the initial (Loader) TSS and LDT selectors in the
  1488                                  ;	GDT, a work area to build the GDTR, and additional text messages.
  1489                                  ;
  1490                                  ;-----------------------------------------------------------------------------------------------------------------------
  1491                                  			align	2
  1492 000000E0 5000                    cwLoaderLDT		dw	ESELLOADERLDT					;loader local descriptor table selector
  1493 000000E2 5800                    cwLoaderTSS		dw	ESELLOADERTSS					;loader task state segment selector
  1494 000000E4 00<rept>                cbLoaderGDT		times	5 db 0						;6-byte GDTR work area
  1495 000000E9 00                      cbLoaderGDTHiByte	db	0						;hi-order byte
  1496 000000EA 546865206F70657261-     czCPUErrorMsg		db	"The operating system requires an i386 or later processor.",13,10
  1496 000000F3 74696E672073797374-
  1496 000000FC 656D20726571756972-
  1496 00000105 657320616E20693338-
  1496 0000010E 36206F72206C617465-
  1496 00000117 722070726F63657373-
  1496 00000120 6F722E0D0A         
  1497 00000125 506C65617365207072-     			db	"Please press any key to restart the computer.",13,10,0
  1497 0000012E 65737320616E79206B-
  1497 00000137 657920746F20726573-
  1497 00000140 746172742074686520-
  1497 00000149 636F6D70757465722E-
  1497 00000152 0D0A00             
  1498 00000155 435055204F4B0D0A00      czCPUOKMsg		db	"CPU OK",13,10,0
  1499 0000015E 474454207072657061-     czGDTOKMsg		db	"GDT prepared",13,10,0
  1499 00000167 7265640D0A00       
  1500 0000016D 4B65726E656C206C6F-     czKernelLoadedMsg	db	"Kernel loaded",13,10,0
  1500 00000176 616465640D0A00     
  1501 0000017D 5374617274696E6720-     czStartingMsg		db	"Starting OS",13,10,0				;starting message
  1501 00000186 4F530D0A00         
  1502 0000018B 00<rept>                			times	510-($-$$) db 0h				;zero fill to end of sector
  1503 000001FE 55AA                    			db	055h,0AAh					;end of sector signature
  1504                                  ;=======================================================================================================================
  1505                                  ;
  1506                                  ;	OS Kernel								@disk: 004400	@mem: 001000
  1507                                  ;
  1508                                  ;	This code is the operating system kernel. It resides on the boot disk image as part of the OS.COM file,
  1509                                  ;	following the 16-bit loader code above. The Kernel executes only 32-bit code in protected mode and contains one
  1510                                  ;	task, the Console, which performs a loop accepting user input from external devices (keyboard, etc.), processes
  1511                                  ;	commands and displays ouput to video memory. The Kernel also includes a library of system functions accessible
  1512                                  ;	through software interrupt 58 (30h). Finally, the Kernel provides CPU and hardware interrupt handlers.
  1513                                  ;
  1514                                  ;=======================================================================================================================
  1515                                  ;=======================================================================================================================
  1516                                  ;
  1517                                  ;	Kernel Tables
  1518                                  ;
  1519                                  ;=======================================================================================================================
  1520                                  ;-----------------------------------------------------------------------------------------------------------------------
  1521                                  ;
  1522                                  ;	Global Descriptor Table							@disk: 004400	@mem: 001000
  1523                                  ;
  1524                                  ;	The Global Descriptor Table (GDT) consists of eight-byte descriptors that define reserved memory areas. The
  1525                                  ;	first descriptor must be all nulls.
  1526                                  ;
  1527                                  ;	6   5         4         3         2         1         0
  1528                                  ;	3210987654321098765432109876543210987654321098765432109876543210
  1529                                  ;	----------------------------------------------------------------
  1530                                  ;	h......hffffmmmma......ab......................bn..............n
  1531                                  ;	00000000			all areas have base addresses below 2^24
  1532                                  ;	        0100     		(0x4) 32-bit single-byte granularity
  1533                                  ;		1100    		(0xC) 32-bit 4KB granularity
  1534                                  ;	            1001		present, ring-0, selector
  1535                                  ;
  1536                                  ;	h...h	hi-order base address (bits 24-31)
  1537                                  ;	ffff	flags
  1538                                  ;	mmmm	hi-order limit (bits 16-19)
  1539                                  ;	a...a	access
  1540                                  ;	b...b	lo-order base address (bits 0-23)
  1541                                  ;	n...n	lo-order limit (bits 0-15)
  1542                                  ;
  1543                                  ;-----------------------------------------------------------------------------------------------------------------------
  1544                                  section			gdt							;global descriptor table
  1545 00000000 0000000000000000        			dq	0000000000000000h				;00 required null selector
  1546 00000008 FF07001000934000        			dq	00409300100007FFh				;08 2KB  writable data  (GDT alias)
  1547 00000010 FF07001800934000        			dq	00409300180007FFh				;10 2KB  writable data  (IDT alias)
  1548 00000018 FFFF00000093CF00        			dq	00CF93000000FFFFh				;18 4GB  writable data  (kernel)     DS:
  1549 00000020 FF0F00800B934000        			dq	0040930B80000FFFh				;20 4KB  writable data  (CGA)        ES:
  1550 00000028 FF0F000000934000        			dq	0040930000000FFFh				;28 4KB  writable stack (Loader)     SS:
  1551 00000030 FFFF0000009B0000        			dq	00009B000000FFFFh				;30 64KB readable code  (loader)     CS:
  1552 00000038 FFFF0000FF9B0000        			dq	00009BFF0000FFFFh				;38 64KB readable code  (BIOS)
  1553 00000040 FFFF000400934000        			dq	004093000400FFFFh				;40 64KB writable data  (BIOS)
  1554 00000048 FF1F0020009B4000        			dq	00409B0020001FFFh				;48 8KB  readable code  (kernel)
  1555 00000050 7F00000F00824000        			dq	004082000F00007Fh				;50 80B  writable LDT   (loader)
  1556 00000058 7F00800F00894000        			dq	004089000F80007Fh				;58 80B  writable TSS   (loader)
  1557 00000060 7F00004700824000        			dq	004082004700007Fh				;60 80B  writable LDT   (console)
  1558 00000068 7F00804700894000        			dq	004089004780007Fh				;88 80B  writable TSS   (console)
  1559 00000070 7F00006700824000        			dq	004082006700007Fh				;70 80B  writable LDT   (background)
  1560 00000078 7F00806700894000        			dq	004089006780007Fh				;78 80B  writable TSS   (background)
  1561 00000080 FF07004800934000        			dq	00409300480007FFh				;80 2KB  foreground task message queue
  1562 00000088 00<rept>                			times	2048-($-$$) db 0h				;zero fill to end of section
  1563                                  ;-----------------------------------------------------------------------------------------------------------------------
  1564                                  ;
  1565                                  ;	Interrupt Descriptor Table						@disk: 004c00	@mem: 001800
  1566                                  ;
  1567                                  ;	The Interrupt Descriptor Table (IDT) consists of one eight-byte entry (descriptor) for each interrupt. The
  1568                                  ;	descriptors here are of two kinds, interrupt gates and trap gates. The "mint" and "mtrap" macros define the
  1569                                  ;	descriptors, taking only the name of the entry point for the code handling the interrupt.
  1570                                  ;
  1571                                  ;	6   5         4         3         2         1         0
  1572                                  ;	3210987654321098765432109876543210987654321098765432109876543210
  1573                                  ;	----------------------------------------------------------------
  1574                                  ;	h..............hPzzStttt00000000S..............Sl..............l
  1575                                  ;
  1576                                  ;	h...h	high-order offset (bits 16-31)
  1577                                  ;	P	present (0=unused interrupt)
  1578                                  ;	zz	descriptor privilege level
  1579                                  ;	S	storage segment (must be zero for IDT)
  1580                                  ;	tttt	type: 0101=task, 1110=int, 1111=trap
  1581                                  ;	S...S	handling code selector in GDT
  1582                                  ;	l...l	lo-order offset (bits 0-15)
  1583                                  ;
  1584                                  ;-----------------------------------------------------------------------------------------------------------------------
  1585                                  section			idt							;interrupt descriptor table
  1586                                  			mint	dividebyzero					;00 divide by zero
  1586                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1586 00000000 00004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1587                                  			mint	singlestep					;01 single step
  1587                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1587 00000008 0C004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1588                                  			mint	nmi						;02 non-maskable
  1588                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1588 00000010 18004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1589                                  			mint	break						;03 break
  1589                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1589 00000018 24004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1590                                  			mint	into						;04 into
  1590                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1590 00000020 30004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1591                                  			mint	bounds						;05 bounds
  1591                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1591 00000028 3C004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1592                                  			mint	badopcode					;06 bad op code
  1592                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1592 00000030 48004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1593                                  			mint	nocoproc					;07 no coprocessor
  1593                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1593 00000038 54004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1594                                  			mint	doublefault					;08 double-fault
  1594                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1594 00000040 60004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1595                                  			mint	operand						;09 operand
  1595                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1595 00000048 6C004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1596                                  			mint	badtss						;0a bad TSS
  1596                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1596 00000050 78004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1597                                  			mint	notpresent					;0b not-present
  1597                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1597 00000058 84004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1598                                  			mint	stacklimit					;0c stack limit
  1598                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1598 00000060 90004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1599                                  			mint	protection					;0d general protection fault
  1599                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1599 00000068 9C004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1600                                  			mint	int14						;0e (reserved)
  1600                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1600 00000070 A8004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1601                                  			mint	int15						;0f (reserved)
  1601                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1601 00000078 B4004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1602                                  			mint	coproccalc					;10 (reserved)
  1602                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1602 00000080 C0004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1603                                  			mint	int17						;11 (reserved)
  1603                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1603 00000088 CC004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1604                                  			mint	int18						;12 (reserved)
  1604                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1604 00000090 D5004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1605                                  			mint	int19						;13 (reserved)
  1605                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1605 00000098 DE004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1606                                  			mint	int20						;14 (reserved)
  1606                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1606 000000A0 E7004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1607                                  			mint	int21						;15 (reserved)
  1607                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1607 000000A8 F0004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1608                                  			mint	int22						;16 (reserved)
  1608                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1608 000000B0 F9004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1609                                  			mint	int23						;17 (reserved)
  1609                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1609 000000B8 02014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1610                                  			mint	int24						;18 (reserved)
  1610                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1610 000000C0 0B014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1611                                  			mint	int25						;19 (reserved)
  1611                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1611 000000C8 14014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1612                                  			mint	int26						;1a (reserved)
  1612                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1612 000000D0 1D014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1613                                  			mint	int27						;1b (reserved)
  1613                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1613 000000D8 26014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1614                                  			mint	int28						;1c (reserved)
  1614                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1614 000000E0 2F014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1615                                  			mint	int29						;1d (reserved)
  1615                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1615 000000E8 38014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1616                                  			mint	int30						;1e (reserved)
  1616                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1616 000000F0 41014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1617                                  			mint	int31						;1f (reserved)
  1617                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1617 000000F8 4A014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1618                                  			mtrap	clocktick					;20 IRQ0 clock tick
  1618                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1618 00000100 31054800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1619                                  			mtrap	keyboard					;21 IRQ1 keyboard
  1619                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1619 00000108 BF054800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1620                                  			mtrap	iochannel					;22 IRQ2 second 8259A cascade
  1620                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1620 00000110 2B094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1621                                  			mtrap	com2						;23 IRQ3 com2
  1621                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1621 00000118 2E094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1622                                  			mtrap	com1						;24 IRQ4 com1
  1622                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1622 00000120 31094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1623                                  			mtrap	lpt2						;25 IRQ5 lpt2
  1623                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1623 00000128 34094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1624                                  			mtrap	diskette					;26 IRQ6 diskette
  1624                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1624 00000130 37094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1625                                  			mtrap	lpt1						;27 IRQ7 lpt1
  1625                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1625 00000138 4B094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1626                                  			mtrap	rtclock						;28 IRQ8 real-time clock
  1626                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1626 00000140 4E094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1627                                  			mtrap	retrace						;29 IRQ9 CGA vertical retrace
  1627                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1627 00000148 51094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1628                                  			mtrap	irq10						;2a IRQA (reserved)
  1628                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1628 00000150 54094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1629                                  			mtrap	irq11						;2b IRQB (reserved)
  1629                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1629 00000158 57094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1630                                  			mtrap	ps2mouse					;2c IRQC ps/2 mouse
  1630                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1630 00000160 5A094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1631                                  			mtrap	coprocessor					;2d IRQD coprocessor
  1631                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1631 00000168 5D094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1632                                  			mtrap	fixeddisk					;2e IRQE fixed disk
  1632                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1632 00000170 60094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1633                                  			mtrap	irq15						;2f IRQF (reserved)
  1633                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1633 00000178 63094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1634                                  			mtrap	svc						;30 OS services
  1634                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1634 00000180 74094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1635 00000188 00<rept>                			times	2048-($-$$) db 0h				;zero fill to end of section
  1636                                  ;=======================================================================================================================
  1637                                  ;
  1638                                  ;	Interrupt Handlers							@disk: 005400	@mem:  002000
  1639                                  ;
  1640                                  ;	Interrupt handlers are 32-bit routines that receive control either in response to events or by direct
  1641                                  ;	invocation from other kernel code. The interrupt handlers are of three basic types. CPU interrupts occur when a
  1642                                  ;	CPU exception is detected. Hardware interrupts occur when an external device (timer, keyboard, disk, etc.)
  1643                                  ;	signals the CPU on an interrupt request line (IRQ). Software interrupts occur when directly called by other code
  1644                                  ;	using the INT instruction. Each interrupt handler routine is defined by using our "menter" macro, which simply
  1645                                  ;	establishes a label defining the offset address of the entry point from the start of the kernel section. This
  1646                                  ;	label is referenced in the "mint" and "mtrap" macros found in the IDT to specify the address of the handlers.
  1647                                  ;
  1648                                  ;=======================================================================================================================
  1649                                  section			kernel	vstart=0h					;data offsets relative to 0
  1650                                  			cpu	386						;allow 80386 instructions
  1651                                  			bits	32						;this is 32-bit code
  1652                                  ;=======================================================================================================================
  1653                                  ;
  1654                                  ;	CPU Interrupt Handlers
  1655                                  ;
  1656                                  ;	The first 32 entries in the Interrupt Descriptor Table are reserved for use by CPU interrupts. The handling
  1657                                  ;	of these interrupts is expanded here to display the contents of registers at the time of the interrupt.
  1658                                  ;
  1659                                  ;=======================================================================================================================
  1660                                  ;-----------------------------------------------------------------------------------------------------------------------
  1661                                  ;
  1662                                  ;	INT0	Divide By Zero
  1663                                  ;
  1664                                  ;-----------------------------------------------------------------------------------------------------------------------
  1665                                  			menter	dividebyzero					;divide by zero
  1665                              <1> ?%1 equ ($-$$)
  1666 00000000 6A00                    			push	0						;store interrupt nbr
  1667 00000002 68[29030000]            			push	czIntDivideByZero				;store message offset
  1668 00000007 E947010000              			jmp	ReportInterrupt					;report interrupt
  1669                                  ;-----------------------------------------------------------------------------------------------------------------------
  1670                                  ;
  1671                                  ;	INT1	Single Step
  1672                                  ;
  1673                                  ;-----------------------------------------------------------------------------------------------------------------------
  1674                                  			menter	singlestep					;single step
  1674                              <1> ?%1 equ ($-$$)
  1675 0000000C 6A01                    			push	1						;store interrupt nbr
  1676 0000000E 68[3A030000]            			push	czIntSingleStep					;store message offset
  1677 00000013 E93B010000              			jmp	ReportInterrupt					;report interrupt
  1678                                  ;-----------------------------------------------------------------------------------------------------------------------
  1679                                  ;
  1680                                  ;	INT2	Non-Maskable Interrupt
  1681                                  ;
  1682                                  ;-----------------------------------------------------------------------------------------------------------------------
  1683                                  			menter	nmi						;non-maskable
  1683                              <1> ?%1 equ ($-$$)
  1684 00000018 6A02                    			push	2						;store interrupt nbr
  1685 0000001A 68[46030000]            			push	czIntNonMaskable				;store message offset
  1686 0000001F E92F010000              			jmp	ReportInterrupt					;report interrupt
  1687                                  ;-----------------------------------------------------------------------------------------------------------------------
  1688                                  ;
  1689                                  ;	INT3	Break
  1690                                  ;
  1691                                  ;-----------------------------------------------------------------------------------------------------------------------
  1692                                  			menter	break						;break
  1692                              <1> ?%1 equ ($-$$)
  1693 00000024 6A03                    			push	3						;store interrupt nbr
  1694 00000026 68[5D030000]            			push	czIntBreak					;store message offset
  1695 0000002B E923010000              			jmp	ReportInterrupt					;report interrupt
  1696                                  ;-----------------------------------------------------------------------------------------------------------------------
  1697                                  ;
  1698                                  ;	INT4	Into
  1699                                  ;
  1700                                  ;-----------------------------------------------------------------------------------------------------------------------
  1701                                  			menter	into						;into
  1701                              <1> ?%1 equ ($-$$)
  1702 00000030 6A04                    			push	4						;store interrupt nbr
  1703 00000032 68[63030000]            			push	czIntInto					;store message offset
  1704 00000037 E917010000              			jmp	ReportInterrupt					;report interrupt
  1705                                  ;-----------------------------------------------------------------------------------------------------------------------
  1706                                  ;
  1707                                  ;	INT5	Bounds
  1708                                  ;
  1709                                  ;-----------------------------------------------------------------------------------------------------------------------
  1710                                  			menter	bounds						;bounds
  1710                              <1> ?%1 equ ($-$$)
  1711 0000003C 6A05                    			push	5						;store interrupt nbr
  1712 0000003E 68[68030000]            			push	czIntBounds					;store message offset
  1713 00000043 E90B010000              			jmp	ReportInterrupt					;report interrupt
  1714                                  ;-----------------------------------------------------------------------------------------------------------------------
  1715                                  ;
  1716                                  ;	INT6	Bad Operation Code
  1717                                  ;
  1718                                  ;-----------------------------------------------------------------------------------------------------------------------
  1719                                  			menter	badopcode					;bad opcode interrupt
  1719                              <1> ?%1 equ ($-$$)
  1720 00000048 6A06                    			push	6						;store interrupt nbr
  1721 0000004A 68[6F030000]            			push	czIntBadOpCode					;store message offset
  1722 0000004F E9FF000000              			jmp	ReportInterrupt					;report interrupt
  1723                                  ;-----------------------------------------------------------------------------------------------------------------------
  1724                                  ;
  1725                                  ;	INT7	No Coprocessor
  1726                                  ;
  1727                                  ;-----------------------------------------------------------------------------------------------------------------------
  1728                                  			menter	nocoproc					;no coprocessor interrupt
  1728                              <1> ?%1 equ ($-$$)
  1729 00000054 6A07                    			push	7						;store interrupt nbr
  1730 00000056 68[82030000]            			push	czIntNoCoprocessor				;store message offset
  1731 0000005B E9F3000000              			jmp	ReportInterrupt					;report interrupt
  1732                                  ;-----------------------------------------------------------------------------------------------------------------------
  1733                                  ;
  1734                                  ;	INT8	Double Fault
  1735                                  ;
  1736                                  ;-----------------------------------------------------------------------------------------------------------------------
  1737                                  			menter	doublefault					;doublefault interrupt
  1737                              <1> ?%1 equ ($-$$)
  1738 00000060 6A08                    			push	8						;store interrupt nbr
  1739 00000062 68[91030000]            			push	czIntDoubleFault				;store message offset
  1740 00000067 E9E7000000              			jmp	ReportInterrupt					;report interrupt
  1741                                  ;-----------------------------------------------------------------------------------------------------------------------
  1742                                  ;
  1743                                  ;	INT9	Operand
  1744                                  ;
  1745                                  ;-----------------------------------------------------------------------------------------------------------------------
  1746                                  			menter	operand						;operand interrupt
  1746                              <1> ?%1 equ ($-$$)
  1747 0000006C 6A09                    			push	9						;store interrupt nbr
  1748 0000006E 68[9E030000]            			push	czIntOperand					;store message offset
  1749 00000073 E9DB000000              			jmp	ReportInterrupt					;report interrupt
  1750                                  ;-----------------------------------------------------------------------------------------------------------------------
  1751                                  ;
  1752                                  ;	INT10	Bad Task State Segment
  1753                                  ;
  1754                                  ;-----------------------------------------------------------------------------------------------------------------------
  1755                                  			menter	badtss						;bad tss interrupt
  1755                              <1> ?%1 equ ($-$$)
  1756 00000078 6A0A                    			push	10						;store interrupt nbr
  1757 0000007A 68[A6030000]            			push	czIntBadTSS					;store message offset
  1758 0000007F E9CF000000              			jmp	ReportInterrupt					;report interrupt
  1759                                  ;-----------------------------------------------------------------------------------------------------------------------
  1760                                  ;
  1761                                  ;	INT11	Not Present
  1762                                  ;
  1763                                  ;-----------------------------------------------------------------------------------------------------------------------
  1764                                  			menter	notpresent					;not present interrupt
  1764                              <1> ?%1 equ ($-$$)
  1765 00000084 6A0B                    			push	11						;store interrupt nbr
  1766 00000086 68[BD030000]            			push	czIntNotPresent					;store message offset
  1767 0000008B E9C3000000              			jmp	ReportInterrupt					;report interrupt
  1768                                  ;-----------------------------------------------------------------------------------------------------------------------
  1769                                  ;
  1770                                  ;	INT12	Stack Limit
  1771                                  ;
  1772                                  ;-----------------------------------------------------------------------------------------------------------------------
  1773                                  			menter	stacklimit					;stack limit interrupt
  1773                              <1> ?%1 equ ($-$$)
  1774 00000090 6A0C                    			push	12						;store interrupt nbr
  1775 00000092 68[C9030000]            			push	czIntStackLimit					;store message offset
  1776 00000097 E9B7000000              			jmp	ReportInterrupt					;report interrupt
  1777                                  ;-----------------------------------------------------------------------------------------------------------------------
  1778                                  ;
  1779                                  ;	INT13	General Protection Fault
  1780                                  ;
  1781                                  ;-----------------------------------------------------------------------------------------------------------------------
  1782                                  			menter	protection					;protection fault interrupt
  1782                              <1> ?%1 equ ($-$$)
  1783 0000009C 6A0D                    			push	13						;store interrupt nbr
  1784 0000009E 68[D5030000]            			push	czIntProtection					;store message offset
  1785 000000A3 E9AB000000              			jmp	ReportInterrupt					;report interrupt
  1786                                  ;-----------------------------------------------------------------------------------------------------------------------
  1787                                  ;
  1788                                  ;	INT14	Reserved
  1789                                  ;
  1790                                  ;-----------------------------------------------------------------------------------------------------------------------
  1791                                  			menter	int14						;(reserved)
  1791                              <1> ?%1 equ ($-$$)
  1792 000000A8 6A0E                    			push	14						;store interrupt nbr
  1793 000000AA 68[06040000]            			push	czIntReserved					;store message offset
  1794 000000AF E99F000000              			jmp	ReportInterrupt					;report interrupt
  1795                                  ;-----------------------------------------------------------------------------------------------------------------------
  1796                                  ;
  1797                                  ;	INT15	Reserved
  1798                                  ;
  1799                                  ;-----------------------------------------------------------------------------------------------------------------------
  1800                                  			menter	int15						;(reserved)
  1800                              <1> ?%1 equ ($-$$)
  1801 000000B4 6A0F                    			push	15						;store interrupt nbr
  1802 000000B6 68[06040000]            			push	czIntReserved					;store message offset
  1803 000000BB E993000000              			jmp	ReportInterrupt					;report interrupt
  1804                                  ;-----------------------------------------------------------------------------------------------------------------------
  1805                                  ;
  1806                                  ;	INT16	Coprocessor Calculation
  1807                                  ;
  1808                                  ;-----------------------------------------------------------------------------------------------------------------------
  1809                                  			menter	coproccalc					;coprocessor calculation
  1809                              <1> ?%1 equ ($-$$)
  1810 000000C0 6A10                    			push	16						;store interrupt nbr
  1811 000000C2 68[EE030000]            			push	czIntCoprocessorCalc				;store message offset
  1812 000000C7 E987000000              			jmp	ReportInterrupt					;report interrupt
  1813                                  ;-----------------------------------------------------------------------------------------------------------------------
  1814                                  ;
  1815                                  ;	INT17	Reserved
  1816                                  ;
  1817                                  ;-----------------------------------------------------------------------------------------------------------------------
  1818                                  			menter	int17						;(reserved)
  1818                              <1> ?%1 equ ($-$$)
  1819 000000CC 6A11                    			push	17						;store interrupt nbr
  1820 000000CE 68[06040000]            			push	czIntReserved					;store message offset
  1821 000000D3 EB7E                    			jmp	ReportInterrupt					;report interrupt
  1822                                  ;-----------------------------------------------------------------------------------------------------------------------
  1823                                  ;
  1824                                  ;	INT18	Reserved
  1825                                  ;
  1826                                  ;-----------------------------------------------------------------------------------------------------------------------
  1827                                  			menter	int18						;(reserved)
  1827                              <1> ?%1 equ ($-$$)
  1828 000000D5 6A12                    			push	18						;store interrupt nbr
  1829 000000D7 68[06040000]            			push	czIntReserved					;store message offset
  1830 000000DC EB75                    			jmp	ReportInterrupt					;report interrupt
  1831                                  ;-----------------------------------------------------------------------------------------------------------------------
  1832                                  ;
  1833                                  ;	INT19	Reserved
  1834                                  ;
  1835                                  ;-----------------------------------------------------------------------------------------------------------------------
  1836                                  			menter	int19						;(reserved)
  1836                              <1> ?%1 equ ($-$$)
  1837 000000DE 6A13                    			push	19						;store interrupt nbr
  1838 000000E0 68[06040000]            			push	czIntReserved					;store message offset
  1839 000000E5 EB6C                    			jmp	ReportInterrupt					;report interrupt
  1840                                  ;-----------------------------------------------------------------------------------------------------------------------
  1841                                  ;
  1842                                  ;	INT20	Reserved
  1843                                  ;
  1844                                  ;-----------------------------------------------------------------------------------------------------------------------
  1845                                  			menter	int20						;(reserved)
  1845                              <1> ?%1 equ ($-$$)
  1846 000000E7 6A14                    			push	20						;store interrupt nbr
  1847 000000E9 68[06040000]            			push	czIntReserved					;store message offset
  1848 000000EE EB63                    			jmp	ReportInterrupt					;report interrupt
  1849                                  ;-----------------------------------------------------------------------------------------------------------------------
  1850                                  ;
  1851                                  ;	INT21	Reserved
  1852                                  ;
  1853                                  ;-----------------------------------------------------------------------------------------------------------------------
  1854                                  			menter	int21						;(reserved)
  1854                              <1> ?%1 equ ($-$$)
  1855 000000F0 6A15                    			push	21						;store interrupt nbr
  1856 000000F2 68[06040000]            			push	czIntReserved					;store message offset
  1857 000000F7 EB5A                    			jmp	ReportInterrupt					;report interrupt
  1858                                  ;-----------------------------------------------------------------------------------------------------------------------
  1859                                  ;
  1860                                  ;	INT22	Reserved
  1861                                  ;
  1862                                  ;-----------------------------------------------------------------------------------------------------------------------
  1863                                  			menter	int22						;(reserved)
  1863                              <1> ?%1 equ ($-$$)
  1864 000000F9 6A16                    			push	22						;store interrupt nbr
  1865 000000FB 68[06040000]            			push	czIntReserved					;store message offset
  1866 00000100 EB51                    			jmp	ReportInterrupt					;report interrupt
  1867                                  ;-----------------------------------------------------------------------------------------------------------------------
  1868                                  ;
  1869                                  ;	INT23	Reserved
  1870                                  ;
  1871                                  ;-----------------------------------------------------------------------------------------------------------------------
  1872                                  			menter	int23						;(reserved)
  1872                              <1> ?%1 equ ($-$$)
  1873 00000102 6A17                    			push	23						;store interrupt nbr
  1874 00000104 68[06040000]            			push	czIntReserved					;store message offset
  1875 00000109 EB48                    			jmp	ReportInterrupt					;report interrupt
  1876                                  ;-----------------------------------------------------------------------------------------------------------------------
  1877                                  ;
  1878                                  ;	INT24	Reserved
  1879                                  ;
  1880                                  ;-----------------------------------------------------------------------------------------------------------------------
  1881                                  			menter	int24						;(reserved)
  1881                              <1> ?%1 equ ($-$$)
  1882 0000010B 6A18                    			push	24						;store interrupt nbr
  1883 0000010D 68[06040000]            			push	czIntReserved					;store message offset
  1884 00000112 EB3F                    			jmp	ReportInterrupt					;report interrupt
  1885                                  ;-----------------------------------------------------------------------------------------------------------------------
  1886                                  ;
  1887                                  ;	INT25	Reserved
  1888                                  ;
  1889                                  ;-----------------------------------------------------------------------------------------------------------------------
  1890                                  			menter	int25						;(reserved)
  1890                              <1> ?%1 equ ($-$$)
  1891 00000114 6A19                    			push	25						;store interrupt nbr
  1892 00000116 68[06040000]            			push	czIntReserved					;store message offset
  1893 0000011B EB36                    			jmp	ReportInterrupt					;report interrupt
  1894                                  ;-----------------------------------------------------------------------------------------------------------------------
  1895                                  ;
  1896                                  ;	INT26	Reserved
  1897                                  ;
  1898                                  ;-----------------------------------------------------------------------------------------------------------------------
  1899                                  			menter	int26						;(reserved)
  1899                              <1> ?%1 equ ($-$$)
  1900 0000011D 6A1A                    			push	26						;store interrupt nbr
  1901 0000011F 68[06040000]            			push	czIntReserved					;store message offset
  1902 00000124 EB2D                    			jmp	ReportInterrupt					;report interrupt
  1903                                  ;-----------------------------------------------------------------------------------------------------------------------
  1904                                  ;
  1905                                  ;	INT27	Reserved
  1906                                  ;
  1907                                  ;-----------------------------------------------------------------------------------------------------------------------
  1908                                  			menter	int27						;(reserved)
  1908                              <1> ?%1 equ ($-$$)
  1909 00000126 6A1B                    			push	27						;store interrupt nbr
  1910 00000128 68[06040000]            			push	czIntReserved					;store message offset
  1911 0000012D EB24                    			jmp	ReportInterrupt					;report interrupt
  1912                                  ;-----------------------------------------------------------------------------------------------------------------------
  1913                                  ;
  1914                                  ;	INT28	Reserved
  1915                                  ;
  1916                                  ;-----------------------------------------------------------------------------------------------------------------------
  1917                                  			menter	int28						;(reserved)
  1917                              <1> ?%1 equ ($-$$)
  1918 0000012F 6A1C                    			push	28						;store interrupt nbr
  1919 00000131 68[06040000]            			push	czIntReserved					;store message offset
  1920 00000136 EB1B                    			jmp	ReportInterrupt					;report interrupt
  1921                                  ;-----------------------------------------------------------------------------------------------------------------------
  1922                                  ;
  1923                                  ;	INT29	Reserved
  1924                                  ;
  1925                                  ;-----------------------------------------------------------------------------------------------------------------------
  1926                                  			menter	int29						;(reserved)
  1926                              <1> ?%1 equ ($-$$)
  1927 00000138 6A1D                    			push	29						;store interrupt nbr
  1928 0000013A 68[06040000]            			push	czIntReserved					;store message offset
  1929 0000013F EB12                    			jmp	ReportInterrupt					;report interrupt
  1930                                  ;-----------------------------------------------------------------------------------------------------------------------
  1931                                  ;
  1932                                  ;	INT30	Reserved
  1933                                  ;
  1934                                  ;-----------------------------------------------------------------------------------------------------------------------
  1935                                  			menter	int30						;(reserved)
  1935                              <1> ?%1 equ ($-$$)
  1936 00000141 6A1E                    			push	30						;store interrupt nbr
  1937 00000143 68[06040000]            			push	czIntReserved					;store message offset
  1938 00000148 EB09                    			jmp	ReportInterrupt					;report interrupt
  1939                                  ;-----------------------------------------------------------------------------------------------------------------------
  1940                                  ;
  1941                                  ;	INT31	Reserved
  1942                                  ;
  1943                                  ;-----------------------------------------------------------------------------------------------------------------------
  1944                                  			menter	int31						;(reserved)
  1944                              <1> ?%1 equ ($-$$)
  1945 0000014A 6A1F                    			push	31						;store interrupt nbr
  1946 0000014C 68[06040000]            			push	czIntReserved					;store message offset
  1947 00000151 EB00                    			jmp	ReportInterrupt					;report interrupt
  1948                                  ;-----------------------------------------------------------------------------------------------------------------------
  1949                                  ;
  1950                                  ;	Routine:	ReportInterrupt
  1951                                  ;
  1952                                  ;	Description:	This routine will be used to respond to processor interrupts that are not otherwise handled.
  1953                                  ;			At this stage, we simply restore the stack and return from the interrupt.
  1954                                  ;
  1955                                  ;	In:		[esp+16]	eflags					stored by interrupt call
  1956                                  ;			[esp+12]	cs					stored by interrupt call
  1957                                  ;			[esp+8]		eip					stored by interrupt call
  1958                                  ;			[esp+4]		interrupt number (0-31)			stored by push instruction
  1959                                  ;			[esp+0]		error message address			stored by push instructions
  1960                                  ;
  1961                                  ;	Out:		N/A		This routine does not exit.
  1962                                  ;
  1963                                  ;-----------------------------------------------------------------------------------------------------------------------
  1964 00000153 1E                      ReportInterrupt		push	ds						;save DS at time of interrupt
  1965 00000154 06                      			push	es						;save ES at time of interrupt
  1966 00000155 60                      			pushad							;save EAX,ECX,EDX,EBX,EBP,ESP,ESI,EDI
  1967 00000156 89E5                    			mov	ebp,esp						;ebp --> [EDI]
  1968                                  ;
  1969                                  ;	Addressability to registers at the time of the interrupt is now established as:
  1970                                  ;
  1971                                  ;			[ebp+56]	eflags
  1972                                  ;			[ebp+52]	cs
  1973                                  ;			[ebp+48]	eip
  1974                                  ;			[ebp+44]	interrupt number (0-31)
  1975                                  ;			[ebp+40]	error message address
  1976                                  ;			[ebp+36]	ds
  1977                                  ;			[ebp+32]	es
  1978                                  ;			[ebp+28]	eax
  1979                                  ;			[ebp+24]	ecx
  1980                                  ;			[ebp+20]	edx
  1981                                  ;			[ebp+16]	ebx
  1982                                  ;			[ebp+12]	esp
  1983                                  ;			[ebp+8]		ebp
  1984                                  ;			[ebp+4]		esi
  1985                                  ;			[ebp+0]		edi
  1986                                  ;
  1987 00000158 0E                      			push	cs						;load code selector ...
  1988 00000159 1F                      			pop	ds						;... into DS
  1989 0000015A 6A20                    			push	ESELCGA						;load CGA memory selector ...
  1990 0000015C 07                      			pop	es						;... into ES
  1991                                  ;
  1992                                  ;	Display the interrupt report boundary box
  1993                                  ;
  1994 0000015D B10D                    			mov	cl,13						;column
  1995 0000015F B506                    			mov	ch,6						;row
  1996 00000161 B232                    			mov	dl,50						;width
  1997 00000163 B608                    			mov	dh,8						;height
  1998 00000165 B707                    			mov	bh,07h						;attribute
  1999 00000167 E84C030000              			call	DrawTextDialogBox				;draw text dialog box
  2000                                  ;
  2001                                  ;	Display the report header
  2002                                  ;
  2003 0000016C B10F                    			mov	cl,15						;column
  2004 0000016E B507                    			mov	ch,7						;row
  2005 00000170 BE[0F040000]            			mov	esi,czIntHeader					;interrupt message header
  2006 00000175 E897110000              			call	SetConsoleString				;draw text string
  2007                                  ;
  2008                                  ;	Display the interrupt description label
  2009                                  ;
  2010 0000017A B10F                    			mov	cl,15						;column
  2011 0000017C B508                    			mov	ch,8						;row
  2012 0000017E BE[3E040000]            			mov	esi,czIntLabel					;interrupt message description lead
  2013 00000183 E889110000              			call	SetConsoleString				;draw text string
  2014                                  ;
  2015                                  ;	Display the interrupt number
  2016                                  ;
  2017 00000188 8B452C                  			mov	eax,[ebp+44]					;interrupt number
  2018 0000018B B11A                    			mov	cl,26						;column
  2019 0000018D B508                    			mov	ch,8						;row
  2020 0000018F E87F0F0000              			call	PutConsoleHexByte				;draw ASCII hex byte
  2021                                  ;
  2022                                  ;	Display the interrupt name
  2023                                  ;
  2024 00000194 B11D                    			mov	cl,29						;column
  2025 00000196 B508                    			mov	ch,8						;row
  2026 00000198 8B7528                  			mov	esi,[ebp+40]					;interrupt-specific message
  2027 0000019B E871110000              			call	SetConsoleString				;display interrupt description
  2028                                  ;
  2029                                  ;	Display the register values header
  2030                                  ;
  2031 000001A0 B10F                    			mov	cl,15						;column
  2032 000001A2 B50A                    			mov	ch,10						;row
  2033 000001A4 BE[4A040000]            			mov	esi,czIntRegsHeader				;interrupt registers header
  2034 000001A9 E863110000              			call	SetConsoleString				;draw text string
  2035                                  ;
  2036                                  ;	Display the EAX register label and value
  2037                                  ;
  2038 000001AE B10F                    			mov	cl,15						;column
  2039 000001B0 B50B                    			mov	ch,11						;row
  2040 000001B2 BE[72040000]            			mov	esi,czIntEAX					;register EAX label
  2041 000001B7 E855110000              			call	SetConsoleString				;draw label
  2042 000001BC 8B451C                  			mov	eax,[ebp+28]					;EAX value at interrupt
  2043 000001BF B113                    			mov	cl,19						;column
  2044 000001C1 B50B                    			mov	ch,11						;row
  2045 000001C3 E82B0F0000              			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2046                                  ;
  2047                                  ;	Display the ECX register label and value
  2048                                  ;
  2049 000001C8 B10F                    			mov	cl,15						;column
  2050 000001CA B50C                    			mov	ch,12						;row
  2051 000001CC BE[77040000]            			mov	esi,czIntECX					;label
  2052 000001D1 E83B110000              			call	SetConsoleString				;draw label
  2053 000001D6 8B4518                  			mov	eax,[ebp+24]					;ECX value at interrupt
  2054 000001D9 B113                    			mov	cl,19						;column
  2055 000001DB B50C                    			mov	ch,12						;row
  2056 000001DD E8110F0000              			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2057                                  ;
  2058                                  ;	Display the EDX register label and value
  2059                                  ;
  2060 000001E2 B10F                    			mov	cl,15						;column
  2061 000001E4 B50D                    			mov	ch,13						;row
  2062 000001E6 BE[7C040000]            			mov	esi,czIntEDX					;label
  2063 000001EB E821110000              			call	SetConsoleString				;draw label
  2064 000001F0 8B4514                  			mov	eax,[ebp+20]					;EDX value at interrupt
  2065 000001F3 B113                    			mov	cl,19						;column
  2066 000001F5 B50D                    			mov	ch,13						;row
  2067 000001F7 E8F70E0000              			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2068                                  ;
  2069                                  ;	Display the EBX register label and value
  2070                                  ;
  2071 000001FC B10F                    			mov	cl,15						;column
  2072 000001FE B50E                    			mov	ch,14						;row
  2073 00000200 BE[81040000]            			mov	esi,czIntEBX					;label
  2074 00000205 E807110000              			call	SetConsoleString				;draw label
  2075 0000020A 8B4510                  			mov	eax,[ebp+16]					;EBX value at interrupt
  2076 0000020D B113                    			mov	cl,19						;column
  2077 0000020F B50E                    			mov	ch,14						;row
  2078 00000211 E8DD0E0000              			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2079                                  ;
  2080                                  ;	Display the ESI register label and value
  2081                                  ;
  2082 00000216 B11D                    			mov	cl,29						;column
  2083 00000218 B50B                    			mov	ch,11						;row
  2084 0000021A BE[86040000]            			mov	esi,czIntESI					;label
  2085 0000021F E8ED100000              			call	SetConsoleString				;draw label
  2086 00000224 8B4504                  			mov	eax,[ebp+4]					;ESI
  2087 00000227 B121                    			mov	cl,33						;column
  2088 00000229 B50B                    			mov	ch,11						;row
  2089 0000022B E8C30E0000              			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2090                                  ;
  2091                                  ;	Display the EDI register label and value
  2092                                  ;
  2093 00000230 B11D                    			mov	cl,29						;column
  2094 00000232 B50C                    			mov	ch,12						;row
  2095 00000234 BE[8B040000]            			mov	esi,czIntEDI					;label
  2096 00000239 E8D3100000              			call	SetConsoleString				;draw label
  2097 0000023E 8B4500                  			mov	eax,[ebp+0]					;EDI
  2098 00000241 B121                    			mov	cl,33						;column
  2099 00000243 B50C                    			mov	ch,12						;row
  2100 00000245 E8A90E0000              			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2101                                  ;
  2102                                  ;	Display the EBP register label and value
  2103                                  ;
  2104 0000024A B11D                    			mov	cl,29						;column
  2105 0000024C B50D                    			mov	ch,13						;row
  2106 0000024E BE[90040000]            			mov	esi,czIntEBP					;label
  2107 00000253 E8B9100000              			call	SetConsoleString				;draw label
  2108 00000258 8B4508                  			mov	eax,[ebp+8]					;EBP
  2109 0000025B B121                    			mov	cl,33						;column
  2110 0000025D B50D                    			mov	ch,13						;row
  2111 0000025F E88F0E0000              			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2112                                  ;
  2113                                  ;	Display the DS register label and value
  2114                                  ;
  2115 00000264 B12A                    			mov	cl,42						;column
  2116 00000266 B50B                    			mov	ch,11						;row
  2117 00000268 BE[9A040000]            			mov	esi,czIntDS					;label
  2118 0000026D E89F100000              			call	SetConsoleString				;draw label
  2119 00000272 31C0                    			xor	eax,eax						;zero register
  2120 00000274 668B4524                			mov	ax,[ebp+36]					;DS
  2121 00000278 B12E                    			mov	cl,46						;column
  2122 0000027A B50B                    			mov	ch,11						;row
  2123 0000027C E8820E0000              			call	PutConsoleHexWord				;draw ASCII hex word
  2124                                  ;
  2125                                  ;	Display the ES register label and value
  2126                                  ;
  2127 00000281 B12A                    			mov	cl,42						;column
  2128 00000283 B50C                    			mov	ch,12						;row
  2129 00000285 BE[9F040000]            			mov	esi,czIntES					;label
  2130 0000028A E882100000              			call	SetConsoleString				;draw label
  2131 0000028F 31C0                    			xor	eax,eax						;zero register
  2132 00000291 668B4520                			mov	ax,[ebp+32]					;ES
  2133 00000295 B12E                    			mov	cl,46						;column
  2134 00000297 B50C                    			mov	ch,12						;row
  2135 00000299 E8650E0000              			call	PutConsoleHexWord				;draw ASCII hex word
  2136                                  ;
  2137                                  ;	Display the SS register label and value
  2138                                  ;
  2139 0000029E B12A                    			mov	cl,42						;column
  2140 000002A0 B50D                    			mov	ch,13						;row
  2141 000002A2 BE[A4040000]            			mov	esi,czIntSS					;label
  2142 000002A7 E865100000              			call	SetConsoleString				;draw label
  2143 000002AC 31C0                    			xor	eax,eax						;zero register
  2144 000002AE 668CD0                  			mov	ax,ss						;SS
  2145 000002B1 B12E                    			mov	cl,46						;column
  2146 000002B3 B50D                    			mov	ch,13						;row
  2147 000002B5 E8490E0000              			call	PutConsoleHexWord				;draw ASCII hex word
  2148                                  ;
  2149                                  ;	Display the CS register lable and value
  2150                                  ;
  2151 000002BA B12A                    			mov	cl,42						;column
  2152 000002BC B50E                    			mov	ch,14						;row
  2153 000002BE BE[A9040000]            			mov	esi,czIntCS					;label
  2154 000002C3 E849100000              			call	SetConsoleString				;draw label
  2155 000002C8 31C0                    			xor	eax,eax						;zero register
  2156 000002CA 668B4534                			mov	ax,[ebp+52]					;CS
  2157 000002CE B12E                    			mov	cl,46						;column
  2158 000002D0 B50E                    			mov	ch,14						;row
  2159 000002D2 E82C0E0000              			call	PutConsoleHexWord				;draw ASCII hex word
  2160                                  ;
  2161                                  ;	Display the EFLAGS register label and value
  2162                                  ;
  2163 000002D7 B133                    			mov	cl,51						;column
  2164 000002D9 B50B                    			mov	ch,11						;row
  2165 000002DB BE[AE040000]            			mov	esi,czIntEFLAGS					;label
  2166 000002E0 E82C100000              			call	SetConsoleString				;draw label
  2167 000002E5 8B4538                  			mov	eax,[ebp+56]					;EFLAGS
  2168 000002E8 B137                    			mov	cl,55						;column
  2169 000002EA B50B                    			mov	ch,11						;row
  2170 000002EC E8020E0000              			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2171                                  ;
  2172                                  ;	Display the ESP register label and value
  2173                                  ;
  2174 000002F1 B133                    			mov	cl,51						;column
  2175 000002F3 B50D                    			mov	ch,13						;row
  2176 000002F5 BE[95040000]            			mov	esi,czIntESP					;label
  2177 000002FA E812100000              			call	SetConsoleString				;draw label
  2178 000002FF 8B450C                  			mov	eax,[ebp+12]					;ESP
  2179 00000302 B137                    			mov	cl,55						;column
  2180 00000304 B50D                    			mov	ch,13						;row
  2181 00000306 E8E80D0000              			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2182                                  ;
  2183                                  ;	Display the EIP register label and value
  2184                                  ;
  2185 0000030B B133                    			mov	cl,51						;column
  2186 0000030D B50E                    			mov	ch,14						;row
  2187 0000030F BE[B3040000]            			mov	esi,czIntEIP					;label
  2188 00000314 E8F80F0000              			call	SetConsoleString				;draw label
  2189 00000319 8B4530                  			mov	eax,[ebp+48]					;EIP
  2190 0000031C B137                    			mov	cl,55						;column
  2191 0000031E B50E                    			mov	ch,14						;row
  2192 00000320 E8CE0D0000              			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2193                                  ;
  2194                                  ;	Halt and loop until reset
  2195                                  ;
  2196 00000325 FB                      .10			sti							;enable maskable interrupts
  2197 00000326 F4                      			hlt							;halt processor
  2198 00000327 EBFC                    			jmp	.10						;resume on interrupt
  2199                                  ;-----------------------------------------------------------------------------------------------------------------------
  2200                                  ;
  2201                                  ;	Processor Interrupt Name Strings
  2202                                  ;
  2203                                  ;-----------------------------------------------------------------------------------------------------------------------
  2204 00000329 4469766973696F6E20-     czIntDivideByZero	db	"Division by zero",0
  2204 00000332 6279207A65726F00   
  2205 0000033A 53696E676C65207374-     czIntSingleStep		db	"Single step",0
  2205 00000343 657000             
  2206 00000346 4E6F6E2D6D61736B61-     czIntNonMaskable	db	"Non-maskable interrupt",0
  2206 0000034F 626C6520696E746572-
  2206 00000358 7275707400         
  2207 0000035D 427265616B00            czIntBreak		db	"Break",0
  2208 00000363 496E746F00              czIntInto		db	"Into",0
  2209 00000368 426F756E647300          czIntBounds		db	"Bounds",0
  2210 0000036F 426164204F70657261-     czIntBadOpCode		db	"Bad Operation Code",0
  2210 00000378 74696F6E20436F6465-
  2210 00000381 00                 
  2211 00000382 4E6F20436F70726F63-     czIntNoCoprocessor	db	"No Coprocessor",0
  2211 0000038B 6573736F7200       
  2212 00000391 446F75626C65204661-     czIntDoubleFault	db	"Double Fault",0
  2212 0000039A 756C7400           
  2213 0000039E 4F706572616E6400        czIntOperand		db	"Operand",0
  2214 000003A6 426164205461736B20-     czIntBadTSS		db	"Bad Task State Segment",0
  2214 000003AF 537461746520536567-
  2214 000003B8 6D656E7400         
  2215 000003BD 4E6F74205072657365-     czIntNotPresent		db	"Not Present",0
  2215 000003C6 6E7400             
  2216 000003C9 537461636B204C696D-     czIntStackLimit		db	"Stack Limit",0
  2216 000003D2 697400             
  2217 000003D5 47656E6572616C2050-     czIntProtection		db	"General Protection Fault",0
  2217 000003DE 726F74656374696F6E-
  2217 000003E7 204661756C7400     
  2218 000003EE 436F70726F63657373-     czIntCoprocessorCalc	db	"Coprocessor Calculation",0
  2218 000003F7 6F722043616C63756C-
  2218 00000400 6174696F6E00       
  2219 00000406 526573657276656400      czIntReserved		db	"Reserved",0
  2220                                  ;-----------------------------------------------------------------------------------------------------------------------
  2221                                  ;
  2222                                  ;	Processor Interrupt Handling Strings
  2223                                  ;
  2224                                  ;-----------------------------------------------------------------------------------------------------------------------
  2225 0000040F 416E20756E68616E64-     czIntHeader		db	"An unhandled processor interrupt has occurred:",0
  2225 00000418 6C65642070726F6365-
  2225 00000421 73736F7220696E7465-
  2225 0000042A 727275707420686173-
  2225 00000433 206F63637572726564-
  2225 0000043C 3A00               
  2226 0000043E 496E74657272757074-     czIntLabel		db	"Interrupt #",0
  2226 00000447 202300             
  2227 0000044A 526567697374657273-     czIntRegsHeader		db	"Registers at the time of the interrupt:",0
  2227 00000453 206174207468652074-
  2227 0000045C 696D65206F66207468-
  2227 00000465 6520696E7465727275-
  2227 0000046E 70743A00           
  2228 00000472 4541583A00              czIntEAX		db	"EAX:",0
  2229 00000477 4543583A00              czIntECX		db	"ECX:",0
  2230 0000047C 4544583A00              czIntEDX		db	"EDX:",0
  2231 00000481 4542583A00              czIntEBX		db	"EBX:",0
  2232 00000486 4553493A00              czIntESI		db	"ESI:",0
  2233 0000048B 4544493A00              czIntEDI		db	"EDI:",0
  2234 00000490 4542503A00              czIntEBP		db	"EBP:",0
  2235 00000495 4553503A00              czIntESP		db	"ESP:",0
  2236 0000049A 2044533A00              czIntDS			db	" DS:",0
  2237 0000049F 2045533A00              czIntES			db	" ES:",0
  2238 000004A4 2053533A00              czIntSS			db	" SS:",0
  2239 000004A9 2043533A00              czIntCS			db	" CS:",0
  2240 000004AE 464C473A00              czIntEFLAGS		db	"FLG:",0
  2241 000004B3 4549503A00              czIntEIP		db	"EIP:",0
  2242                                  ;-----------------------------------------------------------------------------------------------------------------------
  2243                                  ;
  2244                                  ;	Routine:	DrawTextDialogBox
  2245                                  ;
  2246                                  ;	Description:	This routine opens a text-mode dialog box with an ASCII border.
  2247                                  ;
  2248                                  ;	In:		CL	upper left column (0-79)
  2249                                  ;			CH	upper left row (0-24)
  2250                                  ;			DL	column width, excluding border
  2251                                  ;			DH	row height, excluding border
  2252                                  ;			BH	color attribute
  2253                                  ;
  2254                                  ;-----------------------------------------------------------------------------------------------------------------------
  2255 000004B8 51                      DrawTextDialogBox	push	ecx						;save non-volatile regs
  2256 000004B9 56                      			push	esi						;
  2257 000004BA 57                      			push	edi						;
  2258 000004BB 06                      			push	es						;
  2259 000004BC 6A20                    			push	ESELCGA						;load CGA selector ...
  2260 000004BE 07                      			pop	es						;... into ES
  2261                                  ;
  2262                                  ;	Compute target display offset
  2263                                  ;
  2264 000004BF 31C0                    			xor	eax,eax						;zero register
  2265 000004C1 88E8                    			mov	al,ch						;row
  2266 000004C3 B4A0                    			mov	ah,ECONROWBYTES					;mulitplicand
  2267 000004C5 F6E4                    			mul	ah						;row offset
  2268 000004C7 00C8                    			add	al,cl						;add column
  2269 000004C9 80D400                  			adc	ah,0						;add overflow
  2270 000004CC 00C8                    			add	al,cl						;add column
  2271 000004CE 80D400                  			adc	ah,0						;add overflow
  2272 000004D1 89C7                    			mov	edi,eax						;target row offset
  2273                                  ;
  2274                                  ;	Display top border row
  2275                                  ;
  2276 000004D3 57                      			push	edi						;save target row offset
  2277 000004D4 88FC                    			mov	ah,bh						;attribute
  2278 000004D6 B0DA                    			mov	al,EASCIIBORDSGLUPRLFT				;upper-left single border
  2279 000004D8 66AB                    			stosw							;display character and attribute
  2280 000004DA B0C4                    			mov	al,EASCIIBORDSGLHORZ				;horizontal single border
  2281 000004DC 31C9                    			xor	ecx,ecx						;zero register
  2282 000004DE 88D1                    			mov	cl,dl						;width, excluding border
  2283 000004E0 F366AB                  			rep	stosw						;display horizontal border
  2284 000004E3 B0BF                    			mov	al,EASCIIBORDSGLUPRRGT				;upper-right single border
  2285 000004E5 66AB                    			stosw							;display character and attribute
  2286 000004E7 5F                      			pop	edi						;restore target row offset
  2287 000004E8 81C7A0000000            			add	edi,ECONROWBYTES				;next row
  2288                                  ;
  2289                                  ;	Display dialog box body rows
  2290                                  ;
  2291 000004EE 31C9                    			xor	ecx,ecx						;zero register
  2292 000004F0 88F1                    			mov	cl,dh						;height, excluding border
  2293 000004F2 51                      .10			push	ecx						;save remaining rows
  2294 000004F3 57                      			push	edi						;save target row offset
  2295 000004F4 88FC                    			mov	ah,bh						;attribute
  2296 000004F6 B0B3                    			mov	al,EASCIIBORDSGLVERT				;vertical single border
  2297 000004F8 66AB                    			stosw							;display character and attribute
  2298 000004FA B020                    			mov	al,EASCIISPACE					;space
  2299 000004FC 31C9                    			xor	ecx,ecx						;zero register
  2300 000004FE 88D1                    			mov	cl,dl						;width, excluding border
  2301 00000500 F366AB                  			rep	stosw						;display row
  2302 00000503 B0B3                    			mov	al,EASCIIBORDSGLVERT				;vertical single border
  2303 00000505 66AB                    			stosw							;display character and attribute
  2304 00000507 5F                      			pop	edi						;restore target row offset
  2305 00000508 81C7A0000000            			add	edi,ECONROWBYTES				;next row
  2306 0000050E 59                      			pop	ecx						;remaining rows
  2307 0000050F E2E1                    			loop	.10						;next row
  2308                                  ;
  2309                                  ;	Display bottom border row
  2310                                  ;
  2311 00000511 57                      			push	edi						;save target row offset
  2312 00000512 88FC                    			mov	ah,bh						;attribute
  2313 00000514 B0C0                    			mov	al,EASCIIBORDSGLLWRLFT				;lower-left single border
  2314 00000516 66AB                    			stosw							;display character and attribute
  2315 00000518 B0C4                    			mov	al,EASCIIBORDSGLHORZ				;horizontal single border
  2316 0000051A 31C9                    			xor	ecx,ecx						;zero register
  2317 0000051C 88D1                    			mov	cl,dl						;width, excluding border
  2318 0000051E F366AB                  			rep	stosw						;display horizontal border
  2319 00000521 B0D9                    			mov	al,EASCIIBORDSGLLWRRGT				;lower-right single border
  2320 00000523 66AB                    			stosw							;display character and attribute
  2321 00000525 5F                      			pop	edi						;restore target row offset
  2322 00000526 81C7A0000000            			add	edi,ECONROWBYTES				;next row
  2323                                  ;
  2324                                  ;	Restore and return
  2325                                  ;
  2326 0000052C 07                      			pop	es						;restore non-volatile regs
  2327 0000052D 5F                      			pop	edi						;
  2328 0000052E 5E                      			pop	esi						;
  2329 0000052F 59                      			pop	ecx						;
  2330 00000530 C3                      			ret							;return
  2331                                  ;=======================================================================================================================
  2332                                  ;
  2333                                  ;	Hardware Device Interupts
  2334                                  ;
  2335                                  ;	The next 16 interrupts are defined as our hardware interrupts. These interrupts vectors (20h-2Fh) are mapped to
  2336                                  ;	the hardware interrupts IRQ0-IRQF by the BIOS when the call to the BIOS is made invoking BIOS function 89h
  2337                                  ;	(BX=2028h).
  2338                                  ;
  2339                                  ;=======================================================================================================================
  2340                                  ;-----------------------------------------------------------------------------------------------------------------------
  2341                                  ;
  2342                                  ;	IRQ0	Clock Tick Interrupt
  2343                                  ;
  2344                                  ;	PC compatible systems contain or emulate the function of the Intel 8253 Programmable Interval Timer (PIT).
  2345                                  ;	Channel 0 of this chip decrements an internal counter to zero and then issues a hardware interrupt. The default
  2346                                  ;	rate at which IRQ0 occurs is approximately 18.2 times per second or, more accurately, 1,573,040 times per day.
  2347                                  ;
  2348                                  ;	Every time IRQ0 occurs, a counter at 40:6c is incremented. When the number of ticks reaches the maximum for one
  2349                                  ;	day, the counter is set to zero and the number of days counter at 40:70 is incremented.
  2350                                  ;
  2351                                  ;	This handler also decrements the floppy drive motor count at 40:40 if it is not zero. When this count reaches
  2352                                  ;	zero, the floppy disk motors are turned off.
  2353                                  ;
  2354                                  ;-----------------------------------------------------------------------------------------------------------------------
  2355                                  			menter	clocktick					;clock tick interrupt
  2355                              <1> ?%1 equ ($-$$)
  2356 00000531 50                      			push	eax						;save modified regs
  2357 00000532 52                      			push	edx						;
  2358 00000533 1E                      			push	ds						;
  2359                                  ;
  2360                                  ;	Update the clock tick count and the elapsed days as needed
  2361                                  ;
  2362 00000534 6A18                    			push	ESELDAT						;load OS data selector ...
  2363 00000536 1F                      			pop	ds						;... into data segment register
  2364 00000537 A16C040000              			mov	eax,[wdClockTicks]				;eax = clock ticks
  2365 0000053C 40                      			inc	eax						;increment clock ticks
  2366 0000053D 3DB0001800              			cmp	eax,EPITDAYTICKS				;clock ticks per day?
  2367 00000542 7208                    			jb	irq0.10						;no, skip ahead
  2368 00000544 FE0570040000            			inc	byte [wbClockDays]				;increment clock days
  2369 0000054A 31C0                    			xor	eax,eax						;reset clock ticks
  2370 0000054C A36C040000              irq0.10			mov	dword [wdClockTicks],eax			;save clock ticks
  2371                                  ;
  2372                                  ;	Decrement floppy disk motor timeout
  2373                                  ;
  2374 00000551 803D4004000000          			cmp	byte [wbFDCMotor],0				;floppy motor timeout?
  2375 00000558 741E                    			je	irq0.20						;yes, skip ahead
  2376 0000055A FE0D40040000            			dec	byte [wbFDCMotor]				;decrement motor timeout
  2377 00000560 7516                    			jnz	irq0.20						;skip ahead if non-zero
  2378                                  ;
  2379                                  ;	Turn off the floppy disk motor if appropriate
  2380                                  ;
  2381 00000562 FB                      			sti							;enable maskable interrupts
  2382 00000563 B603                    irq0.15 		mov	dh,EFDCPORTHI					;FDC controller port hi
  2383 00000565 B2F4                    			mov	dl,EFDCPORTLOSTAT				;FDC main status register
  2384 00000567 EC                      			in	al,dx						;FDC main status byte
  2385 00000568 A810                    			test	al,EFDCSTATBUSY					;test FDC main status for busy
  2386 0000056A 75F7                    			jnz	irq0.15						;wait while busy
  2387 0000056C B00C                    			mov	al,EFDCMOTOROFF					;motor-off / enable/ DMA setting
  2388 0000056E A23F040000              			mov	byte [wbFDCControl],al				;save motor-off setting
  2389 00000573 B603                    			mov	dh,EFDCPORTHI					;fdc port hi
  2390 00000575 B2F2                    			mov	dl,EFDCPORTLOOUT				;fdc digital output register
  2391 00000577 EE                      			out	dx,al						;turn motor off
  2392                                  ;
  2393                                  ;	Signal the end of the hardware interrupt
  2394                                  ;
  2395 00000578 E8E40D0000              irq0.20			call	PutPrimaryEndOfInt				;send end-of-interrupt to PIC
  2396                                  ;
  2397                                  ;	Determine if a task switch is appropriate
  2398                                  ;
  2399 0000057D 803D070A000000          			cmp	byte [wbInCriticalSection],0			;any task holding a critical section?
  2400 00000584 7535                    			jne	irq0.30						;yes, do not switch tasks
  2401 00000586 FE05060A0000            			inc	byte [wbTaskIndex]				;increment task queue index (0-255)
  2402 0000058C 0FB605060A0000          			movzx	eax,byte [wbTaskIndex]				;load task queue index
  2403 00000593 668B940000080000        			mov	dx,[wwTaskQueue+eax*2]				;next task selector
  2404 0000059B 660F00C8                			str	ax						;current task selector
  2405 0000059F 6639C2                  			cmp	dx,ax						;next task same is current task?
  2406 000005A2 7417                    			je	irq0.30						;yes, skip task switch
  2407                                  ;
  2408                                  ;	Switch task
  2409                                  ;
  2410 000005A4 06                      			push	es						;save extra segment register
  2411 000005A5 6A08                    			push	ESELGDT						;load GDT alias selector ...
  2412 000005A7 07                      			pop	es						;... into extra segment reg
  2413 000005A8 26806005FD              			and	byte [es:eax+5],0FDh				;reset task-busy bit of current task
  2414 000005AD 07                      			pop	es						;restore extra segment register
  2415 000005AE 668915040A0000          			mov	word [wwFarJumpSelector],dx			;set next task selector in jmp instr
  2416 000005B5 FF2D000A0000            			jmp	far [wdFarJumpEIP]				;jump to next task
  2417                                  ;
  2418                                  ;	Restore and return
  2419                                  ;
  2420 000005BB 1F                      irq0.30			pop	ds						;restore modified regs
  2421 000005BC 5A                      			pop	edx						;
  2422 000005BD 58                      			pop	eax						;
  2423 000005BE CF                      			iretd							;return
  2424                                  ;-----------------------------------------------------------------------------------------------------------------------
  2425                                  ;
  2426                                  ;	IRQ1	Keyboard Interrupt
  2427                                  ;
  2428                                  ;	This handler is called when an IRQ1 hardware interrupt occurs, caused by a keyboard event. The scan-code(s)
  2429                                  ;	corresponding to the keyboard event are read and message events are appended to the message queue. Since this
  2430                                  ;	code is called in response to a hardware interrupt, no task switch occurs. We need to preseve the state of
  2431                                  ;	ALL modified registers upon return. Note that keyboard messages are added to the keyboard focus message queue.
  2432                                  ;	This is a queue referenced in the global descriptor table and must always reference the message queue for the
  2433                                  ;	task that has the keyboard focus. To direct keyboard messages to another task, update the GDT descriptor to
  2434                                  ;	point to the message queue for that task.
  2435                                  ;
  2436                                  ;-----------------------------------------------------------------------------------------------------------------------
  2437                                  			menter	keyboard					;keyboard interrrupt
  2437                              <1> ?%1 equ ($-$$)
  2438 000005BF 50                      			push	eax						;save non-volatile regs
  2439 000005C0 53                      			push	ebx						;
  2440 000005C1 51                      			push	ecx						;
  2441 000005C2 56                      			push	esi						;
  2442 000005C3 1E                      			push	ds						;
  2443 000005C4 6A18                    			push	ESELDAT						;load OS data selector ...
  2444 000005C6 1F                      			pop	ds						;... into data segment register
  2445 000005C7 30C0                    			xor	al,al						;zero
  2446 000005C9 A22D0A0000              			mov	[wbConsoleScan0],al				;clear scan code 0
  2447 000005CE A22E0A0000              			mov	[wbConsoleScan1],al				;clear scan code 1
  2448 000005D3 A22F0A0000              			mov	[wbConsoleScan2],al				;clear scan code 2
  2449 000005D8 A2300A0000              			mov	[wbConsoleScan3],al				;clear scan code 3
  2450 000005DD A2310A0000              			mov	[wbConsoleScan4],al				;clear scan code 4
  2451 000005E2 A2320A0000              			mov	[wbConsoleScan5],al				;clear scan code 5
  2452 000005E7 B020                    			mov	al,' '						;space
  2453 000005E9 A2330A0000              			mov	[wbConsoleChar],al				;set character to space
  2454 000005EE B080                    			mov	al,EKEYFTIMEOUT					;controller timeout flag
  2455 000005F0 F6D0                    			not	al						;controller timeout mask
  2456 000005F2 20052C0A0000            			and	[wbConsoleStatus],al				;clear controller timeout flag
  2457 000005F8 8A1D2A0A0000            			mov	bl,[wbConsoleShift]				;shift flags
  2458 000005FE 8A3D2B0A0000            			mov	bh,[wbConsoleLock]				;lock flags
  2459 00000604 E80D0E0000              			call	WaitForKeyOutBuffer				;controller timeout?
  2460 00000609 0F8404020000            			jz	irq1.140					;yes, skip ahead
  2461 0000060F E460                    			in	al,EKEYBPORTDATA				;read scan code 0
  2462 00000611 A22D0A0000              			mov	[wbConsoleScan0],al				;save scan code 0
  2463 00000616 88C4                    			mov	ah,al						;copy scan code 0
  2464 00000618 B002                    			mov	al,EKEYFSHIFTLEFT				;left shift flag
  2465 0000061A 80FC2A                  			cmp	ah,EKEYBSHIFTLDOWN				;left shift key down code?
  2466 0000061D 0F84E0000000            			je	irq1.30						;yes, set flag
  2467 00000623 80FCAA                  			cmp	ah,EKEYBSHIFTLUP				;left shift key up code?
  2468 00000626 0F84DB000000            			je	irq1.40						;yes, reset flag
  2469 0000062C B010                    			mov	al,EKEYFSHIFTRIGHT				;right shift flag
  2470 0000062E 80FC36                  			cmp	ah,EKEYBSHIFTRDOWN				;right shift key down code?
  2471 00000631 0F84CC000000            			je	irq1.30						;yes, set flag
  2472 00000637 80FCB6                  			cmp	ah,EKEYBSHIFTRUP				;right shift key up code?
  2473 0000063A 0F84C7000000            			je	irq1.40						;yes, reset flag
  2474 00000640 B001                    			mov	al,EKEYFCTRLLEFT				;left control flag
  2475 00000642 80FC1D                  			cmp	ah,EKEYBCTRLDOWN				;control key down code?
  2476 00000645 0F84B8000000            			je	irq1.30						;yes, set flag
  2477 0000064B 80FC9D                  			cmp	ah,EKEYBCTRLUP					;control key up code?
  2478 0000064E 0F84B3000000            			je	irq1.40						;yes, reset flag
  2479 00000654 B004                    			mov	al,EKEYFALTLEFT					;left alt flag
  2480 00000656 80FC38                  			cmp	ah,EKEYBALTDOWN					;alt key down code?
  2481 00000659 0F84A4000000            			je	irq1.30						;yes, set flag
  2482 0000065F 80FCB8                  			cmp	ah,EKEYBALTUP					;alt key up code?
  2483 00000662 0F849F000000            			je	irq1.40						;yes, reset flag
  2484 00000668 B004                    			mov	al,EKEYFLOCKCAPS				;caps-lock flag
  2485 0000066A 80FC3A                  			cmp	ah,EKEYBCAPSDOWN				;caps-lock key down code?
  2486 0000066D 0F849A000000            			je	irq1.50						;yes, toggle lamps and flags
  2487 00000673 B002                    			mov	al,EKEYFLOCKNUM					;num-lock flag
  2488 00000675 80FC45                  			cmp	ah,EKEYBNUMDOWN					;num-lock key down code?
  2489 00000678 0F848F000000            			je	irq1.50						;yes, toggle lamps and flags
  2490 0000067E B001                    			mov	al,EKEYFLOCKSCROLL				;scroll-lock flag
  2491 00000680 80FC46                  			cmp	ah,EKEYBSCROLLDOWN				;scroll-lock key down code?
  2492 00000683 0F8484000000            			je	irq1.50						;yes, toggle lamps and flags
  2493 00000689 80FCE0                  			cmp	ah,EKEYBCODEEXT0				;extended scan code 0?
  2494 0000068C 0F8598000000            			jne	irq1.70 					;no, skip ahead
  2495 00000692 E87F0D0000              			call	WaitForKeyOutBuffer				;controller timeout?
  2496 00000697 0F8476010000            			jz	irq1.140					;yes, skip ahead
  2497 0000069D E460                    			in	al,EKEYBPORTDATA				;read scan code 1
  2498 0000069F A22E0A0000              			mov	[wbConsoleScan1],al				;save scan code 1
  2499 000006A4 88C4                    			mov	ah,al						;copy scan code 1
  2500 000006A6 B008                    			mov	al,EKEYFCTRLRIGHT				;right control flag
  2501 000006A8 80FC1D                  			cmp	ah,EKEYBCTRLDOWN				;control key down code?
  2502 000006AB 7456                    			je	irq1.30						;yes, set flag
  2503 000006AD 80FC9D                  			cmp	ah,EKEYBCTRLUP					;control key up code?
  2504 000006B0 7455                    			je	irq1.40						;yes, reset flag
  2505 000006B2 B020                    			mov	al,EKEYFALTRIGHT				;right alt flag
  2506 000006B4 80FC38                  			cmp	ah,EKEYBALTDOWN					;alt key down code?
  2507 000006B7 744A                    			je	irq1.30						;yes, set flag
  2508 000006B9 80FCB8                  			cmp	ah,EKEYBALTUP					;alt key up code?
  2509 000006BC 7449                    			je	irq1.40						;yes, reset flag
  2510 000006BE 80FC35                  			cmp	ah,EKEYBSLASH					;slash down code?
  2511 000006C1 0F84D2000000            			je	irq1.80						;yes, skip ahead
  2512 000006C7 80FCB5                  			cmp	ah,EKEYBSLASHUP					;slash up code?
  2513 000006CA 0F84C9000000            			je	irq1.80						;yes, skip ahead
  2514 000006D0 80FC2A                  			cmp	ah,EKEYBPRTSCRDOWN				;print screen down code?
  2515 000006D3 7405                    			je	irq1.10						;yes, continue
  2516 000006D5 80FCB7                  			cmp	ah,EKEYBPRTSCRUP				;print screen up code?
  2517 000006D8 7524                    			jne	irq1.20						;no, skip ahead
  2518 000006DA E8370D0000              irq1.10			call	WaitForKeyOutBuffer				;controller timeout?
  2519 000006DF 0F842E010000            			jz	irq1.140					;yes, skip ahead
  2520 000006E5 E460                    			in	al,EKEYBPORTDATA				;read scan code 2
  2521 000006E7 A22F0A0000              			mov	[wbConsoleScan2],al				;save scan code 2
  2522 000006EC E8250D0000              			call	WaitForKeyOutBuffer				;controller timeout?
  2523 000006F1 0F841C010000            			jz	irq1.140					;yes, skip ahead
  2524 000006F7 E460                    			in	al,EKEYBPORTDATA				;read scan code 3
  2525 000006F9 A2300A0000              			mov	[wbConsoleScan3],al				;read scan code 3
  2526 000006FE E918010000              irq1.20			jmp	irq1.150					;finish keyboard handling
  2527 00000703 08C3                    irq1.30			or	bl,al						;set shift flag
  2528 00000705 EB0D                    			jmp	irq1.60						;skip ahead
  2529 00000707 F6D0                    irq1.40			not	al						;convert flag to mask
  2530 00000709 20C3                    			and	bl,al						;reset shift flag
  2531 0000070B EB07                    			jmp	irq1.60						;skip ahead
  2532 0000070D 30C7                    irq1.50			xor	bh,al						;toggle lock flag
  2533 0000070F E8D30C0000              			call	SetKeyboardLamps				;update keyboard lamps
  2534 00000714 881D2A0A0000            irq1.60			mov	[wbConsoleShift],bl				;save shift flags
  2535 0000071A 883D2B0A0000            			mov	[wbConsoleLock],bh				;save lock flags
  2536 00000720 E8DC080000              			call	PutConsoleOIAShift				;update OIA indicators
  2537 00000725 E9F1000000              			jmp	irq1.150					;finish keyboard handling
  2538 0000072A 80FCE1                  irq1.70			cmp	ah,EKEYBCODEEXT1				;extended scan code 1?
  2539 0000072D 756A                    			jne	irq1.80						;no continue
  2540 0000072F E8E20C0000              			call	WaitForKeyOutBuffer				;controller timeout?
  2541 00000734 0F84D9000000            			jz	irq1.140					;yes, skip ahead
  2542 0000073A E460                    			in	al,EKEYBPORTDATA				;read scan code 1
  2543 0000073C A22E0A0000              			mov	[wbConsoleScan1],al				;save scan code 1
  2544 00000741 88C4                    			mov	ah,al						;copy scan code 1
  2545 00000743 80FC1D                  			cmp	ah,EKEYBPAUSEDOWN				;pause key down code?
  2546 00000746 0F85CF000000            			jne	irq1.150					;no, finish keyboard handling
  2547 0000074C E8C50C0000              			call	WaitForKeyOutBuffer				;controller timeout?
  2548 00000751 0F84BC000000            			jz	irq1.140					;yes, skip ahead
  2549 00000757 E460                    			in	al,EKEYBPORTDATA				;read scan code 2
  2550 00000759 A22F0A0000              			mov	[wbConsoleScan2],al				;save scan code 2
  2551 0000075E E8B30C0000              			call	WaitForKeyOutBuffer				;controller timeout?
  2552 00000763 0F84AA000000            			jz	irq1.140					;yes, skip ahead
  2553 00000769 E460                    			in	al,EKEYBPORTDATA				;read scan code 3
  2554 0000076B A2300A0000              			mov	[wbConsoleScan3],al				;save scan code 3
  2555 00000770 E8A10C0000              			call	WaitForKeyOutBuffer				;controller timeout?
  2556 00000775 0F8498000000            			jz	irq1.140					;yes, skip ahead
  2557 0000077B E460                    			in	al,EKEYBPORTDATA				;read scan code 4
  2558 0000077D A2310A0000              			mov	[wbConsoleScan4],al				;save scan code 4
  2559 00000782 E88F0C0000              			call	WaitForKeyOutBuffer				;controller timeout?
  2560 00000787 0F8486000000            			jz	irq1.140					;yes, skip ahead
  2561 0000078D E460                    			in	al,EKEYBPORTDATA				;read scan code 5
  2562 0000078F A2320A0000              			mov	[wbConsoleScan5],al				;save scan code 5
  2563 00000794 E982000000              			jmp	irq1.150					;continue
  2564 00000799 30C0                    irq1.80			xor	al,al						;assume no ASCII translation
  2565 0000079B F6C480                  			test	ah,EKEYBUP					;release code?
  2566 0000079E 7571                    			jnz	irq1.130					;yes, skip ahead
  2567 000007A0 BE[2B080000]            			mov	esi,tscan2ascii					;scan-to-ascii table address
  2568 000007A5 F6C312                  			test	bl,EKEYFSHIFT					;either shift key down?
  2569 000007A8 7405                    			jz	irq1.90						;no, skip ahead
  2570 000007AA BE[AB080000]            			mov	esi,tscan2shift					;scan-to-shifted table address
  2571 000007AF 0FB6CC                  irq1.90			movzx	ecx,ah						;scan code offset
  2572 000007B2 2E8A0431                			mov	al,[cs:ecx+esi]					;al = ASCII code
  2573 000007B6 F6C704                  			test	bh,EKEYFLOCKCAPS				;caps-lock on?
  2574 000007B9 7411                    			jz	irq1.100					;no skip ahead
  2575 000007BB 88C1                    			mov	cl,al						;copy ASCII code
  2576 000007BD 80E1DF                  			and	cl,EASCIICASEMASK				;clear case mask of copy
  2577 000007C0 80F941                  			cmp	cl,EASCIIUPPERA					;less than 'A'?
  2578 000007C3 7207                    			jb	irq1.100					;yes, skip ahead
  2579 000007C5 80F95A                  			cmp	cl,EASCIIUPPERZ					;greater than 'Z'?
  2580 000007C8 7702                    			ja	irq1.100					;yes, skip ahead
  2581 000007CA 3420                    			xor	al,EASCIICASE					;switch case
  2582 000007CC A2330A0000              irq1.100		mov	[wbConsoleChar],al				;save ASCII code
  2583 000007D1 BA00000041              irq1.110		mov	edx,EMSGKEYDOWN					;assume key-down event
  2584 000007D6 F6C480                  			test	ah,EKEYBUP					;release scan-code?
  2585 000007D9 7405                    			jz	irq1.120					;no, skip ahead
  2586 000007DB BA00000141              			mov	edx,EMSGKEYUP					;key-up event
  2587 000007E0 25FFFF0000              irq1.120		and	eax,0FFFFh					;clear high-order word
  2588 000007E5 09C2                    			or	edx,eax						;msg id and codes
  2589 000007E7 31C9                    			xor	ecx,ecx						;null param
  2590 000007E9 50                      			push	eax						;save codes
  2591 000007EA B880000000              			mov	eax,ESELKEYBOARDMQ				;keyboard focus message queue
  2592 000007EF E85A0A0000              			call	PutMessage					;put message to console
  2593 000007F4 58                      			pop	eax						;restore codes
  2594 000007F5 84C0                    			test	al,al						;ASCII translation?
  2595 000007F7 7418                    			jz	irq1.130					;no, skip ahead
  2596 000007F9 BA00000241              			mov	edx,EMSGKEYCHAR					;key-character event
  2597 000007FE 25FFFF0000              			and	eax,0FFFFh					;clear high-order word
  2598 00000803 09C2                    			or	edx,eax						;msg id and codes
  2599 00000805 31C9                    			xor	ecx,ecx						;null param
  2600 00000807 B880000000              			mov	eax,ESELKEYBOARDMQ				;keyboard focus message queue
  2601 0000080C E83D0A0000              			call	PutMessage					;put message to console
  2602 00000811 EB08                    irq1.130		jmp	irq1.150					;finish keyboard handling
  2603 00000813 B080                    irq1.140		mov	al,EKEYFTIMEOUT					;controller timeout flag
  2604 00000815 08052C0A0000            			or	[wbConsoleStatus],al				;set controller timeout flag
  2605 0000081B E87B080000              irq1.150		call	PutConsoleOIAChar				;update operator info area
  2606 00000820 E83C0B0000              			call	PutPrimaryEndOfInt				;send end-of-interrupt to PIC
  2607 00000825 1F                      			pop	ds						;restore non-volatile regs
  2608 00000826 5E                      			pop	esi						;
  2609 00000827 59                      			pop	ecx						;
  2610 00000828 5B                      			pop	ebx						;
  2611 00000829 58                      			pop	eax						;
  2612 0000082A CF                      			iretd							;return
  2613                                  ;-----------------------------------------------------------------------------------------------------------------------
  2614                                  ;	Scan-Code to ASCII Translation Tables
  2615                                  ;-----------------------------------------------------------------------------------------------------------------------
  2616 0000082B 001B313233343536        tscan2ascii		db	000h,01Bh,031h,032h,033h,034h,035h,036h		;00-07
  2617 00000833 373839302D3D0809        			db	037h,038h,039h,030h,02Dh,03Dh,008h,009h		;08-0F
  2618 0000083B 7177657274797569        			db	071h,077h,065h,072h,074h,079h,075h,069h		;10-17
  2619 00000843 6F705B5D0D006173        			db	06Fh,070h,05Bh,05Dh,00Dh,000h,061h,073h		;18-1F
  2620 0000084B 646667686A6B6C3B        			db	064h,066h,067h,068h,06Ah,06Bh,06Ch,03Bh		;20-27
  2621 00000853 2760005C7A786376        			db	027h,060h,000h,05Ch,07Ah,078h,063h,076h		;28-2F
  2622 0000085B 626E6D2C2E2F002A        			db	062h,06Eh,06Dh,02Ch,02Eh,02Fh,000h,02Ah		;30-37
  2623 00000863 0020000000000000        			db	000h,020h,000h,000h,000h,000h,000h,000h		;38-3F
  2624 0000086B 0000000000000037        			db	000h,000h,000h,000h,000h,000h,000h,037h		;40-47
  2625 00000873 38392D3435362B31        			db	038h,039h,02Dh,034h,035h,036h,02Bh,031h		;48-4F
  2626 0000087B 3233302E00000000        			db	032h,033h,030h,02Eh,000h,000h,000h,000h		;50-57
  2627 00000883 0000000000000000        			db	000h,000h,000h,000h,000h,000h,000h,000h		;58-5F
  2628 0000088B 0000000000000000        			db	000h,000h,000h,000h,000h,000h,000h,000h		;60-67
  2629 00000893 0000000000000000        			db	000h,000h,000h,000h,000h,000h,000h,000h		;68-6F
  2630 0000089B 0000000000000000        			db	000h,000h,000h,000h,000h,000h,000h,000h		;70-77
  2631 000008A3 0000000000000000        			db	000h,000h,000h,000h,000h,000h,000h,000h		;78-7F
  2632 000008AB 001B21402324255E        tscan2shift		db	000h,01Bh,021h,040h,023h,024h,025h,05Eh		;80-87
  2633 000008B3 262A28295F2B0800        			db	026h,02Ah,028h,029h,05Fh,02Bh,008h,000h		;88-8F
  2634 000008BB 5157455254595549        			db	051h,057h,045h,052h,054h,059h,055h,049h		;90-97
  2635 000008C3 4F507B7D0D004153        			db	04Fh,050h,07Bh,07Dh,00Dh,000h,041h,053h		;98-9F
  2636 000008CB 444647484A4B4C3A        			db	044h,046h,047h,048h,04Ah,04Bh,04Ch,03Ah		;A0-A7
  2637 000008D3 227E007C5A584356        			db	022h,07Eh,000h,07Ch,05Ah,058h,043h,056h		;A8-AF
  2638 000008DB 424E4D3C3E3F002A        			db	042h,04Eh,04Dh,03Ch,03Eh,03Fh,000h,02Ah		;B0-B7
  2639 000008E3 0020000000000000        			db	000h,020h,000h,000h,000h,000h,000h,000h		;B8-BF
  2640 000008EB 0000000000000037        			db	000h,000h,000h,000h,000h,000h,000h,037h		;C0-C7
  2641 000008F3 38392D3435362B31        			db	038h,039h,02Dh,034h,035h,036h,02Bh,031h		;C8-CF
  2642 000008FB 3233302E00000000        			db	032h,033h,030h,02Eh,000h,000h,000h,000h		;D0-D7
  2643 00000903 0000000000000000        			db	000h,000h,000h,000h,000h,000h,000h,000h		;D8-DF
  2644 0000090B 0000000000000000        			db	000h,000h,000h,000h,000h,000h,000h,000h		;E0-E7
  2645 00000913 0000000000000000        			db	000h,000h,000h,000h,000h,000h,000h,000h		;E8-EF
  2646 0000091B 0000000000000000        			db	000h,000h,000h,000h,000h,000h,000h,000h		;F0-F7
  2647 00000923 0000000000000000        			db	000h,000h,000h,000h,000h,000h,000h,000h		;F8-FF
  2648                                  ;-----------------------------------------------------------------------------------------------------------------------
  2649                                  ;
  2650                                  ;	IRQ2	Secondary 8259A Cascade Hardware Interrupt
  2651                                  ;
  2652                                  ;-----------------------------------------------------------------------------------------------------------------------
  2653                                  			menter	iochannel					;secondary 8259A cascade
  2653                              <1> ?%1 equ ($-$$)
  2654 0000092B 50                      			push	eax						;save modified regs
  2655 0000092C EB3F                    			jmp	hwint						;end interrupt and return
  2656                                  ;-----------------------------------------------------------------------------------------------------------------------
  2657                                  ;
  2658                                  ;	IRQ3	Communication Port 2 Hardware Interrupt
  2659                                  ;
  2660                                  ;-----------------------------------------------------------------------------------------------------------------------
  2661                                  			menter	com2						;serial port 2 interrupt
  2661                              <1> ?%1 equ ($-$$)
  2662 0000092E 50                      			push	eax						;save modified regs
  2663 0000092F EB3C                    			jmp	hwint						;end interrupt and return
  2664                                  ;-----------------------------------------------------------------------------------------------------------------------
  2665                                  ;
  2666                                  ;	IRQ4	Communication Port 1 Hardware Interrupt
  2667                                  ;
  2668                                  ;-----------------------------------------------------------------------------------------------------------------------
  2669                                  			menter	com1						;serial port 1 interrupt
  2669                              <1> ?%1 equ ($-$$)
  2670 00000931 50                      			push	eax						;save modified regs
  2671 00000932 EB39                    			jmp	hwint						;end interrupt and return
  2672                                  ;-----------------------------------------------------------------------------------------------------------------------
  2673                                  ;
  2674                                  ;	IRQ5	Parallel Port 2 Hardware Interrupt
  2675                                  ;
  2676                                  ;-----------------------------------------------------------------------------------------------------------------------
  2677                                  			menter	lpt2						;parallel port 2 interrupt
  2677                              <1> ?%1 equ ($-$$)
  2678 00000934 50                      			push	eax						;save modified regs
  2679 00000935 EB36                    			jmp	hwint						;end interrupt and return
  2680                                  ;-----------------------------------------------------------------------------------------------------------------------
  2681                                  ;
  2682                                  ;	IRQ6	Diskette Hardware Interrupt
  2683                                  ;
  2684                                  ;-----------------------------------------------------------------------------------------------------------------------
  2685                                  			menter	diskette					;floppy disk interrupt
  2685                              <1> ?%1 equ ($-$$)
  2686 00000937 50                      			push	eax						;save non-volatile regs
  2687 00000938 1E                      			push	ds						;
  2688 00000939 6A18                    			push	ESELDAT						;load OS data selector ...
  2689 0000093B 1F                      			pop	ds						;... into DS register
  2690 0000093C A03E040000              			mov	al,[wbFDCStatus]				;al = FDC calibration status
  2691 00000941 0C80                    			or	al,10000000b					;set IRQ flag
  2692 00000943 A23E040000              			mov	[wbFDCStatus],al				;update FDC calibration status
  2693 00000948 1F                      			pop	ds						;restore non-volatile regs
  2694 00000949 EB22                    			jmp	hwint						;end primary PIC interrupt
  2695                                  ;-----------------------------------------------------------------------------------------------------------------------
  2696                                  ;
  2697                                  ;	IRQ7	Parallel Port 1 Hardware Interrupt
  2698                                  ;
  2699                                  ;-----------------------------------------------------------------------------------------------------------------------
  2700                                  			menter	lpt1						;parallel port 1 interrupt
  2700                              <1> ?%1 equ ($-$$)
  2701 0000094B 50                      			push	eax						;save modified regs
  2702 0000094C EB1F                    			jmp	hwint						;end interrupt and return
  2703                                  ;-----------------------------------------------------------------------------------------------------------------------
  2704                                  ;
  2705                                  ;	IRQ8	Real-time Clock Hardware Interrupt
  2706                                  ;
  2707                                  ;-----------------------------------------------------------------------------------------------------------------------
  2708                                  			menter	rtclock						;real-time clock interrupt
  2708                              <1> ?%1 equ ($-$$)
  2709 0000094E 50                      			push	eax						;save modified regs
  2710 0000094F EB15                    			jmp	hwwint						;end interrupt and return
  2711                                  ;-----------------------------------------------------------------------------------------------------------------------
  2712                                  ;
  2713                                  ;	IRQ9	CGA Vertical Retrace Hardware Interrupt
  2714                                  ;
  2715                                  ;-----------------------------------------------------------------------------------------------------------------------
  2716                                  			menter	retrace						;CGA vertical retrace interrupt
  2716                              <1> ?%1 equ ($-$$)
  2717 00000951 50                      			push	eax						;save modified regs
  2718 00000952 EB12                    			jmp	hwwint						;end interrupt and return
  2719                                  ;-----------------------------------------------------------------------------------------------------------------------
  2720                                  ;
  2721                                  ;	IRQ10	Reserved Hardware Interrupt
  2722                                  ;
  2723                                  ;-----------------------------------------------------------------------------------------------------------------------
  2724                                  			menter	irq10						;reserved
  2724                              <1> ?%1 equ ($-$$)
  2725 00000954 50                      			push	eax						;save modified regs
  2726 00000955 EB0F                    			jmp	hwwint						;end interrupt and return
  2727                                  ;-----------------------------------------------------------------------------------------------------------------------
  2728                                  ;
  2729                                  ;	IRQ11	Reserved Hardware Interrupt
  2730                                  ;
  2731                                  ;-----------------------------------------------------------------------------------------------------------------------
  2732                                  			menter	irq11						;reserved
  2732                              <1> ?%1 equ ($-$$)
  2733 00000957 50                      			push	eax						;save modified regs
  2734 00000958 EB0C                    			jmp	hwwint						;end interrupt and return
  2735                                  ;-----------------------------------------------------------------------------------------------------------------------
  2736                                  ;
  2737                                  ;	IRQ12	PS/2 Mouse Hardware Interrupt
  2738                                  ;
  2739                                  ;-----------------------------------------------------------------------------------------------------------------------
  2740                                  			menter	ps2mouse					;PS/2 mouse interrupt
  2740                              <1> ?%1 equ ($-$$)
  2741 0000095A 50                      			push	eax						;save modified regs
  2742 0000095B EB09                    			jmp	hwwint						;end interrupt and return
  2743                                  ;-----------------------------------------------------------------------------------------------------------------------
  2744                                  ;
  2745                                  ;	IRQ13	Coprocessor Hardware Interrupt
  2746                                  ;
  2747                                  ;-----------------------------------------------------------------------------------------------------------------------
  2748                                  			menter	coprocessor					;coprocessor interrupt
  2748                              <1> ?%1 equ ($-$$)
  2749 0000095D 50                      			push	eax						;save modified regs
  2750 0000095E EB06                    			jmp	hwwint						;end interrupt and return
  2751                                  ;-----------------------------------------------------------------------------------------------------------------------
  2752                                  ;
  2753                                  ;	IRQ14	Fixed Disk Hardware Interrupt
  2754                                  ;
  2755                                  ;-----------------------------------------------------------------------------------------------------------------------
  2756                                  			menter	fixeddisk					;fixed disk interrupt
  2756                              <1> ?%1 equ ($-$$)
  2757 00000960 50                      			push	eax						;save modified regs
  2758 00000961 EB03                    			jmp	hwwint						;end interrupt and return
  2759                                  ;-----------------------------------------------------------------------------------------------------------------------
  2760                                  ;
  2761                                  ;	IRQ15	Reserved Hardware Interrupt
  2762                                  ;
  2763                                  ;-----------------------------------------------------------------------------------------------------------------------
  2764                                  			menter	irq15						;reserved
  2764                              <1> ?%1 equ ($-$$)
  2765 00000963 50                      			push	eax						;save modified regs
  2766 00000964 EB00                    			jmp	hwwint						;end interrupt and return
  2767                                  ;-----------------------------------------------------------------------------------------------------------------------
  2768                                  ;
  2769                                  ;	Exit from hardware interrupt
  2770                                  ;
  2771                                  ;-----------------------------------------------------------------------------------------------------------------------
  2772 00000966 E8FC090000              hwwint			call	PutSecondaryEndOfInt				;send EOI to secondary PIC
  2773 0000096B EB05                    			jmp	hwint90						;skip ahead
  2774 0000096D E8EF090000              hwint			call	PutPrimaryEndOfInt				;send EOI to primary PIC
  2775 00000972 58                      hwint90			pop	eax						;restore modified regs
  2776 00000973 CF                      			iretd							;return from interrupt
  2777                                  ;-----------------------------------------------------------------------------------------------------------------------
  2778                                  ;
  2779                                  ;	INT 30h Operating System Software Service Interrupt
  2780                                  ;
  2781                                  ;	Interrupt 30h is used by our operating system as an entry point for many commonly-used subroutines reusable by
  2782                                  ;	any task. These routines include low-level i/o functions that shield applications from having to handle
  2783                                  ;	device-specific communications. On entry to this interrupt, AL contains a function number that is used to load
  2784                                  ;	the entry address of the specific function from a table.
  2785                                  ;
  2786                                  ;-----------------------------------------------------------------------------------------------------------------------
  2787                                  			menter	svc
  2787                              <1> ?%1 equ ($-$$)
  2788 00000974 3C1D                    			cmp	al,maxtsvc					;is our function out of range?
  2789 00000976 730D                    			jae	svc90						;yes, skip ahead
  2790 00000978 0FB6C0                  			movzx	eax,al						;function
  2791 0000097B C1E002                  			shl	eax,2						;offset into table
  2792 0000097E 2EFF90[86090000]        			call	dword [cs:tsvc+eax]				;far call to indirect address
  2793 00000985 CF                      svc90			iretd							;return from interrupt
  2794                                  ;-----------------------------------------------------------------------------------------------------------------------
  2795                                  ;
  2796                                  ;	Service Request Table
  2797                                  ;
  2798                                  ;
  2799                                  ;	These tsvce macros expand to define an address vector table for the service request interrupt (int 30h).
  2800                                  ;
  2801                                  ;-----------------------------------------------------------------------------------------------------------------------
  2802                                  tsvc			tsvce	AllocateMemory					;allocate memory block
  2802                              <1> tsvc :
  2802                              <1> e%1 equ ($-tsvc)/4
  2802 00000986 [FA090000]          <1>  dd %1
  2803                                  			tsvce	ClearConsoleScreen				;clear console screen
  2803                              <1> e%1 equ ($-tsvc)/4
  2803 0000098A [AA120000]          <1>  dd %1
  2804                                  			tsvce	CompareMemory					;compare memory
  2804                              <1> e%1 equ ($-tsvc)/4
  2804 0000098E [920E0000]          <1>  dd %1
  2805                                  			tsvce	CopyMemory					;copy memory
  2805                              <1> e%1 equ ($-tsvc)/4
  2805 00000992 [AF0E0000]          <1>  dd %1
  2806                                  			tsvce	DecimalToUnsigned				;convert decimal string to unsigned integer
  2806                              <1> e%1 equ ($-tsvc)/4
  2806 00000996 [FD110000]          <1>  dd %1
  2807                                  			tsvce	FreeMemory					;free memory block
  2807                              <1> e%1 equ ($-tsvc)/4
  2807 0000099A [180B0000]          <1>  dd %1
  2808                                  			tsvce	GetConsoleString				;get string input
  2808                              <1> e%1 equ ($-tsvc)/4
  2808 0000099E [EE0E0000]          <1>  dd %1
  2809                                  			tsvce	HexadecimalToUnsigned				;convert hexadecimal string to unsigned integer
  2809                              <1> e%1 equ ($-tsvc)/4
  2809 000009A2 [30120000]          <1>  dd %1
  2810                                  			tsvce	IsLeapYear					;return ecx=1 if leap year
  2810                              <1> e%1 equ ($-tsvc)/4
  2810 000009A6 [630C0000]          <1>  dd %1
  2811                                  			tsvce	PlaceCursor					;place the cursor at the current loc
  2811                              <1> e%1 equ ($-tsvc)/4
  2811 000009AA [37130000]          <1>  dd %1
  2812                                  			tsvce	PutConsoleString				;tty output asciiz string
  2812                              <1> e%1 equ ($-tsvc)/4
  2812 000009AE [C10E0000]          <1>  dd %1
  2813                                  			tsvce	PutDateString					;put MM/DD/YYYY string
  2813                              <1> e%1 equ ($-tsvc)/4
  2813 000009B2 [7E0C0000]          <1>  dd %1
  2814                                  			tsvce	PutDayString					;put DD string
  2814                              <1> e%1 equ ($-tsvc)/4
  2814 000009B6 [BF0C0000]          <1>  dd %1
  2815                                  			tsvce	PutHourString					;put hh string
  2815                              <1> e%1 equ ($-tsvc)/4
  2815 000009BA [CD0C0000]          <1>  dd %1
  2816                                  			tsvce	PutMinuteString					;put mm string
  2816                              <1> e%1 equ ($-tsvc)/4
  2816 000009BE [DB0C0000]          <1>  dd %1
  2817                                  			tsvce	PutMonthString					;put MM string
  2817                              <1> e%1 equ ($-tsvc)/4
  2817 000009C2 [E90C0000]          <1>  dd %1
  2818                                  			tsvce	PutMonthNameString				;put name(MM) string
  2818                              <1> e%1 equ ($-tsvc)/4
  2818 000009C6 [F70C0000]          <1>  dd %1
  2819                                  			tsvce	PutSecondString					;put ss string
  2819                              <1> e%1 equ ($-tsvc)/4
  2819 000009CA [1B0D0000]          <1>  dd %1
  2820                                  			tsvce	PutTimeString					;put HH:MM:SS string
  2820                              <1> e%1 equ ($-tsvc)/4
  2820 000009CE [280D0000]          <1>  dd %1
  2821                                  			tsvce	PutWeekdayString				;put weekday string
  2821                              <1> e%1 equ ($-tsvc)/4
  2821 000009D2 [5D0D0000]          <1>  dd %1
  2822                                  			tsvce	PutWeekdayNameString				;put name(weekday) string
  2822                              <1> e%1 equ ($-tsvc)/4
  2822 000009D6 [6B0D0000]          <1>  dd %1
  2823                                  			tsvce	PutYearString					;put YYYY string
  2823                              <1> e%1 equ ($-tsvc)/4
  2823 000009DA [8E0D0000]          <1>  dd %1
  2824                                  			tsvce	ReadRealTimeClock				;get real-time clock date and time
  2824                              <1> e%1 equ ($-tsvc)/4
  2824 000009DE [6D130000]          <1>  dd %1
  2825                                  			tsvce	ResetSystem					;reset system using 8042 chip
  2825                              <1> e%1 equ ($-tsvc)/4
  2825 000009E2 [D8130000]          <1>  dd %1
  2826                                  			tsvce	SetConsoleString				;set console string
  2826                              <1> e%1 equ ($-tsvc)/4
  2826 000009E6 [11130000]          <1>  dd %1
  2827                                  			tsvce	UnsignedToDecimalString 			;convert unsigned integer to decimal string
  2827                              <1> e%1 equ ($-tsvc)/4
  2827 000009EA [39110000]          <1>  dd %1
  2828                                  			tsvce	UnsignedToHexadecimal				;convert unsigned integer to hexadecimal string
  2828                              <1> e%1 equ ($-tsvc)/4
  2828 000009EE [DD110000]          <1>  dd %1
  2829                                  			tsvce	UpperCaseString					;upper-case string
  2829                              <1> e%1 equ ($-tsvc)/4
  2829 000009F2 [780E0000]          <1>  dd %1
  2830                                  			tsvce	Yield						;halt until interrupt
  2830                              <1> e%1 equ ($-tsvc)/4
  2830 000009F6 [7B0F0000]          <1>  dd %1
  2831                                  maxtsvc			equ	($-tsvc)/4					;function out of range
  2832                                  ;-----------------------------------------------------------------------------------------------------------------------
  2833                                  ;
  2834                                  ;	Service Request Macros
  2835                                  ;
  2836                                  ;	These macros provide positional parameterization of service request calls.
  2837                                  ;
  2838                                  ;-----------------------------------------------------------------------------------------------------------------------
  2839                                  %macro			allocateMemory 1
  2840                                  			mov	ecx,%1						;bytes to allocate
  2841                                  			mov	al,eAllocateMemory				;allocate memory fn.
  2842                                  			int	_svc						;invoke OS service
  2843                                  %endmacro
  2844                                  %macro			clearConsoleScreen 0
  2845                                  			mov	al,eClearConsoleScreen				;function code
  2846                                  			int	_svc						;invoke OS service
  2847                                  %endmacro
  2848                                  %macro			compareMemory 0
  2849                                  			mov	al,eCompareMemory				;function code
  2850                                  			int	_svc						;invoke OS service
  2851                                  %endmacro
  2852                                  %macro			compareMemory 3
  2853                                  			mov	edx,%1						;first memory address
  2854                                  			mov	ebx,%2						;second memory address
  2855                                  			mov	ecx,%3						;length
  2856                                  			mov	al,eCompareMemory				;function code
  2857                                  			int	_svc						;invoke OS service
  2858                                  %endmacro
  2859                                  %macro			copyMemory 3
  2860                                  			mov	edx,%1						;first memory address
  2861                                  			mov	ebx,%2						;second memory address
  2862                                  			mov	ecx,%3						;length
  2863                                  			mov	al,eCopyMemory					;function code
  2864                                  			int	_svc						;invoke OS service
  2865                                  %endmacro
  2866                                  %macro			decimalToUnsigned 0
  2867                                  			mov	al,eDecimalToUnsigned				;function code
  2868                                  			int	_svc						;invoke OS servie
  2869                                  %endmacro
  2870                                  %macro			freeMemory 1
  2871                                  			mov	edx,%1						;address of memory block
  2872                                  			mov	al,eFreeMemory					;function code
  2873                                  			int	_svc						;invoke OS service
  2874                                  %endmacro
  2875                                  %macro			getConsoleString 4
  2876                                  			mov	edx,%1						;buffer address
  2877                                  			mov	ecx,%2						;max characters
  2878                                  			mov	bh,%3						;echo indicator
  2879                                  			mov	bl,%4						;terminator
  2880                                  			mov	al,eGetConsoleString				;function code
  2881                                  			int	_svc						;invoke OS service
  2882                                  %endmacro
  2883                                  %macro			hexadecimalToUnsigned 0
  2884                                  			mov	al,eHexadecimalToUnsigned			;function code
  2885                                  			int	_svc						;invoke OS service
  2886                                  %endmacro
  2887                                  %macro			isLeapYear 1
  2888                                  			mov	ebx,%1						;DATETIME addr
  2889                                  			mov	al,eIsLeapYear					;function code
  2890                                  			int	_svc						;invoke OS service
  2891                                  %endmacro
  2892                                  %macro			placeCursor 0
  2893                                  			mov	al,ePlaceCursor					;function code
  2894                                  			int	_svc						;invoke OS service
  2895                                  %endmacro
  2896                                  %macro			putConsoleString 1
  2897                                  			mov	edx,%1						;string address
  2898                                  			mov	al,ePutConsoleString				;function code
  2899                                  			int	_svc						;invoke OS service
  2900                                  %endmacro
  2901                                  %macro			putDateString 0
  2902                                  			mov	al,ePutDateString				;function code
  2903                                  			int	_svc						;invoke OS service
  2904                                  %endmacro
  2905                                  %macro			putDateString 2
  2906                                  			mov	ebx,%1						;DATETIME addr
  2907                                  			mov	edx,%2						;output buffer addr
  2908                                  			mov	al,ePutDateString				;function code
  2909                                  			int	_svc						;invoke OS service
  2910                                  %endmacro
  2911                                  %macro			putDayString 2
  2912                                  			mov	ebx,%1						;DATETIME addr
  2913                                  			mov	edx,%2						;output buffer addr
  2914                                  			mov	al,ePutDayString				;function code
  2915                                  			int	_svc						;invoke OS service
  2916                                  %endmacro
  2917                                  %macro			putHourString 2
  2918                                  			mov	ebx,%1						;DATETIME addr
  2919                                  			mov	edx,%2						;output buffer addr
  2920                                  			mov	al,ePutHourString				;function code
  2921                                  			int	_svc						;invoke OS service
  2922                                  %endmacro
  2923                                  %macro			putMinuteString 2
  2924                                  			mov	ebx,%1						;DATETIME addr
  2925                                  			mov	edx,%2						;output buffer addr
  2926                                  			mov	al,ePutMinuteString				;function code
  2927                                  			int	_svc						;invoke OS service
  2928                                  %endmacro
  2929                                  %macro			putMonthString 2
  2930                                  			mov	ebx,%1						;DATETIME addr
  2931                                  			mov	edx,%2						;output buffer addr
  2932                                  			mov	al,ePutMonthString				;function code
  2933                                  			int	_svc						;invoke OS service
  2934                                  %endmacro
  2935                                  %macro			putMonthNameString 2
  2936                                  			mov	ebx,%1						;DATETIME addr
  2937                                  			mov	edx,%2						;output buffer addr
  2938                                  			mov	al,ePutMonthNameString				;function code
  2939                                  			int	_svc						;invoke OS service
  2940                                  %endmacro
  2941                                  %macro			putSecondString 2
  2942                                  			mov	ebx,%1						;DATETIME addr
  2943                                  			mov	edx,%2						;output buffer addr
  2944                                  			mov	al,ePutSecondString				;function code
  2945                                  			int	_svc						;invoke OS service
  2946                                  %endmacro
  2947                                  %macro			putTimeString 0
  2948                                  			mov	al,ePutTimeString				;function code
  2949                                  			int	_svc						;invoke OS service
  2950                                  %endmacro
  2951                                  %macro			putTimeString 2
  2952                                  			mov	ebx,%1						;DATETIME addr
  2953                                  			mov	edx,%2						;output buffer addr
  2954                                  			mov	al,ePutTimeString				;function code
  2955                                  			int	_svc						;invoke OS service
  2956                                  %endmacro
  2957                                  %macro			putWeekdayString 2
  2958                                  			mov	ebx,%1						;DATETIME addr
  2959                                  			mov	edx,%2						;output buffer addr
  2960                                  			mov	al,ePutWeekdayString				;function code
  2961                                  			int	_svc						;invoke OS service
  2962                                  %endmacro
  2963                                  %macro			putWeekdayNameString 2
  2964                                  			mov	ebx,%1						;DATETIME addr
  2965                                  			mov	edx,%2						;output buffer addr
  2966                                  			mov	al,ePutWeekdayNameString			;function code
  2967                                  			int	_svc						;invoke OS service
  2968                                  %endmacro
  2969                                  %macro			putYearString 2
  2970                                  			mov	ebx,%1						;DATETIME addr
  2971                                  			mov	edx,%2						;output buffer addr
  2972                                  			mov	al,ePutYearString				;function code
  2973                                  			int	_svc						;invoke OS service
  2974                                  %endmacro
  2975                                  %macro			readRealTimeClock 0
  2976                                  			mov	al,eReadRealTimeClock				;function code
  2977                                  			int	_svc						;invoke OS service
  2978                                  %endmacro
  2979                                  %macro			readRealTimeClock 1
  2980                                  			mov	ebx,%1						;DATETIME addr
  2981                                  			mov	al,eReadRealTimeClock				;function code
  2982                                  			int	_svc						;invoke OS service
  2983                                  %endmacro
  2984                                  %macro			resetSystem 0
  2985                                  			mov	al,eResetSystem					;AL = system reset fn.
  2986                                  			int	_svc						;invoke OS service
  2987                                  %endmacro
  2988                                  %macro			setConsoleString 0
  2989                                  			mov	al,eSetConsoleString				;function code
  2990                                  			int	_svc						;invoke OS service
  2991                                  %endmacro
  2992                                  %macro			unsignedToDecimalString 0
  2993                                  			mov	al,eUnsignedToDecimalString			;function code
  2994                                  			int	_svc						;invoke OS service
  2995                                  %endmacro
  2996                                  %macro			unsignedToHexadecimal 0
  2997                                  			mov	al,eUnsignedToHexadecimal			;function code
  2998                                  			int	_svc						;invoke OS service
  2999                                  %endmacro
  3000                                  %macro			upperCaseString 0
  3001                                  			mov	al,eUpperCaseString				;function code
  3002                                  			int	_svc						;invoke OS service
  3003                                  %endmacro
  3004                                  %macro			yield 0
  3005                                  			mov	al,eYield					;function code
  3006                                  			int	_svc						;invoke OS service
  3007                                  %endmacro
  3008                                  ;=======================================================================================================================
  3009                                  ;
  3010                                  ;	Kernel Function Library
  3011                                  ;
  3012                                  ;=======================================================================================================================
  3013                                  ;=======================================================================================================================
  3014                                  ;
  3015                                  ;	Memory Helper Routines
  3016                                  ;
  3017                                  ;	AllocateMemory
  3018                                  ;	FreeMemory
  3019                                  ;
  3020                                  ;=======================================================================================================================
  3021                                  ;-----------------------------------------------------------------------------------------------------------------------
  3022                                  ;
  3023                                  ;	Routine:	AllocateMemory
  3024                                  ;
  3025                                  ;	Description:	This routine allocates a memory block for the given task.
  3026                                  ;
  3027                                  ;	In:		ECX	bytes of memory to allocate
  3028                                  ;
  3029                                  ;	Out:		EAX	!0	address of user portion of newly allocated memory block
  3030                                  ;				0	unable to allocate memory
  3031                                  ;
  3032                                  ;-----------------------------------------------------------------------------------------------------------------------
  3033 000009FA 53                      AllocateMemory		push	ebx						;save non-volatile regs
  3034 000009FB 51                      			push	ecx						;
  3035 000009FC 56                      			push	esi						;
  3036 000009FD 1E                      			push	ds						;
  3037                                  ;
  3038                                  ;	Address kernel memory structures
  3039                                  ;
  3040 000009FE 6A18                    			push	ESELDAT						;load OS data GDT selector ...
  3041 00000A00 1F                      			pop	ds						;... into data segment reg
  3042 00000A01 BE0C0A0000              			mov	esi,wsMemRoot					;memory root structure address
  3043                                  ;
  3044                                  ;	Set requested size to minimum block size if requested size is too small.
  3045                                  ;
  3046 00000A06 81F900010000            			cmp	ecx,EMEMMINSIZE					;is requested size too small?
  3047 00000A0C 7305                    			jae	.10						;no, branch
  3048 00000A0E B900010000              			mov	ecx,EMEMMINSIZE					;set requested size to minimum
  3049 00000A13 83C120                  .10			add	ecx,EMEMBLOCKLEN				;add header block length
  3050                                  ;
  3051                                  ;	Find the first free memory block large enough to satisfy the request.
  3052                                  ;
  3053 00000A16 8B4608                  			mov	eax,[esi+MEMROOT.firstfree]			;first free block ptr
  3054 00000A19 85C0                    .20			test	eax,eax						;end of free block chain?
  3055 00000A1B 0F84F2000000            			jz	.220						;yes, branch
  3056 00000A21 3B4804                  			cmp	ecx,[eax+MEMBLOCK.bytes]			;free block big enough?
  3057 00000A24 7605                    			jbe	.30						;yes, branch
  3058 00000A26 8B4018                  			mov	eax,[eax+MEMBLOCK.nextblock]			;next free block addr
  3059 00000A29 EBEE                    			jmp	.20						;continue
  3060                                  ;-----------------------------------------------------------------------------------------------------------------------
  3061                                  ;
  3062                                  ;	Address the previous and next free memory blocks.
  3063                                  ;
  3064 00000A2B 8B581C                  .30			mov	ebx,[eax+MEMBLOCK.previousblock]		;previous free block addr
  3065 00000A2E 8B5018                  			mov	edx,[eax+MEMBLOCK.nextblock]			;next free block addr
  3066                                  ;
  3067                                  ;	Remove the free memory block from the forward free memory block chain.
  3068                                  ;
  3069 00000A31 85DB                    			test	ebx,ebx						;any previous free memory block?
  3070 00000A33 7405                    			jz	.40						;no, branch
  3071 00000A35 895318                  			mov	[ebx+MEMBLOCK.nextblock],edx			;remove free block from forwrad chain
  3072 00000A38 EB03                    			jmp	.50						;continue
  3073 00000A3A 895608                  .40			mov	[esi+MEMROOT.firstfree],edx			;next free is now also the first free
  3074                                  ;
  3075                                  ;	Remove the free memory block from the reverse free memory block chain.
  3076                                  ;
  3077 00000A3D 85D2                    .50			test	edx,edx						;any next free memory block?
  3078 00000A3F 7405                    			jz	.60						;no, branch
  3079 00000A41 895A1C                  			mov	[edx+MEMBLOCK.previousblock],ebx		;remove free block from reverse chain
  3080 00000A44 EB03                    			jmp	.70						;continue
  3081 00000A46 895E0C                  .60			mov	[esi+MEMROOT.lastfree],ebx			;previous free is now also the last free
  3082                                  ;-----------------------------------------------------------------------------------------------------------------------
  3083                                  ;
  3084                                  ;	Determine if the free memory block can be split.
  3085                                  ;
  3086 00000A49 8B5804                  .70			mov	ebx,[eax+MEMBLOCK.bytes]			;size of free memory block
  3087 00000A4C 29CB                    			sub	ebx,ecx						;subtract requested memory size
  3088 00000A4E 81FB00010000            			cmp	ebx,EMEMMINSIZE					;remaining block can stand alone?
  3089 00000A54 7263                    			jb	.150						;no, branch
  3090                                  ;
  3091                                  ;	We know that our block can be split to create a new free memory block. We update the size of our free memory
  3092                                  ;	block to the requested memory size. We update the next contiguous block pointer to point just past the end
  3093                                  ;	of the requested memory size.
  3094                                  ;
  3095 00000A56 894804                  			mov	[eax+MEMBLOCK.bytes],ecx			;shorten memory block size
  3096 00000A59 89C2                    			mov	edx,eax						;memory block address
  3097 00000A5B 01CA                    			add	edx,ecx						;address new new next contig block
  3098 00000A5D 8B4810                  			mov	ecx,[eax+MEMBLOCK.nextcontig]			;next contig block address
  3099 00000A60 895010                  			mov	[eax+MEMBLOCK.nextcontig],edx			;update next contig block address
  3100                                  ;
  3101                                  ;	If there is a next contiguous block, we update that memory block's previous contig pointer to point to the new
  3102                                  ;	free block we are splitting off. If there is no next contiguous block, we update the last contig block pointer.
  3103                                  ;
  3104 00000A63 E305                    			jecxz	.80						;no next contig, branch
  3105 00000A65 895114                  			mov	[ecx+MEMBLOCK.previouscontig],edx		;update previous contig pointer
  3106 00000A68 EB03                    			jmp	.90						;continue
  3107 00000A6A 895604                  .80			mov	[esi+MEMROOT.lastcontig],edx			;update last contig pointer
  3108                                  ;
  3109                                  ;	Now that the contig block pointers have been updated, we initialize the new free block members.
  3110                                  ;
  3111 00000A6D 895A04                  .90			mov	[edx+MEMBLOCK.bytes],ebx			;set the block size
  3112 00000A70 894A10                  			mov	[edx+MEMBLOCK.nextcontig],ecx			;set the next contig block addr
  3113 00000A73 894214                  			mov	[edx+MEMBLOCK.previouscontig],eax		;set the previous contig block addr
  3114 00000A76 BB46524545              			mov	ebx,EMEMFREECODE				;free memory signature
  3115 00000A7B 891A                    			mov	[edx+MEMBLOCK.signature],ebx			;set the block signature
  3116 00000A7D 31DB                    			xor	ebx,ebx						;zero register
  3117 00000A7F 895A0C                  			mov	[edx+MEMBLOCK.reserved],ebx			;set reserved
  3118 00000A82 895A08                  			mov	[edx+MEMBLOCK.owner],ebx			;set the owner
  3119                                  ;
  3120                                  ;	Find the proper location in the free block chain for the new free block
  3121                                  ;
  3122 00000A85 8B5A04                  			mov	ebx,[edx+MEMBLOCK.bytes]			;free block size
  3123 00000A88 8B4E08                  			mov	ecx,[esi+MEMROOT.firstfree]			;first free block addr
  3124 00000A8B E30A                    .100			jecxz	.110						;branch if at end of chain
  3125 00000A8D 3B5904                  			cmp	ebx,[ecx+MEMBLOCK.bytes]			;new block smaller or equal?
  3126 00000A90 7605                    			jbe	.110						;yes, branch
  3127 00000A92 8B4918                  			mov	ecx,[ecx+MEMBLOCK.nextblock]			;next free block addr
  3128 00000A95 EBF4                    			jmp	.100						;continue
  3129                                  ;
  3130                                  ;	Having found the proper location for our new free block, we store the address of the following free block, or
  3131                                  ;	zero if our new free block is larger than any other, as our next free block. Then, we take the address of our
  3132                                  ;	next block's previous block or the global last-free block as our new previous block and update the previous
  3133                                  ;	block of hte next block, if there is one.
  3134                                  ;
  3135 00000A97 894A18                  .110			mov	[edx+MEMBLOCK.nextblock],ecx			;set the new free block's next ptr
  3136 00000A9A 8B5E0C                  			mov	ebx,[esi+MEMROOT.lastfree]			;last free block addr
  3137 00000A9D E308                    			jecxz	.120						;branch if no next block
  3138 00000A9F 8B591C                  			mov	ebx,[ecx+MEMBLOCK.previousblock]		;next block's previous block
  3139 00000AA2 89511C                  			mov	[ecx+MEMBLOCK.previousblock],edx		;set the next block's previous block
  3140 00000AA5 EB03                    			jmp	.130						;continue
  3141 00000AA7 89560C                  .120			mov	[esi+MEMROOT.lastfree],edx			;set the new last free block
  3142                                  ;
  3143                                  ;	Store our previous block pointer. If we have a previous free block, update that block's next block pointer to
  3144                                  ;	point to the new block. Since the new block may now be the first or last user block, we update the first and/or
  3145                                  ;	last user block pointers if necessary.
  3146                                  ;
  3147 00000AAA 895A1C                  .130			mov	[edx+MEMBLOCK.previousblock],ebx		;set the previous block pointer
  3148 00000AAD 85DB                    			test	ebx,ebx						;is there a previous block?
  3149 00000AAF 7405                    			jz	.140						;no, branch
  3150 00000AB1 895318                  			mov	[ebx+MEMBLOCK.nextblock],edx			;set the previous block's next ptr
  3151 00000AB4 EB03                    			jmp	.150						;continue
  3152 00000AB6 895608                  .140			mov	[esi+MEMROOT.firstfree],edx			;set the new first free ptr
  3153                                  ;
  3154                                  ;	Update the newly allocated block's owner and signature.
  3155                                  ;
  3156 00000AB9 BA55534552              .150			mov	edx,EMEMUSERCODE				;user memory signature
  3157 00000ABE 8910                    			mov	[eax+MEMBLOCK.signature],edx			;set the block signature
  3158 00000AC0 31D2                    			xor	edx,edx						;zero register
  3159 00000AC2 660F00CA                			str	dx						;load the task state register
  3160 00000AC6 895008                  			mov	[eax+MEMBLOCK.owner],edx			;set the block owner
  3161                                  ;
  3162                                  ;	Remove the allocated block from the free block chain and insert it into the user block chain.
  3163                                  ;
  3164 00000AC9 8B4E10                  			mov	ecx,[esi+MEMROOT.firsttask]			;first task block
  3165 00000ACC E323                    .160			jecxz	.180						;branch if at end of chain
  3166 00000ACE 3B5108                  			cmp	edx,[ecx+MEMBLOCK.owner]			;does this block belong to the task?
  3167 00000AD1 721E                    			jb	.180						;branch if block belongs to next task
  3168 00000AD3 7405                    			je	.170						;branch if block belongs to this task
  3169 00000AD5 8B4918                  			mov	ecx,[ecx+MEMBLOCK.nextblock]			;next task block
  3170 00000AD8 EBF2                    			jmp	.160						;continue
  3171                                  ;
  3172                                  ;	We have found the start of our task's user block chain or the start of the next task's user block chain. If we
  3173                                  ;	have found the next task's chain, then we have no other user memory for this task and we can simply add the
  3174                                  ;	block here. If we are at the start of our task's user block chain, then we need to further seek for the proper
  3175                                  ;	place to insert the block.
  3176                                  ;
  3177 00000ADA 8B5004                  .170			mov	edx,[eax+MEMBLOCK.bytes]			;size of block in bytes
  3178 00000ADD 3B5104                  			cmp	edx,[ecx+MEMBLOCK.bytes]			;less or equal to chain block?
  3179 00000AE0 760F                    			jbe	.180						;yes, branch
  3180 00000AE2 8B4918                  			mov	ecx,[ecx+MEMBLOCK.nextblock]			;next chain block address
  3181 00000AE5 85C9                    			test	ecx,ecx						;end of chain?
  3182 00000AE7 7408                    			jz	.180						;yes, branch
  3183 00000AE9 8B5008                  			mov	edx,[eax+MEMBLOCK.owner]			;owning task
  3184 00000AEC 3B5108                  			cmp	edx,[ecx+MEMBLOCK.owner]			;same task?
  3185 00000AEF 74E9                    			je	.170						;yes, continue search
  3186                                  ;
  3187                                  ;	We have found the proper place in our task's user-block chain to insert our new user block. It may also be the
  3188                                  ;	end of the user-block chain. To insert our new user block, first we update the next-block pointer. Then, we load
  3189                                  ;	the next-block's previous-block pointer or the global last-user block pointer if we have no next-block. If we
  3190                                  ;	do have a previous-block, we update that block's next-block pointer.
  3191                                  ;
  3192 00000AF1 894818                  .180			mov	[eax+MEMBLOCK.nextblock],ecx			;set the next task block
  3193 00000AF4 8B5E14                  			mov	ebx,[esi+MEMROOT.lasttask]			;last task block
  3194 00000AF7 E308                    			jecxz	.190						;branch if no next-task block
  3195 00000AF9 8B591C                  			mov	ebx,[ecx+MEMBLOCK.previousblock]		;next-task's previous-task block
  3196 00000AFC 89411C                  			mov	[ecx+MEMBLOCK.previousblock],eax		;update next-task block's previous-task
  3197 00000AFF EB03                    			jmp	.200						;continue
  3198 00000B01 894614                  .190			mov	[esi+MEMROOT.lasttask],eax			;new block is the last user-block
  3199                                  ;
  3200                                  ;	Now wes tore our previous-block pointer and, if we have a previous-free block, we update that block's next-
  3201                                  ;	block pointer to point to our block. Since our block may now be the first or last user-block, we update the
  3202                                  ;	global first and/or last user-block pointers if necessary.
  3203                                  ;
  3204 00000B04 89581C                  .200			mov	[eax+MEMBLOCK.previousblock],ebx		;set the previous task block
  3205 00000B07 85DB                    			test	ebx,ebx						;do we have a previous task block?
  3206 00000B09 7405                    			jz	.210						;no, branch
  3207 00000B0B 894318                  			mov	[ebx+MEMBLOCK.nextblock],eax			;set previous-block's next-task block
  3208 00000B0E EB03                    			jmp	.220						;continue
  3209 00000B10 894610                  .210			mov	[esi+MEMROOT.firsttask],eax			;new block is the first user-block
  3210                                  ;
  3211                                  ;	Restore registers and return to caller.
  3212                                  ;
  3213 00000B13 1F                      .220			pop	ds						;restore non-volatie regs
  3214 00000B14 5E                      			pop	esi						;
  3215 00000B15 59                      			pop	ecx						;
  3216 00000B16 5B                      			pop	ebx						;
  3217 00000B17 C3                      			ret							;return
  3218                                  ;-----------------------------------------------------------------------------------------------------------------------
  3219                                  ;
  3220                                  ;	Routine:	FreeMemory
  3221                                  ;
  3222                                  ;	Description:	This routine frees a memory block for the given task. The address provided in EDX points to the
  3223                                  ;			memory block header. The memory block must be USER memory, not a FREE memory block. If the block
  3224                                  ;			is adjacent to a contiguous FREE memory block, then the blocks are merged. The residual FREE
  3225                                  ;			memory is repositioned in the FREE memory block chain according to size. The user portion of the
  3226                                  ;			block, following the block header, is reset (wiped) with the memory wipe value.
  3227                                  ;
  3228                                  ;	In:		EDX	memory block to free, relative to ESELDAT
  3229                                  ;
  3230                                  ;	Out:		EAX	-1	invalid memory block
  3231                                  ;				0	memory block freed
  3232                                  ;
  3233                                  ;-----------------------------------------------------------------------------------------------------------------------
  3234 00000B18 53                      FreeMemory		push	ebx						;save non-volatile regs
  3235 00000B19 51                      			push	ecx						;
  3236 00000B1A 56                      			push	esi						;
  3237 00000B1B 57                      			push	edi						;
  3238 00000B1C 1E                      			push	ds						;
  3239 00000B1D 06                      			push	es						;
  3240                                  ;
  3241                                  ;	Address the root memory structure
  3242                                  ;
  3243 00000B1E 6A18                    			push	ESELDAT
  3244 00000B20 07                      			pop	es
  3245 00000B21 6A18                    			push	ESELDAT						;load OS data selector ...
  3246 00000B23 1F                      			pop	ds						;... into data segment reg
  3247 00000B24 BE0C0A0000              			mov	esi,wsMemRoot					;memory root structure
  3248 00000B29 89D7                    			mov	edi,edx						;memory block address
  3249                                  ;
  3250                                  ;	If the block is FREE, return success. Otherwise, if it is not USER, return with error.
  3251                                  ;
  3252 00000B2B 31C0                    			xor	eax,eax						;indicate success
  3253 00000B2D 813F46524545            			cmp	dword [edi+MEMBLOCK.signature],EMEMFREECODE	;is the block FREE?
  3254 00000B33 0F8415010000            			je	.240						;yes, branch
  3255 00000B39 48                      			dec	eax						;indicate failure
  3256 00000B3A 813F55534552            			cmp	dword [edi+MEMBLOCK.signature],EMEMUSERCODE	;is the block USER?
  3257 00000B40 0F8508010000            			jne	.240						;no, branch
  3258                                  ;-----------------------------------------------------------------------------------------------------------------------
  3259                                  ;
  3260                                  ;	Unlink the USER memory block.
  3261                                  ;
  3262                                  ;-----------------------------------------------------------------------------------------------------------------------
  3263                                  ;
  3264                                  ;	Set the block signature. Reset owner.
  3265                                  ;
  3266 00000B46 C70746524545            			mov	dword [edi+MEMBLOCK.signature],EMEMFREECODE	;set FREE block signature
  3267 00000B4C 31C0                    			xor	eax,eax						;zero register
  3268 00000B4E 894708                  			mov	[edi+MEMBLOCK.owner],eax			;zero block owner
  3269                                  ;
  3270                                  ;	Wipe user area.
  3271                                  ;
  3272 00000B51 57                      			push	edi						;save block address
  3273 00000B52 8B4F04                  			mov	ecx,[edi+MEMBLOCK.bytes]			;block size
  3274 00000B55 83E920                  			sub	ecx,EMEMBLOCKLEN				;subtract header size
  3275 00000B58 83C720                  			add	edi,EMEMBLOCKLEN				;point to user area
  3276 00000B5B B000                    			mov	al,EMEMWIPEBYTE					;memory wipe byte
  3277 00000B5D F3AA                    			rep	stosb						;clear memory
  3278 00000B5F 5F                      			pop	edi						;restore block address
  3279                                  ;
  3280                                  ;	Address the preceding and following USER memory blocks
  3281                                  ;
  3282 00000B60 8B5F1C                  			mov	ebx,[edi+MEMBLOCK.previousblock]		;previous block pointer
  3283 00000B63 8B4F18                  			mov	ecx,[edi+MEMBLOCK.nextblock]			;next block pointer
  3284                                  ;
  3285                                  ;	If a USER block precedes this block, update that block's next pointer. Otherwise, update the first task
  3286                                  ;	pointer to point to the USER block following this block.
  3287                                  ;
  3288 00000B66 85DB                    			test	ebx,ebx						;is there a previous block?
  3289 00000B68 7405                    			jz	.10						;no, branch
  3290 00000B6A 894B18                  			mov	[ebx+MEMBLOCK.nextblock],ecx			;update previous block's next pointer
  3291 00000B6D EB03                    			jmp	.20						;continue
  3292 00000B6F 894E10                  .10			mov	[esi+MEMROOT.firsttask],ecx			;update first USER pointer
  3293                                  ;
  3294                                  ;	If a USER block follows this block, update that block's previous pointer. Otherwise, update the last task
  3295                                  ;	pointer to point to the USER block preceding this block.
  3296                                  ;
  3297 00000B72 E305                    .20			jecxz	.30						;branch if no next block
  3298 00000B74 89591C                  			mov	[ecx+MEMBLOCK.previousblock],ebx		;update next block's previous pointer
  3299 00000B77 EB03                    			jmp	.40						;continue
  3300 00000B79 895E14                  .30			mov	[esi+MEMROOT.lasttask],ebx			;update last USER pointer
  3301                                  ;-----------------------------------------------------------------------------------------------------------------------
  3302                                  ;
  3303                                  ;	Merge with a previous contiguous FREE memory block.
  3304                                  ;
  3305                                  ;-----------------------------------------------------------------------------------------------------------------------
  3306                                  ;
  3307                                  ;	Address the preceding and following contiguous memory blocks.
  3308                                  ;
  3309 00000B7C 8B5F14                  .40			mov	ebx,[edi+MEMBLOCK.previouscontig]		;previous contiguous block ptr
  3310 00000B7F 8B4F10                  			mov	ecx,[edi+MEMBLOCK.nextcontig]			;next contiguous block ptr
  3311                                  ;
  3312                                  ;	Verify we have a previous contiguous FREE block.
  3313                                  ;
  3314 00000B82 85DB                    			test	ebx,ebx						;is there a previous block?
  3315 00000B84 7442                    			jz	.100						;no, branch
  3316 00000B86 813B46524545            			cmp	dword [ebx+MEMBLOCK.signature],EMEMFREECODE	;is the previous block FREE?
  3317 00000B8C 753A                    			jne	.100						;no, branch
  3318                                  ;
  3319                                  ;	Update adjacent block's contiguous pointers.
  3320                                  ;
  3321 00000B8E 894B10                  			mov	[ebx+MEMBLOCK.nextcontig],ecx			;update previous contig's next contig
  3322 00000B91 E305                    			jecxz	.50						;branch if no next contiguous block
  3323 00000B93 895914                  			mov	[ecx+MEMBLOCK.previouscontig],ebx		;update next congit's previous contig
  3324 00000B96 EB03                    			jmp	.60						;continue
  3325 00000B98 895E04                  .50			mov	[esi+MEMROOT.lastcontig],ebx			;update last contig pointer
  3326                                  ;
  3327                                  ;	Update the size of the merged FREE block.
  3328                                  ;
  3329 00000B9B 8B4704                  .60			mov	eax,[edi+MEMBLOCK.bytes]			;current block size
  3330 00000B9E 014304                  			add	[ebx+MEMBLOCK.bytes],eax			;update previous block's size
  3331                                  ;
  3332                                  ;	Having merged our new free block into the previous free block, make the previous free block the current block
  3333                                  ;
  3334 00000BA1 B920000000              			mov	ecx,EMEMBLOCKLEN				;block header length
  3335 00000BA6 B000                    			mov	al,EMEMWIPEBYTE					;memory wipe byte
  3336 00000BA8 F3AA                    			rep	stosb						;clear memory header
  3337 00000BAA 89DF                    			mov	edi,ebx						;current block is now previous block
  3338                                  ;-----------------------------------------------------------------------------------------------------------------------
  3339                                  ;
  3340                                  ;	Unlink the previous contiguous FREE memory block
  3341                                  ;
  3342                                  ;-----------------------------------------------------------------------------------------------------------------------
  3343                                  ;
  3344                                  ;	Address the preceding and following USER memory blocks
  3345                                  ;
  3346 00000BAC 8B5F1C                  			mov	ebx,[edi+MEMBLOCK.previousblock]		;previous block pointer
  3347 00000BAF 8B4F18                  			mov	ecx,[edi+MEMBLOCK.nextblock]			;next block pointer
  3348                                  ;
  3349                                  ;	Update the previous block's next-block pointer if there is a previous block. Otherwise, update the first free
  3350                                  ;	block pointer.
  3351                                  ;
  3352 00000BB2 85DB                    			test	ebx,ebx						;is there a previous block?
  3353 00000BB4 7405                    			jz	.70						;no, branch
  3354 00000BB6 894B18                  			mov	[ebx+MEMBLOCK.nextblock],ecx			;update previous block's next pointer
  3355 00000BB9 EB03                    			jmp	.80						;branch
  3356 00000BBB 894E08                  .70			mov	[esi+MEMROOT.firstfree],ecx			;update first FREE block pointer
  3357                                  ;
  3358                                  ;	Update the next block's previous-block pointer if there is a next block. Otherwise, update the last free block
  3359                                  ;	pointer.
  3360                                  ;
  3361 00000BBE E305                    .80			jecxz	.90						;branch if no next block
  3362 00000BC0 89591C                  			mov	[ecx+MEMBLOCK.previousblock],ebx		;update next block's previous pointer
  3363 00000BC3 EB03                    			jmp	.100						;continue
  3364 00000BC5 895E0C                  .90			mov	[esi+MEMROOT.lastfree],ebx			;update last FREE block pointer
  3365                                  ;-----------------------------------------------------------------------------------------------------------------------
  3366                                  ;
  3367                                  ;	Merge with a following contiguous FREE memory block.
  3368                                  ;
  3369                                  ;-----------------------------------------------------------------------------------------------------------------------
  3370                                  ;
  3371                                  ;	Verify we have a following contiguous FREE block.
  3372                                  ;
  3373 00000BC8 8B4F10                  .100			mov	ecx,[edi+MEMBLOCK.nextcontig]			;next contiguous block ptr
  3374 00000BCB E34B                    			jecxz	.170						;branch if no next contiguous block
  3375 00000BCD 813946524545            			cmp	dword [ecx+MEMBLOCK.signature],EMEMFREECODE	;is the next-contiguous block free?
  3376 00000BD3 7543                    			jne	.170						;no, branch
  3377                                  ;
  3378                                  ;	Add the size of the following adjacent FREE block to this block's size.
  3379                                  ;
  3380 00000BD5 8B4104                  			mov	eax,[ecx+MEMBLOCK.bytes]			;next contiguous (free) block size
  3381 00000BD8 014704                  			add	[edi+MEMBLOCK.bytes],eax			;add size to this block's size
  3382                                  ;
  3383                                  ;	Unlink the following contiguous FREE block from the contiguous block chain.
  3384                                  ;
  3385 00000BDB 8B4110                  			mov	eax,[ecx+MEMBLOCK.nextcontig]			;following block's next-contig ptr
  3386 00000BDE 894710                  			mov	[edi+MEMBLOCK.nextcontig],eax			;update this block's next-contig ptr
  3387 00000BE1 85C0                    			test	eax,eax						;does a block follow the next contig blk
  3388 00000BE3 7405                    			jz	.110						;no, branch
  3389 00000BE5 897814                  			mov	[eax+MEMBLOCK.previouscontig],edi		;update following block's prev contig
  3390 00000BE8 EB03                    			jmp	.120						;continue
  3391 00000BEA 897E04                  .110			mov	[esi+MEMROOT.lastcontig],edi			;update last contig block ptr
  3392                                  ;-----------------------------------------------------------------------------------------------------------------------
  3393                                  ;
  3394                                  ;	Unlink the following contiguous FREE memory block
  3395                                  ;
  3396                                  ;-----------------------------------------------------------------------------------------------------------------------
  3397                                  ;
  3398                                  ;	Unlink the following adjacent FREE block from the FREE block chain.
  3399                                  ;
  3400 00000BED 57                      .120			push	edi						;save this block
  3401 00000BEE 89CF                    			mov	edi,ecx						;next contiguous block
  3402 00000BF0 51                      			push	ecx						;save next contiguous block
  3403                                  ;
  3404                                  ;	Address the preceding and following USER memory blocks
  3405                                  ;
  3406 00000BF1 8B5F1C                  			mov	ebx,[edi+MEMBLOCK.previousblock]		;next contig's previous block pointer
  3407 00000BF4 8B4F18                  			mov	ecx,[edi+MEMBLOCK.nextblock]			;next contig's next block pointer
  3408                                  ;
  3409                                  ;	Update the previous block's next-block pointer if there is a previous block. Otherwise, update the first free
  3410                                  ;	block pointer.
  3411                                  ;
  3412 00000BF7 85DB                    			test	ebx,ebx						;is there a previous block?
  3413 00000BF9 7405                    			jz	.130						;no, branch
  3414 00000BFB 894B18                  			mov	[ebx+MEMBLOCK.nextblock],ecx			;update next contig's prev blk next-ptr
  3415 00000BFE EB03                    			jmp	.140						;branch
  3416 00000C00 894E08                  .130			mov	[esi+MEMROOT.firstfree],ecx			;update first FREE block pointer
  3417                                  ;
  3418                                  ;	Update the next block's previous-block pointer if there is a next block. Otherwise, update the last free block
  3419                                  ;	pointer.
  3420                                  ;
  3421 00000C03 E305                    .140			jecxz	.150						;branch if no next block
  3422 00000C05 89591C                  			mov	[ecx+MEMBLOCK.previousblock],ebx		;update next contig's next blk prev-ptr
  3423 00000C08 EB03                    			jmp	.160						;continue
  3424 00000C0A 895E0C                  .150			mov	[esi+MEMROOT.lastfree],ebx			;update last FREE block pointer
  3425                                  ;
  3426                                  ;	Clear next contiguous block's header
  3427                                  ;
  3428 00000C0D 5F                      .160			pop	edi						;next congiguous block pointer
  3429 00000C0E B920000000              			mov	ecx,EMEMBLOCKLEN				;memory block header length
  3430 00000C13 B000                    			mov	al,EMEMWIPEBYTE					;memory wipe byte
  3431 00000C15 F3AA                    			rep	stosb						;clear memory header
  3432 00000C17 5F                      			pop	edi						;this block's pointer
  3433                                  ;-----------------------------------------------------------------------------------------------------------------------
  3434                                  ;
  3435                                  ;	Insert the final FREE block back into the block chain.
  3436                                  ;
  3437                                  ;-----------------------------------------------------------------------------------------------------------------------
  3438                                  ;
  3439                                  ;	Walk the FREE memory chain until a block is found that is larger than or equal in size to the block being
  3440                                  ;	inserted. The block being inserted will be inserted before that block or after the last block found if none
  3441                                  ;	all are smaller in size.
  3442                                  ;
  3443 00000C18 8B5F04                  .170			mov	ebx,[edi+MEMBLOCK.bytes]			;size of block
  3444 00000C1B 8B4E08                  			mov	ecx,[esi+MEMROOT.firstfree]			;first free block ptr
  3445 00000C1E E30A                    .180			jecxz	.190						;exit if no ptr
  3446 00000C20 3B5904                  			cmp	ebx,[ecx+MEMBLOCK.bytes]			;next block bigger?
  3447 00000C23 7205                    			jb	.190						;yes, branch
  3448 00000C25 8B4918                  			mov	ecx,[ecx+MEMBLOCK.nextblock]			;next free memory block
  3449 00000C28 EBF4                    			jmp	.180						;continue
  3450                                  ;
  3451                                  ;	Set the next-block pointer. Determine the previous-block, which may be the last FREE block if we found no
  3452                                  ;	larger free block. Update the next block's previous block pointer.
  3453                                  ;
  3454 00000C2A 894F18                  .190			mov	[edi+MEMBLOCK.nextblock],ecx			;set the next block ptr
  3455 00000C2D 8B5E0C                  			mov	ebx,[esi+MEMROOT.lastfree]			;assume all blocks smaller
  3456 00000C30 E308                    			jecxz	.200						;branch if no block found
  3457 00000C32 8B591C                  			mov	ebx,[ecx+MEMBLOCK.previousblock]		;next block's previous block ptr
  3458 00000C35 89791C                  			mov	[ecx+MEMBLOCK.previousblock],edi		;update next block's previous ptr
  3459 00000C38 EB03                    			jmp	.210						;continue
  3460 00000C3A 897E0C                  .200			mov	[esi+MEMROOT.lastfree],edi			;this block is now the last free
  3461                                  ;
  3462                                  ;	Set our previous block pointer to either the previous pointer of the found block or the last free block.
  3463                                  ;	If there is no previous block pointer, then this block now the first FREE block. Otherwise update that block's
  3464                                  ;	next pointer.
  3465                                  ;
  3466 00000C3D 895F1C                  .210			mov	[edi+MEMBLOCK.previousblock],ebx		;set the previous block ptr
  3467 00000C40 85DB                    			test	ebx,ebx						;do we have a previous block?
  3468 00000C42 7405                    			jz	.220						;no, branch
  3469 00000C44 897B18                  			mov	[ebx+MEMBLOCK.nextblock],edi			;update previous block's next block ptr
  3470 00000C47 EB03                    			jmp	.230						;continue
  3471 00000C49 897E08                  .220			mov	[esi+MEMROOT.firstfree],edi			;update first free ptr
  3472                                  ;
  3473                                  ;	The memory free has completed.
  3474                                  ;
  3475 00000C4C 31C0                    .230			xor	eax,eax						;indicate success
  3476                                  ;
  3477                                  ;	Restore and return.
  3478                                  ;
  3479 00000C4E 07                      .240			pop	es						;restore non-volatile regs
  3480 00000C4F 1F                      			pop	ds						;
  3481 00000C50 5F                      			pop	edi						;
  3482 00000C51 5E                      			pop	esi						;
  3483 00000C52 59                      			pop	ecx						;
  3484 00000C53 5B                      			pop	ebx						;
  3485 00000C54 C3                      			ret							;return
  3486                                  ;=======================================================================================================================
  3487                                  ;
  3488                                  ;	Date and Time Helper Routines
  3489                                  ;
  3490                                  ;	GetYear
  3491                                  ;	IsLeapYear
  3492                                  ;	PutDateString
  3493                                  ;	PutDayString
  3494                                  ;	PutHourString
  3495                                  ;	PutMinuteString
  3496                                  ;	PutMonthString
  3497                                  ;	PutMonthNameString
  3498                                  ;	PutSecondString
  3499                                  ;	PutTimeString
  3500                                  ;	PutWeekdayString
  3501                                  ;	PutWeekdayNameString
  3502                                  ;	PutYearString
  3503                                  ;
  3504                                  ;=======================================================================================================================
  3505                                  ;-----------------------------------------------------------------------------------------------------------------------
  3506                                  ;
  3507                                  ;	Routine:	GetYear
  3508                                  ;
  3509                                  ;	Description:	Return the four-digit year (century * 100 + year of century)
  3510                                  ;
  3511                                  ;	In:		DS:EBX	DATETIME address
  3512                                  ;
  3513                                  ;	Out:		ECX	year
  3514                                  ;
  3515                                  ;-----------------------------------------------------------------------------------------------------------------------
  3516 00000C55 0FB64B07                GetYear			movzx	ecx,byte [ebx+DATETIME.century]			;century
  3517 00000C59 6BC964                  			imul	ecx,100						;century * 100
  3518 00000C5C 0FB64306                			movzx	eax,byte [ebx+DATETIME.year]			;year of century
  3519 00000C60 01C1                    			add	ecx,eax						;year (YYYY)
  3520 00000C62 C3                      			ret							;return
  3521                                  ;-----------------------------------------------------------------------------------------------------------------------
  3522                                  ;
  3523                                  ;	Routine:	IsLeapYear
  3524                                  ;
  3525                                  ;	Description:	This routine returns an indicator if the current year is a leap year.
  3526                                  ;
  3527                                  ;	In:		DS:EBX	DATETIME ADDRESS
  3528                                  ;
  3529                                  ;	Out:		ECX	0 = not a leap year
  3530                                  ;				1 = leap year
  3531                                  ;
  3532                                  ;-----------------------------------------------------------------------------------------------------------------------
  3533 00000C63 E8EDFFFFFF              IsLeapYear		call	GetYear						;ECX = YYYY
  3534 00000C68 89C8                    			mov	eax,ecx						;EAX = YYYY
  3535 00000C6A 31C9                    			xor	ecx,ecx						;assume not leap year
  3536 00000C6C A803                    			test	al,00000011b					;multiple of four?
  3537 00000C6E 750D                    			jnz	.no						;no, branch
  3538 00000C70 B264                    			mov	dl,100						;divisor
  3539 00000C72 F6F2                    			div	dl						;divide by 100
  3540 00000C74 84E4                    			test	ah,ah						;multiple of 100?
  3541 00000C76 7504                    			jnz	.yes						;yes, branch
  3542 00000C78 A803                    			test	al,00000011b					;multiple of 400?
  3543 00000C7A 7501                    			jnz	.no						;no, branch
  3544 00000C7C 41                      .yes			inc	ecx						;indicate leap
  3545 00000C7D C3                      .no			ret							;
  3546                                  ;-----------------------------------------------------------------------------------------------------------------------
  3547                                  ;
  3548                                  ;	Routine:	PutDateString
  3549                                  ;
  3550                                  ;	Description:	This routine returns an ASCIIZ mm/dd/yyyy string at ds:edx from the date in the DATETIME
  3551                                  ;			structure at ds:ebx.
  3552                                  ;
  3553                                  ;	In:		DS:EBX	DATETIME address
  3554                                  ;			DS:EDX	output buffer address
  3555                                  ;
  3556                                  ;-----------------------------------------------------------------------------------------------------------------------
  3557 00000C7E 51                      PutDateString		push	ecx						;save non-volatile regs
  3558 00000C7F 57                      			push	edi						;
  3559 00000C80 06                      			push	es						;
  3560 00000C81 1E                      			push	ds						;store data selector ...
  3561 00000C82 07                      			pop	es						;... in extra segment reg
  3562 00000C83 89D7                    			mov	edi,edx						;output buffer address
  3563 00000C85 B10A                    			mov	cl,10						;divisor
  3564 00000C87 BA30302F00              			mov	edx,0002F3030h					;ASCIIZ "00/" (reversed)
  3565 00000C8C 0FB64305                			movzx	eax,byte [ebx+DATETIME.month]			;month
  3566 00000C90 F6F1                    			div	cl						;AH = rem; AL = quotient
  3567 00000C92 09D0                    			or	eax,edx						;apply ASCII zones and delimiter
  3568 00000C94 FC                      			cld							;forward strings
  3569 00000C95 AB                      			stosd							;store "mm/"nul
  3570 00000C96 4F                      			dec	edi						;address of terminator
  3571 00000C97 0FB64304                			movzx	eax,byte [ebx+DATETIME.day]			;day
  3572 00000C9B F6F1                    			div	cl						;AH = rem; AL = quotient
  3573 00000C9D 09D0                    			or	eax,edx						;apply ASCII zones and delimiter
  3574 00000C9F AB                      			stosd							;store "dd/"nul
  3575 00000CA0 4F                      			dec	edi						;address of terminator
  3576 00000CA1 0FB64307                			movzx	eax,byte [ebx+DATETIME.century]			;century
  3577 00000CA5 F6F1                    			div	cl						;AH = rem; AL = quotient
  3578 00000CA7 09D0                    			or	eax,edx						;apply ASCII zones and delimiter
  3579 00000CA9 AB                      			stosd							;store "cc/"null
  3580 00000CAA 4F                      			dec	edi						;address of terminator
  3581 00000CAB 4F                      			dec	edi						;address of delimiter
  3582 00000CAC 0FB64306                			movzx	eax,byte [ebx+DATETIME.year]			;year (yy)
  3583 00000CB0 F6F1                    			div	cl						;AH = rem; AL = quotient
  3584 00000CB2 09D0                    			or	eax,edx						;apply ASCII zones and delimiter
  3585 00000CB4 AA                      			stosb							;store quotient
  3586 00000CB5 88E0                    			mov	al,ah						;remainder
  3587 00000CB7 AA                      			stosb							;store remainder
  3588 00000CB8 30C0                    			xor	al,al						;null terminator
  3589 00000CBA AA                      			stosb							;store terminator
  3590 00000CBB 07                      			pop	es						;restore non-volatile regs
  3591 00000CBC 5F                      			pop	edi						;
  3592 00000CBD 59                      			pop	ecx						;
  3593 00000CBE C3                      			ret							;return
  3594                                  ;-----------------------------------------------------------------------------------------------------------------------
  3595                                  ;
  3596                                  ;	Routine:	PutDayString
  3597                                  ;
  3598                                  ;	Description:	This routine returns an ASCIIZ dd string at ds:edx from the date in the DATETIME
  3599                                  ;			structure at ds:ebx.
  3600                                  ;
  3601                                  ;	In:		DS:EBX	DATETIME address
  3602                                  ;			DS:EDX	output buffer address
  3603                                  ;
  3604                                  ;-----------------------------------------------------------------------------------------------------------------------
  3605 00000CBF 51                      PutDayString		push	ecx						;save non-volatile regs
  3606 00000CC0 0FB64B04                			movzx	ecx,byte [ebx+DATETIME.day]			;day
  3607 00000CC4 B701                    			mov	bh,1						;trim leading zeros; no commas
  3608 00000CC6 E86E040000              			call	UnsignedToDecimalString				;store ASCII decimal string
  3609 00000CCB 59                      			pop	ecx						;
  3610 00000CCC C3                      			ret							;return
  3611                                  ;-----------------------------------------------------------------------------------------------------------------------
  3612                                  ;
  3613                                  ;	Routine:	PutHourString
  3614                                  ;
  3615                                  ;	Description:	This routine returns an ASCIIZ hh string at ds:edx from the date in the DATETIME
  3616                                  ;			structure at ds:ebx.
  3617                                  ;
  3618                                  ;	In:		DS:EBX	DATETIME address
  3619                                  ;			DS:EDX	output buffer address
  3620                                  ;
  3621                                  ;-----------------------------------------------------------------------------------------------------------------------
  3622 00000CCD 51                      PutHourString		push	ecx						;save non-volatile regs
  3623 00000CCE 0FB64B02                			movzx	ecx,byte [ebx+DATETIME.hour]			;hour
  3624 00000CD2 B701                    			mov	bh,1						;trim leading zeros; no commas
  3625 00000CD4 E860040000              			call	UnsignedToDecimalString				;store ASCII decimal string
  3626 00000CD9 59                      			pop	ecx						;
  3627 00000CDA C3                      			ret							;return
  3628                                  ;-----------------------------------------------------------------------------------------------------------------------
  3629                                  ;
  3630                                  ;	Routine:	PutMinuteString
  3631                                  ;
  3632                                  ;	Description:	This routine returns an ASCIIZ mm string at ds:edx from the date in the DATETIME
  3633                                  ;			structure at ds:ebx.
  3634                                  ;
  3635                                  ;	In:		DS:EBX	DATETIME address
  3636                                  ;			DS:EDX	output buffer address
  3637                                  ;
  3638                                  ;-----------------------------------------------------------------------------------------------------------------------
  3639 00000CDB 51                      PutMinuteString		push	ecx						;save non-volatile regs
  3640 00000CDC 0FB64B01                			movzx	ecx,byte [ebx+DATETIME.minute]			;minute
  3641 00000CE0 B701                    			mov	bh,1						;trim leading zeros; no commas
  3642 00000CE2 E852040000              			call	UnsignedToDecimalString				;store ASCII decimal string
  3643 00000CE7 59                      			pop	ecx						;
  3644 00000CE8 C3                      			ret							;return
  3645                                  ;-----------------------------------------------------------------------------------------------------------------------
  3646                                  ;
  3647                                  ;	Routine:	PutMonthString
  3648                                  ;
  3649                                  ;	Description:	This routine returns an ASCIIZ mm string at ds:edx from the date in the DATETIME
  3650                                  ;			structure at ds:ebx.
  3651                                  ;
  3652                                  ;	In:		DS:EBX	DATETIME address
  3653                                  ;			DS:EDX	output buffer address
  3654                                  ;
  3655                                  ;-----------------------------------------------------------------------------------------------------------------------
  3656 00000CE9 51                      PutMonthString		push	ecx						;save non-volatile regs
  3657 00000CEA 0FB64B05                			movzx	ecx,byte [ebx+DATETIME.month]			;month
  3658 00000CEE B701                    			mov	bh,1						;trim leading zeros; no commas
  3659 00000CF0 E844040000              			call	UnsignedToDecimalString				;store ASCII decimal string
  3660 00000CF5 59                      			pop	ecx						;
  3661 00000CF6 C3                      			ret							;return
  3662                                  ;-----------------------------------------------------------------------------------------------------------------------
  3663                                  ;
  3664                                  ;	Routine:	PutMonthNameString
  3665                                  ;
  3666                                  ;	Description:	This routine returns an ASCIIZ name(mm) string at ds:edx from the date in the DATETIME
  3667                                  ;			structure at ds:ebx.
  3668                                  ;
  3669                                  ;	In:		DS:EBX	DATETIME address
  3670                                  ;			DS:EDX	output buffer address
  3671                                  ;
  3672                                  ;-----------------------------------------------------------------------------------------------------------------------
  3673 00000CF7 56                      PutMonthNameString	push	esi						;save non-volatile regs
  3674 00000CF8 57                      			push	edi						;
  3675 00000CF9 1E                      			push	ds						;
  3676 00000CFA 06                      			push	es						;
  3677 00000CFB 1E                      			push	ds						;load data selector ...
  3678 00000CFC 07                      			pop	es						;... into extra segment
  3679 00000CFD 89D7                    			mov	edi,edx						;output buffer address
  3680 00000CFF 0FB64305                			movzx	eax,byte [ebx+DATETIME.month]			;month (1-12)
  3681 00000D03 48                      			dec	eax						;month (0-11)
  3682 00000D04 C1E002                  			shl	eax,2						;offset into month name lookup table
  3683 00000D07 0E                      			push	cs						;load code selector ...
  3684 00000D08 1F                      			pop	ds						;... into data segment
  3685 00000D09 8BB0[480E0000]          			mov	esi,[tMonthNames+eax]				;month name address
  3686 00000D0F FC                      			cld							;forward strings
  3687 00000D10 AC                      .10			lodsb							;name character
  3688 00000D11 AA                      			stosb							;store in output buffer
  3689 00000D12 84C0                    			test	al,al						;end of string?
  3690 00000D14 75FA                    			jnz	.10						;no, continue
  3691 00000D16 07                      			pop	es						;restore non-volatile regs
  3692 00000D17 1F                      			pop	ds						;
  3693 00000D18 5F                      			pop	edi						;
  3694 00000D19 5E                      			pop	esi						;
  3695 00000D1A C3                      			ret							;return
  3696                                  ;-----------------------------------------------------------------------------------------------------------------------
  3697                                  ;
  3698                                  ;	Routine:	PutSecondString
  3699                                  ;
  3700                                  ;	Description:	This routine returns an ASCIIZ ss string at ds:edx from the date in the DATETIME
  3701                                  ;			structure at ds:ebx.
  3702                                  ;
  3703                                  ;	In:		DS:EBX	DATETIME address
  3704                                  ;			DS:EDX	output buffer address
  3705                                  ;
  3706                                  ;-----------------------------------------------------------------------------------------------------------------------
  3707 00000D1B 51                      PutSecondString		push	ecx						;save non-volatile regs
  3708 00000D1C 0FB60B                  			movzx	ecx,byte [ebx+DATETIME.second]			;second
  3709 00000D1F B701                    			mov	bh,1						;trim leading zeros; no commas
  3710 00000D21 E813040000              			call	UnsignedToDecimalString				;store ASCII decimal string
  3711 00000D26 59                      			pop	ecx						;
  3712 00000D27 C3                      			ret							;return
  3713                                  ;-----------------------------------------------------------------------------------------------------------------------
  3714                                  ;
  3715                                  ;	Routine:	PutTimeString
  3716                                  ;
  3717                                  ;	Description:	This routine returns an ASCIIZ hh:mm:ss string at ds:edx from the date in the DATETIME
  3718                                  ;			structure at ds:ebx.
  3719                                  ;
  3720                                  ;	In:		DS:EBX	DATETIME address
  3721                                  ;			DS:EDX	output buffer address
  3722                                  ;
  3723                                  ;-----------------------------------------------------------------------------------------------------------------------
  3724 00000D28 51                      PutTimeString		push	ecx						;save non-volatile regs
  3725 00000D29 57                      			push	edi						;
  3726 00000D2A 06                      			push	es						;
  3727 00000D2B 1E                      			push	ds						;store data selector ...
  3728 00000D2C 07                      			pop	es						;... in extra segment reg
  3729 00000D2D 89D7                    			mov	edi,edx						;output buffer address
  3730 00000D2F B10A                    			mov	cl,10						;divisor
  3731 00000D31 BA30303A00              			mov	edx,003a3030h					;ASCIIZ "00:" (reversed)
  3732 00000D36 0FB64302                			movzx	eax,byte [ebx+DATETIME.hour]			;hour
  3733 00000D3A F6F1                    			div	cl						;ah = rem; al = quotient
  3734 00000D3C 09D0                    			or	eax,edx						;apply ASCII zones and delimiter
  3735 00000D3E FC                      			cld							;forward strings
  3736 00000D3F AB                      			stosd							;store "mm/"nul
  3737 00000D40 4F                      			dec	edi						;address of terminator
  3738 00000D41 0FB64301                			movzx	eax,byte [ebx+DATETIME.minute]			;minute
  3739 00000D45 F6F1                    			div	cl						;ah = rem; al = quotient
  3740 00000D47 09D0                    			or	eax,edx						;apply ASCII zones and delimiter
  3741 00000D49 AB                      			stosd							;store "dd/"nul
  3742 00000D4A 4F                      			dec	edi						;address of terminator
  3743 00000D4B 0FB603                  			movzx	eax,byte [ebx+DATETIME.second]			;second
  3744 00000D4E F6F1                    			div	cl						;ah = rem; al = quotient
  3745 00000D50 09D0                    			or	eax,edx						;apply ASCII zones and delimiter
  3746 00000D52 AA                      			stosb							;store quotient
  3747 00000D53 88E0                    			mov	al,ah						;remainder
  3748 00000D55 AA                      			stosb							;store remainder
  3749 00000D56 30C0                    			xor	al,al						;null terminator
  3750 00000D58 AA                      			stosb							;store terminator
  3751 00000D59 07                      			pop	es						;restore non-volatile regs
  3752 00000D5A 5F                      			pop	edi						;
  3753 00000D5B 59                      			pop	ecx						;
  3754 00000D5C C3                      			ret							;return
  3755                                  ;-----------------------------------------------------------------------------------------------------------------------
  3756                                  ;
  3757                                  ;	Routine:	PutWeekdayString
  3758                                  ;
  3759                                  ;	Description:	This routine returns an ASCIIZ weekday string at ds:edx from the date in the DATETIME
  3760                                  ;			structure at ds:ebx.
  3761                                  ;
  3762                                  ;	In:		DS:EBX	DATETIME address
  3763                                  ;			DS:EDX	output buffer address
  3764                                  ;
  3765                                  ;-----------------------------------------------------------------------------------------------------------------------
  3766 00000D5D 51                      PutWeekdayString	push	ecx						;save non-volatile regs
  3767 00000D5E 0FB64B03                			movzx	ecx,byte [ebx+DATETIME.weekday]			;weekday
  3768 00000D62 B701                    			mov	bh,1						;trim leading zeros; no commas
  3769 00000D64 E8D0030000              			call	UnsignedToDecimalString				;store ASCII decimal string
  3770 00000D69 59                      			pop	ecx						;
  3771 00000D6A C3                      			ret							;return
  3772                                  ;-----------------------------------------------------------------------------------------------------------------------
  3773                                  ;
  3774                                  ;	Routine:	PutWeekdayNameString
  3775                                  ;
  3776                                  ;	Description:	This routine returns an ASCIIZ name(weekday) string at ds:edx from the date in the DATETIME
  3777                                  ;			structure at ds:ebx.
  3778                                  ;
  3779                                  ;	In:		DS:EBX	DATETIME address
  3780                                  ;			DS:EDX	output buffer address
  3781                                  ;
  3782                                  ;-----------------------------------------------------------------------------------------------------------------------
  3783 00000D6B 56                      PutWeekdayNameString	push	esi						;save non-volatile regs
  3784 00000D6C 57                      			push	edi						;
  3785 00000D6D 1E                      			push	ds						;
  3786 00000D6E 06                      			push	es						;
  3787 00000D6F 1E                      			push	ds						;load data selector ...
  3788 00000D70 07                      			pop	es						;... into extra segment
  3789 00000D71 89D7                    			mov	edi,edx						;output buffer address
  3790 00000D73 0FB64303                			movzx	eax,byte [ebx+DATETIME.weekday]			;weekday (0-6)
  3791 00000D77 C1E002                  			shl	eax,2						;offset into day name lookup table
  3792 00000D7A 0E                      			push	cs						;load code selector ...
  3793 00000D7B 1F                      			pop	ds						;... into data segment
  3794 00000D7C 8BB0[2C0E0000]          			mov	esi,[tDayNames+eax]				;day name address
  3795 00000D82 FC                      			cld							;forward strings
  3796 00000D83 AC                      .10			lodsb							;name character
  3797 00000D84 AA                      			stosb							;store in output buffer
  3798 00000D85 84C0                    			test	al,al						;end of string?
  3799 00000D87 75FA                    			jnz	.10						;no, continue
  3800 00000D89 07                      			pop	es						;restore non-volatile regs
  3801 00000D8A 1F                      			pop	ds						;
  3802 00000D8B 5F                      			pop	edi						;
  3803 00000D8C 5E                      			pop	esi						;
  3804 00000D8D C3                      			ret							;return
  3805                                  ;-----------------------------------------------------------------------------------------------------------------------
  3806                                  ;
  3807                                  ;	Routine:	PutYearString
  3808                                  ;
  3809                                  ;	Description:	This routine returns an ASCIIZ yyyy string at ds:edx from the date in the DATETIME
  3810                                  ;			structure at ds:ebx.
  3811                                  ;
  3812                                  ;	In:		DS:EBX	DATETIME address
  3813                                  ;			DS:EDX	output buffer address
  3814                                  ;
  3815                                  ;-----------------------------------------------------------------------------------------------------------------------
  3816 00000D8E 51                      PutYearString		push	ecx						;save non-volatile regs
  3817 00000D8F E8C1FEFFFF              			call	GetYear						;ECX = YYYY
  3818 00000D94 B701                    			mov	bh,1						;trim leading zeros; no commas
  3819 00000D96 E89E030000              			call	UnsignedToDecimalString				;store decimal string at DS:EDX
  3820 00000D9B 59                      			pop	ecx						;restore non-volatile regs
  3821 00000D9C C3                      			ret							;return
  3822                                  ;-----------------------------------------------------------------------------------------------------------------------
  3823                                  ;
  3824                                  ;	Day Names
  3825                                  ;
  3826                                  ;-----------------------------------------------------------------------------------------------------------------------
  3827 00000D9D 53756E64617900          czSunday		db	"Sunday",0
  3828 00000DA4 4D6F6E64617900          czMonday		db	"Monday",0
  3829 00000DAB 5475657364617900        czTuesday		db	"Tuesday",0
  3830 00000DB3 5765646E6573646179-     czWednesday		db	"Wednesday",0
  3830 00000DBC 00                 
  3831 00000DBD 546875727364617900      czThursday		db	"Thursday",0
  3832 00000DC6 46726964617900          czFriday		db	"Friday",0
  3833 00000DCD 536174757264617900      czSaturday		db	"Saturday",0
  3834                                  ;-----------------------------------------------------------------------------------------------------------------------
  3835                                  ;
  3836                                  ;	Month Names
  3837                                  ;
  3838                                  ;-----------------------------------------------------------------------------------------------------------------------
  3839 00000DD6 4A616E7561727900        czJanuary		db	"January",0
  3840 00000DDE 466562727561727900      czFebruary		db	"February",0
  3841 00000DE7 4D6172636800            czMarch			db	"March",0
  3842 00000DED 417072696C00            czApril			db	"April",0
  3843 00000DF3 4D617900                czMay			db	"May",0
  3844 00000DF7 4A756E6500              czJune			db	"June",0
  3845 00000DFC 4A756C7900              czJuly			db	"July",0
  3846 00000E01 41756775737400          czAugust		db	"August",0
  3847 00000E08 53657074656D626572-     czSeptember		db	"September",0
  3847 00000E11 00                 
  3848 00000E12 4F63746F62657200        czOctober		db	"October",0
  3849 00000E1A 4E6F76656D62657200      czNovember		db	"November",0
  3850 00000E23 446563656D62657200      czDecember		db	"December",0
  3851                                  ;-----------------------------------------------------------------------------------------------------------------------
  3852                                  ;
  3853                                  ;	Day Names Lookup Table
  3854                                  ;
  3855                                  ;-----------------------------------------------------------------------------------------------------------------------
  3856                                  			align	4
  3857                                  tDayNames		equ	$
  3858 00000E2C [9D0D0000]              			dd	czSunday
  3859 00000E30 [A40D0000]              			dd	czMonday
  3860 00000E34 [AB0D0000]              			dd	czTuesday
  3861 00000E38 [B30D0000]              			dd	czWednesday
  3862 00000E3C [BD0D0000]              			dd	czThursday
  3863 00000E40 [C60D0000]              			dd	czFriday
  3864 00000E44 [CD0D0000]              			dd	czSaturday
  3865                                  EDAYNAMESTBLL		equ	($-tDayNames)
  3866                                  EDAYNAMESTBLCNT		equ	EDAYNAMESTBLL/4
  3867                                  ;-----------------------------------------------------------------------------------------------------------------------
  3868                                  ;
  3869                                  ;	Month Names Lookup Table
  3870                                  ;
  3871                                  ;-----------------------------------------------------------------------------------------------------------------------
  3872                                  			align	4
  3873                                  tMonthNames		equ	$
  3874 00000E48 [D60D0000]              			dd	czJanuary
  3875 00000E4C [DE0D0000]              			dd	czFebruary
  3876 00000E50 [E70D0000]              			dd	czMarch
  3877 00000E54 [ED0D0000]              			dd	czApril
  3878 00000E58 [F30D0000]              			dd	czMay
  3879 00000E5C [F70D0000]              			dd	czJune
  3880 00000E60 [FC0D0000]              			dd	czJuly
  3881 00000E64 [010E0000]              			dd	czAugust
  3882 00000E68 [080E0000]              			dd	czSeptember
  3883 00000E6C [120E0000]              			dd	czOctober
  3884 00000E70 [1A0E0000]              			dd	czNovember
  3885 00000E74 [230E0000]              			dd	czDecember
  3886                                  EMONTHNAMESTBLL		equ	($-tMonthNames)
  3887                                  EMONTHNAMESTBLCNT	equ	EMONTHNAMESTBLL/4
  3888                                  ;=======================================================================================================================
  3889                                  ;
  3890                                  ;	String Helper Routines
  3891                                  ;
  3892                                  ;	UpperCaseString
  3893                                  ;	CompareMemory
  3894                                  ;	CopyMemory
  3895                                  ;
  3896                                  ;=======================================================================================================================
  3897                                  ;-----------------------------------------------------------------------------------------------------------------------
  3898                                  ;
  3899                                  ;	Routine:	UpperCaseString
  3900                                  ;
  3901                                  ;	Description:	This routine places all characters in the given string to upper case.
  3902                                  ;
  3903                                  ;	In:		DS:EDX	string address
  3904                                  ;
  3905                                  ;	Out:		EDX	string address
  3906                                  ;
  3907                                  ;-----------------------------------------------------------------------------------------------------------------------
  3908 00000E78 56                      UpperCaseString		push	esi						;save non-volatile regs
  3909 00000E79 89D6                    			mov	esi,edx						;string address
  3910 00000E7B FC                      			cld							;forward strings
  3911 00000E7C AC                      .10			lodsb							;string character
  3912 00000E7D 84C0                    			test	al,al						;null?
  3913 00000E7F 740F                    			jz	.20						;yes, skip ahead
  3914 00000E81 3C61                    			cmp	al,EASCIILOWERA					;lower-case? (lower bounds)
  3915 00000E83 72F7                    			jb	.10						;no, continue
  3916 00000E85 3C7A                    			cmp	al,EASCIILOWERZ					;lower-case? (upper bounds)
  3917 00000E87 77F3                    			ja	.10						;no, continue
  3918 00000E89 24DF                    			and	al,EASCIICASEMASK				;mask for upper case
  3919 00000E8B 8846FF                  			mov	[esi-1],al					;upper character
  3920 00000E8E EBEC                    			jmp	.10						;continue
  3921 00000E90 5E                      .20			pop	esi						;restore non-volatile regs
  3922 00000E91 C3                      			ret							;return
  3923                                  ;-----------------------------------------------------------------------------------------------------------------------
  3924                                  ;
  3925                                  ;	Routine:	CompareMemory
  3926                                  ;
  3927                                  ;	Description:	This routine compares two byte arrays.
  3928                                  ;
  3929                                  ;	In:		DS:EDX	first source address
  3930                                  ;			DS:EBX	second source address
  3931                                  ;			ECX	comparison length
  3932                                  ;
  3933                                  ;	Out:		EDX	first source address
  3934                                  ;			EBX	second source address
  3935                                  ;			ECX	0	array 1 = array 2
  3936                                  ;				<0	array 1 < array 2
  3937                                  ;				>0	array 1 > array 2
  3938                                  ;
  3939                                  ;-----------------------------------------------------------------------------------------------------------------------
  3940 00000E92 56                      CompareMemory		push	esi						;save non-volatile regs
  3941 00000E93 57                      			push	edi						;
  3942 00000E94 06                      			push	es						;
  3943 00000E95 1E                      			push	ds						;copy DS
  3944 00000E96 07                      			pop	es						;... to ES
  3945 00000E97 89D6                    			mov	esi,edx						;first source address
  3946 00000E99 89DF                    			mov	edi,ebx						;second source address
  3947 00000E9B FC                      			cld							;forward strings
  3948 00000E9C F3A6                    			rep	cmpsb						;compare bytes
  3949 00000E9E B000                    			mov	al,0						;default result
  3950 00000EA0 7406                    			jz	.10						;branch if arrays equal
  3951 00000EA2 B001                    			mov	al,1						;positive result
  3952 00000EA4 7302                    			jnc	.10						;branch if target > source
  3953 00000EA6 B0FF                    			mov	al,-1						;negative result
  3954 00000EA8 0FBEC8                  .10			movsx	ecx,al						;extend sign
  3955 00000EAB 07                      			pop	es						;restore non-volatile regs
  3956 00000EAC 5F                      			pop	edi						;
  3957 00000EAD 5E                      			pop	esi						;
  3958 00000EAE C3                      			ret							;return
  3959                                  ;-----------------------------------------------------------------------------------------------------------------------
  3960                                  ;
  3961                                  ;	Routine:	CopyMemory
  3962                                  ;
  3963                                  ;	Description:	This routine copies a byte array.
  3964                                  ;
  3965                                  ;	In:		DS:EDX	first source address
  3966                                  ;			DS:EBX	second source address
  3967                                  ;			ECX	copy length
  3968                                  ;
  3969                                  ;-----------------------------------------------------------------------------------------------------------------------
  3970 00000EAF 51                      CopyMemory		push	ecx						;save non-volatile regs
  3971 00000EB0 56                      			push	esi						;
  3972 00000EB1 57                      			push	edi						;
  3973 00000EB2 06                      			push	es						;
  3974                                  ;
  3975                                  ;	Compare byte array
  3976                                  ;
  3977 00000EB3 1E                      			push	ds						;load data selector
  3978 00000EB4 07                      			pop	es						;... into ES register
  3979 00000EB5 89D6                    			mov	esi,edx						;first source address
  3980 00000EB7 89DF                    			mov	edi,ebx						;second source address
  3981 00000EB9 FC                      			cld							;forward strings
  3982 00000EBA F3A4                    			rep	movsb						;copy bytes
  3983                                  ;
  3984                                  ;	Restore and return
  3985                                  ;
  3986 00000EBC 07                      			pop	es						;restore non-volatile regs
  3987 00000EBD 5F                      			pop	edi						;
  3988 00000EBE 5E                      			pop	esi						;
  3989 00000EBF 59                      			pop	ecx						;
  3990 00000EC0 C3                      			ret							;return
  3991                                  ;=======================================================================================================================
  3992                                  ;
  3993                                  ;	Console Helper Routines
  3994                                  ;
  3995                                  ;	PutConsoleString
  3996                                  ;	GetConsoleString
  3997                                  ;	GetConsoleChar
  3998                                  ;	Yield
  3999                                  ;	PreviousConsoleColumn
  4000                                  ;	NextConsoleColumn
  4001                                  ;	FirstConsoleColumn
  4002                                  ;	NextConsoleRow
  4003                                  ;	PutConsoleChar
  4004                                  ;	PutConsoleOIAShift
  4005                                  ;	PutConsoleOIAChar
  4006                                  ;	PutConsoleHexByte
  4007                                  ;
  4008                                  ;=======================================================================================================================
  4009                                  ;-----------------------------------------------------------------------------------------------------------------------
  4010                                  ;
  4011                                  ;	Routine:	PutConsoleString
  4012                                  ;
  4013                                  ;	Description:	This routine writes a sequence of ASCII characters to the console until null and updates the
  4014                                  ;			console position as needed.
  4015                                  ;
  4016                                  ;	In:		EDX	source address
  4017                                  ;			DS	OS data selector
  4018                                  ;
  4019                                  ;-----------------------------------------------------------------------------------------------------------------------
  4020 00000EC1 56                      PutConsoleString	push	esi						;save non-volatile regs
  4021 00000EC2 89D6                    			mov	esi,edx						;source address
  4022 00000EC4 FC                      			cld							;forward strings
  4023 00000EC5 AC                      .10			lodsb							;ASCII character
  4024 00000EC6 08C0                    			or	al,al						;end of string?
  4025 00000EC8 7422                    			jz	.40						;yes, skip ahead
  4026 00000ECA 3C0D                    			cmp	al,EASCIIRETURN					;carriage return?
  4027 00000ECC 7507                    			jne	.20						;no, skip ahead
  4028 00000ECE E8EB000000              			call	FirstConsoleColumn				;move to start of row
  4029 00000ED3 EBF0                    			jmp	.10						;next character
  4030 00000ED5 3C0A                    .20			cmp	al,EASCIILINEFEED				;line feed?
  4031 00000ED7 7507                    			jne	.30						;no, skip ahead
  4032 00000ED9 E8E8000000              			call	NextConsoleRow					;move to next row
  4033 00000EDE EBE5                    			jmp	.10						;next character
  4034 00000EE0 E803010000              .30			call	PutConsoleChar					;output character to console
  4035 00000EE5 E8B9000000              			call	NextConsoleColumn				;advance to next column
  4036 00000EEA EBD9                    			jmp	.10						;next character
  4037 00000EEC 5E                      .40			pop	esi						;restore non-volatile regs
  4038 00000EED C3                      			ret							;return
  4039                                  ;-----------------------------------------------------------------------------------------------------------------------
  4040                                  ;
  4041                                  ;	Routine:	GetConsoleString
  4042                                  ;
  4043                                  ;	Description:	This routine accepts keyboard input into a buffer.
  4044                                  ;
  4045                                  ;	In:		DS:EDX	target buffer address
  4046                                  ;			ECX	maximum number of characters to accept
  4047                                  ;			BH	echo to terminal
  4048                                  ;			BL	terminating character
  4049                                  ;
  4050                                  ;-----------------------------------------------------------------------------------------------------------------------
  4051 00000EEE 51                      GetConsoleString	push	ecx						;save non-volatile regs
  4052 00000EEF 56                      			push	esi						;
  4053 00000EF0 57                      			push	edi						;
  4054 00000EF1 06                      			push	es						;
  4055 00000EF2 1E                      			push	ds						;load data segment selector ...
  4056 00000EF3 07                      			pop	es						;... into extra segment register
  4057 00000EF4 89D7                    			mov	edi,edx						;edi = target buffer
  4058 00000EF6 51                      			push	ecx						;save maximum characters
  4059 00000EF7 30C0                    			xor	al,al						;zero register
  4060 00000EF9 FC                      			cld							;forward strings
  4061 00000EFA F3AA                    			rep	stosb						;zero fill buffer
  4062 00000EFC 59                      			pop	ecx						;maximum characters
  4063 00000EFD 89D7                    			mov	edi,edx						;edi = target buffer
  4064 00000EFF 89D6                    			mov	esi,edx						;esi = target buffer
  4065 00000F01 E34E                    .10			jecxz	.50						;exit if max-length is zero
  4066 00000F03 E856000000              .20			call	GetConsoleChar					;al = next input char
  4067 00000F08 38D8                    			cmp	al,bl						;is this the terminator?
  4068 00000F0A 7445                    			je	.50						;yes, exit
  4069 00000F0C 3C08                    			cmp	al,EASCIIBACKSPACE				;is this a backspace?
  4070 00000F0E 7521                    			jne	.30						;no, skip ahead
  4071 00000F10 39FE                    			cmp	esi,edi						;at start of buffer?
  4072 00000F12 74EF                    			je	.20						;yes, get next character
  4073 00000F14 4F                      			dec	edi						;backup target pointer
  4074 00000F15 C60700                  			mov	byte [edi],0					;zero previous character
  4075 00000F18 41                      			inc	ecx						;increment remaining chars
  4076 00000F19 F6C701                  			test	bh,1						;echo to console?
  4077 00000F1C 74E5                    			jz	.20						;no, get next character
  4078 00000F1E E85B000000              			call	PreviousConsoleColumn				;backup console position
  4079 00000F23 B020                    			mov	al,EASCIISPACE					;ASCII space
  4080 00000F25 E8BE000000              			call	PutConsoleChar					;write space to console
  4081 00000F2A E808040000              			call	PlaceCursor					;position the cursor
  4082 00000F2F EBD2                    			jmp	.20						;get next character
  4083 00000F31 3C20                    .30			cmp	al,EASCIISPACE					;printable? (lower bounds)
  4084 00000F33 72CE                    			jb	.20						;no, get another character
  4085 00000F35 3C7E                    			cmp	al,EASCIITILDE					;printable? (upper bounds)
  4086 00000F37 77CA                    			ja	.20						;no, get another character
  4087 00000F39 AA                      			stosb							;store character in buffer
  4088 00000F3A F6C701                  			test	bh,1						;echo to console?
  4089 00000F3D 740F                    			jz	.40						;no, skip ahead
  4090 00000F3F E8A4000000              			call	PutConsoleChar					;write character to console
  4091 00000F44 E85A000000              			call	NextConsoleColumn				;advance console position
  4092 00000F49 E8E9030000              			call	PlaceCursor					;position the cursor
  4093 00000F4E 49                      .40			dec	ecx						;decrement remaining chars
  4094 00000F4F EBB0                    			jmp	.10						;next
  4095 00000F51 30C0                    .50			xor	al,al						;null
  4096 00000F53 AA                      			stosb							;terminate buffer
  4097 00000F54 07                      			pop	es						;restore non-volatile regs
  4098 00000F55 5F                      			pop	edi						;
  4099 00000F56 5E                      			pop	esi						;
  4100 00000F57 59                      			pop	ecx						;
  4101 00000F58 C3                      			ret							;return
  4102                                  ;-----------------------------------------------------------------------------------------------------------------------
  4103                                  ;
  4104                                  ;	Routine:	GetConsoleChar
  4105                                  ;
  4106                                  ;	Description:	This routine waits for EMSGKEYCHAR message and return character code.
  4107                                  ;
  4108                                  ;	Out:		AL	ASCII character code
  4109                                  ;			AH	keyboard scan code
  4110                                  ;
  4111                                  ;-----------------------------------------------------------------------------------------------------------------------
  4112 00000F59 E81D000000              GetConsoleChar.10	call	Yield						;pass control or halt
  4113 00000F5E E812030000              GetConsoleChar		call	GetMessage					;get the next message
  4114 00000F63 09C0                    			or	eax,eax						;do we have a message?
  4115 00000F65 74F2                    			jz	GetConsoleChar.10				;no, skip ahead
  4116 00000F67 50                      			push	eax						;save key codes
  4117 00000F68 250000FFFF              			and	eax,0FFFF0000h					;mask for message type
  4118 00000F6D 3D00000241              			cmp	eax,EMSGKEYCHAR					;key-char message?
  4119 00000F72 58                      			pop	eax						;restore key codes
  4120 00000F73 75E9                    			jne	GetConsoleChar					;no, try again
  4121 00000F75 25FFFF0000              			and	eax,0000ffffh					;mask for key codes
  4122 00000F7A C3                      			ret							;return
  4123                                  ;-----------------------------------------------------------------------------------------------------------------------
  4124                                  ;
  4125                                  ;	Routine:	Yield
  4126                                  ;
  4127                                  ;	Description:	This routine passes control to the next ready task or enter halt.
  4128                                  ;
  4129                                  ;-----------------------------------------------------------------------------------------------------------------------
  4130 00000F7B FB                      Yield			sti							;enable maskagle interrupts
  4131 00000F7C F4                      			hlt							;halt until external interrupt
  4132 00000F7D C3                      			ret							;return
  4133                                  ;-----------------------------------------------------------------------------------------------------------------------
  4134                                  ;
  4135                                  ;	Routine:	PreviousConsoleColumn
  4136                                  ;
  4137                                  ;	Description:	This routine retreats the cursor one logical column. If the cursor was at the start of a row,
  4138                                  ;			the column is set to the last position in the row and the row is decremented.
  4139                                  ;
  4140                                  ;	In:		DS	OS data selector
  4141                                  ;
  4142                                  ;-----------------------------------------------------------------------------------------------------------------------
  4143 00000F7E A0280A0000              PreviousConsoleColumn	mov	al,[wbConsoleColumn]				;current column
  4144 00000F83 08C0                    			or	al,al						;start of row?
  4145 00000F85 7514                    			jnz	.10						;no, skip ahead
  4146 00000F87 8A25290A0000            			mov	ah,[wbConsoleRow]				;current row
  4147 00000F8D 08E4                    			or	ah,ah						;top of screen?
  4148 00000F8F 7411                    			jz	.20						;yes, exit with no change
  4149 00000F91 FECC                    			dec	ah						;decrement row
  4150 00000F93 8825290A0000            			mov	[wbConsoleRow],ah				;save row
  4151 00000F99 B050                    			mov	al,ECONCOLS					;set maximum column
  4152 00000F9B FEC8                    .10			dec	al						;decrement column
  4153 00000F9D A2280A0000              			mov	[wbConsoleColumn],al				;save column
  4154 00000FA2 C3                      .20			ret							;return
  4155                                  ;-----------------------------------------------------------------------------------------------------------------------
  4156                                  ;
  4157                                  ;	Routine:	NextConsoleColumn
  4158                                  ;
  4159                                  ;	Description:	This routine advances the console position one column. The columnn is reset to zero and the row
  4160                                  ;			incremented if the end of the current row is reached.
  4161                                  ;
  4162                                  ;	In:		DS	OS data selector
  4163                                  ;
  4164                                  ;-----------------------------------------------------------------------------------------------------------------------
  4165 00000FA3 A0280A0000              NextConsoleColumn	mov	al,[wbConsoleColumn]				;current column
  4166 00000FA8 FEC0                    			inc	al						;increment column
  4167 00000FAA A2280A0000              			mov	[wbConsoleColumn],al				;save column
  4168 00000FAF 3C50                    			cmp	al,ECONCOLS					;end of row?
  4169 00000FB1 720A                    			jb	.10						;no, skip ahead
  4170 00000FB3 E806000000              			call	FirstConsoleColumn				;reset column to start of row
  4171 00000FB8 E809000000              			call	NextConsoleRow					;line feed to next row
  4172 00000FBD C3                      .10			ret							;return
  4173                                  ;-----------------------------------------------------------------------------------------------------------------------
  4174                                  ;
  4175                                  ;	Routine:	FirstConsoleColumn
  4176                                  ;
  4177                                  ;	Description:	This routine resets the console column to start of the row.
  4178                                  ;
  4179                                  ;	In:		DS	OS data selector
  4180                                  ;
  4181                                  ;-----------------------------------------------------------------------------------------------------------------------
  4182 00000FBE 30C0                    FirstConsoleColumn	xor	al,al						;zero column
  4183 00000FC0 A2280A0000              			mov	[wbConsoleColumn],al				;save column
  4184 00000FC5 C3                      			ret							;return
  4185                                  ;-----------------------------------------------------------------------------------------------------------------------
  4186                                  ;
  4187                                  ;	Routine:	NextConsoleRow
  4188                                  ;
  4189                                  ;	Description:	This routine advances the console position one line. Scroll the screen one row if needed.
  4190                                  ;
  4191                                  ;	In:		DS	OS data selector
  4192                                  ;
  4193                                  ;-----------------------------------------------------------------------------------------------------------------------
  4194 00000FC6 A0290A0000              NextConsoleRow		mov	al,[wbConsoleRow]				;current row
  4195 00000FCB FEC0                    			inc	al						;increment row
  4196 00000FCD A2290A0000              			mov	[wbConsoleRow],al				;save row
  4197 00000FD2 3C18                    			cmp	al,ECONROWS					;end of screen?
  4198 00000FD4 7211                    			jb	.10						;no, skip ahead
  4199 00000FD6 E80A030000              			call	ScrollConsoleRow				;scroll up one row
  4200 00000FDB A0290A0000              			mov	al,[wbConsoleRow]				;row
  4201 00000FE0 FEC8                    			dec	al						;decrement row
  4202 00000FE2 A2290A0000              			mov	[wbConsoleRow],al				;save row
  4203 00000FE7 C3                      .10			ret							;return
  4204                                  ;-----------------------------------------------------------------------------------------------------------------------
  4205                                  ;
  4206                                  ;	Routine:	PutConsoleChar
  4207                                  ;
  4208                                  ;	Description:	This routine writes one ASCII character to the console screen.
  4209                                  ;
  4210                                  ;	In:		AL	ASCII character
  4211                                  ;			DS	OS data selector
  4212                                  ;
  4213                                  ;-----------------------------------------------------------------------------------------------------------------------
  4214 00000FE8 51                      PutConsoleChar		push	ecx						;save non-volatile regs
  4215 00000FE9 06                      			push	es						;
  4216 00000FEA 6A20                    			push	ESELCGA						;load CGA selector ...
  4217 00000FEC 07                      			pop	es						;... into extra segment reg
  4218 00000FED 8A0D280A0000            			mov	cl,[wbConsoleColumn]				;column
  4219 00000FF3 8A2D290A0000            			mov	ch,[wbConsoleRow]				;row
  4220 00000FF9 E823030000              			call	SetConsoleChar					;put character at row, column
  4221 00000FFE 07                      			pop	es						;restore non-volatile regs
  4222 00000FFF 59                      			pop	ecx						;
  4223 00001000 C3                      			ret							;return
  4224                                  ;-----------------------------------------------------------------------------------------------------------------------
  4225                                  ;
  4226                                  ;	Routine:	PutConsoleOIAShift
  4227                                  ;
  4228                                  ;	Description:	This routine updates the shift/ctrl/alt/lock indicators in the operator information area (OIA).
  4229                                  ;
  4230                                  ;	In:		BL	shift flags
  4231                                  ;			BH	lock flags
  4232                                  ;			DS	OS data selector
  4233                                  ;
  4234                                  ;-----------------------------------------------------------------------------------------------------------------------
  4235 00001001 51                      PutConsoleOIAShift	push	ecx						;save non-volatile regs
  4236 00001002 06                      			push	es						;
  4237 00001003 6A20                    			push	ESELCGA						;load CGA selector ...
  4238 00001005 07                      			pop	es						;... into ES register
  4239 00001006 B518                    			mov	ch,ECONOIAROW					;OIA row
  4240 00001008 B020                    			mov	al,EASCIISPACE					;space is default character
  4241 0000100A F6C302                  			test	bl,EKEYFSHIFTLEFT				;left-shift indicated?
  4242 0000100D 7402                    			jz	.10						;no, skip ahead
  4243 0000100F B053                    			mov	al,'S'						;yes, indicate with 'S'
  4244 00001011 B10E                    .10			mov	cl,14						;indicator column
  4245 00001013 E809030000              			call	SetConsoleChar					;display ASCII character
  4246 00001018 B020                    			mov	al,EASCIISPACE					;ASCII space
  4247 0000101A F6C310                  			test	bl,EKEYFSHIFTRIGHT				;right-shift indicated?
  4248 0000101D 7402                    			jz	.20						;no, skip ahead
  4249 0000101F B053                    			mov	al,'S'						;yes, indicate with 'S'
  4250 00001021 B140                    .20			mov	cl,64						;indicator column
  4251 00001023 E8F9020000              			call	SetConsoleChar					;display ASCII character
  4252 00001028 B020                    			mov	al,EASCIISPACE					;ASCII space
  4253 0000102A F6C301                  			test	bl,EKEYFCTRLLEFT				;left-ctrl indicated?
  4254 0000102D 7402                    			jz	.30						;no, skip ahead
  4255 0000102F B043                    			mov	al,'C'						;yes, indicate with 'C'
  4256 00001031 B10F                    .30			mov	cl,15						;indicator column
  4257 00001033 E8E9020000              			call	SetConsoleChar					;display ASCII character
  4258 00001038 B020                    			mov	al,EASCIISPACE					;ASCII space
  4259 0000103A F6C308                  			test	bl,EKEYFCTRLRIGHT				;right-ctrl indicated?
  4260 0000103D 7402                    			jz	.40						;no, skip ahead
  4261 0000103F B043                    			mov	al,'C'						;yes, indicate with 'C'
  4262 00001041 B13F                    .40			mov	cl,63						;indicator column
  4263 00001043 E8D9020000              			call	SetConsoleChar					;display ASCII character
  4264 00001048 B020                    			mov	al,EASCIISPACE					;ASCII space
  4265 0000104A F6C304                  			test	bl,EKEYFALTLEFT					;left-alt indicated?
  4266 0000104D 7402                    			jz	.50						;no, skip ahead
  4267 0000104F B041                    			mov	al,'A'						;yes, indicate with 'A'
  4268 00001051 B110                    .50			mov	cl,16						;indicator column
  4269 00001053 E8C9020000              			call	SetConsoleChar					;display ASCII character
  4270 00001058 B020                    			mov	al,EASCIISPACE					;ASCII space
  4271 0000105A F6C320                  			test	bl,EKEYFALTRIGHT				;right-alt indicated?
  4272 0000105D 7402                    			jz	.60						;no, skip ahead
  4273 0000105F B041                    			mov	al,'A'						;yes, indicate with 'A'
  4274 00001061 B13E                    .60			mov	cl,62						;indicator column
  4275 00001063 E8B9020000              			call	SetConsoleChar					;display ASCII character
  4276 00001068 B020                    			mov	al,EASCIISPACE					;ASCII space
  4277 0000106A F6C704                  			test	bh,EKEYFLOCKCAPS				;caps-lock indicated?
  4278 0000106D 7402                    			jz	.70						;no, skip ahead
  4279 0000106F B043                    			mov	al,'C'						;yes, indicate with 'C'
  4280 00001071 B14E                    .70			mov	cl,78						;indicator column
  4281 00001073 E8A9020000              			call	SetConsoleChar					;display ASCII character
  4282 00001078 B020                    			mov	al,EASCIISPACE					;ASCII space
  4283 0000107A F6C702                  			test	bh,EKEYFLOCKNUM					;num-lock indicated?
  4284 0000107D 7402                    			jz	.80						;no, skip ahead
  4285 0000107F B04E                    			mov	al,'N'						;yes, indicate with 'N'
  4286 00001081 B14D                    .80			mov	cl,77						;indicator column
  4287 00001083 E899020000              			call	SetConsoleChar					;display ASCII character
  4288 00001088 B020                    			mov	al,EASCIISPACE					;ASCII space
  4289 0000108A F6C701                  			test	bh,EKEYFLOCKSCROLL				;scroll-lock indicated?
  4290 0000108D 7402                    			jz	.90						;no, skip ahead
  4291 0000108F B053                    			mov	al,'S'						;yes, indicate with 'S'
  4292 00001091 B14C                    .90			mov	cl,76						;indicator column
  4293 00001093 E889020000              			call	SetConsoleChar					;display ASCII character
  4294 00001098 07                      			pop	es						;restore non-volatile regs
  4295 00001099 59                      			pop	ecx						;
  4296 0000109A C3                      			ret							;return
  4297                                  ;-----------------------------------------------------------------------------------------------------------------------
  4298                                  ;
  4299                                  ;	Routine:	PutConsoleOIAChar
  4300                                  ;
  4301                                  ;	Description:	This routine updates the Operator Information Area (OIA).
  4302                                  ;
  4303                                  ;	In:		DS	OS data selector
  4304                                  ;
  4305                                  ;-----------------------------------------------------------------------------------------------------------------------
  4306 0000109B 53                      PutConsoleOIAChar	push	ebx						;save non-volatile regs
  4307 0000109C 51                      			push	ecx						;
  4308 0000109D 56                      			push	esi						;
  4309 0000109E 1E                      			push	ds						;
  4310 0000109F 06                      			push	es						;
  4311 000010A0 6A18                    			push	ESELDAT						;load OS data selector ...
  4312 000010A2 1F                      			pop	ds						;... into data segment register
  4313 000010A3 6A20                    			push	ESELCGA						;load CGA selector ...
  4314 000010A5 07                      			pop	es						;... into extra segment register
  4315 000010A6 BE2D0A0000              			mov	esi,wbConsoleScan0				;scan codes address
  4316 000010AB B718                    			mov	bh,ECONOIAROW					;OIA row
  4317 000010AD B300                    			mov	bl,0						;starting column
  4318 000010AF B906000000              			mov	ecx,6						;maximum scan codes
  4319 000010B4 51                      .10			push	ecx						;save remaining count
  4320 000010B5 89D9                    			mov	ecx,ebx						;row, column
  4321 000010B7 AC                      			lodsb							;read scan code
  4322 000010B8 08C0                    			or	al,al						;scan code present?
  4323 000010BA 7407                    			jz	.20						;no, skip ahead
  4324 000010BC E852000000              			call	PutConsoleHexByte				;display scan code
  4325 000010C1 EB0E                    			jmp	.30						;continue
  4326 000010C3 B020                    .20			mov	al,' '						;ASCII space
  4327 000010C5 E857020000              			call	SetConsoleChar					;display space
  4328 000010CA B020                    			mov	al,' '						;ASCII space
  4329 000010CC E850020000              			call	SetConsoleChar					;display space
  4330 000010D1 80C302                  .30			add	bl,2						;next column (+2)
  4331 000010D4 59                      			pop	ecx						;restore remaining
  4332 000010D5 E2DD                    			loop	.10						;next code
  4333 000010D7 A0330A0000              			mov	al,[wbConsoleChar]				;console ASCII character
  4334 000010DC 3C20                    			cmp	al,32						;printable? (lower-bounds)
  4335 000010DE 720D                    			jb	.40						;no, skip ahead
  4336 000010E0 3C7E                    			cmp	al,126						;printable? (upper-bounds)
  4337 000010E2 7709                    			ja	.40						;no, skip ahead
  4338 000010E4 88FD                    			mov	ch,bh						;OIA row
  4339 000010E6 B128                    			mov	cl,40						;character display column
  4340 000010E8 E834020000              			call	SetConsoleChar					;display ASCII character
  4341 000010ED 07                      .40			pop	es						;restore non-volatile regs
  4342 000010EE 1F                      			pop	ds						;
  4343 000010EF 5E                      			pop	esi						;
  4344 000010F0 59                      			pop	ecx						;
  4345 000010F1 5B                      			pop	ebx						;
  4346 000010F2 C3                      			ret							;return
  4347                                  ;-----------------------------------------------------------------------------------------------------------------------
  4348                                  ;
  4349                                  ;	Routine:	PutConsoleHexDword
  4350                                  ;
  4351                                  ;	Description:	This routine writes eight ASCII characters to the console representing a doubleword value.
  4352                                  ;
  4353                                  ;	In:		EAX	value
  4354                                  ;			CL	column
  4355                                  ;			CH	row
  4356                                  ;			DS	OS data selector
  4357                                  ;			ES	CGA selector
  4358                                  ;
  4359                                  ;-----------------------------------------------------------------------------------------------------------------------
  4360 000010F3 50                      PutConsoleHexDword	push	eax
  4361 000010F4 C1E810                  			shr	eax,16
  4362 000010F7 E807000000              			call	PutConsoleHexWord
  4363 000010FC 58                      			pop	eax
  4364 000010FD E801000000              			call	PutConsoleHexWord
  4365 00001102 C3                      			ret
  4366                                  ;-----------------------------------------------------------------------------------------------------------------------
  4367                                  ;
  4368                                  ;	Routine:	PutConsoleHexWord
  4369                                  ;
  4370                                  ;	Description:	This routine writes four ASCII characters to the console representing a word value.
  4371                                  ;
  4372                                  ;	In:		EAX	value
  4373                                  ;			CL	column
  4374                                  ;			CH	row
  4375                                  ;			DS	OS data selector
  4376                                  ;			ES	CGA selector
  4377                                  ;
  4378                                  ;-----------------------------------------------------------------------------------------------------------------------
  4379 00001103 50                      PutConsoleHexWord	push	eax
  4380 00001104 C1E808                  			shr	eax,8
  4381 00001107 E807000000              			call	PutConsoleHexByte
  4382 0000110C 58                      			pop	eax
  4383 0000110D E801000000              			call	PutConsoleHexByte
  4384 00001112 C3                      			ret
  4385                                  ;-----------------------------------------------------------------------------------------------------------------------
  4386                                  ;
  4387                                  ;	Routine:	PutConsoleHexByte
  4388                                  ;
  4389                                  ;	Description:	This routine writes two ASCII characters to the console representing a byte value.
  4390                                  ;
  4391                                  ;	In:		AL	byte value
  4392                                  ;			CL	column
  4393                                  ;			CH	row
  4394                                  ;			DS	OS data selector
  4395                                  ;			ES	CGA selector
  4396                                  ;
  4397                                  ;-----------------------------------------------------------------------------------------------------------------------
  4398 00001113 53                      PutConsoleHexByte	push	ebx						;save non-volatile regs
  4399 00001114 88C3                    			mov	bl,al						;save byte value
  4400 00001116 C0E804                  			shr	al,4						;hi-order nybble
  4401 00001119 0C30                    			or	al,030h						;apply ASCII zone
  4402 0000111B 3C3A                    			cmp	al,03ah						;numeric?
  4403 0000111D 7202                    			jb	.10						;yes, skip ahead
  4404 0000111F 0407                    			add	al,7						;add ASCII offset for alpha
  4405 00001121 E8FB010000              .10			call	SetConsoleChar					;display ASCII character
  4406 00001126 88D8                    			mov	al,bl						;byte value
  4407 00001128 240F                    			and	al,0fh						;lo-order nybble
  4408 0000112A 0C30                    			or	al,30h						;apply ASCII zone
  4409 0000112C 3C3A                    			cmp	al,03ah						;numeric?
  4410 0000112E 7202                    			jb	.20						;yes, skip ahead
  4411 00001130 0407                    			add	al,7						;add ASCII offset for alpha
  4412 00001132 E8EA010000              .20			call	SetConsoleChar					;display ASCII character
  4413 00001137 5B                      			pop	ebx						;restore non-volatile regs
  4414 00001138 C3                      			ret							;return
  4415                                  ;=======================================================================================================================
  4416                                  ;
  4417                                  ;	Data-Type Conversion Helper Routines
  4418                                  ;
  4419                                  ;	UnsignedToDecimalString
  4420                                  ;	UnsignedToHexadecimal
  4421                                  ;	HexadecimalToUnsigned
  4422                                  ;
  4423                                  ;=======================================================================================================================
  4424                                  ;-----------------------------------------------------------------------------------------------------------------------
  4425                                  ;
  4426                                  ;	Routine:	UnsignedToDecimalString
  4427                                  ;
  4428                                  ;	Description:	This routine creates an ASCIIZ string representing the decimal value of 32-bit binary input.
  4429                                  ;
  4430                                  ;	Input:		BH	flags		bit 0: 1 = trim leading zeros
  4431                                  ;						bit 1: 1 = include comma grouping delimiters
  4432                                  ;						bit 4: 1 = non-zero digit found (internal)
  4433                                  ;			ECX	32-bit binary
  4434                                  ;			DS:EDX	output buffer address
  4435                                  ;
  4436                                  ;-----------------------------------------------------------------------------------------------------------------------
  4437 00001139 53                      UnsignedToDecimalString push	ebx						;save non-volatile regs
  4438 0000113A 51                      			push	ecx						;
  4439 0000113B 57                      			push	edi						;
  4440 0000113C 06                      			push	es						;
  4441 0000113D 1E                      			push	ds						;load data selector
  4442 0000113E 07                      			pop	es						;... into extra segment reg
  4443 0000113F 89D7                    			mov	edi,edx 					;output buffer address
  4444 00001141 80E70F                  			and	bh,00001111b					;zero internal flags
  4445 00001144 89CA                    			mov	edx,ecx 					;binary
  4446 00001146 B900CA9A3B              			mov	ecx,1000000000					;10^9 divisor
  4447 0000114B E871000000              			call	.30						;divide and store
  4448 00001150 B900E1F505              			mov	ecx,100000000					;10^8 divisor
  4449 00001155 E855000000              			call	.10						;divide and store
  4450 0000115A B980969800              			mov	ecx,10000000					;10^7 divisor
  4451 0000115F E85D000000              			call	.30						;divide and store
  4452 00001164 B940420F00              			mov	ecx,1000000					;10^6 divisor
  4453 00001169 E853000000              			call	.30						;divide and store
  4454 0000116E B9A0860100              			mov	ecx,100000					;10^5 divisor
  4455 00001173 E837000000              			call	.10						;divide and store
  4456 00001178 B910270000              			mov	ecx,10000					;10^4 divisor
  4457 0000117D E83F000000              			call	.30						;divide and store
  4458 00001182 B9E8030000              			mov	ecx,1000					;10^3 divisor
  4459 00001187 E835000000              			call	.30						;divide and store
  4460 0000118C B964000000              			mov	ecx,100 					;10^2 divisor
  4461 00001191 E819000000              			call	.10						;divide and store
  4462 00001196 B90A000000              			mov	ecx,10						;10^2 divisor
  4463 0000119B E821000000              			call	.30						;divide and store
  4464 000011A0 89D0                    			mov	eax,edx 					;10^1 remainder
  4465 000011A2 E827000000              			call	.40						;store
  4466 000011A7 30C0                    			xor	al,al						;null terminator
  4467 000011A9 AA                      			stosb
  4468 000011AA 07                      			pop	es						;restore non-volatile regs
  4469 000011AB 5F                      			pop	edi						;
  4470 000011AC 59                      			pop	ecx						;
  4471 000011AD 5B                      			pop	ebx						;
  4472 000011AE C3                      			ret							;return
  4473 000011AF F6C702                  .10			test	bh,00000010b					;comma group delims?
  4474 000011B2 740D                    			jz	.30						;no, branch
  4475 000011B4 F6C701                  			test	bh,00000001b					;trim leading zeros?
  4476 000011B7 7405                    			jz	.20						;no, store delim
  4477 000011B9 F6C710                  			test	bh,00010000b					;non-zero found?
  4478 000011BC 7403                    			jz	.30						;no, branch
  4479 000011BE B02C                    .20			mov	al,','						;delimiter
  4480 000011C0 AA                      			stosb							;store delimiter
  4481 000011C1 89D0                    .30			mov	eax,edx 					;lo-orer dividend
  4482 000011C3 31D2                    			xor	edx,edx 					;zero hi-order
  4483 000011C5 F7F1                    			div	ecx						;divide by power of 10
  4484 000011C7 84C0                    			test	al,al						;zero?
  4485 000011C9 7407                    			jz	.50						;yes, branch
  4486 000011CB 80CF10                  			or	bh,00010000b					;non-zero found
  4487 000011CE 0C30                    .40			or	al,30h						;ASCII zone
  4488 000011D0 AA                      			stosb							;store digit
  4489 000011D1 C3                      			ret							;return
  4490 000011D2 F6C701                  .50			test	bh,00000001b					;trim leading zeros?
  4491 000011D5 74F7                    			jz	.40						;no, store and continue
  4492 000011D7 F6C710                  			test	bh,00010000b					;non-zero found?
  4493 000011DA 75F2                    			jnz	.40						;yes, store and continue
  4494 000011DC C3                      			ret							;return
  4495                                  ;-----------------------------------------------------------------------------------------------------------------------
  4496                                  ;
  4497                                  ;	Routine:	UnsignedToHexadecimal
  4498                                  ;
  4499                                  ;	Description:	This routine creates an ASCIIZ string representing the hexadecimal value of binary input
  4500                                  ;
  4501                                  ;	Input:		DS:EDX	output buffer address
  4502                                  ;			ECX	32-bit binary
  4503                                  ;
  4504                                  ;-----------------------------------------------------------------------------------------------------------------------
  4505 000011DD 57                      UnsignedToHexadecimal	push	edi						;store non-volatile regs
  4506 000011DE 89D7                    			mov	edi,edx						;output buffer address
  4507 000011E0 89CA                    			mov	edx,ecx						;32-bit unsigned
  4508 000011E2 31C9                    			xor	ecx,ecx						;zero register
  4509 000011E4 B108                    			mov	cl,8						;nybble count
  4510 000011E6 C1C204                  .10			rol	edx,4						;next hi-order nybble in bits 0-3
  4511 000011E9 88D0                    			mov	al,dl						;????bbbb
  4512 000011EB 240F                    			and	al,0fh						;mask out bits 4-7
  4513 000011ED 0C30                    			or	al,30h						;mask in ascii zone
  4514 000011EF 3C3A                    			cmp	al,3ah						;A through F?
  4515 000011F1 7202                    			jb	.20						;no, skip ahead
  4516 000011F3 0407                    			add	al,7						;41h through 46h
  4517 000011F5 AA                      .20			stosb							;store hexnum
  4518 000011F6 E2EE                    			loop	.10						;next nybble
  4519 000011F8 30C0                    			xor	al,al						;zero reg
  4520 000011FA AA                      			stosb							;null terminate
  4521 000011FB 5F                      			pop	edi						;restore non-volatile regs
  4522 000011FC C3                      			ret							;return
  4523                                  ;-----------------------------------------------------------------------------------------------------------------------
  4524                                  ;
  4525                                  ;	Routine:	DecimalToUnsigned
  4526                                  ;
  4527                                  ;	Description:	This routine returns an unsigned integer of the value of the input ASCIIZ decimal string.
  4528                                  ;
  4529                                  ;	Input:		DS:EDX	null-terminated decimal string address
  4530                                  ;
  4531                                  ;	Output: 	EAX	unsigned integer value
  4532                                  ;
  4533                                  ;-----------------------------------------------------------------------------------------------------------------------
  4534 000011FD 56                      DecimalToUnsigned	push	esi						;save non-volatile regs
  4535 000011FE 89D6                    			mov	esi,edx						;source address
  4536 00001200 31D2                    			xor	edx,edx						;zero total
  4537                                  
  4538 00001202 AC                      .10			lodsb							;source byte
  4539 00001203 3C2C                    			cmp	al,','						;comma?
  4540 00001205 74FB                    			je	.10						;yes, ignore
  4541                                  
  4542 00001207 84C0                    			test	al,al						;end of string?
  4543 00001209 7421                    			jz	.30						;yes, done
  4544 0000120B 3C2E                    			cmp	al,'.'						;decimal point?
  4545 0000120D 741D                    			je	.30						;yes, done
  4546                                  
  4547 0000120F 3C30                    			cmp	al,'0'						;numeral?
  4548 00001211 7217                    			jb	.20						;no, invalid string
  4549 00001213 3C39                    			cmp	al,'9'						;numeral?
  4550 00001215 7713                    			ja	.20						;no, invalid string
  4551                                  
  4552 00001217 240F                    			and	al,00Fh						;mask ASCII zone
  4553                                  
  4554 00001219 50                      			push	eax						;save numeral
  4555 0000121A D1E2                    			shl	edx,1						;total * 2
  4556 0000121C 89D0                    			mov	eax,edx						;total * 2
  4557 0000121E C1E202                  			shl	edx,2						;total * 8
  4558 00001221 01C2                    			add	edx,eax						;total * 10
  4559 00001223 58                      			pop	eax						;restore numeral
  4560                                  
  4561 00001224 01C2                    			add	edx,eax						;accumulate decimal digit
  4562 00001226 31C0                    			xor	eax,eax						;zero register
  4563 00001228 EBD8                    			jmp	.10						;next
  4564                                  
  4565 0000122A 31D2                    .20			xor	edx,edx						;zero result on error
  4566 0000122C 89D0                    .30			mov	eax,edx						;result
  4567 0000122E 5E                      			pop	esi						;restore non-volatile regs
  4568 0000122F C3                      			ret							;return
  4569                                  ;-----------------------------------------------------------------------------------------------------------------------
  4570                                  ;
  4571                                  ;	Routine:	HexadecimalToUnsigned
  4572                                  ;
  4573                                  ;	Description:	This routine returns an unsigned integer of the value of the input ASCIIZ hexadecimal string.
  4574                                  ;
  4575                                  ;	Input:		DS:EDX	null-terminated hexadecimal string address
  4576                                  ;
  4577                                  ;	Output: 	EAX	unsigned integer value
  4578                                  ;
  4579                                  ;-----------------------------------------------------------------------------------------------------------------------
  4580 00001230 56                      HexadecimalToUnsigned	push	esi						;save non-volatile regs
  4581 00001231 89D6                    			mov	esi,edx						;source address
  4582 00001233 31D2                    			xor	edx,edx						;zero register
  4583 00001235 AC                      .10			lodsb							;source byte
  4584 00001236 84C0                    			test	al,al						;end of string?
  4585 00001238 7410                    			jz	.30						;yes, branch
  4586 0000123A 3C39                    			cmp	al,'9'						;hexadecimal?
  4587 0000123C 7602                    			jna	.20						;no, skip ahead
  4588 0000123E 2C37                    			sub	al,37h						;'A' = 41h, less 37h = 0Ah
  4589 00001240 83E00F                  .20			and	eax,0fh						;remove ascii zone
  4590 00001243 C1E204                  			shl	edx,4						;previous total x 16
  4591 00001246 01C2                    			add	edx,eax						;add prior value x 16
  4592 00001248 EBEB                    			jmp	.10						;next
  4593 0000124A 89D0                    .30			mov	eax,edx						;result
  4594 0000124C 5E                      			pop	esi						;restore non-volatile regs
  4595 0000124D C3                      			ret							;return
  4596                                  ;=======================================================================================================================
  4597                                  ;
  4598                                  ;	Message Queue Helper Routines
  4599                                  ;
  4600                                  ;	PutMessage
  4601                                  ;	GetMessage
  4602                                  ;
  4603                                  ;=======================================================================================================================
  4604                                  ;-----------------------------------------------------------------------------------------------------------------------
  4605                                  ;
  4606                                  ;	Routine:	PutMessage
  4607                                  ;
  4608                                  ;	Description:	This routine adda a message to the message queue.
  4609                                  ;
  4610                                  ;	In:		EAX	message queue selector
  4611                                  ;			ECX	hi-order data word
  4612                                  ;			EDX	lo-order data word
  4613                                  ;
  4614                                  ;	Out:		CY	0 = success
  4615                                  ;				1 = fail: queue is full
  4616                                  ;
  4617                                  ;-----------------------------------------------------------------------------------------------------------------------
  4618 0000124E 1E                      PutMessage		push	ds						;save non-volatile regs
  4619 0000124F 50                      			push	eax						;load task message queue selector ...
  4620 00001250 1F                      			pop	ds						;... into data segment register
  4621 00001251 A104000000              			mov	eax,[MQTail]					;tail ptr
  4622 00001256 833800                  			cmp	dword [eax],0					;is queue full?
  4623 00001259 F9                      			stc							;assume failure
  4624 0000125A 7517                    			jne	.20						;yes, cannot store
  4625 0000125C 8910                    			mov	[eax],edx					;store lo-order data
  4626 0000125E 894804                  			mov	[eax+4],ecx					;store hi-order data
  4627 00001261 83C008                  			add	eax,8						;next queue element adr
  4628 00001264 25FC030000              			and	eax,03fch					;at end of queue?
  4629 00001269 7502                    			jnz	.10						;no, skip ahead
  4630 0000126B B008                    			mov	al,8						;reset to top of queue
  4631 0000126D A304000000              .10			mov	[MQTail],eax					;save new tail ptr
  4632 00001272 F8                      			clc							;indicate success
  4633 00001273 1F                      .20			pop	ds						;restore non-volatile regs
  4634 00001274 C3                      			ret							;return
  4635                                  ;-----------------------------------------------------------------------------------------------------------------------
  4636                                  ;
  4637                                  ;	Routine:	GetMessage
  4638                                  ;
  4639                                  ;	Description:	This routine reads and removes a message from the message queue.
  4640                                  ;
  4641                                  ;	Out:		EAX	lo-order message data
  4642                                  ;			EDX	hi-order message data
  4643                                  ;
  4644                                  ;			CY	0 = message read
  4645                                  ;				1 = no message to read
  4646                                  ;
  4647                                  ;-----------------------------------------------------------------------------------------------------------------------
  4648 00001275 53                      GetMessage		push	ebx						;save non-volatile regs
  4649 00001276 51                      			push	ecx						;
  4650 00001277 1E                      			push	ds						;
  4651 00001278 6A2C                    			push	ESELMQ						;load message queue selector ...
  4652 0000127A 1F                      			pop	ds						;... into data segment register
  4653 0000127B 8B1D00000000            			mov	ebx,[MQHead]					;head ptr
  4654 00001281 8B03                    			mov	eax,[ebx]					;lo-order 32 bits
  4655 00001283 8B5304                  			mov	edx,[ebx+4]					;hi-order 32 bits
  4656 00001286 09D0                    			or	eax,edx						;is queue empty?
  4657 00001288 F9                      			stc							;assume queue is emtpy
  4658 00001289 741B                    			jz	.20						;yes, skip ahead
  4659 0000128B 31C9                    			xor	ecx,ecx						;store zero
  4660 0000128D 890B                    			mov	[ebx],ecx					;... in lo-order dword
  4661 0000128F 894B04                  			mov	[ebx+4],ecx					;... in hi-order dword
  4662 00001292 83C308                  			add	ebx,8						;next queue element
  4663 00001295 81E3FC030000            			and	ebx,03fch					;at end of queue?
  4664 0000129B 7502                    			jnz	.10						;no, skip ahead
  4665 0000129D B308                    			mov	bl,8						;reset to 1st entry
  4666 0000129F 891D00000000            .10			mov	[MQHead],ebx					;save new head ptr
  4667 000012A5 F8                      			clc							;indicate message read
  4668 000012A6 1F                      .20			pop	ds						;restore non-volatile regs
  4669 000012A7 59                      			pop	ecx						;
  4670 000012A8 5B                      			pop	ebx						;
  4671 000012A9 C3                      			ret							;return
  4672                                  ;=======================================================================================================================
  4673                                  ;
  4674                                  ;	Memory-Mapped Video Routines
  4675                                  ;
  4676                                  ;	These routines read and/or write directly to CGA video memory (B800:0)
  4677                                  ;
  4678                                  ;	ClearConsoleScreen
  4679                                  ;	ScrollConsoleRow
  4680                                  ;	SetConsoleChar
  4681                                  ;
  4682                                  ;=======================================================================================================================
  4683                                  ;-----------------------------------------------------------------------------------------------------------------------
  4684                                  ;
  4685                                  ;	Routine:	ClearConsoleScreen
  4686                                  ;
  4687                                  ;	Description:	This routine clears the console (CGA) screen.
  4688                                  ;
  4689                                  ;-----------------------------------------------------------------------------------------------------------------------
  4690 000012AA 51                      ClearConsoleScreen	push	ecx						;save non-volatile regs
  4691 000012AB 57                      			push	edi						;
  4692 000012AC 1E                      			push	ds						;
  4693 000012AD 06                      			push	es						;
  4694 000012AE 6A18                    			push	ESELDAT						;load OS Data selector ...
  4695 000012B0 1F                      			pop	ds						;... into DS register
  4696 000012B1 6A20                    			push	ESELCGA						;load CGA selector ...
  4697 000012B3 07                      			pop	es						;... into ES register
  4698 000012B4 B820072007              			mov	eax,ECONCLEARDWORD				;initializtion value
  4699 000012B9 B9C0030000              			mov	ecx,ECONROWDWORDS*(ECONROWS)			;double-words to clear
  4700 000012BE 31FF                    			xor	edi,edi						;target offset
  4701 000012C0 FC                      			cld							;forward strings
  4702 000012C1 F3AB                    			rep	stosd						;reset screen body
  4703 000012C3 B820702070              			mov	eax,ECONOIADWORD				;OIA attribute and space
  4704 000012C8 B928000000              			mov	ecx,ECONROWDWORDS				;double-words per row
  4705 000012CD F3AB                    			rep	stosd						;reset OIA line
  4706 000012CF 30C0                    			xor	al,al						;zero register
  4707 000012D1 A2290A0000              			mov	[wbConsoleRow],al				;reset console row
  4708 000012D6 A2280A0000              			mov	[wbConsoleColumn],al				;reset console column
  4709 000012DB E857000000              			call	PlaceCursor					;place cursor at current position
  4710 000012E0 07                      			pop	es						;restore non-volatile regs
  4711 000012E1 1F                      			pop	ds						;
  4712 000012E2 5F                      			pop	edi						;
  4713 000012E3 59                      			pop	ecx						;
  4714 000012E4 C3                      			ret							;return
  4715                                  ;-----------------------------------------------------------------------------------------------------------------------
  4716                                  ;
  4717                                  ;	Routine:	ScrollConsoleRow
  4718                                  ;
  4719                                  ;	Description:	This routine scrolls the console (text) screen up one row.
  4720                                  ;
  4721                                  ;-----------------------------------------------------------------------------------------------------------------------
  4722 000012E5 51                      ScrollConsoleRow	push	ecx						;save non-volatile regs
  4723 000012E6 56                      			push	esi						;
  4724 000012E7 57                      			push	edi						;
  4725 000012E8 1E                      			push	ds						;
  4726 000012E9 06                      			push	es						;
  4727 000012EA 6A20                    			push	ESELCGA						;load CGA video selector ...
  4728 000012EC 1F                      			pop	ds						;... into DS
  4729 000012ED 6A20                    			push	ESELCGA						;load CGA video selector ...
  4730 000012EF 07                      			pop	es						;... into ES
  4731 000012F0 B998030000              			mov	ecx,ECONROWDWORDS*(ECONROWS-1)			;double-words to move
  4732 000012F5 BEA0000000              			mov	esi,ECONROWBYTES				;esi = source (line 2)
  4733 000012FA 31FF                    			xor	edi,edi						;edi = target (line 1)
  4734 000012FC FC                      			cld							;forward strings
  4735 000012FD F3A5                    			rep	movsd						;move 24 lines up
  4736 000012FF B820072007              			mov	eax,ECONCLEARDWORD				;attribute and ASCII space
  4737 00001304 B928000000              			mov	ecx,ECONROWDWORDS				;double-words per row
  4738 00001309 F3AB                    			rep	stosd						;clear bottom row
  4739 0000130B 07                      			pop	es						;restore non-volatile regs
  4740 0000130C 1F                      			pop	ds						;
  4741 0000130D 5F                      			pop	edi						;
  4742 0000130E 5E                      			pop	esi						;
  4743 0000130F 59                      			pop	ecx						;
  4744 00001310 C3                      			ret							;return
  4745                                  ;-----------------------------------------------------------------------------------------------------------------------
  4746                                  ;
  4747                                  ;	Routine:	SetConsoleString
  4748                                  ;
  4749                                  ;	Description:	This routine outputs a sequence of ASCII character at the given row and column.
  4750                                  ;
  4751                                  ;	In:		ESI	source offset (DS:)
  4752                                  ;			CL	column
  4753                                  ;			CH	row
  4754                                  ;			ES	CGA selector
  4755                                  ;
  4756                                  ;-----------------------------------------------------------------------------------------------------------------------
  4757 00001311 56                      SetConsoleString	push	esi						;save non-volatile regs
  4758 00001312 FC                      			cld							;forward strings
  4759 00001313 AC                      .10			lodsb							;next ASCII character
  4760 00001314 84C0                    			test	al,al						;end of string?
  4761 00001316 7407                    			jz	.20						;yes, branch
  4762 00001318 E804000000              			call	SetConsoleChar					;store character
  4763 0000131D EBF4                    			jmp	.10						;continue
  4764 0000131F 5E                      .20			pop	esi						;restore non-volatile regs
  4765 00001320 C3                      			ret							;return
  4766                                  ;-----------------------------------------------------------------------------------------------------------------------
  4767                                  ;
  4768                                  ;	Routine:	SetConsoleChar
  4769                                  ;
  4770                                  ;	Description:	This routine outputs an ASCII character at the given row and column.
  4771                                  ;
  4772                                  ;	In:		AL	ASCII character
  4773                                  ;			CL	column
  4774                                  ;			CH	row
  4775                                  ;			ES	CGA selector
  4776                                  ;
  4777                                  ;	Out:		EAX	last target address written (ES:)
  4778                                  ;			CL	column + 1
  4779                                  ;
  4780                                  ;-----------------------------------------------------------------------------------------------------------------------
  4781 00001321 88C2                    SetConsoleChar		mov	dl,al						;ASCII character
  4782 00001323 0FB6C5                  			movzx	eax,ch						;row
  4783 00001326 B450                    			mov	ah,ECONCOLS					;cols/row
  4784 00001328 F6E4                    			mul	ah						;row * cols/row
  4785 0000132A 00C8                    			add	al,cl						;add column
  4786 0000132C 80D400                  			adc	ah,0						;handle carry
  4787 0000132F D1E0                    			shl	eax,1						;screen offset
  4788 00001331 268810                  			mov	[es:eax],dl					;store character
  4789 00001334 FEC1                    			inc	cl						;next column
  4790 00001336 C3                      			ret							;return
  4791                                  ;=======================================================================================================================
  4792                                  ;
  4793                                  ;	Input/Output Routines
  4794                                  ;
  4795                                  ;	These routines read and/or write directly to ports.
  4796                                  ;
  4797                                  ;	PlaceCursor
  4798                                  ;	PutPrimaryEndOfInt
  4799                                  ;	PutSecondaryEndOfInt
  4800                                  ;	ReadRealTimeClock
  4801                                  ;	ResetSystem
  4802                                  ;	SetKeyboardLamps
  4803                                  ;	WaitForKeyInBuffer
  4804                                  ;	WaitForKeyOutBuffer
  4805                                  ;
  4806                                  ;=======================================================================================================================
  4807                                  ;-----------------------------------------------------------------------------------------------------------------------
  4808                                  ;
  4809                                  ;	Routine:	PlaceCursor
  4810                                  ;
  4811                                  ;	Description:	This routine positions the cursor on the console.
  4812                                  ;
  4813                                  ;	In:		DS	OS data selector
  4814                                  ;
  4815                                  ;-----------------------------------------------------------------------------------------------------------------------
  4816 00001337 51                      PlaceCursor		push	ecx						;save non-volatile regs
  4817 00001338 A0290A0000              			mov	al,[wbConsoleRow]				;al = row
  4818 0000133D B450                    			mov	ah,ECONCOLS					;ah = cols/row
  4819 0000133F F6E4                    			mul	ah						;row offset
  4820 00001341 0205280A0000            			add	al,[wbConsoleColumn]				;add column
  4821 00001347 80D400                  			adc	ah,0						;add overflow
  4822 0000134A 89C1                    			mov	ecx,eax						;screen offset
  4823 0000134C B2D4                    			mov	dl,ECRTPORTLO					;crt controller port lo
  4824 0000134E B603                    			mov	dh,ECRTPORTHI					;crt controller port hi
  4825 00001350 B00E                    			mov	al,ECRTCURLOCHI					;crt cursor loc reg hi
  4826 00001352 EE                      			out	dx,al						;select register
  4827 00001353 42                      			inc	edx						;data port
  4828 00001354 88E8                    			mov	al,ch						;hi-order cursor loc
  4829 00001356 EE                      			out	dx,al						;store hi-order loc
  4830 00001357 4A                      			dec	edx						;register select port
  4831 00001358 B00F                    			mov	al,ECRTCURLOCLO					;crt cursor loc reg lo
  4832 0000135A EE                      			out	dx,al						;select register
  4833 0000135B 42                      			inc	edx						;data port
  4834 0000135C 88C8                    			mov	al,cl						;lo-order cursor loc
  4835 0000135E EE                      			out	dx,al						;store lo-order loc
  4836 0000135F 59                      			pop	ecx						;restore non-volatile regs
  4837 00001360 C3                      			ret							;return
  4838                                  ;-----------------------------------------------------------------------------------------------------------------------
  4839                                  ;
  4840                                  ;	Routine:	PutPrimaryEndOfInt
  4841                                  ;
  4842                                  ;	Description:	This routine sends a non-specific end-of-interrupt signal to the primary PIC.
  4843                                  ;
  4844                                  ;-----------------------------------------------------------------------------------------------------------------------
  4845 00001361 FB                      PutPrimaryEndOfInt	sti							;enable maskable interrupts
  4846 00001362 B020                    			mov	al,EPICEOI					;non-specific end-of-interrupt
  4847 00001364 E620                    			out	EPICPORTPRI,al					;send EOI to primary PIC
  4848 00001366 C3                      			ret							;return
  4849                                  ;-----------------------------------------------------------------------------------------------------------------------
  4850                                  ;
  4851                                  ;	Routine:	PutSecondaryEndOfInt
  4852                                  ;
  4853                                  ;	Description:	This routine sends a non-specific end-of-interrupt signal to the secondary PIC.
  4854                                  ;
  4855                                  ;-----------------------------------------------------------------------------------------------------------------------
  4856 00001367 FB                      PutSecondaryEndOfInt	sti							;enable maskable interrupts
  4857 00001368 B020                    			mov	al,EPICEOI					;non-specific end-of-interrupt
  4858 0000136A E6A0                    			out	EPICPORTSEC,al					;send EOI to secondary PIC
  4859 0000136C C3                      			ret							;return
  4860                                  ;-----------------------------------------------------------------------------------------------------------------------
  4861                                  ;
  4862                                  ;	Routine:	ReadRealTimeClock
  4863                                  ;
  4864                                  ;	Description:	This routine gets current date time from the real-time clock.
  4865                                  ;
  4866                                  ;	In:		DS:EBX	DATETIME structure
  4867                                  ;
  4868                                  ;-----------------------------------------------------------------------------------------------------------------------
  4869 0000136D 56                      ReadRealTimeClock	push	esi						;save non-volatile regs
  4870 0000136E 57                      			push	edi						;
  4871 0000136F 06                      			push	es						;
  4872 00001370 1E                      			push	ds						;store data selector ...
  4873 00001371 07                      			pop	es						;... in es register
  4874 00001372 89DF                    			mov	edi,ebx						;date-time structure
  4875 00001374 B000                    			mov	al,ERTCSECONDREG				;second register
  4876 00001376 E670                    			out	ERTCREGPORT,al					;select second register
  4877 00001378 E471                    			in	al,ERTCDATAPORT					;read second register
  4878 0000137A FC                      			cld							;forward strings
  4879 0000137B AA                      			stosb							;store second value
  4880 0000137C B002                    			mov	al,ERTCMINUTEREG				;minute register
  4881 0000137E E670                    			out	ERTCREGPORT,al					;select minute register
  4882 00001380 E471                    			in	al,ERTCDATAPORT					;read minute register
  4883 00001382 AA                      			stosb							;store minute value
  4884 00001383 B004                    			mov	al,ERTCHOURREG					;hour register
  4885 00001385 E670                    			out	ERTCREGPORT,al					;select hour register
  4886 00001387 E471                    			in	al,ERTCDATAPORT					;read hour register
  4887 00001389 AA                      			stosb							;store hour value
  4888 0000138A B006                    			mov	al,ERTCWEEKDAYREG				;weekday register
  4889 0000138C E670                    			out	ERTCREGPORT,al					;select weekday register
  4890 0000138E E471                    			in	al,ERTCDATAPORT					;read weekday register
  4891 00001390 AA                      			stosb							;store weekday value
  4892 00001391 B007                    			mov	al,ERTCDAYREG					;day register
  4893 00001393 E670                    			out	ERTCREGPORT,al					;select day register
  4894 00001395 E471                    			in	al,ERTCDATAPORT					;read day register
  4895 00001397 AA                      			stosb							;store day value
  4896 00001398 B008                    			mov	al,ERTCMONTHREG					;month register
  4897 0000139A E670                    			out	ERTCREGPORT,al					;select month register
  4898 0000139C E471                    			in	al,ERTCDATAPORT					;read month register
  4899 0000139E AA                      			stosb							;store month value
  4900 0000139F B009                    			mov	al,ERTCYEARREG					;year register
  4901 000013A1 E670                    			out	ERTCREGPORT,al					;select year register
  4902 000013A3 E471                    			in	al,ERTCDATAPORT					;read year register
  4903 000013A5 AA                      			stosb							;store year value
  4904 000013A6 B032                    			mov	al,ERTCCENTURYREG				;century register
  4905 000013A8 E670                    			out	ERTCREGPORT,al					;select century register
  4906 000013AA E471                    			in	al,ERTCDATAPORT					;read century register
  4907 000013AC AA                      			stosb							;store century value
  4908 000013AD B00B                    			mov	al,ERTCSTATUSREG				;status register
  4909 000013AF E670                    			out	ERTCREGPORT,al					;select status register
  4910 000013B1 E471                    			in	al,ERTCDATAPORT					;read status register
  4911 000013B3 A804                    			test	al,ERTCBINARYVALS				;test if values are binary
  4912 000013B5 751D                    			jnz	.20						;skip ahead if binary values
  4913 000013B7 89DE                    			mov	esi,ebx						;date-time structure address
  4914 000013B9 89DF                    			mov	edi,ebx						;date-time structure address
  4915 000013BB B908000000              			mov	ecx,8						;loop counter
  4916 000013C0 AC                      .10			lodsb							;BCD value
  4917 000013C1 88C4                    			mov	ah,al						;BCD value
  4918 000013C3 240F                    			and	al,00001111b					;low-order decimal zone
  4919 000013C5 80E4F0                  			and	ah,11110000b					;hi-order decimal zone
  4920 000013C8 D0EC                    			shr	ah,1						;hi-order decimal * 8
  4921 000013CA 00E0                    			add	al,ah						;low-order + hi-order * 8
  4922 000013CC C0EC02                  			shr	ah,2						;hi-order decimal * 2
  4923 000013CF 00E0                    			add	al,ah						;low-order + hi-order * 10
  4924 000013D1 AA                      			stosb							;replace BCD with binary
  4925 000013D2 E2EC                    			loop	.10						;next value
  4926 000013D4 07                      .20			pop	es						;restore non-volatile regs
  4927 000013D5 5F                      			pop	edi						;
  4928 000013D6 5E                      			pop	esi						;
  4929 000013D7 C3                      			ret							;return
  4930                                  ;-----------------------------------------------------------------------------------------------------------------------
  4931                                  ;
  4932                                  ;	Routine:	ResetSystem
  4933                                  ;
  4934                                  ;	Description:	This routine restarts the system using the 8042 controller.
  4935                                  ;
  4936                                  ;	Out:		N/A	This routine does not return.
  4937                                  ;
  4938                                  ;-----------------------------------------------------------------------------------------------------------------------
  4939 000013D8 B9FFFF1F00              ResetSystem		mov	ecx,001fffffh					;delay to clear ints
  4940 000013DD E2FE                    			loop	$						;clear interrupts
  4941 000013DF B0FE                    			mov	al,EKEYBCMDRESET				;mask out bit zero
  4942 000013E1 E664                    			out	EKEYBPORTSTAT,al				;drive bit zero low
  4943 000013E3 FB                      .10			sti							;enable maskable interrupts
  4944 000013E4 F4                      			hlt							;halt until interrupt
  4945 000013E5 EBFC                    			jmp	.10						;repeat until reset kicks in
  4946                                  ;-----------------------------------------------------------------------------------------------------------------------
  4947                                  ;
  4948                                  ;	Routine:	SetKeyboardLamps
  4949                                  ;
  4950                                  ;	Description:	This routine sends the set/reset mode indicators command to the keyboard device.
  4951                                  ;
  4952                                  ;	In:		BH	00000CNS (C:Caps Lock,N:Num Lock,S:Scroll Lock)
  4953                                  ;
  4954                                  ;-----------------------------------------------------------------------------------------------------------------------
  4955 000013E7 E81C000000              SetKeyboardLamps	call	WaitForKeyInBuffer				;wait for input buffer ready
  4956 000013EC B0ED                    			mov	al,EKEYBCMDLAMPS				;set/reset lamps command
  4957 000013EE E660                    			out	EKEYBPORTDATA,al				;send command to 8042
  4958 000013F0 E821000000              			call	WaitForKeyOutBuffer				;wait for 8042 result
  4959 000013F5 E460                    			in	al,EKEYBPORTDATA				;read 8042 'ACK' (0fah)
  4960 000013F7 E80C000000              			call	WaitForKeyInBuffer				;wait for input buffer ready
  4961 000013FC 88F8                    			mov	al,bh						;set/reset lamps value
  4962 000013FE E660                    			out	EKEYBPORTDATA,al				;send lamps value
  4963 00001400 E811000000              			call	WaitForKeyOutBuffer				;wait for 8042 result
  4964 00001405 E460                    			in	al,EKEYBPORTDATA				;read 8042 'ACK' (0fah)
  4965 00001407 C3                      			ret							;return
  4966                                  ;-----------------------------------------------------------------------------------------------------------------------
  4967                                  ;
  4968                                  ;	Routine:	WaitForKeyInBuffer
  4969                                  ;
  4970                                  ;	Description:	This routine waits for keyboard input buffer to be ready for input.
  4971                                  ;
  4972                                  ;	Out:		ZF	1 = Input buffer ready
  4973                                  ;				0 = Input buffer not ready after timeout
  4974                                  ;
  4975                                  ;-----------------------------------------------------------------------------------------------------------------------
  4976 00001408 51                      WaitForKeyInBuffer	push	ecx						;save non-volatile regs
  4977 00001409 B900000100              			mov	ecx,EKEYBWAITLOOP				;keyboard controller timeout
  4978 0000140E E464                    .10			in	al,EKEYBPORTSTAT				;keyboard status byte
  4979 00001410 A802                    			test	al,EKEYBBITIN					;is input buffer still full?
  4980 00001412 E0FA                    			loopnz	.10						;yes, repeat till timeout
  4981 00001414 59                      			pop	ecx						;restore non-volatile regs
  4982 00001415 C3                      			ret							;return
  4983                                  ;-----------------------------------------------------------------------------------------------------------------------
  4984                                  ;
  4985                                  ;	Routine:	WaitForKeyOutBuffer
  4986                                  ;
  4987                                  ;	Description:	This routine waits for keyboard output buffer to have data to read.
  4988                                  ;
  4989                                  ;	Out:		ZF	1 = Output buffer has data from controller
  4990                                  ;				0 = Output buffer empty after timeout
  4991                                  ;
  4992                                  ;-----------------------------------------------------------------------------------------------------------------------
  4993 00001416 51                      WaitForKeyOutBuffer	push	ecx						;save non-volatile regs
  4994 00001417 B900000100              			mov	ecx,EKEYBWAITLOOP				;keyboard controller timeout
  4995 0000141C E464                    .10			in	al,EKEYBPORTSTAT				;keyboard status byte
  4996 0000141E A801                    			test	al,EKEYBBITOUT					;output buffer status bit
  4997 00001420 E1FA                    			loopz	.10						;loop until output buffer bit
  4998 00001422 59                      			pop	ecx						;restore non-volatile regs
  4999 00001423 C3                      			ret							;return
  5000                                  ;-----------------------------------------------------------------------------------------------------------------------
  5001                                  ;
  5002                                  ;	End of the Kernel Function Library
  5003                                  ;
  5004                                  ;-----------------------------------------------------------------------------------------------------------------------
  5005 00001424 00<rept>                			times	8190-($-$$) db 0h				;zero fill to end of section
  5006 00001FFE 55AA                    			db	055h,0AAh					;end of segment
  5007                                  ;=======================================================================================================================
  5008                                  ;
  5009                                  ;	Console Task
  5010                                  ;
  5011                                  ;	The only task defined in the kernel is the console task. This task consists of code, data, stack, and task state
  5012                                  ;	segments and a local descriptor table. The console task accepts and echos user keyboard input to the console
  5013                                  ;	screen and responds to user commands.
  5014                                  ;
  5015                                  ;=======================================================================================================================
  5016                                  ;-----------------------------------------------------------------------------------------------------------------------
  5017                                  ;
  5018                                  ;	Console Stack								@disk: 007400	@mem:  004000
  5019                                  ;
  5020                                  ;	This is the stack for the console task. It supports 448 nested calls.
  5021                                  ;
  5022                                  ;-----------------------------------------------------------------------------------------------------------------------
  5023                                  section			constack						;console task stack
  5024 00000000 00<rept>                			times	1792-($-$$) db 0h				;zero fill to end of section
  5025                                  ;-----------------------------------------------------------------------------------------------------------------------
  5026                                  ;
  5027                                  ;	Console Local Descriptor Table						@disk: 007B00	@mem:  004700
  5028                                  ;
  5029                                  ;	This is the LDT for the console task. It defines the stack, code, data and queue segments as well as data
  5030                                  ;	aliases for the TSS LDT. Data aliases allow inspection and altering of the TSS and LDT. This LDT can hold up to
  5031                                  ;	16 descriptors. Six are initially defined.
  5032                                  ;
  5033                                  ;-----------------------------------------------------------------------------------------------------------------------
  5034                                  section			conldt							;console local descriptors
  5035 00000000 7F00804700934000        			dq	004093004780007Fh				;04 TSS alias
  5036 00000008 7F00004700934000        			dq	004093004700007Fh				;0C LDT alias
  5037 00000010 FF06004000934000        			dq	00409300400006FFh				;14 stack
  5038 00000018 FFFF00000093CF00        			dq	00CF93000000FFFFh				;1C data
  5039 00000020 FF0F0050009B4000        			dq	00409B0050000FFFh				;24 code
  5040 00000028 FF07004800934000        			dq	00409300480007FFh				;2C message queue
  5041 00000030 00<rept>                			times	128-($-$$) db 0h				;zero fill to end of section
  5042                                  ;-----------------------------------------------------------------------------------------------------------------------
  5043                                  ;
  5044                                  ;	Console Task State Segment						@disk: 007B80	@mem:  004780
  5045                                  ;
  5046                                  ;	This is the TSS for the console task. All rings share the same stack. DS and ES are set to the console data
  5047                                  ;	segment. CS to console code.
  5048                                  ;
  5049                                  ;-----------------------------------------------------------------------------------------------------------------------
  5050                                  section			contss							;console task state segment
  5051 00000000 00000000                			dd	0						;00 back-link tss
  5052 00000004 00070000                			dd	0700h						;04 esp ring 0
  5053 00000008 14000000                			dd	0014h						;08 ss ring 0
  5054 0000000C 00070000                			dd	0700h						;0C esp ring 1
  5055 00000010 14000000                			dd	0014h						;10 es ring 1
  5056 00000014 00070000                			dd	0700h						;14 esp ring 2
  5057 00000018 14000000                			dd	0014h						;18 ss ring 2
  5058 0000001C 00000000                			dd	0						;1C cr ring 3
  5059 00000020 00000000                			dd	0						;20 eip
  5060 00000024 00020000                			dd	0200h						;24 eflags
  5061 00000028 00000000                			dd	0						;28 eax
  5062 0000002C 00000000                			dd	0						;2C ecx
  5063 00000030 00000000                			dd	0						;30 edx
  5064 00000034 00000000                			dd	0						;34 ebx
  5065 00000038 00070000                			dd	0700h						;38 esp ring 3
  5066 0000003C 00000000                			dd	0						;3C ebp
  5067 00000040 00000000                			dd	0						;40 esi
  5068 00000044 00000000                			dd	0						;44 edi
  5069 00000048 1C000000                			dd	001Ch						;48 es
  5070 0000004C 24000000                			dd	0024h						;4C cs
  5071 00000050 14000000                			dd	0014h						;50 ss ring 3
  5072 00000054 1C000000                			dd	001Ch						;54 ds
  5073 00000058 00000000                			dd	0						;58 fs
  5074 0000005C 00000000                			dd	0						;5c gs
  5075 00000060 60000000                			dd	ESELCONSOLELDT					;60 ldt selector in gdt
  5076 00000064 00<rept>                			times	128-($-$$) db 0h				;zero fill to end of section
  5077                                  ;-----------------------------------------------------------------------------------------------------------------------
  5078                                  ;
  5079                                  ;	Console Message Queue							@disk: 007C00	@mem: 004800
  5080                                  ;
  5081                                  ;	The console message queue is 2048 bytes of memory organized as a queue of 510 double words (4 bytes each) and
  5082                                  ;	two double word values that act as indices. The queue is a FIFO that is fed by the keyboard hardware interrupt
  5083                                  ;	handler and consumed by a service routine called from a task. Each queue entry defines an input (keystroke)
  5084                                  ;	event.
  5085                                  ;
  5086                                  ;-----------------------------------------------------------------------------------------------------------------------
  5087                                  section			conmque							;console message queue
  5088 00000000 08000000                			dd	8						;head pointer
  5089 00000004 08000000                			dd	8						;tail pointer
  5090 00000008 00000000<rept>          			times	510 dd 0					;queue elements
  5091                                  ;-----------------------------------------------------------------------------------------------------------------------
  5092                                  ;
  5093                                  ;	Console Code								@disk: 008400	@mem: 005000
  5094                                  ;
  5095                                  ;	This is the code for the console task. The task is defined in the GDT in two descriptors, the Local Descriptor
  5096                                  ;	Table (LDT) at 0050h and the Task State Segment (TSS) at 0058h. Jumping to or calling a TSS selector causes a
  5097                                  ;	task switch, giving control to the code for the task at the CS:IP defined in the TSS for the current ring level.
  5098                                  ;	The initial CS:IP in the Console TSS is 24h:0, where 24h is a selector in the LDT. This selector points to the
  5099                                  ;	concode section, loaded into memory 5000h by the Loader. The console task is dedicated to accepting user key-
  5100                                  ;	board input, echoing to the console screen and responding to user commands.
  5101                                  ;
  5102                                  ;	When control reaches this section, our addressability is set up according to the following diagram.
  5103                                  ;
  5104                                  ;	DS,ES --------> 000000	+-----------------------------------------------+ DS,ES:0000
  5105                                  ;				|  Real Mode Interrupt Vectors			|
  5106                                  ;			000400	+-----------------------------------------------+ DS,ES:0400
  5107                                  ;				|  Reserved BIOS Memory Area			|
  5108                                  ;			000800	+-----------------------------------------------+ DS,ES:0800
  5109                                  ;				|  Shared Kernel Memory Area			|
  5110                                  ;			001000	+-----------------------------------------------+		<-- GDTR
  5111                                  ;				|  Global Descriptor Table (GDT)		|
  5112                                  ;			001800	+-----------------------------------------------+		<-- IDTR
  5113                                  ;				|  Interrupt Descriptor Table (IDT)		|
  5114                                  ;			002000	+-----------------------------------------------+
  5115                                  ;				|  Interrupt Handlers				|
  5116                                  ;				|  Kernel Function Library			|
  5117                                  ;	SS ----------->	004000	+===============================================+ SS:0000
  5118                                  ;				|  Console Task Stack Area			|
  5119                                  ;	SS:SP --------> 004700	+-----------------------------------------------+ SS:0700	<-- LDTR = GDT.SEL 0050h
  5120                                  ;				|  Console Task Local Descriptor Table (LDT)	|
  5121                                  ;			004780	+-----------------------------------------------+		<-- TR  = GDT.SEL 0058h
  5122                                  ;				|  Console Task Task State Segment (TSS)	|
  5123                                  ;			004800	+-----------------------------------------------+
  5124                                  ;				|  Console Task Message Queue			|
  5125                                  ;	CS,CS:IP ----->	005000	+-----------------------------------------------+ CS:0000
  5126                                  ;				|  Console Task Code				|
  5127                                  ;				|  Console Task Constants			|
  5128                                  ;			006000	+===============================================+
  5129                                  ;
  5130                                  ;-----------------------------------------------------------------------------------------------------------------------
  5131                                  section			concode	vstart=05000h					;labels relative to 5000h
  5132 00000000 E874000000              ConCode			call	ConInitializeData				;initialize console variables
  5133                                  
  5134                                  			clearConsoleScreen					;clear the console screen
  5134 00000005 B001                <1>  mov al,eClearConsoleScreen
  5134 00000007 CD30                <1>  int _svc
  5135                                  			putConsoleString czTitle				;display startup message
  5135 00000009 BA[90050000]        <1>  mov edx,%1
  5135 0000000E B00A                <1>  mov al,ePutConsoleString
  5135 00000010 CD30                <1>  int _svc
  5136                                  .10			putConsoleString czPrompt				;display input prompt
  5136                              <1> .10 :
  5136 00000012 BA[8E050000]        <1>  mov edx,%1
  5136 00000017 B00A                <1>  mov al,ePutConsoleString
  5136 00000019 CD30                <1>  int _svc
  5137                                  			placeCursor						;set CRT cursor location
  5137 0000001B B009                <1>  mov al,ePlaceCursor
  5137 0000001D CD30                <1>  int _svc
  5138                                  			getConsoleString wzConsoleInBuffer,79,1,13		;accept keyboard input
  5138 0000001F BA340A0000          <1>  mov edx,%1
  5138 00000024 B94F000000          <1>  mov ecx,%2
  5138 00000029 B701                <1>  mov bh,%3
  5138 0000002B B30D                <1>  mov bl,%4
  5138 0000002D B006                <1>  mov al,eGetConsoleString
  5138 0000002F CD30                <1>  int _svc
  5139                                  			putConsoleString czNewLine				;newline
  5139 00000031 BA[86050000]        <1>  mov edx,%1
  5139 00000036 B00A                <1>  mov al,ePutConsoleString
  5139 00000038 CD30                <1>  int _svc
  5140                                  
  5141 0000003A C605840A000000          			mov	byte [wzConsoleToken],0				;null-terminate token buffer
  5142 00000041 BA340A0000              			mov	edx,wzConsoleInBuffer				;console input buffer
  5143 00000046 BB840A0000              			mov	ebx,wzConsoleToken				;token buffer
  5144 0000004B E880000000              			call	ConTakeToken					;handle console input
  5145 00000050 BA840A0000              			mov	edx,wzConsoleToken				;token buffer
  5146 00000055 E8A4000000              			call	ConDetermineCommand				;determine command number
  5147 0000005A 83F818                  			cmp	eax,ECONJMPTBLCNT				;valid command number?
  5148 0000005D 720B                    			jb	.20						;yes, branch
  5149                                  
  5150                                  			putConsoleString czUnknownCommand			;display error message
  5150 0000005F BA[AE050000]        <1>  mov edx,%1
  5150 00000064 B00A                <1>  mov al,ePutConsoleString
  5150 00000066 CD30                <1>  int _svc
  5151                                  
  5152 00000068 EBA8                    			jmp	.10						;next command
  5153 0000006A C1E002                  .20			shl	eax,2						;index into jump table
  5154 0000006D BA[70040000]            			mov	edx,tConJmpTbl					;jump table base address
  5155 00000072 8B0402                  			mov	eax,[edx+eax]					;command handler routine address
  5156 00000075 FFD0                    			call	eax						;call command handler
  5157 00000077 EB99                    			jmp	.10						;next command
  5158                                  ;-----------------------------------------------------------------------------------------------------------------------
  5159                                  ;
  5160                                  ;	Routine:	ConInitializeData
  5161                                  ;
  5162                                  ;	Description:	This routine initializes console task variables.
  5163                                  ;
  5164                                  ;-----------------------------------------------------------------------------------------------------------------------
  5165 00000079 51                      ConInitializeData	push	ecx						;save non-volatile regs
  5166 0000007A 57                      			push	edi						;
  5167 0000007B 06                      			push	es						;
  5168                                  ;
  5169                                  ;	Initialize console work areas
  5170                                  ;
  5171 0000007C 6A18                    			push	ESELDAT						;load OS data selector ...
  5172 0000007E 07                      			pop	es						;... into extra segment register
  5173 0000007F BF240A0000              			mov	edi,ECONDATA					;OS console data address
  5174 00000084 30C0                    			xor	al,al						;initialization value
  5175 00000086 B908010000              			mov	ecx,ECONDATALEN					;size of OS console data
  5176 0000008B FC                      			cld							;forward strings
  5177 0000008C F3AA                    			rep	stosb						;initialize data
  5178                                  ;
  5179                                  ;	Initialize heap size
  5180                                  ;
  5181 0000008E B800000080              			mov	eax,EMEMHEAPSIZE				;heap size (temporary)
  5182 00000093 A3080A0000              			mov	[wfHeapSize],eax				;set heap size
  5183 00000098 B006                    			mov	al,6
  5184 0000009A A2290A0000              			mov	[wbConsoleRow],al
  5185                                  ;
  5186                                  ;	Initialize MEMROOT structure
  5187                                  ;
  5188 0000009F BF0C0A0000              			mov	edi,wsMemRoot					;memory root structure address
  5189 000000A4 B800000100              			mov	eax,EMEMBASE					;base address of heap storage
  5190 000000A9 31C9                    			xor	ecx,ecx						;zero register
  5191 000000AB B104                    			mov	cl,4						;count
  5192 000000AD F3AB                    			rep	stosd						;store first/last contig and free addrs
  5193 000000AF 31C0                    			xor	eax,eax						;zero register
  5194 000000B1 AB                      			stosd							;zero first task block
  5195 000000B2 AB                      			stosd							;zero last task block
  5196                                  ;
  5197                                  ;	Initialize MEMBLOCK structure at EMEMBASE
  5198                                  ;
  5199 000000B3 BF00000100              			mov	edi,EMEMBASE					;memory block structure address
  5200 000000B8 B846524545              			mov	eax,EMEMFREECODE				;free memory signature
  5201 000000BD AB                      			stosd							;store signature
  5202 000000BE A1080A0000              			mov	eax,[wfHeapSize]				;heap size
  5203 000000C3 AB                      			stosd							;store block size
  5204 000000C4 31C0                    			xor	eax,eax						;zero register
  5205 000000C6 31C9                    			xor	ecx,ecx						;zero register
  5206 000000C8 B106                    			mov	cl,6						;count
  5207 000000CA F3AB                    			rep	stosd						;zero owner, reserved, pointers
  5208                                  ;
  5209                                  ;	Restore and return
  5210                                  ;
  5211 000000CC 07                      			pop	es						;restore non-volatile regs
  5212 000000CD 5F                      			pop	edi						;
  5213 000000CE 59                      			pop	ecx						;
  5214 000000CF C3                      			ret							;return
  5215                                  ;-----------------------------------------------------------------------------------------------------------------------
  5216                                  ;
  5217                                  ;	Routine:	ConTakeToken
  5218                                  ;
  5219                                  ;	Description:	This routine extracts the next token from the given source buffer.
  5220                                  ;
  5221                                  ;	In:		DS:EDX	source buffer address
  5222                                  ;			DS:EBX	target buffer address
  5223                                  ;
  5224                                  ;	Out:		DS:EDX	source buffer address
  5225                                  ;			DS:EBX	target buffer address
  5226                                  ;
  5227                                  ;	Command Form:	Line	= *3( *SP 1*ALNUM )
  5228                                  ;
  5229                                  ;-----------------------------------------------------------------------------------------------------------------------
  5230 000000D0 56                      ConTakeToken		push	esi						;save non-volatile regs
  5231 000000D1 57                      			push	edi						;
  5232 000000D2 89D6                    			mov	esi,edx						;source buffer address
  5233 000000D4 89DF                    			mov	edi,ebx						;target buffer address
  5234 000000D6 FC                      			cld							;forward strings
  5235 000000D7 AC                      .10			lodsb							;load byte
  5236 000000D8 3C20                    			cmp	al,EASCIISPACE					;space?
  5237 000000DA 74FB                    			je	.10						;yes, continue
  5238 000000DC 84C0                    			test	al,al						;end of line?
  5239 000000DE 7410                    			jz	.40						;yes, branch
  5240 000000E0 AA                      .20			stosb							;store byte
  5241 000000E1 AC                      			lodsb							;load byte
  5242 000000E2 84C0                    			test	al,al						;end of line?
  5243 000000E4 740A                    			jz	.40						;no, continue
  5244 000000E6 3C20                    			cmp	al,EASCIISPACE					;space?
  5245 000000E8 75F6                    			jne	.20						;no, continue
  5246 000000EA AC                      .30			lodsb							;load byte
  5247 000000EB 3C20                    			cmp	al,EASCIISPACE					;space?
  5248 000000ED 74FB                    			je	.30						;yes, continue
  5249 000000EF 4E                      			dec	esi						;pre-position
  5250 000000F0 C60700                  .40			mov	byte [edi],0					;terminate buffer
  5251 000000F3 89D7                    			mov	edi,edx						;source buffer address
  5252 000000F5 AC                      .50			lodsb							;remaining byte
  5253 000000F6 AA                      			stosb							;move to front of buffer
  5254 000000F7 84C0                    			test	al,al						;end of line?
  5255 000000F9 75FA                    			jnz	.50						;no, continue
  5256 000000FB 5F                      			pop	edi						;restore non-volatile regs
  5257 000000FC 5E                      			pop	esi						;
  5258 000000FD C3                      			ret							;return
  5259                                  ;-----------------------------------------------------------------------------------------------------------------------
  5260                                  ;
  5261                                  ;	Routine:	ConDetermineCommand
  5262                                  ;
  5263                                  ;	Description:	This routine determines the command number for the command at DS:EDX.
  5264                                  ;
  5265                                  ;	input:		DS:EDX	command address
  5266                                  ;
  5267                                  ;	output:		EAX	>=0	= command nbr
  5268                                  ;				0	= unknown command
  5269                                  ;
  5270                                  ;-----------------------------------------------------------------------------------------------------------------------
  5271 000000FE 53                      ConDetermineCommand	push	ebx						;save non-volatile regs
  5272 000000FF 51                      			push	ecx						;
  5273 00000100 56                      			push	esi						;
  5274 00000101 57                      			push	edi						;
  5275                                  
  5276                                  			upperCaseString						;upper-case string at EDX
  5276 00000102 B01B                <1>  mov al,eUpperCaseString
  5276 00000104 CD30                <1>  int _svc
  5277                                  
  5278 00000106 BE[D0040000]            			mov	esi,tConCmdTbl					;commands table
  5279 0000010B 31FF                    			xor	edi,edi						;intialize command number
  5280 0000010D FC                      			cld							;forward strings
  5281 0000010E AC                      .10			lodsb							;command length
  5282 0000010F 0FB6C8                  			movzx	ecx,al						;command length
  5283 00000112 E30D                    			jecxz	.20						;branch if end of table
  5284 00000114 89F3                    			mov	ebx,esi						;table entry address
  5285 00000116 01CE                    			add	esi,ecx						;next table entry address
  5286                                  
  5287                                  			compareMemory						;compare byte arrays at EDX, EBX
  5287 00000118 B002                <1>  mov al,eCompareMemory
  5287 0000011A CD30                <1>  int _svc
  5288                                  
  5289 0000011C E303                    			jecxz	.20						;branch if equal
  5290 0000011E 47                      			inc	edi						;increment command nbr
  5291 0000011F EBED                    			jmp	.10						;repeat
  5292 00000121 89F8                    .20			mov	eax,edi						;command number
  5293 00000123 5F                      			pop	edi						;restore non-volatile regs
  5294 00000124 5E                      			pop	esi						;
  5295 00000125 59                      			pop	ecx						;
  5296 00000126 5B                      			pop	ebx						;
  5297 00000127 C3                      			ret							;return
  5298                                  ;-----------------------------------------------------------------------------------------------------------------------
  5299                                  ;
  5300                                  ;	Routine:	ConClear
  5301                                  ;
  5302                                  ;	Description:	This routine handles the CLEAR command and its CLS alias.
  5303                                  ;
  5304                                  ;-----------------------------------------------------------------------------------------------------------------------
  5305                                  ConClear		clearConsoleScreen					;clear console screen
  5305                              <1> ConClear :
  5305 00000128 B001                <1>  mov al,eClearConsoleScreen
  5305 0000012A CD30                <1>  int _svc
  5306 0000012C C3                      			ret							;return
  5307                                  ;-----------------------------------------------------------------------------------------------------------------------
  5308                                  ;
  5309                                  ;	Routine:	ConDate
  5310                                  ;
  5311                                  ;	Description:	This routine handles the DATE command.
  5312                                  ;
  5313                                  ;-----------------------------------------------------------------------------------------------------------------------
  5314                                  ConDate			readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5314                              <1> ConDate :
  5314 0000012D BB240B0000          <1>  mov ebx,%1
  5314 00000132 B016                <1>  mov al,eReadRealTimeClock
  5314 00000134 CD30                <1>  int _svc
  5315                                  			putDateString	  wsConsoleDateTime,wzConsoleOutBuffer	;format date string
  5315 00000136 BB240B0000          <1>  mov ebx,%1
  5315 0000013B BAD40A0000          <1>  mov edx,%2
  5315 00000140 B00B                <1>  mov al,ePutDateString
  5315 00000142 CD30                <1>  int _svc
  5316                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5316 00000144 BAD40A0000          <1>  mov edx,%1
  5316 00000149 B00A                <1>  mov al,ePutConsoleString
  5316 0000014B CD30                <1>  int _svc
  5317                                  			putConsoleString  czNewLine				;write newline to console
  5317 0000014D BA[86050000]        <1>  mov edx,%1
  5317 00000152 B00A                <1>  mov al,ePutConsoleString
  5317 00000154 CD30                <1>  int _svc
  5318 00000156 C3                      			ret							;return
  5319                                  ;-----------------------------------------------------------------------------------------------------------------------
  5320                                  ;
  5321                                  ;	Routine:	ConDay
  5322                                  ;
  5323                                  ;	Description:	This routine handles the DAY command.
  5324                                  ;
  5325                                  ;-----------------------------------------------------------------------------------------------------------------------
  5326                                  ConDay			readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5326                              <1> ConDay :
  5326 00000157 BB240B0000          <1>  mov ebx,%1
  5326 0000015C B016                <1>  mov al,eReadRealTimeClock
  5326 0000015E CD30                <1>  int _svc
  5327                                  			putDayString      wsConsoleDateTime,wzConsoleOutBuffer	;format day string
  5327 00000160 BB240B0000          <1>  mov ebx,%1
  5327 00000165 BAD40A0000          <1>  mov edx,%2
  5327 0000016A B00C                <1>  mov al,ePutDayString
  5327 0000016C CD30                <1>  int _svc
  5328                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5328 0000016E BAD40A0000          <1>  mov edx,%1
  5328 00000173 B00A                <1>  mov al,ePutConsoleString
  5328 00000175 CD30                <1>  int _svc
  5329                                  			putConsoleString  czNewLine				;write newline to console
  5329 00000177 BA[86050000]        <1>  mov edx,%1
  5329 0000017C B00A                <1>  mov al,ePutConsoleString
  5329 0000017E CD30                <1>  int _svc
  5330 00000180 C3                      			ret							;return
  5331                                  ;-----------------------------------------------------------------------------------------------------------------------
  5332                                  ;
  5333                                  ;	Routine:	ConExit
  5334                                  ;
  5335                                  ;	Description:	This routine handles the EXIT command and its SHUTDOWN and QUIT aliases.
  5336                                  ;
  5337                                  ;-----------------------------------------------------------------------------------------------------------------------
  5338                                  ConExit			resetSystem						;issue system reset
  5338                              <1> ConExit :
  5338 00000181 B017                <1>  mov al,eResetSystem
  5338 00000183 CD30                <1>  int _svc
  5339 00000185 C3                      			ret							;return
  5340                                  ;-----------------------------------------------------------------------------------------------------------------------
  5341                                  ;
  5342                                  ;	Routine:	ConFree
  5343                                  ;
  5344                                  ;	Description:	This routine handles the FREE command.
  5345                                  ;
  5346                                  ;	Input:		wzConsoleInBuffer contains parameter(s)
  5347                                  ;
  5348                                  ;-----------------------------------------------------------------------------------------------------------------------
  5349 00000186 53                      ConFree			push	ebx						;save non-volatile regs
  5350 00000187 51                      			push	ecx						;
  5351 00000188 56                      			push	esi						;
  5352 00000189 57                      			push	edi						;
  5353                                  ;
  5354                                  ;	Get address parameter
  5355                                  ;
  5356 0000018A BA340A0000              			mov	edx,wzConsoleInBuffer				;console input buffer address (param)
  5357 0000018F BB840A0000              			mov	ebx,wzConsoleToken				;console command token address
  5358 00000194 E837FFFFFF              			call	ConTakeToken					;take first param as token
  5359                                  ;
  5360                                  ;	Convert input parameter from hexadecimal string to binary
  5361                                  ;
  5362 00000199 803D840A000000          			cmp	byte [wzConsoleToken],0				;token found?
  5363 000001A0 7421                    			je	.10						;no, branch
  5364 000001A2 BA840A0000              			mov	edx,wzConsoleToken				;first param as token address
  5365                                  
  5366                                  			hexadecimalToUnsigned					;convert string token to unsigned
  5366 000001A7 B007                <1>  mov al,eHexadecimalToUnsigned
  5366 000001A9 CD30                <1>  int _svc
  5367                                  
  5368 000001AB 85C0                    			test	eax,eax						;valid parameter?
  5369 000001AD 7414                    			jz	.10						;no, branch
  5370                                  ;
  5371                                  ;	Free memory block
  5372                                  ;
  5373                                  			freeMemory eax						;free memory
  5373 000001AF 89C2                <1>  mov edx,%1
  5373 000001B1 B005                <1>  mov al,eFreeMemory
  5373 000001B3 CD30                <1>  int _svc
  5374                                  
  5375 000001B5 83F8FF                  			cmp	eax,-1						;memory freed?
  5376 000001B8 7409                    			je	.10						;no, branch
  5377                                  ;
  5378                                  ;	Indicate memory freed
  5379                                  ;
  5380                                  			putConsoleString czOK
  5380 000001BA BA[89050000]        <1>  mov edx,%1
  5380 000001BF B00A                <1>  mov al,ePutConsoleString
  5380 000001C1 CD30                <1>  int _svc
  5381                                  ;
  5382                                  ;	Restore and return
  5383                                  ;
  5384 000001C3 5F                      .10			pop	edi						;restore non-volatile regs
  5385 000001C4 5E                      			pop	esi						;
  5386 000001C5 59                      			pop	ecx						;
  5387 000001C6 5B                      			pop	ebx						;
  5388 000001C7 C3                      			ret							;return
  5389                                  ;-----------------------------------------------------------------------------------------------------------------------
  5390                                  ;
  5391                                  ;	Routine:	ConHour
  5392                                  ;
  5393                                  ;	Description:	This routine Handles the HOUR command.
  5394                                  ;
  5395                                  ;-----------------------------------------------------------------------------------------------------------------------
  5396                                  ConHour			readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5396                              <1> ConHour :
  5396 000001C8 BB240B0000          <1>  mov ebx,%1
  5396 000001CD B016                <1>  mov al,eReadRealTimeClock
  5396 000001CF CD30                <1>  int _svc
  5397                                  			putHourString     wsConsoleDateTime,wzConsoleOutBuffer	;format hour string
  5397 000001D1 BB240B0000          <1>  mov ebx,%1
  5397 000001D6 BAD40A0000          <1>  mov edx,%2
  5397 000001DB B00D                <1>  mov al,ePutHourString
  5397 000001DD CD30                <1>  int _svc
  5398                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5398 000001DF BAD40A0000          <1>  mov edx,%1
  5398 000001E4 B00A                <1>  mov al,ePutConsoleString
  5398 000001E6 CD30                <1>  int _svc
  5399                                  			putConsoleString  czNewLine				;write newline to console
  5399 000001E8 BA[86050000]        <1>  mov edx,%1
  5399 000001ED B00A                <1>  mov al,ePutConsoleString
  5399 000001EF CD30                <1>  int _svc
  5400 000001F1 C3                      			ret							;return
  5401                                  ;-----------------------------------------------------------------------------------------------------------------------
  5402                                  ;
  5403                                  ;	Routine:	ConInt6
  5404                                  ;
  5405                                  ;	Description:	This routine issues an interrupt 6 to exercise the interrupt handler.
  5406                                  ;
  5407                                  ;-----------------------------------------------------------------------------------------------------------------------
  5408 000001F2 0F0B                    ConInt6			ud2							;raise bad opcode exception
  5409 000001F4 C3                      			ret							;return (not executed)
  5410                                  ;-----------------------------------------------------------------------------------------------------------------------
  5411                                  ;
  5412                                  ;	Routine:	ConMalloc
  5413                                  ;
  5414                                  ;	Description:	This routine handles the MALLOC command.
  5415                                  ;
  5416                                  ;	Input:		wzConsoleInBuffer contains parameter(s)
  5417                                  ;
  5418                                  ;-----------------------------------------------------------------------------------------------------------------------
  5419 000001F5 53                      ConMalloc		push	ebx						;save non-volatile regs
  5420 000001F6 51                      			push	ecx						;
  5421 000001F7 56                      			push	esi						;
  5422 000001F8 57                      			push	edi						;
  5423                                  ;
  5424                                  ;	Get size parameter
  5425                                  ;
  5426 000001F9 BA340A0000              			mov	edx,wzConsoleInBuffer				;console input buffer address (params)
  5427 000001FE BB840A0000              			mov	ebx,wzConsoleToken				;console command token address
  5428 00000203 E8C8FEFFFF              			call	ConTakeToken					;take first param as token
  5429                                  ;
  5430                                  ;	Convert input parameter from decimal string to binary
  5431                                  ;
  5432 00000208 803D840A000000          			cmp	byte [wzConsoleToken],0				;token found?
  5433 0000020F 7434                    			je	.10						;no, branch
  5434 00000211 BA840A0000              			mov	edx,wzConsoleToken				;first param as token address
  5435                                  
  5436                                  			decimalToUnsigned					;convert string token to unsigned
  5436 00000216 B004                <1>  mov al,eDecimalToUnsigned
  5436 00000218 CD30                <1>  int _svc
  5437                                  
  5438 0000021A 85C0                    			test	eax,eax						;valid parameter?
  5439 0000021C 7427                    			jz	.10						;no, branch
  5440                                  ;
  5441                                  ;	Allocate memory block
  5442                                  ;
  5443                                  			allocateMemory eax					;allocate memory
  5443 0000021E 89C1                <1>  mov ecx,%1
  5443 00000220 B000                <1>  mov al,eAllocateMemory
  5443 00000222 CD30                <1>  int _svc
  5444                                  
  5445 00000224 85C0                    			test	eax,eax						;memory allocated?
  5446 00000226 741D                    			jz	.10						;no, branch
  5447                                  ;
  5448                                  ;	Report allocated memory block address
  5449                                  ;
  5450 00000228 BAD40A0000              			mov	edx,wzConsoleOutBuffer				;output buffer address
  5451 0000022D 89C1                    			mov	ecx,eax						;memory address
  5452                                  
  5453                                  			unsignedToHexadecimal					;convert memory address to hex
  5453 0000022F B01A                <1>  mov al,eUnsignedToHexadecimal
  5453 00000231 CD30                <1>  int _svc
  5454                                  			putConsoleString wzConsoleOutBuffer			;display memory address
  5454 00000233 BAD40A0000          <1>  mov edx,%1
  5454 00000238 B00A                <1>  mov al,ePutConsoleString
  5454 0000023A CD30                <1>  int _svc
  5455                                  			putConsoleString czNewLine				;display new line
  5455 0000023C BA[86050000]        <1>  mov edx,%1
  5455 00000241 B00A                <1>  mov al,ePutConsoleString
  5455 00000243 CD30                <1>  int _svc
  5456                                  
  5457 00000245 5F                      .10			pop	edi						;restore non-volatile regs
  5458 00000246 5E                      			pop	esi						;
  5459 00000247 59                      			pop	ecx						;
  5460 00000248 5B                      			pop	ebx
  5461 00000249 C3                      			ret							;return
  5462                                  ;-----------------------------------------------------------------------------------------------------------------------
  5463                                  ;
  5464                                  ;	Routine:	ConMem
  5465                                  ;
  5466                                  ;	Description:	This routine handles the MEMORY command and its MEM alias.
  5467                                  ;
  5468                                  ;	Input:		wzConsoleInBuffer contains parameter(s)
  5469                                  ;
  5470                                  ;-----------------------------------------------------------------------------------------------------------------------
  5471 0000024A 53                      ConMem			push	ebx						;save non-volatile regs
  5472 0000024B 56                      			push	esi						;
  5473 0000024C 57                      			push	edi						;
  5474                                  ;
  5475                                  ;			update the source address if a parameter is given
  5476                                  ;
  5477 0000024D BA340A0000              			mov	edx,wzConsoleInBuffer				;console input buffer address (params)
  5478 00000252 BB840A0000              			mov	ebx,wzConsoleToken				;console command token address
  5479 00000257 E874FEFFFF              			call	ConTakeToken					;take first param as token
  5480 0000025C 803D840A000000          			cmp	byte [wzConsoleToken],0				;token found?
  5481 00000263 740E                    			je	.10						;no, branch
  5482 00000265 BA840A0000              			mov	edx,wzConsoleToken				;first param as token address
  5483                                  
  5484                                  			hexadecimalToUnsigned					;convert string token to unsigned
  5484 0000026A B007                <1>  mov al,eHexadecimalToUnsigned
  5484 0000026C CD30                <1>  int _svc
  5485                                  
  5486 0000026E A3240A0000              			mov	[wfConsoleMemAddr],eax				;save console memory address
  5487                                  ;
  5488                                  ;			setup source address and row count
  5489                                  ;
  5490 00000273 8B35240A0000            .10			mov	esi,[wfConsoleMemAddr]				;source memory address
  5491 00000279 31C9                    			xor	ecx,ecx						;zero register
  5492 0000027B B110                    			mov	cl,16						;row count
  5493                                  ;
  5494                                  ;			start the row with the source address in hexadecimal
  5495                                  ;
  5496 0000027D 51                      .20			push	ecx						;save remaining rows
  5497 0000027E BFD40A0000              			mov	edi,wzConsoleOutBuffer				;output buffer address
  5498 00000283 89FA                    			mov	edx,edi						;output buffer address
  5499 00000285 89F1                    			mov	ecx,esi						;console memory address
  5500                                  
  5501                                  			unsignedToHexadecimal					;convert unsigned address to hex string
  5501 00000287 B01A                <1>  mov al,eUnsignedToHexadecimal
  5501 00000289 CD30                <1>  int _svc
  5502                                  
  5503 0000028B 83C708                  			add	edi,8						;end of memory addr hexnum
  5504 0000028E B020                    			mov	al,' '						;ascii space
  5505 00000290 AA                      			stosb							;store delimiter
  5506                                  ;
  5507                                  ;			output 16 ASCII hexadecimal byte values for the row
  5508                                  ;
  5509 00000291 31C9                    			xor	ecx,ecx						;zero register
  5510 00000293 B110                    			mov	cl,16						;loop count
  5511 00000295 51                      .30			push	ecx						;save loop count
  5512 00000296 AC                      			lodsb							;memory byte
  5513 00000297 88C4                    			mov	ah,al						;memory byte
  5514 00000299 C0E804                  			shr	al,4						;high-order in bits 3-0
  5515 0000029C 0C30                    			or	al,30h						;apply ascii numeric zone
  5516 0000029E 3C3A                    			cmp	al,3ah						;numeric range?
  5517 000002A0 7202                    			jb	.40						;yes, skip ahead
  5518 000002A2 0407                    			add	al,7						;adjust ascii for 'A'-'F'
  5519 000002A4 AA                      .40			stosb							;store ascii hexadecimal of high-order
  5520 000002A5 88E0                    			mov	al,ah						;low-order in bits 3-0
  5521 000002A7 240F                    			and	al,0fh						;mask out high-order bits
  5522 000002A9 0C30                    			or	al,30h						;apply ascii numeric zone
  5523 000002AB 3C3A                    			cmp	al,3ah						;numeric range?
  5524 000002AD 7202                    			jb	.50						;yes, skip ahead
  5525 000002AF 0407                    			add	al,7						;adjust ascii for 'A'-'F'
  5526 000002B1 AA                      .50			stosb							;store ascii hexadecimal of low-order
  5527 000002B2 B020                    			mov	al,' '						;ascii space
  5528 000002B4 AA                      			stosb							;store ascii space delimiter
  5529 000002B5 59                      			pop	ecx						;loop count
  5530 000002B6 E2DD                    			loop	.30						;next
  5531                                  ;
  5532                                  ;			output printable ASCII character section for the row
  5533                                  ;
  5534 000002B8 83EE10                  			sub	esi,16						;reset source pointer
  5535 000002BB B110                    			mov	cl,16						;loop count
  5536 000002BD AC                      .60			lodsb							;source byte
  5537 000002BE 3C20                    			cmp	al,32						;printable? (low-range test)
  5538 000002C0 7204                    			jb	.70						;no, skip ahead
  5539 000002C2 3C80                    			cmp	al,128						;printable? (high-range test)
  5540 000002C4 7202                    			jb	.80						;yes, skip ahead
  5541 000002C6 B020                    .70			mov	al,' '						;display space instead of printable
  5542 000002C8 AA                      .80			stosb							;store printable ascii byte
  5543 000002C9 E2F2                    			loop	.60						;next source byte
  5544 000002CB 30C0                    			xor	al,al						;nul-terminator
  5545 000002CD AA                      			stosb							;terminate output line
  5546                                  ;
  5547                                  ;			display constructed output buffer and newline
  5548                                  ;
  5549                                  			putConsoleString wzConsoleOutBuffer			;display constructed output
  5549 000002CE BAD40A0000          <1>  mov edx,%1
  5549 000002D3 B00A                <1>  mov al,ePutConsoleString
  5549 000002D5 CD30                <1>  int _svc
  5550                                  			putConsoleString czNewLine				;display new line
  5550 000002D7 BA[86050000]        <1>  mov edx,%1
  5550 000002DC B00A                <1>  mov al,ePutConsoleString
  5550 000002DE CD30                <1>  int _svc
  5551                                  ;
  5552                                  ;			repeat until all lines displayed and preserve source address
  5553                                  ;
  5554 000002E0 59                      			pop	ecx						;remaining rows
  5555 000002E1 E29A                    			loop	.20						;next row
  5556 000002E3 8935240A0000            			mov	[wfConsoleMemAddr],esi				;update console memory address
  5557 000002E9 5F                      			pop	edi						;restore regs
  5558 000002EA 5E                      			pop	esi						;
  5559 000002EB 5B                      			pop	ebx						;
  5560 000002EC C3                      			ret							;return
  5561                                  ;-----------------------------------------------------------------------------------------------------------------------
  5562                                  ;
  5563                                  ;	Routine:	ConMinute
  5564                                  ;
  5565                                  ;	Description:	This routine Handles the MINUTE command.
  5566                                  ;
  5567                                  ;-----------------------------------------------------------------------------------------------------------------------
  5568                                  ConMinute		readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5568                              <1> ConMinute :
  5568 000002ED BB240B0000          <1>  mov ebx,%1
  5568 000002F2 B016                <1>  mov al,eReadRealTimeClock
  5568 000002F4 CD30                <1>  int _svc
  5569                                  			putMinuteString   wsConsoleDateTime,wzConsoleOutBuffer	;format minute string
  5569 000002F6 BB240B0000          <1>  mov ebx,%1
  5569 000002FB BAD40A0000          <1>  mov edx,%2
  5569 00000300 B00E                <1>  mov al,ePutMinuteString
  5569 00000302 CD30                <1>  int _svc
  5570                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5570 00000304 BAD40A0000          <1>  mov edx,%1
  5570 00000309 B00A                <1>  mov al,ePutConsoleString
  5570 0000030B CD30                <1>  int _svc
  5571                                  			putConsoleString  czNewLine				;write newline to console
  5571 0000030D BA[86050000]        <1>  mov edx,%1
  5571 00000312 B00A                <1>  mov al,ePutConsoleString
  5571 00000314 CD30                <1>  int _svc
  5572 00000316 C3                      			ret							;return
  5573                                  ;-----------------------------------------------------------------------------------------------------------------------
  5574                                  ;
  5575                                  ;	Routine:	ConMonth
  5576                                  ;
  5577                                  ;	Description:	This routine Handles the MONTH command.
  5578                                  ;
  5579                                  ;-----------------------------------------------------------------------------------------------------------------------
  5580                                  ConMonth		readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5580                              <1> ConMonth :
  5580 00000317 BB240B0000          <1>  mov ebx,%1
  5580 0000031C B016                <1>  mov al,eReadRealTimeClock
  5580 0000031E CD30                <1>  int _svc
  5581                                  			putMonthString    wsConsoleDateTime,wzConsoleOutBuffer	;format month string
  5581 00000320 BB240B0000          <1>  mov ebx,%1
  5581 00000325 BAD40A0000          <1>  mov edx,%2
  5581 0000032A B00F                <1>  mov al,ePutMonthString
  5581 0000032C CD30                <1>  int _svc
  5582                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5582 0000032E BAD40A0000          <1>  mov edx,%1
  5582 00000333 B00A                <1>  mov al,ePutConsoleString
  5582 00000335 CD30                <1>  int _svc
  5583                                  			putConsoleString  czNewLine				;write newline to console
  5583 00000337 BA[86050000]        <1>  mov edx,%1
  5583 0000033C B00A                <1>  mov al,ePutConsoleString
  5583 0000033E CD30                <1>  int _svc
  5584 00000340 C3                      			ret							;return
  5585                                  ;-----------------------------------------------------------------------------------------------------------------------
  5586                                  ;
  5587                                  ;	Routine:	ConMonthName
  5588                                  ;
  5589                                  ;	Description:	This routine Handles the MONTH.NAME command.
  5590                                  ;
  5591                                  ;-----------------------------------------------------------------------------------------------------------------------
  5592                                  ConMonthName		readRealTimeClock  wsConsoleDateTime			;read RTC data into structure
  5592                              <1> ConMonthName :
  5592 00000341 BB240B0000          <1>  mov ebx,%1
  5592 00000346 B016                <1>  mov al,eReadRealTimeClock
  5592 00000348 CD30                <1>  int _svc
  5593                                  			putMonthNameString wsConsoleDateTime,wzConsoleOutBuffer	;format month name string
  5593 0000034A BB240B0000          <1>  mov ebx,%1
  5593 0000034F BAD40A0000          <1>  mov edx,%2
  5593 00000354 B010                <1>  mov al,ePutMonthNameString
  5593 00000356 CD30                <1>  int _svc
  5594                                  			putConsoleString   wzConsoleOutBuffer			;write string to console
  5594 00000358 BAD40A0000          <1>  mov edx,%1
  5594 0000035D B00A                <1>  mov al,ePutConsoleString
  5594 0000035F CD30                <1>  int _svc
  5595                                  			putConsoleString   czNewLine				;write newline to console
  5595 00000361 BA[86050000]        <1>  mov edx,%1
  5595 00000366 B00A                <1>  mov al,ePutConsoleString
  5595 00000368 CD30                <1>  int _svc
  5596 0000036A C3                      			ret							;return
  5597                                  ;-----------------------------------------------------------------------------------------------------------------------
  5598                                  ;
  5599                                  ;	Routine:	ConSecond
  5600                                  ;
  5601                                  ;	Description:	This routine Handles the SECOND command.
  5602                                  ;
  5603                                  ;-----------------------------------------------------------------------------------------------------------------------
  5604                                  ConSecond		readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5604                              <1> ConSecond :
  5604 0000036B BB240B0000          <1>  mov ebx,%1
  5604 00000370 B016                <1>  mov al,eReadRealTimeClock
  5604 00000372 CD30                <1>  int _svc
  5605                                  			putSecondString   wsConsoleDateTime,wzConsoleOutBuffer	;format second string
  5605 00000374 BB240B0000          <1>  mov ebx,%1
  5605 00000379 BAD40A0000          <1>  mov edx,%2
  5605 0000037E B011                <1>  mov al,ePutSecondString
  5605 00000380 CD30                <1>  int _svc
  5606                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5606 00000382 BAD40A0000          <1>  mov edx,%1
  5606 00000387 B00A                <1>  mov al,ePutConsoleString
  5606 00000389 CD30                <1>  int _svc
  5607                                  			putConsoleString  czNewLine				;write newline to console
  5607 0000038B BA[86050000]        <1>  mov edx,%1
  5607 00000390 B00A                <1>  mov al,ePutConsoleString
  5607 00000392 CD30                <1>  int _svc
  5608 00000394 C3                      			ret							;return
  5609                                  ;-----------------------------------------------------------------------------------------------------------------------
  5610                                  ;
  5611                                  ;	Routine:	ConTime
  5612                                  ;
  5613                                  ;	Description:	This routine Handles the TIME command.
  5614                                  ;
  5615                                  ;-----------------------------------------------------------------------------------------------------------------------
  5616                                  ConTime			readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5616                              <1> ConTime :
  5616 00000395 BB240B0000          <1>  mov ebx,%1
  5616 0000039A B016                <1>  mov al,eReadRealTimeClock
  5616 0000039C CD30                <1>  int _svc
  5617                                  			putTimeString	  wsConsoleDateTime,wzConsoleOutBuffer	;format time string
  5617 0000039E BB240B0000          <1>  mov ebx,%1
  5617 000003A3 BAD40A0000          <1>  mov edx,%2
  5617 000003A8 B012                <1>  mov al,ePutTimeString
  5617 000003AA CD30                <1>  int _svc
  5618                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5618 000003AC BAD40A0000          <1>  mov edx,%1
  5618 000003B1 B00A                <1>  mov al,ePutConsoleString
  5618 000003B3 CD30                <1>  int _svc
  5619                                  			putConsoleString  czNewLine				;write newline to console
  5619 000003B5 BA[86050000]        <1>  mov edx,%1
  5619 000003BA B00A                <1>  mov al,ePutConsoleString
  5619 000003BC CD30                <1>  int _svc
  5620 000003BE C3                      			ret							;return
  5621                                  ;-----------------------------------------------------------------------------------------------------------------------
  5622                                  ;
  5623                                  ;	Routine:	ConWeekday
  5624                                  ;
  5625                                  ;	Description:	This routine handles the WEEKDAY command.
  5626                                  ;
  5627                                  ;-----------------------------------------------------------------------------------------------------------------------
  5628                                  ConWeekday		readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5628                              <1> ConWeekday :
  5628 000003BF BB240B0000          <1>  mov ebx,%1
  5628 000003C4 B016                <1>  mov al,eReadRealTimeClock
  5628 000003C6 CD30                <1>  int _svc
  5629                                  			putWeekdayString  wsConsoleDateTime,wzConsoleOutBuffer	;format weekday string
  5629 000003C8 BB240B0000          <1>  mov ebx,%1
  5629 000003CD BAD40A0000          <1>  mov edx,%2
  5629 000003D2 B013                <1>  mov al,ePutWeekdayString
  5629 000003D4 CD30                <1>  int _svc
  5630                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5630 000003D6 BAD40A0000          <1>  mov edx,%1
  5630 000003DB B00A                <1>  mov al,ePutConsoleString
  5630 000003DD CD30                <1>  int _svc
  5631                                  			putConsoleString  czNewLine				;write newline to console
  5631 000003DF BA[86050000]        <1>  mov edx,%1
  5631 000003E4 B00A                <1>  mov al,ePutConsoleString
  5631 000003E6 CD30                <1>  int _svc
  5632 000003E8 C3                      			ret							;return
  5633                                  ;-----------------------------------------------------------------------------------------------------------------------
  5634                                  ;
  5635                                  ;	Routine:	ConWeekdayName
  5636                                  ;
  5637                                  ;	Description:	This routine Handles the WEEKDAY.NAME command.
  5638                                  ;
  5639                                  ;-----------------------------------------------------------------------------------------------------------------------
  5640                                  ConWeekdayName		readRealTimeClock    wsConsoleDateTime				;read RTC data into structure
  5640                              <1> ConWeekdayName :
  5640 000003E9 BB240B0000          <1>  mov ebx,%1
  5640 000003EE B016                <1>  mov al,eReadRealTimeClock
  5640 000003F0 CD30                <1>  int _svc
  5641                                  			putWeekdayNameString wsConsoleDateTime,wzConsoleOutBuffer	;format day name string
  5641 000003F2 BB240B0000          <1>  mov ebx,%1
  5641 000003F7 BAD40A0000          <1>  mov edx,%2
  5641 000003FC B014                <1>  mov al,ePutWeekdayNameString
  5641 000003FE CD30                <1>  int _svc
  5642                                  			putConsoleString     wzConsoleOutBuffer				;write string to console
  5642 00000400 BAD40A0000          <1>  mov edx,%1
  5642 00000405 B00A                <1>  mov al,ePutConsoleString
  5642 00000407 CD30                <1>  int _svc
  5643                                  			putConsoleString     czNewLine					;write newline to console
  5643 00000409 BA[86050000]        <1>  mov edx,%1
  5643 0000040E B00A                <1>  mov al,ePutConsoleString
  5643 00000410 CD30                <1>  int _svc
  5644 00000412 C3                      			ret								;return
  5645                                  ;-----------------------------------------------------------------------------------------------------------------------
  5646                                  ;
  5647                                  ;	Routine:	ConYear
  5648                                  ;
  5649                                  ;	Description:	This routine Handles the YEAR command.
  5650                                  ;
  5651                                  ;-----------------------------------------------------------------------------------------------------------------------
  5652                                  ConYear			readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5652                              <1> ConYear :
  5652 00000413 BB240B0000          <1>  mov ebx,%1
  5652 00000418 B016                <1>  mov al,eReadRealTimeClock
  5652 0000041A CD30                <1>  int _svc
  5653                                  			putYearString	  wsConsoleDateTime,wzConsoleOutBuffer	;format year string
  5653 0000041C BB240B0000          <1>  mov ebx,%1
  5653 00000421 BAD40A0000          <1>  mov edx,%2
  5653 00000426 B015                <1>  mov al,ePutYearString
  5653 00000428 CD30                <1>  int _svc
  5654                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5654 0000042A BAD40A0000          <1>  mov edx,%1
  5654 0000042F B00A                <1>  mov al,ePutConsoleString
  5654 00000431 CD30                <1>  int _svc
  5655                                  			putConsoleString  czNewLine				;write newline to console
  5655 00000433 BA[86050000]        <1>  mov edx,%1
  5655 00000438 B00A                <1>  mov al,ePutConsoleString
  5655 0000043A CD30                <1>  int _svc
  5656 0000043C C3                      			ret							;return
  5657                                  ;-----------------------------------------------------------------------------------------------------------------------
  5658                                  ;
  5659                                  ;	Routine:	ConYearIsLeap
  5660                                  ;
  5661                                  ;	Description:	This routine handles the YEAR.ISLEAP command
  5662                                  ;
  5663                                  ;-----------------------------------------------------------------------------------------------------------------------
  5664                                  ConYearIsLeap		readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5664                              <1> ConYearIsLeap :
  5664 0000043D BB240B0000          <1>  mov ebx,%1
  5664 00000442 B016                <1>  mov al,eReadRealTimeClock
  5664 00000444 CD30                <1>  int _svc
  5665                                  			isLeapYear        wsConsoleDateTime			;indicate if year is leap year
  5665 00000446 BB240B0000          <1>  mov ebx,%1
  5665 0000044B B008                <1>  mov al,eIsLeapYear
  5665 0000044D CD30                <1>  int _svc
  5666                                  
  5667 0000044F E30B                    			jecxz	.10						;branch if not leap
  5668                                  
  5669                                  			putConsoleString  czYearIsLeap				;display year is leap message
  5669 00000451 BA[C0050000]        <1>  mov edx,%1
  5669 00000456 B00A                <1>  mov al,ePutConsoleString
  5669 00000458 CD30                <1>  int _svc
  5670                                  
  5671 0000045A EB09                    			jmp	.20						;continue
  5672                                  
  5673                                  .10			putConsoleString  czYearIsNotLeap			;display year is not leap mesage
  5673                              <1> .10 :
  5673 0000045C BA[DB050000]        <1>  mov edx,%1
  5673 00000461 B00A                <1>  mov al,ePutConsoleString
  5673 00000463 CD30                <1>  int _svc
  5674 00000465 C3                      .20			ret							;return
  5675                                  ;-----------------------------------------------------------------------------------------------------------------------
  5676                                  ;
  5677                                  ;	Routine:	ConVersion
  5678                                  ;
  5679                                  ;	Description:	This routine handles the VERSION command and its alias, VER.
  5680                                  ;
  5681                                  ;-----------------------------------------------------------------------------------------------------------------------
  5682                                  ConVersion		putConsoleString czTitle				;display version message
  5682                              <1> ConVersion :
  5682 00000466 BA[90050000]        <1>  mov edx,%1
  5682 0000046B B00A                <1>  mov al,ePutConsoleString
  5682 0000046D CD30                <1>  int _svc
  5683 0000046F C3                      			ret							;return
  5684                                  ;-----------------------------------------------------------------------------------------------------------------------
  5685                                  ;
  5686                                  ;	Tables
  5687                                  ;
  5688                                  ;-----------------------------------------------------------------------------------------------------------------------
  5689                                  										;---------------------------------------
  5690                                  										;  Command Jump Table
  5691                                  										;---------------------------------------
  5692                                  tConJmpTbl		equ	$						;command jump table
  5693 00000470 E9030000                			dd	ConWeekdayName	- ConCode			;weekday.name command routine offset
  5694 00000474 3D040000                			dd	ConYearIsLeap	- ConCode			;year.isleap command routine offset
  5695 00000478 41030000                			dd	ConMonthName	- ConCode			;month.name command routine offset
  5696 0000047C 81010000                			dd	ConExit		- ConCode			;shutdown command routine offset
  5697 00000480 66040000                			dd	ConVersion	- ConCode			;version command routine offset
  5698 00000484 BF030000                			dd	ConWeekday	- ConCode			;weekday command routine offset
  5699 00000488 F5010000                			dd	ConMalloc	- ConCode			;malloc command routine offset
  5700 0000048C 4A020000                			dd	ConMem		- ConCode			;memory command routine offset
  5701 00000490 ED020000                			dd	ConMinute	- ConCode			;minute command routine offset
  5702 00000494 6B030000                			dd	ConSecond	- ConCode			;second command routine offset
  5703 00000498 28010000                			dd	ConClear	- ConCode			;clear command routine offset
  5704 0000049C 17030000                			dd	ConMonth	- ConCode			;month command routine offset
  5705 000004A0 2D010000                			dd	ConDate		- ConCode			;date command routine offset
  5706 000004A4 81010000                			dd	ConExit		- ConCode			;exit command routine offset
  5707 000004A8 86010000                			dd	ConFree		- ConCode			;free command routine offset
  5708 000004AC C8010000                			dd	ConHour		- ConCode			;hour command routine offset
  5709 000004B0 F2010000                			dd	ConInt6		- ConCode			;int6 command routine offset
  5710 000004B4 81010000                			dd	ConExit		- ConCode			;quit command routine offset
  5711 000004B8 95030000                			dd	ConTime		- ConCode			;time command routine offset
  5712 000004BC 13040000                			dd	ConYear		- ConCode			;year command routine offset
  5713 000004C0 28010000                			dd	ConClear	- ConCode			;cls command routine offset
  5714 000004C4 57010000                			dd	ConDay		- ConCode			;day command routine offset
  5715 000004C8 4A020000                			dd	ConMem		- ConCode			;mem command routine offset
  5716 000004CC 66040000                			dd	ConVersion	- ConCode			;ver command routine offset
  5717                                  ECONJMPTBLL		equ	($-tConJmpTbl)					;table length
  5718                                  ECONJMPTBLCNT		equ	ECONJMPTBLL/4					;table entries
  5719                                  										;---------------------------------------
  5720                                  										;  Command Name Table
  5721                                  										;---------------------------------------
  5722                                  tConCmdTbl		equ	$						;command name table
  5723 000004D0 0D5745454B4441592E-     			db	13,"WEEKDAY.NAME",0				;weekday.name command
  5723 000004D9 4E414D4500         
  5724 000004DE 0C594541522E49534C-     			db	12,"YEAR.ISLEAP",0				;year.isleap command
  5724 000004E7 45415000           
  5725 000004EB 0B4D4F4E54482E4E41-     			db	11,"MONTH.NAME",0				;month.name command
  5725 000004F4 4D4500             
  5726 000004F7 0953485554444F574E-     			db	9,"SHUTDOWN",0					;shutdown command
  5726 00000500 00                 
  5727 00000501 0856455253494F4E00      			db	8,"VERSION",0					;version command
  5728 0000050A 085745454B44415900      			db	8,"WEEKDAY",0					;weekday command
  5729 00000513 074D414C4C4F4300        			db	7,"MALLOC",0					;malloc command
  5730 0000051B 074D454D4F525900        			db	7,"MEMORY",0					;memory command
  5731 00000523 074D494E55544500        			db	7,"MINUTE",0					;minute command
  5732 0000052B 075345434F4E4400        			db	7,"SECOND",0					;second command
  5733 00000533 06434C45415200          			db	6,"CLEAR",0					;clear command
  5734 0000053A 064D4F4E544800          			db	6,"MONTH",0					;month command
  5735 00000541 054441544500            			db	5,"DATE",0					;date command
  5736 00000547 054558495400            			db	5,"EXIT",0					;exit command
  5737 0000054D 054652454500            			db	5,"FREE",0					;free command
  5738 00000553 05484F555200            			db	5,"HOUR",0					;hour command
  5739 00000559 05494E543600            			db	5,"INT6",0					;int6 command
  5740 0000055F 055155495400            			db	5,"QUIT",0					;quit command
  5741 00000565 0554494D4500            			db	5,"TIME",0					;time command
  5742 0000056B 055945415200            			db	5,"YEAR",0					;year command
  5743 00000571 04434C5300              			db	4,"CLS",0					;cls command
  5744 00000576 0444415900              			db	4,"DAY",0					;day command
  5745 0000057B 044D454D00              			db	4,"MEM",0					;mem command
  5746 00000580 0456455200              			db	4,"VER",0					;ver command
  5747 00000585 00                      			db	0						;end of table
  5748                                  ;-----------------------------------------------------------------------------------------------------------------------
  5749                                  ;
  5750                                  ;	Constants
  5751                                  ;
  5752                                  ;-----------------------------------------------------------------------------------------------------------------------
  5753 00000586 0D0A00                  czNewLine		db	13,10,0						;new line string
  5754 00000589 4F4B0D0A00              czOK			db	"OK",13,10,0					;OK string
  5755 0000058E 3A00                    czPrompt		db	":",0						;prompt string
  5756 00000590 437573746F6D204F70-     czTitle			db	"Custom Operating System 1.0",13,10,0		;version string
  5756 00000599 65726174696E672053-
  5756 000005A2 797374656D20312E30-
  5756 000005AB 0D0A00             
  5757 000005AE 556E6B6E6F776E2063-     czUnknownCommand	db	"Unknown command",13,10,0			;unknown command response string
  5757 000005B7 6F6D6D616E640D0A00 
  5758 000005C0 546865207965617220-     czYearIsLeap		db	"The year is a leap year.",13,10,0		;leap year message
  5758 000005C9 69732061206C656170-
  5758 000005D2 20796561722E0D0A00 
  5759 000005DB 546865207965617220-     czYearIsNotLeap		db	"The year is not a leap year.",13,10,0		;not leap year message
  5759 000005E4 6973206E6F74206120-
  5759 000005ED 6C6561702079656172-
  5759 000005F6 2E0D0A00           
  5760 000005FA 00<rept>                			times	4094-($-$$) db 0h				;zero fill to end of section
  5761 00000FFE 55AA                    			db	055h,0AAh					;end of section
  5762                                  ;=======================================================================================================================
  5763                                  ;
  5764                                  ;	Background Task								@disk: 009400	@mem: 006000
  5765                                  ;
  5766                                  ;	This task executes monitoring and self-correcting functions.
  5767                                  ;
  5768                                  ;			000000	+-----------------------------------------------+
  5769                                  ;				|  Real Mode Interrupt Vectors			|
  5770                                  ;			000400	+-----------------------------------------------+ DS,ES:0400
  5771                                  ;				|  Reserved BIOS Memory Area			|
  5772                                  ;			000800	+-----------------------------------------------+ DS,ES:0800
  5773                                  ;				|  Shared Kernel Memory Area			|
  5774                                  ;			001000	+-----------------------------------------------+		<-- GDTR
  5775                                  ;				|  Global Descriptor Table (GDT)		|
  5776                                  ;			001800	+-----------------------------------------------+		<-- IDTR
  5777                                  ;				|  Interrupt Descriptor Table (IDT)		|
  5778                                  ;			002000	+-----------------------------------------------+
  5779                                  ;				|  Interrupt Handlers				|
  5780                                  ;				|  Kernel Function Library			|
  5781                                  ;			004000	+===============================================+
  5782                                  ;				|  Console Task Stack Area			|
  5783                                  ;			004700	+-----------------------------------------------+
  5784                                  ;				|  Console Task Local Descriptor Table (LDT)	|
  5785                                  ;			004780	+-----------------------------------------------+
  5786                                  ;				|  Console Task Task State Segment (TSS)	|
  5787                                  ;			004800	+-----------------------------------------------+
  5788                                  ;				|  Console Task Message Queue			|
  5789                                  ;			005000	+-----------------------------------------------+
  5790                                  ;				|  Console Task Code				|
  5791                                  ;				|  Console Task Constants			|
  5792                                  ;			006000	+===============================================+
  5793                                  ;				|  Background Task Stack Area			|
  5794                                  ;	SS:SP --------> 006700	+-----------------------------------------------+ SS:0700	<-- LDTR = GDT.SEL 0060h
  5795                                  ;				|  Background Task Local Descriptor Table (LDT) |
  5796                                  ;			006780  +-----------------------------------------------+		<-- TR = GDT.SEL 0068h
  5797                                  ;				|  Background Task Task State Segment (TSS)	|
  5798                                  ;			006800	+-----------------------------------------------+
  5799                                  ;				|  Background Task Message Queue		|
  5800                                  ;	CS,CS:IP ----->	007000	+-----------------------------------------------+ CS:0000
  5801                                  ;				|  Background Task Code				|
  5802                                  ;				|  Background Task Constants			|
  5803                                  ;			008000	+===============================================+
  5804                                  ;
  5805                                  ;=======================================================================================================================
  5806                                  ;-----------------------------------------------------------------------------------------------------------------------
  5807                                  ;
  5808                                  ;	Background Task Stack							@disk: 009400	@mem:  006000
  5809                                  ;
  5810                                  ;	This is the stack for the background task. It supports 448 nested calls.
  5811                                  ;
  5812                                  ;-----------------------------------------------------------------------------------------------------------------------
  5813                                  section			bgstack							;background task stack
  5814 00000000 00<rept>                			times	1792-($-$$) db 0h				;zero fill to end of section
  5815                                  ;-----------------------------------------------------------------------------------------------------------------------
  5816                                  ;
  5817                                  ;	Background Task Local Descriptor Table					@disk: 009B00	@mem:  006700
  5818                                  ;
  5819                                  ;	This is the LDT for the background task. It defines the stack, code, data and queue segments as well as data
  5820                                  ;	aliases for the TSS LDT. Data aliases allow inspection and altering of the TSS and LDT. This LDT can hold up to
  5821                                  ;	16 descriptors. Six are initially defined.
  5822                                  ;
  5823                                  ;-----------------------------------------------------------------------------------------------------------------------
  5824                                  section			bgldt							;background task local descriptors
  5825 00000000 7F00806700934000        			dq	004093006780007Fh				;04 TSS alias		128B  @ 6780
  5826 00000008 7F00006700934000        			dq	004093006700007Fh				;0C LDT alias		128B  @ 6700
  5827 00000010 FF06006000934000        			dq	00409300600006FFh				;14 stack		1792B @ 6600
  5828 00000018 FFFF00000093CF00        			dq	00CF93000000FFFFh				;1C data		4GB   @ 0000
  5829 00000020 FF0F0070009B4000        			dq	00409B0070000FFFh				;24 code                4KB   @ 7000
  5830 00000028 FF07006800934000        			dq	00409300680007FFh				;2C message queue	2KB   @ 6800
  5831 00000030 00<rept>                			times	128-($-$$) db 0h				;zero fill to end of section
  5832                                  ;-----------------------------------------------------------------------------------------------------------------------
  5833                                  ;
  5834                                  ;	Background Task State Segment						@disk: 009B80	@mem:  006780
  5835                                  ;
  5836                                  ;	This is the TSS for the console task. All rings share the same stack. DS and ES are set to the console data
  5837                                  ;	segment. CS to console code.
  5838                                  ;
  5839                                  ;-----------------------------------------------------------------------------------------------------------------------
  5840                                  section			bgtss							;background task state segment
  5841 00000000 00000000                			dd	0						;00 back-link tss
  5842 00000004 00070000                			dd	0700h						;04 esp ring 0
  5843 00000008 14000000                			dd	0014h						;08 ss ring 0
  5844 0000000C 00070000                			dd	0700h						;0C esp ring 1
  5845 00000010 14000000                			dd	0014h						;10 es ring 1
  5846 00000014 00070000                			dd	0700h						;14 esp ring 2
  5847 00000018 14000000                			dd	0014h						;18 ss ring 2
  5848 0000001C 00000000                			dd	0						;1C cr ring 3
  5849 00000020 00000000                			dd	0						;20 eip
  5850 00000024 00020000                			dd	0200h						;24 eflags
  5851 00000028 00000000                			dd	0						;28 eax
  5852 0000002C 00000000                			dd	0						;2C ecx
  5853 00000030 00000000                			dd	0						;30 edx
  5854 00000034 00000000                			dd	0						;34 ebx
  5855 00000038 00070000                			dd	0700h						;38 esp ring 3
  5856 0000003C 00000000                			dd	0						;3C ebp
  5857 00000040 00000000                			dd	0						;40 esi
  5858 00000044 00000000                			dd	0						;44 edi
  5859 00000048 1C000000                			dd	001Ch						;48 es
  5860 0000004C 24000000                			dd	0024h						;4C cs
  5861 00000050 14000000                			dd	0014h						;50 ss ring 3
  5862 00000054 1C000000                			dd	001Ch						;54 ds
  5863 00000058 00000000                			dd	0						;58 fs
  5864 0000005C 00000000                			dd	0						;5c gs
  5865 00000060 70000000                			dd	ESELBACKGROUNDLDT				;60 ldt selector in gdt
  5866 00000064 00<rept>                			times	128-($-$$) db 0h				;zero fill to end of section
  5867                                  ;-----------------------------------------------------------------------------------------------------------------------
  5868                                  ;
  5869                                  ;	Background Task Message Queue						@disk: 009C00	@mem: 006800
  5870                                  ;
  5871                                  ;	The console message queue is 2048 bytes of memory organized as a queue of 510 double words (4 bytes each) and
  5872                                  ;	two double word values that act as indices. The queue is a FIFO that is fed by the keyboard hardware interrupt
  5873                                  ;	handler and consumed by a service routine called from a task. Each queue entry defines an input (keystroke)
  5874                                  ;	event.
  5875                                  ;
  5876                                  ;-----------------------------------------------------------------------------------------------------------------------
  5877                                  section			bgmque							;console message queue
  5878 00000000 08000000                			dd	8						;head pointer
  5879 00000004 08000000                			dd	8						;tail pointer
  5880 00000008 00000000<rept>          			times	510 dd 0					;queue elements
  5881                                  ;-----------------------------------------------------------------------------------------------------------------------
  5882                                  ;
  5883                                  ;	Background Task Code							@disk: 00A400	@mem: 007000
  5884                                  ;
  5885                                  ;-----------------------------------------------------------------------------------------------------------------------
  5886                                  section			bgcode	vstart=07000h					;labels relative to 7000h
  5887 00000000 E857000000              BackgroundCode		call	BgInitializeData				;initialize the background variables
  5888                                  
  5889                                  .10			readRealTimeClock wsBgDateTime				;read real-time clock data
  5889                              <1> .10 :
  5889 00000005 BB2C0B0000          <1>  mov ebx,%1
  5889 0000000A B016                <1>  mov al,eReadRealTimeClock
  5889 0000000C CD30                <1>  int _svc
  5890                                  			putTimeString     wsBgDateTime,wzBgTime			;create ASCII time string
  5890 0000000E BB2C0B0000          <1>  mov ebx,%1
  5890 00000013 BA340B0000          <1>  mov edx,%2
  5890 00000018 B012                <1>  mov al,ePutTimeString
  5890 0000001A CD30                <1>  int _svc
  5891                                  			compareMemory	  wzBgTime,wzBgTimeCmpr,EBGTIMELEN	;compare to previous time string
  5891 0000001C BA340B0000          <1>  mov edx,%1
  5891 00000021 BB3D0B0000          <1>  mov ebx,%2
  5891 00000026 B909000000          <1>  mov ecx,%3
  5891 0000002B B002                <1>  mov al,eCompareMemory
  5891 0000002D CD30                <1>  int _svc
  5892                                  
  5893 0000002F E3D4                    			jecxz	.10						;repeat if equal
  5894 00000031 06                      			push	es						;save non-volatile reg
  5895 00000032 6A20                    			push	ESELCGA						;load CGA selector ...
  5896 00000034 07                      			pop	es						;... into extra segment reg
  5897 00000035 BE340B0000              			mov	esi,wzBgTime					;string address
  5898 0000003A B518                    			mov	ch,24						;OIA row
  5899 0000003C B143                    			mov	cl,67						;OIA column
  5900                                  
  5901                                  			setConsoleString					;display string
  5901 0000003E B018                <1>  mov al,eSetConsoleString
  5901 00000040 CD30                <1>  int _svc
  5902                                  
  5903 00000042 07                      			pop	es						;restore non-volatile reg
  5904                                  
  5905                                  			copyMemory	  wzBgTime,wzBgTimeCmpr,EBGTIMELEN	;copy to comparison string
  5905 00000043 BA340B0000          <1>  mov edx,%1
  5905 00000048 BB3D0B0000          <1>  mov ebx,%2
  5905 0000004D B909000000          <1>  mov ecx,%3
  5905 00000052 B003                <1>  mov al,eCopyMemory
  5905 00000054 CD30                <1>  int _svc
  5906                                  			yield							;halt until interrupt
  5906 00000056 B01C                <1>  mov al,eYield
  5906 00000058 CD30                <1>  int _svc
  5907                                  
  5908 0000005A EBA9                    			jmp	.10						;continue
  5909                                  ;-----------------------------------------------------------------------------------------------------------------------
  5910                                  ;
  5911                                  ;	Routine:	BgInitializeData
  5912                                  ;
  5913                                  ;	Description:	This routine initializes background task variables.
  5914                                  ;
  5915                                  ;-----------------------------------------------------------------------------------------------------------------------
  5916 0000005C 51                      BgInitializeData	push	ecx						;save non-volatile regs
  5917 0000005D 57                      			push	edi						;
  5918 0000005E 06                      			push	es						;
  5919                                  ;
  5920                                  ;	Initialize console work areas
  5921                                  ;
  5922 0000005F 6A18                    			push	ESELDAT						;load OS data selector ...
  5923 00000061 07                      			pop	es						;... into extra segment register
  5924 00000062 BF2C0B0000              			mov	edi,EBGDATA					;OS console data address
  5925 00000067 30C0                    			xor	al,al						;initialization value
  5926 00000069 B91A000000              			mov	ecx,EBGDATALEN					;size of OS console data
  5927 0000006E FC                      			cld							;forward strings
  5928 0000006F F3AA                    			rep	stosb						;initialize data
  5929                                  ;
  5930                                  ;	Restore and return
  5931                                  ;
  5932 00000071 07                      			pop	es						;restore non-volatile regs
  5933 00000072 5F                      			pop	edi						;
  5934 00000073 59                      			pop	ecx						;
  5935 00000074 C3                      			ret							;return
  5936                                  ;-----------------------------------------------------------------------------------------------------------------------
  5937                                  ;
  5938                                  ;	Background Task Constants
  5939                                  ;
  5940                                  ;-----------------------------------------------------------------------------------------------------------------------
  5941 00000075 00<rept>                			times	4094-($-$$) db 0h				;zero fill to end of section
  5942 00000FFE 55AA                    			db	055h,0AAh					;end of section
  5943                                  %endif
  5944                                  %ifdef BUILDDISK
  5945                                  ;-----------------------------------------------------------------------------------------------------------------------
  5946                                  ;
  5947                                  ;	Free Disk Space								@disk: 00B400	@mem:  n/a
  5948                                  ;
  5949                                  ;	Following the convention introduced by DOS, we use the value 'F6' to indicate unused floppy disk storage.
  5950                                  ;
  5951                                  ;-----------------------------------------------------------------------------------------------------------------------
  5952                                  section			unused							;unused disk space
  5953                                  			times	EBOOTDISKBYTES-0B400h db 0F6h			;fill to end of disk image
  5954                                  %endif
  5955                                  ;=======================================================================================================================
  5956                                  ;
  5957                                  ;	End of Program Code
  5958                                  ;
  5959                                  ;=======================================================================================================================
