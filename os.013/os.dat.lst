     1                                  ;=======================================================================================================================
     2                                  ;
     3                                  ;	File:		os.asm
     4                                  ;
     5                                  ;	Project:	os.013
     6                                  ;
     7                                  ;	Description:	In this sample, the console task is expanded to add a "pciprobe" command that searches the
     8                                  ;			system for PCI expansion BIOS.
     9                                  ;
    10                                  ;	Revised:	July 1, 2017
    11                                  ;
    12                                  ;	Assembly:	nasm os.asm -f bin -o os.dat     -l os.dat.lst     -DBUILDBOOT
    13                                  ;			nasm os.asm -f bin -o os.dsk     -l os.dsk.lst     -DBUILDDISK
    14                                  ;			nasm os.asm -f bin -o os.com     -l os.com.lst     -DBUILDCOM
    15                                  ;			nasm os.asm -f bin -o osprep.com -l osprep.com.lst -DBUILDPREP
    16                                  ;
    17                                  ;	Assembler:	Netwide Assembler (NASM) 2.13.01
    18                                  ;
    19                                  ;			Copyright (C) 2010-2017 by David J. Walling. All Rights Reserved.
    20                                  ;
    21                                  ;=======================================================================================================================
    22                                  ;-----------------------------------------------------------------------------------------------------------------------
    23                                  ;
    24                                  ;	Assembly Directives
    25                                  ;
    26                                  ;	Use one of the following as an assembly directive (-D) with NASM.
    27                                  ;
    28                                  ;	BUILDBOOT	Creates os.dat, a 512-byte boot sector as a standalone file.
    29                                  ;	BUILDDISK	Creates os.dsk, a 1.44MB (3.5") floppy disk image file.
    30                                  ;	BUILDCOM	Creates os.com, the OS loader and kernel as a standalone DOS program.
    31                                  ;	BUILDPREP	Creates osprep.com, a DOS program that prepares a floppy disk to boot the OS
    32                                  ;
    33                                  ;-----------------------------------------------------------------------------------------------------------------------
    34                                  %ifdef BUILDDISK
    35                                  %define BUILDBOOT
    36                                  %define BUILDCOM
    37                                  %endif
    38                                  %ifdef BUILDPREP
    39                                  %define BUILDBOOT
    40                                  %endif
    41                                  ;-----------------------------------------------------------------------------------------------------------------------
    42                                  ;
    43                                  ;	Conventions
    44                                  ;
    45                                  ;	Labels:		Labels within a routine are numeric and begin with a period (.10, .20).
    46                                  ;			Labels within a routine begin at ".10" and increment by 10.
    47                                  ;
    48                                  ;	Comments:	A comment that spans the entire line begins with a semicolon in column 1.
    49                                  ;			A comment that accompanies code on a line begins with a semicolon in column 81.
    50                                  ;			Register names in comments are in upper case.
    51                                  ;			Hexadecimal values in comments are in lower case.
    52                                  ;			Routines are preceded with a comment box that includes the routine name, description, and
    53                                  ;			register contents on entry and exit.
    54                                  ;
    55                                  ;	Alignment:	Assembly instructions (mnemonics) begin in column 25.
    56                                  ;			Assembly operands begin in column 33.
    57                                  ;			Lines should not extend beyond column 120.
    58                                  ;
    59                                  ;	Routines:	Routine names are in mixed case (GetYear, ReadRealTimeClock).
    60                                  ;			Routine names begin with a verb (Get, Read, etc.).
    61                                  ;			Routines should have a single entry address and a single exit instruction (ret, iretd, etc.).
    62                                  ;
    63                                  ;	Constants:	Symbolic constants (equates) are named in all-caps beginning with 'E' (EDATAPORT).
    64                                  ;			Constant stored values are named in camel case, starting with 'c'.
    65                                  ;			The 2nd letter of the constant label indicates the storage type.
    66                                  ;
    67                                  ;			cq......	constant quad-word (dq)
    68                                  ;			cd......	constant double-word (dd)
    69                                  ;			cw......	constant word (dw)
    70                                  ;			cb......	constant byte (db)
    71                                  ;			cz......	constant ASCIIZ (null-terminated) string
    72                                  ;
    73                                  ;	Variables:	Variables are named in camel case, starting with 'w'.
    74                                  ;			The 2nd letter of the variable label indicates the storage type.
    75                                  ;
    76                                  ;			wq......	variable quad-word (resq)
    77                                  ;			wd......	variable double-word (resd)
    78                                  ;			ww......	variable word (resw)
    79                                  ;			wb......	variable byte (resb)
    80                                  ;
    81                                  ;	Literals:	Literal values defined by external standards should be defined as symbolic constants (equates).
    82                                  ;			Hexadecimal literals in code are in upper case with a leading '0' and trailing 'h'. e.g. 01Fh.
    83                                  ;			Binary literal values in source code are encoded with a final 'b', e.g. 1010b.
    84                                  ;			Decimal literal values in source code are strictly numerals, e.g. 2048.
    85                                  ;			Octal literal values are avoided.
    86                                  ;			String literals are enclosed in double quotes, e.g. "Loading OS".
    87                                  ;			Single character literals are enclosed in single quotes, e.g. 'A'.
    88                                  ;
    89                                  ;	Structures:	Structure names are in all-caps (DATETIME).
    90                                  ;			Structure names do not begin with a verb.
    91                                  ;
    92                                  ;	Macros:		Macro names are in camel case (getDateString).
    93                                  ;			Macro names do begin with a verb.
    94                                  ;
    95                                  ;	Registers:	Register names in comments are in upper case.
    96                                  ;			Register names in source code are in lower case.
    97                                  ;
    98                                  ;	Usage:		Registers EBX, ECX, ESI, EDI, EBP, SS, CS, DS and ES are preserved by all OS routines.
    99                                  ;			Registers EAX and ECX are preferred for returning response/result values.
   100                                  ;			Register EBX is preferred for passing a context (structure) address parameter.
   101                                  ;			Registers EAX, EDX, ECX and EBX are preferred for passing integral parameters.
   102                                  ;
   103                                  ;-----------------------------------------------------------------------------------------------------------------------
   104                                  ;=======================================================================================================================
   105                                  ;
   106                                  ;	Equates
   107                                  ;
   108                                  ;	The equate (equ) statement defines a symbolic name for a fixed value so that such a value can be defined and
   109                                  ;	verified once and then used throughout the code. Using symbolic names simplifies searching for where logical
   110                                  ;	values are used. Equate names are in all-caps and begin with the letter 'E'. Equates are grouped into related
   111                                  ;	sets. Hardware-based values are listed first, followed by BIOS, protocol and application values.
   112                                  ;
   113                                  ;=======================================================================================================================
   114                                  ;-----------------------------------------------------------------------------------------------------------------------
   115                                  ;
   116                                  ;	8042 Keyboard Controller						EKEYB...
   117                                  ;
   118                                  ;	The 8042 Keyboard Controller (8042) is a programmable controller that accepts input signals from the keyboard
   119                                  ;	device. It also signals a hardware interrupt to the CPU when the low-order bit of I/O port 64h is set to zero.
   120                                  ;
   121                                  ;-----------------------------------------------------------------------------------------------------------------------
   122                                  EKEYBPORTDATA		equ	060h						;data port
   123                                  EKEYBPORTSTAT		equ	064h						;status port
   124                                  EKEYBCMDRESET		equ	0FEh						;reset bit 0 to restart system
   125                                  EKEYBBITOUT		equ	001h						;output buffer status bit
   126                                  EKEYBBITIN		equ	002h						;input buffer status bit
   127                                  EKEYBCMDLAMPS		equ	0EDh						;set/reset lamps command
   128                                  EKEYBWAITLOOP		equ	010000h						;wait loop
   129                                  										;---------------------------------------
   130                                  										;	Keyboard Scan Codes
   131                                  										;---------------------------------------
   132                                  EKEYBCTRLDOWN		equ	01Dh						;control key down
   133                                  EKEYBPAUSEDOWN		equ	01Dh						;pause key down (e1 1d ... )
   134                                  EKEYBSHIFTLDOWN		equ	02Ah						;left shift key down
   135                                  EKEYBPRTSCRDOWN		equ	02Ah						;print-screen key down (e0 2a ...)
   136                                  EKEYBSLASH		equ	035h						;slash
   137                                  EKEYBSHIFTRDOWN		equ	036h						;right shift key down
   138                                  EKEYBALTDOWN		equ	038h						;alt key down
   139                                  EKEYBCAPSDOWN		equ	03Ah						;caps-lock down
   140                                  EKEYBNUMDOWN		equ	045h						;num-lock down
   141                                  EKEYBSCROLLDOWN		equ	046h						;scroll-lock down
   142                                  EKEYBINSERTDOWN		equ	052h						;insert down (e0 52)
   143                                  EKEYBUP			equ	080h						;up
   144                                  EKEYBCTRLUP		equ	09Dh						;control key up
   145                                  EKEYBSHIFTLUP		equ	0AAh						;left shift key up
   146                                  EKEYBSLASHUP		equ	0B5h						;slash key up
   147                                  EKEYBSHIFTRUP		equ	0B6h						;right shift key up
   148                                  EKEYBPRTSCRUP		equ	0B7h						;print-screen key up (e0 b7 ...)
   149                                  EKEYBALTUP		equ	0B8h						;alt key up
   150                                  EKEYBCAPSUP		equ	0BAh						;caps-lock up
   151                                  EKEYBNUMUP		equ	0C5h						;num-lock up
   152                                  EKEYBSCROLLUP		equ	0C6h						;scroll-lock up
   153                                  EKEYBINSERTUP		equ	0D2h						;insert up (e0 d2)
   154                                  EKEYBCODEEXT0		equ	0E0h						;extended scan code 0
   155                                  EKEYBCODEEXT1		equ	0E1h						;extended scan code 1
   156                                  ;-----------------------------------------------------------------------------------------------------------------------
   157                                  ;
   158                                  ;	8253 Programmable Interrupt Timer					EPIT...
   159                                  ;
   160                                  ;	The Intel 8253 Programmable Interrupt Time (PIT) is a chip that produces a hardware interrupt (IRQ0)
   161                                  ;	approximately 18.2 times per second.
   162                                  ;
   163                                  ;-----------------------------------------------------------------------------------------------------------------------
   164                                  EPITDAYTICKS		equ	1800B0h						;ticks per day
   165                                  ;-----------------------------------------------------------------------------------------------------------------------
   166                                  ;
   167                                  ;	8259 Peripheral Interrupt Controller					EPIC...
   168                                  ;
   169                                  ;	The 8259 Peripheral Interrupt Controller (PIC) is a programmable controller that accepts interrupt signals from
   170                                  ;	external devices and signals a hardware interrupt to the CPU.
   171                                  ;
   172                                  ;-----------------------------------------------------------------------------------------------------------------------
   173                                  EPICPORTPRI		equ	020h						;primary control port 0
   174                                  EPICPORTPRI1		equ	021h						;primary control port 1
   175                                  EPICPORTSEC		equ	0A0h						;secondary control port 0
   176                                  EPICPORTSEC1		equ	0A1h						;secondary control port 1
   177                                  EPICEOI			equ	020h						;non-specific EOI code
   178                                  ;-----------------------------------------------------------------------------------------------------------------------
   179                                  ;
   180                                  ;	6845 Cathode Ray Tube (CRT) Controller					ECRT...
   181                                  ;
   182                                  ;	The Motorola 6845 CRT Controller (CRTC) is a programmable controller
   183                                  ;	for CGA, EGA, VGA and compatible video modes.
   184                                  ;
   185                                  ;-----------------------------------------------------------------------------------------------------------------------
   186                                  ECRTPORTHI		equ	003h						;controller port hi
   187                                  ECRTPORTLO		equ	0D4h						;controller port lo
   188                                  ECRTCURLOCHI		equ	00Eh						;cursor loc reg hi
   189                                  ECRTCURLOCLO		equ	00Fh						;cursor loc reg lo
   190                                  ;-----------------------------------------------------------------------------------------------------------------------
   191                                  ;
   192                                  ;	NEC 765 Floppy Disk Controller (FDC)					EFDC...
   193                                  ;
   194                                  ;	The NEC 765 FDC is a programmable controller for floppy disk drives.
   195                                  ;
   196                                  ;-----------------------------------------------------------------------------------------------------------------------
   197                                  EFDCPORTHI		equ	003h						;controller port hi
   198                                  EFDCPORTLOOUT		equ	0F2h						;digital output register lo
   199                                  EFDCPORTLOSTAT		equ	0F4h						;main status register lo
   200                                  EFDCSTATBUSY		equ	010h						;main status is busy
   201                                  EFDCMOTOROFF		equ	00Ch						;motor off / enable / DMA
   202                                  ;-----------------------------------------------------------------------------------------------------------------------
   203                                  ;
   204                                  ;	Motorola MC 146818 Real-Time Clock					ERTC...
   205                                  ;
   206                                  ;	The Motorola MC 146818 was the original real-time clock in PCs.
   207                                  ;
   208                                  ;-----------------------------------------------------------------------------------------------------------------------
   209                                  ERTCREGPORT		equ	70h						;register select port
   210                                  ERTCDATAPORT		equ	71h						;data port
   211                                  ERTCSECONDREG		equ	00h						;second
   212                                  ERTCMINUTEREG		equ	02h						;minute
   213                                  ERTCHOURREG		equ	04h						;hour
   214                                  ERTCWEEKDAYREG		equ	06h						;weekday
   215                                  ERTCDAYREG		equ	07h						;day
   216                                  ERTCMONTHREG		equ	08h						;month
   217                                  ERTCYEARREG		equ	09h						;year of the century
   218                                  ERTCSTATUSREG		equ	0bh						;status
   219                                  ERTCCENTURYREG		equ	32h						;century
   220                                  ERTCBINARYVALS		equ	00000100b					;values are binary
   221                                  ;-----------------------------------------------------------------------------------------------------------------------
   222                                  ;
   223                                  ;	x86 Descriptor Access Codes						EACC...
   224                                  ;
   225                                  ;	The x86 architecture supports the classification of memory areas or segments. Segment attributes are defined by
   226                                  ;	structures known as descriptors. Within a descriptor are access type codes that define the type of the segment.
   227                                  ;
   228                                  ;	0.......	Segment is not present in memory (triggers int 11)
   229                                  ;	1.......	Segment is present in memory
   230                                  ;	.LL.....	Segment is of privilege level LL (0,1,2,3)
   231                                  ;	...0....	Segment is a system segment
   232                                  ;	...00010		Local Descriptor Table
   233                                  ;	...00101		Task Gate
   234                                  ;	...010B1		Task State Segment (B:0=Available,1=Busy)
   235                                  ;	...01100		Call Gate (386)
   236                                  ;	...01110		Interrupt Gate (386)
   237                                  ;	...01111		Trap Gate (386)
   238                                  ;	...1...A	Segment is a code or data (A:1=Accesssed)
   239                                  ;	...10DW.		Data (D:1=Expand Down,W:1=Writable)
   240                                  ;	...11CR.		Code (C:1=Conforming,R:1=Readable)
   241                                  ;
   242                                  ;-----------------------------------------------------------------------------------------------------------------------
   243                                  EACCLDT			equ	10000010b					;local descriptor table
   244                                  EACCTASK		equ	10000101b					;task gate
   245                                  EACCTSS			equ	10001001b					;task-state segment
   246                                  EACCGATE		equ	10001100b					;call gate
   247                                  EACCINT			equ	10001110b					;interrupt gate
   248                                  EACCTRAP		equ	10001111b					;trap gate
   249                                  EACCDATA		equ	10010011b					;upward writable data
   250                                  EACCCODE		equ	10011011b					;non-conforming readable code
   251                                  ;-----------------------------------------------------------------------------------------------------------------------
   252                                  ;
   253                                  ;	BIOS Interrupts and Functions						EBIOS...
   254                                  ;
   255                                  ;	Basic Input/Output System (BIOS) functions are grouped and accessed by issuing an interrupt call. Each
   256                                  ;	BIOS interrupt supports several funtions. The function code is typically passed in the AH register.
   257                                  ;
   258                                  ;-----------------------------------------------------------------------------------------------------------------------
   259                                  EBIOSINTVIDEO		equ	010h						;video services interrupt
   260                                  EBIOSFNSETVMODE		equ	000h						;video set mode function
   261                                  EBIOSMODETEXT80		equ	003h						;video mode 80x25 text
   262                                  EBIOSFNTTYOUTPUT	equ	00Eh						;video TTY output function
   263                                  EBIOSINTDISKETTE	equ	013h						;diskette services interrupt
   264                                  EBIOSINTMISC		equ	015h						;miscellaneous services interrupt
   265                                  EBIOSFNINITPROTMODE	equ	089h						;initialize protected mode fn
   266                                  EBIOSINTKEYBOARD	equ	016h						;keyboard services interrupt
   267                                  EBIOSFNKEYSTATUS	equ	001h						;keyboard status function
   268                                  ;-----------------------------------------------------------------------------------------------------------------------
   269                                  ;
   270                                  ;	ASCII									EASCII...
   271                                  ;
   272                                  ;-----------------------------------------------------------------------------------------------------------------------
   273                                  EASCIIBACKSPACE		equ	008h						;backspace
   274                                  EASCIILINEFEED		equ	00Ah						;line feed
   275                                  EASCIIRETURN		equ	00Dh						;carriage return
   276                                  EASCIIESCAPE		equ	01Bh						;escape
   277                                  EASCIISPACE		equ	020h						;space
   278                                  EASCIIPERIOD		equ	02Eh						;period
   279                                  EASCIIUPPERA		equ	041h						;'A'
   280                                  EASCIIUPPERZ		equ	05Ah						;'Z'
   281                                  EASCIILOWERA		equ	061h						;'a'
   282                                  EASCIILOWERZ		equ	07Ah						;'z'
   283                                  EASCIITILDE		equ	07Eh						;'~'
   284                                  EASCIIBORDSGLVERT	equ	0B3h						;vertical single border
   285                                  EASCIIBORDSGLUPRRGT	equ	0BFh						;upper-right single border
   286                                  EASCIIBORDSGLLWRLFT	equ	0C0h						;lower-left single border
   287                                  EASCIIBORDSGLHORZ	equ	0C4h						;horizontal single border
   288                                  EASCIIBORDSGLLWRRGT	equ	0D9h						;lower-right single border
   289                                  EASCIIBORDSGLUPRLFT	equ	0DAh						;upper-left single border
   290                                  EASCIICASE		equ	00100000b					;case bit
   291                                  EASCIICASEMASK		equ	11011111b					;case mask
   292                                  ;-----------------------------------------------------------------------------------------------------------------------
   293                                  ;
   294                                  ;	PCI									EPCI...
   295                                  ;
   296                                  ;-----------------------------------------------------------------------------------------------------------------------
   297                                  EPCIVENDORAPPLE		equ	106Bh						;Apple
   298                                  EPCIVENDORINTEL		equ	8086h						;Intel
   299                                  EPCIVENDORORACLE	equ	80EEh						;Oracle
   300                                  EPCIAPPLEUSB		equ	003Fh						;USB Controller
   301                                  EPCIINTELPRO1000MT	equ	100Fh						;Pro/1000 MT Ethernet Adapter
   302                                  EPCIINTELPCIMEM		equ	1237h						;PCI & Memory
   303                                  EPCIINTELAD1881		equ	2415h						;Aureal AD1881 SOUNDMAX
   304                                  EPCIINTELPIIX3		equ	7000h						;PIIX3 PCI-to-ISA Bridge (Triton II)
   305                                  EPCIINTEL82371AB	equ	7111h						;82371AB/EB PCI Bus Master IDE Cntrlr
   306                                  EPCIINTELPIIX4		equ	7113h						;PIIX4/4E/4M Power Mgmt Cntrlr
   307                                  EPCIORACLEVBOXGA	equ	0BEEFh						;VirtualBox Graphics Adapter
   308                                  EPCIORACLEVBOXDEVICE	equ	0CAFEh						;VirtualBox Device
   309                                  ;-----------------------------------------------------------------------------------------------------------------------
   310                                  ;
   311                                  ;	Boot Sector and Loader Constants					EBOOT...
   312                                  ;
   313                                  ;	Equates in this section support the boot sector and the 16-bit operating system loader, which will be
   314                                  ;	responsible for placing the CPU into protected mode and calling the initial operating system task.
   315                                  ;
   316                                  ;-----------------------------------------------------------------------------------------------------------------------
   317                                  EBOOTSTACKTOP		equ	0100h						;boot sector stack top relative to DS
   318                                  EBOOTSECTORBYTES	equ	512						;bytes per sector
   319                                  EBOOTDISKSECTORS	equ	2880						;sectors per disk
   320                                  EBOOTDISKBYTES		equ	(EBOOTSECTORBYTES*EBOOTDISKSECTORS)		;bytes per disk
   321                                  EBOOTFATBASE		equ	(EBOOTSTACKTOP+EBOOTSECTORBYTES)		;offset of FAT I/O buffer rel to DS
   322                                  EBOOTMAXTRIES		equ	5						;max read retries
   323                                  ;-----------------------------------------------------------------------------------------------------------------------
   324                                  ;	Global Descriptor Table (GDT) Selectors					ESEL...
   325                                  ;-----------------------------------------------------------------------------------------------------------------------
   326                                  ESELGDT			equ	008h						;gdt alias selector
   327                                  ESELDAT			equ	018h						;kernel data selector
   328                                  ESELCGA			equ	020h						;cga video selector
   329                                  ESELOSCODE		equ	048h						;os kernel code selector
   330                                  ESELLOADERLDT		equ	050h						;loader local descriptor table selector
   331                                  ESELLOADERTSS		equ	058h						;loader task state segment selector
   332                                  ESELCONSOLELDT		equ	060h						;console local descriptor table selector
   333                                  ESELCONSOLETSS		equ	068h						;console task state segment selector
   334                                  ESELBACKGROUNDLDT	equ	070h						;background local descr table selector
   335                                  ESELBACKGROUNDTSS	equ	078h						;background task state segment selector
   336                                  ESELKEYBOARDMQ		equ	080h						;keyboard focus message queue (IRQ1)
   337                                  ;-----------------------------------------------------------------------------------------------------------------------
   338                                  ;	LDT Selectors								ESEL...
   339                                  ;-----------------------------------------------------------------------------------------------------------------------
   340                                  ESELMQ			equ	02Ch						;console task message queue
   341                                  ;-----------------------------------------------------------------------------------------------------------------------
   342                                  ;	Kernel Constants							EKRN...
   343                                  ;-----------------------------------------------------------------------------------------------------------------------
   344                                  EKRNDESLEN		equ	8						;size of descriptor
   345                                  EKRNDATASEG		equ	00000h						;kernel data segment (0000:0800)
   346                                  EKRNCODEADR		equ	01000h						;kernel base address (0000:1000)
   347                                  EKRNCODESEG		equ	(EKRNCODEADR >> 4)				;kernel code segment (0100:0000)
   348                                  ;-----------------------------------------------------------------------------------------------------------------------
   349                                  ;	Keyboard Flags								EKEYF...
   350                                  ;-----------------------------------------------------------------------------------------------------------------------
   351                                  EKEYFCTRLLEFT		equ	00000001b					;left control
   352                                  EKEYFSHIFTLEFT		equ	00000010b					;left shift
   353                                  EKEYFALTLEFT		equ	00000100b					;left alt
   354                                  EKEYFCTRLRIGHT		equ	00001000b					;right control
   355                                  EKEYFSHIFTRIGHT		equ	00010000b					;right shift
   356                                  EKEYFSHIFT		equ	00010010b					;left or right shift
   357                                  EKEYFALTRIGHT		equ	00100000b					;right alt
   358                                  EKEYFLOCKSCROLL		equ	00000001b					;scroll-lock flag
   359                                  EKEYFLOCKNUM		equ	00000010b					;num-lock flag
   360                                  EKEYFLOCKCAPS		equ	00000100b					;cap-lock flag
   361                                  EKEYFTIMEOUT		equ	10000000b					;controller timeout
   362                                  ;-----------------------------------------------------------------------------------------------------------------------
   363                                  ;	Hardware Flags
   364                                  ;-----------------------------------------------------------------------------------------------------------------------
   365                                  EHWETHERNET		equ	80h						;ethernet adapter found
   366                                  ;-----------------------------------------------------------------------------------------------------------------------
   367                                  ;	Console Constants							ECON...
   368                                  ;-----------------------------------------------------------------------------------------------------------------------
   369                                  ECONCOLS		equ	80						;columns per row
   370                                  ECONROWS		equ	24						;console rows
   371                                  ECONOIAROW		equ	24						;operator information area row
   372                                  ECONCOLBYTES		equ	2						;bytes per column
   373                                  ECONROWBYTES		equ	(ECONCOLS*ECONCOLBYTES)				;bytes per row
   374                                  ECONROWDWORDS		equ	(ECONROWBYTES/4)				;double-words per row
   375                                  ECONCLEARDWORD		equ	007200720h					;attribute and ASCII space
   376                                  ECONOIADWORD		equ	070207020h					;attribute and ASCII space
   377                                  ;-----------------------------------------------------------------------------------------------------------------------
   378                                  ;	Kernel Message Identifiers						EMSG...
   379                                  ;-----------------------------------------------------------------------------------------------------------------------
   380                                  EMSGKEYDOWN		equ	041000000h					;key-down
   381                                  EMSGKEYUP		equ	041010000h					;key-up
   382                                  EMSGKEYCHAR		equ	041020000h					;character
   383                                  ;-----------------------------------------------------------------------------------------------------------------------
   384                                  ;	Background Task Identifiers						EBG...
   385                                  ;-----------------------------------------------------------------------------------------------------------------------
   386                                  EBGTIMELEN		equ	9						;length of time string HH:MM:SS\0
   387                                  ;-----------------------------------------------------------------------------------------------------------------------
   388                                  ;	Memory Constants							EMEM...
   389                                  ;-----------------------------------------------------------------------------------------------------------------------
   390                                  EMEMBASE		equ	10000h						;heap base address
   391                                  EMEMMINSIZE		equ	256						;minimum heap block size (incl. hdr)
   392                                  EMEMFREECODE		equ	"FREE"						;free memory signature
   393                                  EMEMUSERCODE		equ	"USER"						;user memory signature
   394                                  EMEMHEAPSIZE		equ	80000000h					;heap size (temporary)
   395                                  EMEMWIPEBYTE		equ	000h						;byte value to wipe storage
   396                                  ;=======================================================================================================================
   397                                  ;
   398                                  ;	Structures
   399                                  ;
   400                                  ;=======================================================================================================================
   401                                  ;-----------------------------------------------------------------------------------------------------------------------
   402                                  ;
   403                                  ;	DATETIME
   404                                  ;
   405                                  ;	The DATETIME structure stores date and time values from the real-time clock.
   406                                  ;
   407                                  ;-----------------------------------------------------------------------------------------------------------------------
   408                                  struc			DATETIME
   409 00000000 <res 00000001>          .second			resb	1						;seconds
   410 00000001 <res 00000001>          .minute			resb	1						;minutes
   411 00000002 <res 00000001>          .hour			resb	1						;hours
   412 00000003 <res 00000001>          .weekday		resb	1						;day of week
   413 00000004 <res 00000001>          .day			resb	1						;day of month
   414 00000005 <res 00000001>          .month			resb	1						;month of year
   415 00000006 <res 00000001>          .year			resb	1						;year of century
   416 00000007 <res 00000001>          .century		resb	1						;century
   417                                  EDATETIMELEN		equ	($-.second)
   418                                  endstruc
   419                                  ;-----------------------------------------------------------------------------------------------------------------------
   420                                  ;
   421                                  ;	MEMBLOCK
   422                                  ;
   423                                  ;	The MEMBLOCK structure defines a memory block.
   424                                  ;
   425                                  ;-----------------------------------------------------------------------------------------------------------------------
   426                                  struc			MEMBLOCK
   427 00000000 <res 00000004>          .signature		resd	1						;starting signature
   428 00000004 <res 00000004>          .bytes			resd	1						;block size in bytes
   429 00000008 <res 00000004>          .owner			resd	1						;owning task
   430 0000000C <res 00000004>          .reserved		resd	1						;reserved
   431 00000010 <res 00000004>          .nextcontig		resd	1						;next contiguous block
   432 00000014 <res 00000004>          .previouscontig		resd	1						;previous contiguous block
   433 00000018 <res 00000004>          .nextblock		resd	1						;next free/task block
   434 0000001C <res 00000004>          .previousblock		resd	1						;previous free/task block
   435                                  EMEMBLOCKLEN		equ	($-.signature)
   436                                  endstruc
   437                                  ;-----------------------------------------------------------------------------------------------------------------------
   438                                  ;
   439                                  ;	MEMROOT
   440                                  ;
   441                                  ;	The MEMROOT structure defines starting and ending addresses of memory block chains.
   442                                  ;
   443                                  ;-----------------------------------------------------------------------------------------------------------------------
   444                                  struc			MEMROOT
   445 00000000 <res 00000004>          .firstcontig		resd	1						;first contiguous block
   446 00000004 <res 00000004>          .lastcontig		resd	1						;last contiguous block
   447 00000008 <res 00000004>          .firstfree		resd	1						;first free block
   448 0000000C <res 00000004>          .lastfree		resd	1						;last free block
   449 00000010 <res 00000004>          .firsttask		resd	1						;first task block
   450 00000014 <res 00000004>          .lasttask		resd	1						;last task block
   451                                  EMEMROOTLEN		equ	($-.firstcontig)
   452                                  endstruc
   453                                  ;-----------------------------------------------------------------------------------------------------------------------
   454                                  ;
   455                                  ;	MQUEUE
   456                                  ;
   457                                  ;	The MQUEUE structure maps memory used for a message queue.
   458                                  ;
   459                                  ;-----------------------------------------------------------------------------------------------------------------------
   460                                  struc			MQUEUE
   461 00000000 <res 00000004>          MQHead			resd	1						;000 head ptr
   462 00000004 <res 00000004>          MQTail			resd	1						;004 tail ptr
   463 00000008 <res 000003F8>          MQData			resd	254						;message queue
   464                                  endstruc
   465                                  ;-----------------------------------------------------------------------------------------------------------------------
   466                                  ;
   467                                  ;	OSDATA
   468                                  ;
   469                                  ;	The OSDATA structure maps low-memory addresses used by the OS. Some of these addresses are predetermined and
   470                                  ;	used by the BIOS.
   471                                  ;
   472                                  ;-----------------------------------------------------------------------------------------------------------------------
   473                                  struc			OSDATA
   474 00000000 <res 00000400>          			resb	0400h						;000 real mode interrupt vectors
   475 00000400 <res 00000002>          			resw	1						;400 COM1 port address
   476 00000402 <res 00000002>          			resw	1						;402 COM2 port address
   477 00000404 <res 00000002>          			resw	1						;404 COM3 port address
   478 00000406 <res 00000002>          			resw	1						;406 COM4 port address
   479 00000408 <res 00000002>          			resw	1						;408 LPT1 port address
   480 0000040A <res 00000002>          			resw	1						;40a LPT2 port address
   481 0000040C <res 00000002>          			resw	1						;40c LPT3 port address
   482 0000040E <res 00000002>          			resw	1						;40e LPT4 port address
   483 00000410 <res 00000002>          			resb	2						;410 equipment list flags
   484 00000412 <res 00000001>          			resb	1						;412 errors in PCjr infrared keybd link
   485 00000413 <res 00000002>          			resw	1						;413 memory size (kb) INT 12h
   486 00000415 <res 00000001>          			resb	1						;415 mfr error test scratchpad
   487 00000416 <res 00000001>          			resb	1						;416 PS/2 BIOS control flags
   488 00000417 <res 00000001>          			resb	1						;417 keyboard flag byte 0
   489 00000418 <res 00000001>          			resb	1						;418 keyboard flag byte 1
   490 00000419 <res 00000001>          			resb	1						;419 alternate keypad entry
   491 0000041A <res 00000002>          			resw	1						;41a keyboard buffer head offset
   492 0000041C <res 00000002>          			resw	1						;41c keyboard buffer tail offset
   493 0000041E <res 00000020>          			resb	32						;41e keyboard buffer
   494 0000043E <res 00000001>          wbFDCStatus		resb	1						;43e drive recalibration status
   495 0000043F <res 00000001>          wbFDCControl		resb	1						;43f FDC motor status/control byte
   496 00000440 <res 00000001>          wbFDCMotor		resb	1						;440 FDC motor timeout byte
   497 00000441 <res 00000001>          			resb	1						;441 status of last diskette operation
   498 00000442 <res 00000007>          			resb	7						;442 NEC diskette controller status
   499 00000449 <res 00000001>          			resb	1						;449 current video mode
   500 0000044A <res 00000002>          			resw	1						;44a screen columns
   501 0000044C <res 00000002>          			resw	1						;44c video regen buffer size
   502 0000044E <res 00000002>          			resw	1						;44e current video page offset
   503 00000450 <res 00000010>          			resw	8						;450 cursor postions of pages 1-8
   504 00000460 <res 00000001>          			resb	1						;460 cursor ending scanline
   505 00000461 <res 00000001>          			resb	1						;461 cursor start scanline
   506 00000462 <res 00000001>          			resb	1						;462 active display page number
   507 00000463 <res 00000002>          			resw	1						;463 CRTC base port address
   508 00000465 <res 00000001>          			resb	1						;465 CRT mode control register value
   509 00000466 <res 00000001>          			resb	1						;466 CGA current color palette mask
   510 00000467 <res 00000002>          			resw	1						;467 CS:IP for 286 return from PROT MODE
   511 00000469 <res 00000003>          			resb	3						;469 vague
   512 0000046C <res 00000004>          wdClockTicks		resd	1						;46c clock ticks
   513 00000470 <res 00000001>          wbClockDays		resb	1						;470 clock days
   514 00000471 <res 00000001>          			resb	1						;471 bios break flag
   515 00000472 <res 00000002>          			resw	1						;472 soft reset
   516 00000474 <res 00000001>          			resb	1						;474 last hard disk operation status
   517 00000475 <res 00000001>          			resb	1						;475 hard disks attached
   518 00000476 <res 00000001>          			resb	1						;476 XT fised disk drive control byte
   519 00000477 <res 00000001>          			resb	1						;477 port offset to current fixed disk adapter
   520 00000478 <res 00000004>          			resb	4						;478 LPT timeout values
   521 0000047C <res 00000004>          			resb	4						;47c COM timeout values
   522 00000480 <res 00000002>          			resw	1						;480 keyboard buffer start offset
   523 00000482 <res 00000002>          			resw	1						;482 keyboard buffer end offset
   524 00000484 <res 00000001>          			resb	1						;484 Rows on screen less 1 (EGA+)
   525 00000485 <res 00000001>          			resb	1						;485 point height of character matrix (EGA+)
   526 00000486 <res 00000001>          			resb	1						;486 PC Jr initial keybd delay
   527 00000487 <res 00000001>          			resb	1						;487 EGA+ video mode ops
   528 00000488 <res 00000001>          			resb	1						;488 EGA feature bit switches
   529 00000489 <res 00000001>          			resb	1						;489 VGA video display data area
   530 0000048A <res 00000001>          			resb	1						;48a EGA+ display combination code
   531 0000048B <res 00000001>          			resb	1						;48b last diskette data rate selected
   532 0000048C <res 00000001>          			resb	1						;48c hard disk status from controller
   533 0000048D <res 00000001>          			resb	1						;48d hard disk error from controller
   534 0000048E <res 00000001>          			resb	1						;48e hard disk interrupt control flag
   535 0000048F <res 00000001>          			resb	1						;48f combination hard/floppy disk card
   536 00000490 <res 00000004>          			resb	4						;490 drive 0,1,2,3 media state
   537 00000494 <res 00000001>          			resb	1						;494 track currently seeked to on drive 0
   538 00000495 <res 00000001>          			resb	1						;495 track currently seeked to on drive 1
   539 00000496 <res 00000001>          			resb	1						;496 keyboard mode/type
   540 00000497 <res 00000001>          			resb	1						;497 keyboard LED flags
   541 00000498 <res 00000004>          			resd	1						;498 pointer to user wait complete flag
   542 0000049C <res 00000004>          			resd	1						;49c user wait time-out value in microseconds
   543 000004A0 <res 00000001>          			resb	1						;4a0 RTC wait function flag
   544 000004A1 <res 00000001>          			resb	1						;4a1 LANA DMA channel flags
   545 000004A2 <res 00000002>          			resb	2						;4a2 status of LANA 0,1
   546 000004A4 <res 00000004>          			resd	1						;4a4 saved hard disk interrupt vector
   547 000004A8 <res 00000004>          			resd	1						;4a8 BIOS video save/override pointer table addr
   548 000004AC <res 00000008>          			resb	8						;4ac reserved
   549 000004B4 <res 00000001>          			resb	1						;4b4 keyboard NMI control flags
   550 000004B5 <res 00000004>          			resd	1						;4b5 keyboard break pending flags
   551 000004B9 <res 00000001>          			resb	1						;4b9 Port 60 single byte queue
   552 000004BA <res 00000001>          			resb	1						;4ba scan code of last key
   553 000004BB <res 00000001>          			resb	1						;4bb NMI buffer head pointer
   554 000004BC <res 00000001>          			resb	1						;4bc NMI buffer tail pointer
   555 000004BD <res 00000010>          			resb	16						;4bd NMI scan code buffer
   556 000004CD <res 00000001>          			resb	1						;4cd unknown
   557 000004CE <res 00000002>          			resw	1						;4de day counter
   558 000004D0 <res 00000020>          			resb	32						;4d0 unknown
   559 000004F0 <res 00000010>          			resb	16						;4f0 intra-app comm area
   560 00000500 <res 00000001>          			resb	1						;500 print-screen status byte
   561 00000501 <res 00000003>          			resb	3						;501 used by BASIC
   562 00000504 <res 00000001>          			resb	1						;504 DOS single diskette mode
   563 00000505 <res 0000000A>          			resb	10						;505 POST work area
   564 0000050F <res 00000001>          			resb	1						;50f BASIC shell flag
   565 00000510 <res 00000002>          			resw	1						;510 BASIC default DS (DEF SEG)
   566 00000512 <res 00000004>          			resd	1						;512 BASIC INT 1C interrupt handler
   567 00000516 <res 00000004>          			resd	1						;516 BASIC INT 23 interrupt handler
   568 0000051A <res 00000004>          			resd	1						;51a BASIC INT 24 interrupt handler
   569 0000051E <res 00000002>          			resw	1						;51e unknown
   570 00000520 <res 00000002>          			resw	1						;520 DOS dynamic storage
   571 00000522 <res 0000000E>          			resb	14						;522 DOS diskette initialization table (INT 1e)
   572 00000530 <res 00000004>          			resb	4						;530 MODE command
   573 00000534 <res 000001CC>          			resb	460						;534 unused
   574 00000700 <res 00000100>          			resb	256						;700 i/o drivers from io.sys/ibmbio.com
   575                                  ;-----------------------------------------------------------------------------------------------------------------------
   576                                  ;
   577                                  ;	OS Variables								@disk: N/A	@mem: 000800
   578                                  ;
   579                                  ;	Operating system variables are system global. They are defined at low memory address 800h and are typically
   580                                  ;	accessed using GDT selector 18H, which defines a 4GB address space at address 0:0. The variables defined here
   581                                  ;	are organized based on the task that usually accesses them.
   582                                  ;
   583                                  ;-----------------------------------------------------------------------------------------------------------------------
   584                                  ;-----------------------------------------------------------------------------------------------------------------------
   585                                  ;
   586                                  ;	Kernel Variables
   587                                  ;
   588                                  ;	These variables are not task-specific. They are initialized by the OS loader before the system is placed into
   589                                  ;	protected mode. This is necessary because as soon as the system enters protected mode, the timer interrupt
   590                                  ;	(IRQ0) will begin to reference the task selectors queue to implement task switching.
   591                                  ;
   592                                  ;-----------------------------------------------------------------------------------------------------------------------
   593                                  			align	4
   594                                  EKERNELDATA		equ	($)
   595 00000800 <res 00000200>          wwTaskQueue		resw	256						;task selector queue
   596 00000A00 <res 00000004>          wdFarJumpEIP		resd	1						;destination EIP of next task (ignored)
   597 00000A04 <res 00000002>          wwFarJumpSelector	resw	1						;destination task gate
   598 00000A06 <res 00000001>          wbTaskIndex		resb	1						;task selector index
   599 00000A07 <res 00000001>          wbInCriticalSection	resb	1						;task in critical section
   600                                  			align	4
   601 00000A08 <res 00000004>          wfHeapSize		resd	1						;heap size
   602 00000A0C <res 00000018>          wsMemRoot		resb	EMEMROOTLEN					;base memory map
   603                                  EKERNELDATALEN		equ	($-EKERNELDATA)
   604                                  ;-----------------------------------------------------------------------------------------------------------------------
   605                                  ;
   606                                  ;	Console Task Variables
   607                                  ;
   608                                  ;	These variables are exclusve to the console task. These variables are initialized by the console task when
   609                                  ;	the console task starts.
   610                                  ;
   611                                  ;-----------------------------------------------------------------------------------------------------------------------
   612                                  			align	4
   613                                  ECONDATA		equ	($)
   614 00000A24 <res 00000004>          wfConsoleMemAddr	resd	1						;console memory address
   615 00000A28 <res 00000004>          wfConsolePCISelector	resd	1						;PCI selector (bbbbbbbb dddddfff)
   616                                  wfConsolePCIData	equ	$						;PCI register data value
   617 00000A2C <res 00000002>          wwConsolePCIVendor	resw	1						;PCI data vendor
   618 00000A2E <res 00000002>          wwConsolePCIChip	resw	1						;PCI data chip
   619 00000A30 <res 00000004>          wfConsolePCIVendorStr	resd	1						;PCI vendor name string addr
   620 00000A34 <res 00000004>          wfConsolePCIChipStr	resd	1						;PCI device name string addr
   621 00000A38 <res 00000004>          wfConsoleEthernetDevice	resd	1						;PCI ethernet adapter selector
   622 00000A3C <res 00000004>          wfConsoleEthernetMem	resd	1						;PCI ethernet memory mapped i/o address
   623 00000A40 <res 00000004>          wfConsoleEthernetPort	resd	1						;PCI ethernet i/o port
   624 00000A44 <res 00000004>          wfConsoleEthernetCtrl	resd	1						;PCI ethernet control register value
   625 00000A48 <res 00000001>          wbConsoleColumn		resb	1						;console column
   626 00000A49 <res 00000001>          wbConsoleRow		resb	1						;console row
   627 00000A4A <res 00000001>          wbConsoleShift		resb	1						;console shift flags
   628 00000A4B <res 00000001>          wbConsoleLock		resb	1						;console lock flags
   629 00000A4C <res 00000001>          wbConsoleStatus		resb	1						;controller status
   630 00000A4D <res 00000001>          wbConsoleScan0		resb	1						;scan code
   631 00000A4E <res 00000001>          wbConsoleScan1		resb	1						;scan code
   632 00000A4F <res 00000001>          wbConsoleScan2		resb	1						;scan code
   633 00000A50 <res 00000001>          wbConsoleScan3		resb	1						;scan code
   634 00000A51 <res 00000001>          wbConsoleScan4		resb	1						;scan code
   635 00000A52 <res 00000001>          wbConsoleScan5		resb	1						;scan code
   636 00000A53 <res 00000001>          wbConsoleChar		resb	1						;ASCII code
   637 00000A54 <res 00000001>          wbConsolePCIBus		resb	1						;PCI bus
   638 00000A55 <res 00000001>          wbConsolePCIDevice	resb	1						;PCI device
   639 00000A56 <res 00000001>          wbConsolePCIFunction	resb	1						;PCI function
   640 00000A57 <res 00000001>          wbConsoleHWFlags	resb	1						;Hardware Flags
   641 00000A58 <res 00000050>          wzConsoleInBuffer	resb	80						;command input buffer
   642 00000AA8 <res 00000050>          wzConsoleToken		resb	80						;token buffer
   643 00000AF8 <res 00000050>          wzConsoleOutBuffer	resb	80						;response output buffer
   644 00000B48 <res 00000008>          wsConsoleDateTime	resb	EDATETIMELEN					;date-time buffer
   645                                  ECONDATALEN		equ	($-ECONDATA)					;size of console data area
   646                                  ;-----------------------------------------------------------------------------------------------------------------------
   647                                  ;
   648                                  ;	Background Task Variables
   649                                  ;
   650                                  ;	These variables are exclusve to the background task. These variables are initialized by the background task when
   651                                  ;	the task starts.
   652                                  ;
   653                                  ;-----------------------------------------------------------------------------------------------------------------------
   654                                  			align	4
   655                                  EBGDATA			equ	($)
   656 00000B50 <res 00000008>          wsBgDateTime		resb	EDATETIMELEN					;date-time buffer
   657 00000B58 <res 00000009>          wzBgTime		resb	EBGTIMELEN					;time string buffer
   658 00000B61 <res 00000009>          wzBgTimeCmpr		resb	EBGTIMELEN					;time string comparison buffer
   659                                  EBGDATALEN		equ	($-EBGDATA)
   660                                  ;-----------------------------------------------------------------------------------------------------------------------
   661                                  ;
   662                                  ;	End of OS Variables
   663                                  ;
   664                                  ;-----------------------------------------------------------------------------------------------------------------------
   665                                  endstruc
   666                                  ;-----------------------------------------------------------------------------------------------------------------------
   667                                  ;
   668                                  ;	Macros
   669                                  ;
   670                                  ;	These macros are used to assist in defining descriptor tables and interrupt table offsets.
   671                                  ;
   672                                  ;-----------------------------------------------------------------------------------------------------------------------
   673                                  %macro			mint	1
   674                                  _%1			equ	($-$$) / EKRNDESLEN
   675                                  			dq	((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
   676                                  %endmacro
   677                                  %macro			mtrap	1
   678                                  _%1			equ	($-$$) / EKRNDESLEN
   679                                  			dq	((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
   680                                  %endmacro
   681                                  %macro			menter	1
   682                                  ?%1			equ	($-$$)
   683                                  %endmacro
   684                                  %macro			tsvce	1
   685                                  e%1			equ	($-tsvc)/4
   686                                  			dd	%1
   687                                  %endmacro
   688                                  %ifdef BUILDBOOT
   689                                  ;=======================================================================================================================
   690                                  ;
   691                                  ;	Boot Sector								@disk: 000000	@mem: 007c00
   692                                  ;
   693                                  ;	The first sector of the disk is the boot sector. The BIOS will load the boot sector into memory and pass
   694                                  ;	control to the code at the start of the sector. The boot sector code is responsible for loading the operating
   695                                  ;	system into memory. The boot sector contains a disk parameter table describing the geometry and allocation
   696                                  ;	of the disk. Following the disk parameter table is code to load the operating system kernel into memory.
   697                                  ;
   698                                  ;	The 'cpu' directive limits emitted code to those instructions supported by the most primitive processor
   699                                  ;	we expect to ever execute our code. The 'vstart' parameter indicates addressability of symbols so as to
   700                                  ;	emulating the DOS .COM program model. Although the BIOS is expected to load the boot sector at address 7c00,
   701                                  ;	we do not make that assumption. The CPU starts in 16-bit addressing mode. A three-byte jump instruction is
   702                                  ;	immediately followed by a disk parameter table.
   703                                  ;
   704                                  ;=======================================================================================================================
   705                                  			cpu	8086						;assume minimal CPU
   706                                  section			boot	vstart=0100h					;emulate .COM (CS,DS,ES=PSP) addressing
   707                                  			bits	16						;16-bit code at power-up
   708                                  %ifdef BUILDPREP
   709                                  Boot			jmp	word Prep					;jump to preparation code
   710                                  %else
   711 00000000 E91B00                  Boot			jmp	word Boot.10					;jump over parameter table
   712                                  %endif
   713                                  ;-----------------------------------------------------------------------------------------------------------------------
   714                                  ;
   715                                  ;	Disk Parameter Table
   716                                  ;
   717                                  ;	The disk parameter table informs the BIOS of the floppy disk architecture. Here, we use parameters for the
   718                                  ;	3.5" 1.44MB floppy disk since this format is widely supported by virtual machine hypervisors.
   719                                  ;
   720                                  ;-----------------------------------------------------------------------------------------------------------------------
   721 00000003 437573746F6D4F53        			db	"CustomOS"					;eight-byte label
   722 0000000B 0002                    cwSectorBytes		dw	EBOOTSECTORBYTES				;bytes per sector
   723 0000000D 01                      cbClusterSectors	db	1						;sectors per cluster
   724 0000000E 0100                    cwReservedSectors	dw	1						;reserved sectors
   725 00000010 02                      cbFatCount		db	2						;file allocation table copies
   726 00000011 E000                    cwDirEntries		dw	224						;max directory entries
   727 00000013 400B                    cwDiskSectors		dw	EBOOTDISKSECTORS				;sectors per disk
   728 00000015 F0                      cbDiskType		db	0F0h						;1.44MB
   729 00000016 0900                    cwFatSectors		dw	9						;sectors per FAT copy
   730                                  cbTrackSectors		equ	$						;sectors per track (as byte)
   731 00000018 1200                    cwTrackSectors		dw	18						;sectors per track (as word)
   732 0000001A 0200                    cwDiskSides		dw	2						;sides per disk
   733 0000001C 0000                    cwSpecialSectors	dw	0						;special sectors
   734                                  ;
   735                                  ;	BIOS typically loads the boot sector at absolute address 7c00 and sets the stack pointer at 512 bytes past the
   736                                  ;	end of the boot sector. But, since BIOS code varies, we don't make any assumptions as to where our boot sector
   737                                  ;	is loaded. For example, the initial CS:IP could be 0:7c00, 700:c00, 7c0:0, etc. So, to avoid assumptions, we
   738                                  ;	first normalize CS:IP to get the absolute segment address in BX. The comments below show the effect of this code
   739                                  ;	given several possible starting values for CS:IP.
   740                                  ;
   741                                  										;CS:IP	 0:7c00 700:c00 7c0:0
   742 0000001E E80000                  Boot.10			call	word .20					;[ESP] =   7c21     c21    21
   743                                  .@20			equ	$-$$						;.@20 = 021h
   744 00000021 58                      .20			pop	ax						;AX =	   7c21     c21    21
   745 00000022 83E821                  			sub	ax,.@20						;BX =	   7c00     c00     0
   746 00000025 B104                    			mov	cl,4						;shift count
   747 00000027 D3E8                    			shr	ax,cl						;AX =	    7c0      c0     0
   748 00000029 8CCB                    			mov	bx,cs						;BX =	      0     700   7c0
   749 0000002B 01C3                    			add	bx,ax						;BX =	    7c0     7c0   7c0
   750                                  ;
   751                                  ;	Now, since we are assembling our boot code to emulate the addressing of a .COM file, we want the DS and ES
   752                                  ;	registers to be set to where a Program Segment Prefix (PSP) would be, exactly 100h (256) bytes prior to
   753                                  ;	the start of our code. This will correspond to our assembled data address offsets. Note that we instructed
   754                                  ;	the assembler to produce addresses for our symbols that are offset from our code by 100h. See the "vstart"
   755                                  ;	parameter for the "section" directive above. We also set SS to the PSP and SP to the address of our i/o
   756                                  ;	buffer. This leaves 256 bytes of usable stack from 7b0:300 to 7b0:400.
   757                                  ;
   758 0000002D 83EB10                  			sub	bx,16						;BX = 07b0
   759 00000030 8EDB                    			mov	ds,bx						;DS = 07b0 = psp
   760 00000032 8EC3                    			mov	es,bx						;ES = 07b0 = psp
   761 00000034 8ED3                    			mov	ss,bx						;SS = 07b0 = psp (ints disabled)
   762 00000036 BC0001                  			mov	sp,EBOOTSTACKTOP				;SP = 0100       (ints enabled)
   763                                  ;
   764                                  ;	Our boot addressability is now set up according to the following diagram.
   765                                  ;
   766                                  ;	DS,ES,SS ----->	007b00	+-----------------------------------------------+ DS:0000
   767                                  ;				|  Boot Stack & Boot PSP (Unused)		|
   768                                  ;				|  256 = 100h bytes				|
   769                                  ;	SS:SP -------->	007c00	+-----------------------------------------------+ DS:0100  07b0:0100
   770                                  ;				|  Boot Sector (vstart=0100h)			|
   771                                  ;				|  1 sector = 512 = 200h bytes			|
   772                                  ;			007e00	+-----------------------------------------------+ DS:0300
   773                                  ;				|  File Allocation Table (FAT) I/O Buffer	|
   774                                  ;				|  9x512-byte sectors = 4,608 = 1200h bytes	|
   775                                  ;			009000	+-----------------------------------------------+ DS:1500  08f0:0100
   776                                  ;				|  Directory Sector Buffer & Kernel Load Area	|
   777                                  ;			009200	+-----------------------------------------------+ DS:1700
   778                                  ;
   779                                  ;	On entry, DL indicates the drive being booted from.
   780                                  ;
   781 00000039 8816[F801]              			mov	[wbDrive],dl					;[drive] = drive being booted from
   782                                  ;
   783                                  ;	Compute directory i/o buffer address.
   784                                  ;
   785 0000003D A1[1600]                			mov	ax,[cwFatSectors]				;AX = 0009 = FAT sectors
   786 00000040 F726[0B00]              			mul	word [cwSectorBytes]				;DX:AX = 0000:1200 = FAT bytes
   787 00000044 050003                  			add	ax,EBOOTFATBASE					;AX = 1500 = end of FAT buffer
   788 00000047 A3[EC01]                			mov	[wwDirBuffer],ax				;[dirbuffer] = 1500
   789                                  ;
   790                                  ;	Compute segment where os.com will be loaded.
   791                                  ;
   792 0000004A D3E8                    			shr	ax,cl						;AX = 0150
   793 0000004C 01D8                    			add	ax,bx						;AX = 0150 + 07b0 = 0900
   794 0000004E 83E810                  			sub	ax,16						;AX = 08f0
   795 00000051 A3[3F01]                			mov	[wwLoadSegment],ax				;[loadsegment] = 08f0
   796                                  ;
   797                                  ;	Set the video mode to 80 column, 25 row, text.
   798                                  ;
   799 00000054 B80300                  			mov	ax,EBIOSFNSETVMODE<<8|EBIOSMODETEXT80		;set mode function, 80x25 text mode
   800 00000057 CD10                    			int	EBIOSINTVIDEO					;call BIOS display interrupt
   801                                  ;
   802                                  ;	Write a message to the console so we know we have our addressability established.
   803                                  ;
   804 00000059 BE[C501]                			mov	si,czLoadMsg					;loading message
   805 0000005C E84B01                  			call	BootPrint					;display loader message
   806                                  ;
   807                                  ;	Initialize the number of directory sectors to search.
   808                                  ;
   809 0000005F A1[1100]                			mov	ax,[cwDirEntries]				;AX = 224 = max dir entries
   810 00000062 A3[EE01]                			mov	[wwEntriesLeft],ax				;[entriesleft] = 224
   811                                  ;
   812                                  ;	Compute number of directory sectors and initialize overhead count.
   813                                  ;
   814 00000065 89C1                    			mov	cx,ax						;CX = 00e0 = 224 entries
   815 00000067 F726[B801]              			mul	word [cwEntryLen]				;DX:AX = 224 * 32 = 7168
   816 0000006B F736[0B00]              			div	word [cwSectorBytes]				;AX = 7168 / 512 = 14 = dir sectors
   817 0000006F A3[F001]                			mov	[wwOverhead],ax					;[overhead] = 000e
   818                                  ;
   819                                  ;	Compute directory entries per sector.
   820                                  ;
   821 00000072 91                      			xchg	ax,cx						;DX:AX = 0:00e0, DX = 0000e
   822 00000073 F7F1                    			div	cx						;AX = 0010 = entries per dir sector
   823 00000075 A3[F201]                			mov	[wwSectorEntries],ax				;[sectorentries] = 0010
   824                                  ;
   825                                  ;	Compute first logical directory sector and update overhead count.
   826                                  ;
   827 00000078 A1[1600]                			mov	ax,[cwFatSectors]				;AX = 0009 = FAT sectors per copy
   828 0000007B F626[1000]              			mul	byte [cbFatCount]				;AX = 0012 = FAT sectors
   829 0000007F 0306[0E00]              			add	ax,[cwReservedSectors]				;AX = 0013 = FAT plus reserved
   830 00000083 0306[1C00]              			add	ax,[cwSpecialSectors]				;AX = 0013 = FAT + reserved + special
   831 00000087 A3[F401]                			mov	[wwLogicalSector],ax				;[logicalsector] = 0013
   832 0000008A 0106[F001]              			add	[wwOverhead],ax					;[overhead] = 0021 = res+spec+FAT+dir
   833                                  ;
   834                                  ;	Read directory sector.
   835                                  ;
   836 0000008E B001                    .30			mov	al,1						;sector count
   837 00000090 A2[F601]                			mov	[wbReadCount],al				;[readcount] = 01
   838 00000093 8B1E[EC01]              			mov	bx,[wwDirBuffer]				;BX = 1500
   839 00000097 E8A700                  			call	ReadSector					;read sector into es:bx
   840                                  ;
   841                                  ;	Setup variables to search this directory sector.
   842                                  ;
   843 0000009A A1[EE01]                			mov	ax,[wwEntriesLeft]				;directory entries to search
   844 0000009D 3B06[F201]              			cmp	ax,[wwSectorEntries]				;need to search more sectors?
   845 000000A1 7603                    			jna	.40						;no, continue
   846 000000A3 A1[F201]                			mov	ax,[wwSectorEntries]				;yes, limit search to sector
   847 000000A6 2906[EE01]              .40			sub	[wwEntriesLeft],ax				;update entries left to searh
   848 000000AA BE[BA01]                			mov	si,cbKernelProgram				;program name
   849 000000AD 8B3E[EC01]              			mov	di,[wwDirBuffer]				;DI = 1500
   850                                  ;
   851                                  ;	Loop through directory sectors searching for kernel program.
   852                                  ;
   853 000000B1 56                      .50			push	si						;save kernel name address
   854 000000B2 57                      			push	di						;save dir i/o buffer address
   855 000000B3 B90B00                  			mov	cx,11						;length of 8+3 name
   856 000000B6 FC                      			cld							;forward strings
   857 000000B7 F3A6                    			repe	cmpsb						;compare entry name
   858 000000B9 5F                      			pop	di						;restore dir i/o buffer address
   859 000000BA 5E                      			pop	si						;restore kernel name address
   860 000000BB 7418                    			je	.60						;exit loop if found
   861 000000BD 033E[B801]              			add	di,[cwEntryLen]					;point to next dir entry
   862 000000C1 48                      			dec	ax						;decrement remaining entries
   863 000000C2 75ED                    			jnz	.50						;next entry
   864                                  ;
   865                                  ;	Repeat search if we are not at the end of the directory.
   866                                  ;
   867 000000C4 FF06[F401]              			inc	word [wwLogicalSector]				;increment logical sector
   868 000000C8 833E[EE01]00            			cmp	word [wwEntriesLeft],0				;done with directory?
   869 000000CD 75BF                    			jne	.30						;no, get next sector
   870 000000CF BE[E001]                			mov	si,czNoKernel					;missing kernel message
   871 000000D2 E9C000                  			jmp	BootExit					;display message and exit
   872                                  ;
   873                                  ;	If we find the kernel program in the directory, read the FAT.
   874                                  ;
   875 000000D5 A1[0E00]                .60			mov	ax,[cwReservedSectors]				;AX = 0001
   876 000000D8 A3[F401]                			mov	[wwLogicalSector],ax				;start past boot sector
   877 000000DB A1[1600]                			mov	ax,[cwFatSectors]				;AX = 0009
   878 000000DE A2[F601]                			mov	[wbReadCount],al				;[readcount] = 09
   879 000000E1 BB0003                  			mov	bx,EBOOTFATBASE					;BX = 0300
   880 000000E4 E85A00                  			call	ReadSector					;read FAT into buffer
   881                                  ;
   882                                  ;	Get the starting cluster of the kernel program and target address.
   883                                  ;
   884 000000E7 8B451A                  			mov	ax,[di+26]					;AX = starting cluster of file
   885 000000EA C41E[3D01]              			les	bx,[wwLoadOffset]				;ES:BX = kernel load add (08F0:0100)
   886                                  ;
   887                                  ;	Read each program cluster into RAM.
   888                                  ;
   889 000000EE 50                      .70			push	ax						;save cluster nbr
   890 000000EF 83E802                  			sub	ax,2						;AX = cluster nbr base 0
   891 000000F2 8A0E[0D00]              			mov	cl,[cbClusterSectors]				;CL = sectors per cluster
   892 000000F6 880E[F601]              			mov	[wbReadCount],cl				;save sectors to read
   893 000000FA 30ED                    			xor	ch,ch						;CX = sectors per cluster
   894 000000FC F7E1                    			mul	cx						;DX:AX = logical cluster sector
   895 000000FE 0306[F001]              			add	ax,[wwOverhead]					;AX = kernel sector nbr
   896 00000102 A3[F401]                			mov	[wwLogicalSector],ax				;save logical sector nbr
   897 00000105 E83900                  			call	ReadSector					;read sectors into ES:BX
   898                                  ;
   899                                  ;	Update buffer pointer for next cluster.
   900                                  ;
   901 00000108 A0[0D00]                			mov	al,[cbClusterSectors]				;AL = sectors per cluster
   902 0000010B 30E4                    			xor	ah,ah						;AX = sectors per cluster
   903 0000010D F726[0B00]              			mul	word [cwSectorBytes]				;DX:AX = cluster bytes
   904 00000111 01C3                    			add	bx,ax						;BX = next cluster target address
   905 00000113 58                      			pop	ax						;AX = restore cluster nbr
   906                                  ;
   907                                  ;	Compute next cluster number.
   908                                  ;
   909 00000114 89C1                    			mov	cx,ax						;CX = cluster nbr
   910 00000116 89C7                    			mov	di,ax						;DI = cluster nbr
   911 00000118 D1E8                    			shr	ax,1						;AX = cluster/2
   912 0000011A 89C2                    			mov	dx,ax						;DX = cluster/2
   913 0000011C 01D0                    			add	ax,dx						;AX = 2*(cluster/2)
   914 0000011E 01D0                    			add	ax,dx						;AX = 3*(cluster/2)
   915 00000120 83E701                  			and	di,1						;get low bit
   916 00000123 01C7                    			add	di,ax						;add one if cluster is odd
   917 00000125 81C70003                			add	di,EBOOTFATBASE					;add FAT buffer address
   918 00000129 8B05                    			mov	ax,[di]						;get cluster bytes
   919                                  ;
   920                                  ;	Adjust cluster nbr by 4 bits if cluster is odd; test for end of chain.
   921                                  ;
   922 0000012B F6C101                  			test	cl,1						;is cluster odd?
   923 0000012E 7404                    			jz	.80						;no, skip ahead
   924 00000130 B104                    			mov	cl,4						;shift count
   925 00000132 D3E8                    			shr	ax,cl						;shift nybble low
   926 00000134 25FF0F                  .80			and	ax,0FFFh					;mask for 24 bits; next cluster nbr
   927 00000137 3DFF0F                  			cmp	ax,0FFFh					;end of chain?
   928 0000013A 75B2                    			jne	.70						;no, continue
   929                                  ;
   930                                  ;	Transfer control to the operating system program.
   931                                  ;
   932 0000013C EA                      			db	0EAh						;jmp seg:offset
   933 0000013D 0001                    wwLoadOffset		dw	0100h						;kernel entry offset
   934 0000013F F008                    wwLoadSegment		dw	08F0h						;kernel entry segment (computed)
   935                                  ;
   936                                  ;	Read [readcount] disk sectors from [logicalsector] into ES:BX.
   937                                  ;
   938 00000141 A1[1800]                ReadSector		mov	ax,[cwTrackSectors]				;AX = sectors per track
   939 00000144 F726[1A00]              			mul	word [cwDiskSides]				;DX:AX = sectors per cylinder
   940 00000148 89C1                    			mov	cx,ax						;CX = sectors per cylinder
   941 0000014A A1[F401]                			mov	ax,[wwLogicalSector]				;DX:AX = logical sector
   942 0000014D F7F1                    			div	cx						;AX = cylinder; DX = cyl sector
   943 0000014F A2[FB01]                			mov	[wbTrack],al					;[track] = cylinder
   944 00000152 89D0                    			mov	ax,dx						;AX = cyl sector
   945 00000154 F636[1800]              			div	byte [cbTrackSectors]				;AH = sector, AL = head
   946 00000158 FEC4                    			inc	ah						;AH = sector (1,2,3,...)
   947 0000015A A3[F901]                			mov	[wbHead],ax					;[head]= head, [sector]= sector
   948                                  ;
   949                                  ;	Try maxtries times to read sector.
   950                                  ;
   951 0000015D B90500                  			mov	cx,EBOOTMAXTRIES				;CX = 0005
   952 00000160 53                      .10			push	bx						;save buffer address
   953 00000161 51                      			push	cx						;save retry count
   954 00000162 8B16[F801]              			mov	dx,[wwDriveHead]				;DH = head, DL = drive
   955 00000166 8B0E[FA01]              			mov	cx,[wwSectorTrack]				;CH = track, CL = sector
   956 0000016A A1[F601]                			mov	ax,[wwReadCountCommand]				;AH = fn., AL = sector count
   957 0000016D CD13                    			int	EBIOSINTDISKETTE				;read sector
   958 0000016F 59                      			pop	cx						;restore retry count
   959 00000170 5B                      			pop	bx						;restore buffer address
   960 00000171 7343                    			jnc	BootReturn					;skip ahead if done
   961 00000173 E2EB                    			loop	.10						;retry
   962                                  ;
   963                                  ;	Handle disk error: convert to ASCII and store in error string.
   964                                  ;
   965 00000175 88E0                    			mov	al,ah						;AL = bios error code
   966 00000177 30E4                    			xor	ah,ah						;AX = bios error code
   967 00000179 B210                    			mov	dl,16						;divisor for base 16
   968 0000017B F6F2                    			div	dl						;AL = hi order, AH = lo order
   969 0000017D 0D3030                  			or	ax,03030h					;apply ASCII zone bits
   970 00000180 80FC3A                  			cmp	ah,03Ah						;range test ASCII numeral
   971 00000183 7203                    			jb	.20						;continue if numeral
   972 00000185 80C407                  			add	ah,7						;adjust for ASCII 'A'-'F'
   973 00000188 3C3A                    .20			cmp	al,03Ah						;range test ASCII numeral
   974 0000018A 7203                    			jb	.30						;continue if numeral
   975 0000018C 80C407                  			add	ah,7						;adjust for ASCII 'A'-'F'
   976 0000018F A3[DD01]                .30			mov	[wzErrorCode],ax				;store ASCII error code
   977 00000192 BE[D201]                			mov	si,czErrorMsg					;error message address
   978 00000195 E81200                  BootExit		call	BootPrint					;display messge to console
   979 00000198 B401                    .10			mov	ah,EBIOSFNKEYSTATUS				;bios keyboard status function
   980 0000019A CD16                    			int	EBIOSINTKEYBOARD				;get keyboard status
   981 0000019C 7504                    			jnz	.20						;continue if key pressed
   982 0000019E FB                      			sti							;enable maskable interrupts
   983 0000019F F4                      			hlt							;wait for interrupt
   984 000001A0 EBF6                    			jmp	.10						;repeat
   985 000001A2 B0FE                    .20			mov	al,EKEYBCMDRESET				;8042 pulse output port pin
   986 000001A4 E664                    			out	EKEYBPORTSTAT,al				;drive B0 low to restart
   987 000001A6 FB                      .30			sti							;enable maskable interrupts
   988 000001A7 F4                      			hlt							;stop until reset, int, nmi
   989 000001A8 EBFC                    			jmp	.30						;loop until restart kicks in
   990                                  ;
   991                                  ;	Display text message.
   992                                  ;
   993 000001AA FC                      BootPrint		cld							;forward strings
   994 000001AB AC                      			lodsb							;load next byte at DS:SI in AL
   995 000001AC 84C0                    			test	al,al						;end of string?
   996 000001AE 7406                    			jz	BootReturn					;... yes, exit our loop
   997 000001B0 B40E                    			mov	ah,EBIOSFNTTYOUTPUT				;BIOS teletype function
   998 000001B2 CD10                    			int	EBIOSINTVIDEO					;call BIOS display interrupt
   999 000001B4 EBF4                    			jmp	BootPrint					;repeat until done
  1000 000001B6 C3                      BootReturn		ret							;return
  1001                                  ;-----------------------------------------------------------------------------------------------------------------------
  1002                                  ;
  1003                                  ;	Constants
  1004                                  ;
  1005                                  ;-----------------------------------------------------------------------------------------------------------------------
  1006 000001B7 90                      			align	2
  1007 000001B8 2000                    cwEntryLen		dw	32						;length of directory entry
  1008 000001BA 4F5320202020202043-     cbKernelProgram		db	"OS      COM"					;kernel program name
  1008 000001C3 4F4D               
  1009 000001C5 4C6F6164696E67204F-     czLoadMsg		db	"Loading OS",13,10,0				;loading message
  1009 000001CE 530D0A00           
  1010 000001D2 4469736B206572726F-     czErrorMsg		db	"Disk error "					;error message
  1010 000001DB 7220               
  1011 000001DD 202000                  wzErrorCode		db	020h,020h,0					;error code and null terminator
  1012 000001E0 4F53206D697373696E-     czNoKernel		db	"OS missing",0					;missing kernel message
  1012 000001E9 6700               
  1013                                  ;-----------------------------------------------------------------------------------------------------------------------
  1014                                  ;
  1015                                  ;	Work Areas
  1016                                  ;
  1017                                  ;-----------------------------------------------------------------------------------------------------------------------
  1018 000001EB 90                      			align	2
  1019 000001EC 0000                    wwDirBuffer		dw	0						;directory i/o buffer address
  1020 000001EE 0000                    wwEntriesLeft		dw	0						;directory entries to search
  1021 000001F0 0000                    wwOverhead		dw	0						;overhead sectors
  1022 000001F2 0000                    wwSectorEntries		dw	0						;directory entries per sector
  1023 000001F4 0000                    wwLogicalSector		dw	0						;current logical sector
  1024                                  wwReadCountCommand	equ	$						;read count and command
  1025 000001F6 00                      wbReadCount		db	0						;sectors to read
  1026 000001F7 02                      cbReadCommand		db	2						;BIOS read disk fn code
  1027                                  wwDriveHead		equ	$						;drive, head (word)
  1028 000001F8 00                      wbDrive			db	0						;drive
  1029 000001F9 00                      wbHead			db	0						;head
  1030                                  wwSectorTrack		equ	$						;sector, track (word)
  1031 000001FA 00                      			db	0						;sector
  1032 000001FB 00                      wbTrack			db	0						;track
  1033 000001FC 00<rept>                			times	510-($-$$) db 0h				;zero fill to end of sector
  1034 000001FE 55AA                    			db	055h,0AAh					;end of sector signature
  1035                                  %endif
  1036                                  %ifdef BUILDPREP
  1037                                  ;=======================================================================================================================
  1038                                  ;
  1039                                  ;	Diskette Preparation Code
  1040                                  ;
  1041                                  ;	This routine writes the OS boot sector code to a formatted floppy diskette. The diskette parameter table,
  1042                                  ;	which is located in the first 30 bytes of the boot sector is first read from the diskette and overlayed onto
  1043                                  ;	the OS bootstrap code so that the diskette format parameters are preserved.
  1044                                  ;
  1045                                  ;=======================================================================================================================
  1046                                  ;
  1047                                  ;	Query the user to insert a flopppy diskette and press enter or cancel.
  1048                                  ;
  1049                                  Prep			mov	si,czPrepMsg10					;starting message address
  1050                                  			call	BootPrint					;display message
  1051                                  ;
  1052                                  ;	Exit if the Escape key is pressed or loop until Enter is pressed.
  1053                                  ;
  1054                                  .10			mov	ah,EBIOSFNKEYSTATUS				;BIOS keyboard status function
  1055                                  			int	EBIOSINTKEYBOARD				;get keyboard status
  1056                                  			jnz	.12						;continue if key pressed
  1057                                  			sti							;enable interrupts
  1058                                  			hlt							;wait for interrupt
  1059                                  			jmp	.10						;repeat
  1060                                  .12			cmp	al,EASCIIRETURN					;Enter key pressed?
  1061                                  			je	.15						;yes, branch
  1062                                  			cmp	al,EASCIIESCAPE					;Escape key pressed?
  1063                                  			jne	.10						;no, repeat
  1064                                  			jmp	.90						;yes, exit program
  1065                                  ;
  1066                                  ;	Display writing-sector message and patch the JMP instruction.
  1067                                  ;
  1068                                  .15			mov	si,czPrepMsg12					;writing-sector message address
  1069                                  			call	BootPrint					;display message
  1070                                  			mov	bx,Boot+1					;address of JMP instruction operand
  1071                                  			mov	ax,01Bh						;address past disk parameter table
  1072                                  			mov	[bx],ax						;update the JMP instruction
  1073                                  ;
  1074                                  ;	Try to read the boot sector.
  1075                                  ;
  1076                                  			mov	cx,EBOOTMAXTRIES				;try up to five times
  1077                                  .20			push	cx						;save remaining tries
  1078                                  			mov	bx,wcPrepInBuf					;input buffer address
  1079                                  			mov	dx,0						;head zero, drive zero
  1080                                  			mov	cx,1						;track zero, sector one
  1081                                  			mov	ax,0201h					;read one sector
  1082                                  			int	EBIOSINTDISKETTE				;attempt the read
  1083                                  			pop	cx						;restore remaining retries
  1084                                  			jnc	.30						;skip ahead if successful
  1085                                  			loop	.20						;try again
  1086                                  			mov	si,czPrepMsg20					;read-error message address
  1087                                  			jmp	.50						;branch to error routine
  1088                                  ;
  1089                                  ;	Copy diskette parms from input buffer to output buffer.
  1090                                  ;
  1091                                  .30			mov	si,wcPrepInBuf					;input buffer address
  1092                                  			add	si,11						;skip over JMP and system ID
  1093                                  			mov	di,Boot						;output buffer address
  1094                                  			add	di,11						;skip over JMP and system ID
  1095                                  			mov	cx,19						;length of diskette parameters
  1096                                  			cld							;forward string copies
  1097                                  			rep	movsb						;copy diskette parameters
  1098                                  ;
  1099                                  ;	Try to write boot sector to diskette.
  1100                                  ;
  1101                                  			mov	cx,EBOOTMAXTRIES				;try up to five times
  1102                                  .40			push	cx						;save remaining tries
  1103                                  			mov	bx,Boot						;output buffer address
  1104                                  			mov	dx,0						;head zero, drive zero
  1105                                  			mov	cx,1						;track zero, sector one
  1106                                  			mov	ax,0301h					;write one sector
  1107                                  			int	EBIOSINTDISKETTE				;attempt the write
  1108                                  			pop	cx						;restore remaining retries
  1109                                  			jnc	.80						;skip ahead if successful
  1110                                  			loop	.40						;try again
  1111                                  			mov	si,czPrepMsg30					;write-error message address
  1112                                  ;
  1113                                  ;	Convert the error code to ASCII and display the error message.
  1114                                  ;
  1115                                  .50			push	ax						;save error code
  1116                                  			mov	al,ah						;copy error code
  1117                                  			mov	ah,0						;AX = error code
  1118                                  			mov	dl,10h						;hexadecimal divisor
  1119                                  			idiv	dl						;AL = hi-order, AH = lo-order
  1120                                  			or	ax,03030h					;add ASCII zone digits
  1121                                  			cmp	ah,03Ah						;AH ASCII numeral?
  1122                                  			jb	.60						;yes, continue
  1123                                  			add	ah,7						;no, make ASCII 'A'-'F'
  1124                                  .60			cmp	al,03Ah						;al ASCII numeral?
  1125                                  			jb	.70						;yes, continue
  1126                                  			add	al,7						;no, make ASCII
  1127                                  .70			mov	[si+17],ax					;put ASCII error code in message
  1128                                  			call	BootPrint					;write error message
  1129                                  			pop	ax						;restore error code
  1130                                  ;
  1131                                  ;	Display the completion message.
  1132                                  ;
  1133                                  .80			mov	si,czPrepMsgOK					;assume successful completion
  1134                                  			mov	al,ah						;BIOS return code
  1135                                  			cmp	al,0						;success?
  1136                                  			je	.85						;yes, continue
  1137                                  			mov	si,czPrepMsgErr1				;disk parameter error message
  1138                                  			cmp	al,1						;disk parameter error?
  1139                                  			je	.85						;yes, continue
  1140                                  			mov	si,czPrepMsgErr2				;address mark not found message
  1141                                  			cmp	al,2						;address mark not found?
  1142                                  			je	.85						;yes, continue
  1143                                  			mov	si,czPrepMsgErr3				;protected disk message
  1144                                  			cmp	al,3						;protected disk?
  1145                                  			je	.85						;yes, continue
  1146                                  			mov	si,czPrepMsgErr6				;diskette removed message
  1147                                  			cmp	al,6						;diskette removed?
  1148                                  			je	.85						;yes, continue
  1149                                  			mov	si,czPrepMsgErr80				;drive timed out message
  1150                                  			cmp	al,80H						;drive timed out?
  1151                                  			je	.85						;yes, continue
  1152                                  			mov	si,czPrepMsgErrXX				;unknown error message
  1153                                  .85			call	BootPrint					;display result message
  1154                                  .90			mov	ax,04C00H					;terminate with zero result code
  1155                                  			int	021h						;terminate DOS program
  1156                                  			ret							;return (should not execute)
  1157                                  ;-----------------------------------------------------------------------------------------------------------------------
  1158                                  ;
  1159                                  ;	Diskette Preparation Messages
  1160                                  ;
  1161                                  ;-----------------------------------------------------------------------------------------------------------------------
  1162                                  czPrepMsg10		db	13,10,"CustomOS Boot-Diskette Preparation Program"
  1163                                  			db	13,10,"Copyright (C) 2010-2017 David J. Walling. All rights reserved."
  1164                                  			db	13,10
  1165                                  			db	13,10,"This program overwrites the boot sector of a diskette with startup code that"
  1166                                  			db	13,10,"will load the operating system into memory when the computer is restarted."
  1167                                  			db	13,10,"To proceed, place a formatted diskette into drive A: and press the Enter key."
  1168                                  			db	13,10,"To exit this program without preparing a diskette, press the Escape key."
  1169                                  			db	13,10,0
  1170                                  czPrepMsg12		db	13,10,"Writing the boot sector to the diskette ..."
  1171                                  			db	13,10,0
  1172                                  czPrepMsg20		db	13,10,"The error-code .. was returned from the BIOS while reading from the disk."
  1173                                  			db	13,10,0
  1174                                  czPrepMsg30		db	13,10,"The error-code .. was returned from the BIOS while writing to the disk."
  1175                                  			db	13,10,0
  1176                                  czPrepMsgOK		db	13,10,"The boot-sector was written to the diskette. Before booting your computer with"
  1177                                  			db	13,10,"this diskette, make sure that the file OS.COM is copied onto the diskette."
  1178                                  			db	13,10,0
  1179                                  czPrepMsgErr1		db	13,10,"(01) Invalid Disk Parameter"
  1180                                  			db	13,10,"This is an internal error caused by an invalid value being passed to a system"
  1181                                  			db	13,10,"function. The OSBOOT.COM file may be corrupt. Copy or download the file again"
  1182                                  			db	13,10,"and retry."
  1183                                  			db	13,10,0
  1184                                  czPrepMsgErr2		db	13,10,"(02) Address Mark Not Found"
  1185                                  			db	13,10,"This error indicates a physical problem with the floppy diskette. Please retry"
  1186                                  			db	13,10,"using another diskette."
  1187                                  			db	13,10,0
  1188                                  czPrepMsgErr3		db	13,10,"(03) Protected Disk"
  1189                                  			db	13,10,"This error is usually caused by attempting to write to a write-protected disk."
  1190                                  			db	13,10,"Check the 'write-protect' setting on the disk or retry using using another disk."
  1191                                  			db	13,10,0
  1192                                  czPrepMsgErr6		db	13,10,"(06) Diskette Removed"
  1193                                  			db	13,10,"This error may indicate that the floppy diskette has been removed from the"
  1194                                  			db	13,10,"diskette drive. On some systems, this code may also occur if the diskette is"
  1195                                  			db	13,10,"'write protected.' Please verify that the diskette is not write-protected and"
  1196                                  			db	13,10,"is properly inserted in the diskette drive."
  1197                                  			db	13,10,0
  1198                                  czPrepMsgErr80		db	13,10,"(80) Drive Timed Out"
  1199                                  			db	13,10,"This error usually indicates that no diskette is in the diskette drive. Please"
  1200                                  			db	13,10,"make sure that the diskette is properly seated in the drive and retry."
  1201                                  			db	13,10,0
  1202                                  czPrepMsgErrXX		db	13,10,"(??) Unknown Error"
  1203                                  			db	13,10,"The error-code returned by the BIOS is not a recognized error. Please consult"
  1204                                  			db	13,10,"your computer's technical reference for a description of this error code."
  1205                                  			db	13,10,0
  1206                                  wcPrepInBuf		equ	$
  1207                                  %endif
  1208                                  %ifdef BUILDDISK
  1209                                  ;=======================================================================================================================
  1210                                  ;
  1211                                  ;	File Allocation Tables
  1212                                  ;
  1213                                  ;	The disk contains two copies of the File Allocation Table (FAT). On our disk, each FAT copy is 1200h bytes in
  1214                                  ;	length. Each FAT entry contains the logical number of the next cluster. The first two entries are reserved. Our
  1215                                  ;	OS.COM file will be 7200h bytes in length. The first 200h bytes is the 16-bit loader code. The remaining 7000h
  1216                                  ;	bytes is the 32-bit kernel code. Our disk parameter table defines a cluster as containing one sector and each
  1217                                  ;	sector having 200h bytes. Therefore, our FAT table must reserve 57 clusters for OS.COM. The clusters used by
  1218                                  ;	OS.COM, then, will be cluster 2 through 59. The entry for cluster 59 is set to "0FFFh" to indicate that it is
  1219                                  ;	the last cluster in the chain.
  1220                                  ;
  1221                                  ;	Every three bytes encode two FAT entries as follows:
  1222                                  ;
  1223                                  ;	db	0abh,0cdh,0efh	;even cluster: 0dabh, odd cluster: 0efch
  1224                                  ;
  1225                                  ;=======================================================================================================================
  1226                                  ;-----------------------------------------------------------------------------------------------------------------------
  1227                                  ;
  1228                                  ;	FAT copy 1								@disk: 000200	@mem: n/a
  1229                                  ;
  1230                                  ;-----------------------------------------------------------------------------------------------------------------------
  1231                                  section			fat1							;first copy of FAT
  1232                                  			db	0F0h,0FFh,0FFh,	003h,040h,000h			;clusters 0-3		ff0 fff 003 004
  1233                                  			db	005h,060h,000h,	007h,080h,000h			;custters 4-7   	005 006 007 008
  1234                                  			db	009h,0A0h,000h,	00Bh,0C0h,000h			;clusters 8-11  	009 00a 00b 00c
  1235                                  			db	00Dh,0E0h,000h,	00Fh,000h,001h			;clusters 12-15 	00d 00e 00f 010
  1236                                  			db	011h,020h,001h,	013h,040h,001h			;clusters 16-19 	011 012 013 014
  1237                                  			db	015h,060h,001h,	017h,080h,001h			;clusters 20-23		015 016 017 018
  1238                                  			db	019h,0A0h,001h,	01Bh,0C0h,001h			;clusters 24-27		019 01a 01b 01c
  1239                                  			db	01Dh,0E0h,001h,	01Fh,000h,002h			;clusters 28-31		01d 01e 01f 020
  1240                                  			db	021h,020h,002h,	023h,040h,002h			;clusters 32-35		021 022 023 024
  1241                                  			db	025h,060h,002h,	027h,080h,002h			;clusters 36-39		025 026 027 028
  1242                                  			db	029h,0A0h,002h,	02Bh,0C0h,002h			;clusters 40-43		029 02A 02B 02C
  1243                                  			db	02Dh,0E0h,002h, 02Fh,000h,003h			;clusters 44-47		02D 02E 02F 030
  1244                                  			db	031h,020h,003h, 033h,040h,003h			;clusters 48-51		031 032 033 034
  1245                                  			db	035h,060h,003h, 037h,080h,003h			;clusters 52-55		035 036 037 038
  1246                                  			db	039h,0A0h,003h, 0FFh,00Fh,000h			;clusters 56-59		039 03A FFF 000
  1247                                  			times	(9*512)-($-$$) db 0				;zero fill to end of section
  1248                                  ;-----------------------------------------------------------------------------------------------------------------------
  1249                                  ;
  1250                                  ;	FAT copy 2								@disk: 001400	@mem: n/a
  1251                                  ;
  1252                                  ;-----------------------------------------------------------------------------------------------------------------------
  1253                                  section			fat2							;second copy of FAT
  1254                                  			db	0F0h,0FFh,0FFh,	003h,040h,000h			;clusters 0-3		ff0 fff 003 004
  1255                                  			db	005h,060h,000h,	007h,080h,000h			;custters 4-7   	005 006 007 008
  1256                                  			db	009h,0A0h,000h,	00Bh,0C0h,000h			;clusters 8-11  	009 00a 00b 00c
  1257                                  			db	00Dh,0E0h,000h,	00Fh,000h,001h			;clusters 12-15 	00d 00e 00f 010
  1258                                  			db	011h,020h,001h,	013h,040h,001h			;clusters 16-19 	011 012 013 014
  1259                                  			db	015h,060h,001h,	017h,080h,001h			;clusters 20-23		015 016 017 018
  1260                                  			db	019h,0A0h,001h,	01Bh,0C0h,001h			;clusters 24-27		019 01a 01b 01c
  1261                                  			db	01Dh,0E0h,001h,	01Fh,000h,002h			;clusters 28-31		01d 01e 01f 020
  1262                                  			db	021h,020h,002h,	023h,040h,002h			;clusters 32-35		021 022 023 024
  1263                                  			db	025h,060h,002h,	027h,080h,002h			;clusters 36-39		025 026 027 028
  1264                                  			db	029h,0A0h,002h,	02Bh,0C0h,002h			;clusters 40-43		029 02A 02B 02C
  1265                                  			db	02Dh,0E0h,002h, 02Fh,000h,003h			;clusters 44-47		02D 02E 02F 030
  1266                                  			db	031h,020h,003h, 033h,040h,003h			;clusters 48-51		031 032 033 034
  1267                                  			db	035h,060h,003h, 037h,080h,003h			;clusters 52-55		035 036 037 038
  1268                                  			db	039h,0A0h,003h, 0FFh,00Fh,000h			;clusters 56-59		039 03A FFF 000
  1269                                  			times	(9*512)-($-$$) db 0				;zero fill to end of section
  1270                                  ;-----------------------------------------------------------------------------------------------------------------------
  1271                                  ;
  1272                                  ;	Diskette Directory							@disk: 002600	@mem: n/a
  1273                                  ;
  1274                                  ;	The disk contains one copy of the diskette directory. Each directory entry is 32 bytes long. Our directory
  1275                                  ;	contains only one entry. Unused entries are set to all nulls. The directory immediately follows the second FAT
  1276                                  ;	copy.
  1277                                  ;
  1278                                  ;-----------------------------------------------------------------------------------------------------------------------
  1279                                  section			dir							;diskette directory
  1280                                  			db	"OS      COM"					;file name (must contain spaces)
  1281                                  			db	020h						;attribute (archive bit set)
  1282                                  			times	10 db 0						;unused
  1283                                  			dw	0h						;time
  1284                                  			db	01000001b					;mmm = 10 MOD 8 = 2; ddddd = 1
  1285                                  			db	01001001b					;yyyyyyy = 2016-1980 = 36 = 24h; m/8 = 1
  1286                                  			dw	2						;first cluster
  1287                                  			dd	07200h						;file size
  1288                                  			times	(224*32)-($-$$) db 0h				;zero fill to end of section
  1289                                  %endif
  1290                                  %ifdef BUILDCOM
  1291                                  ;=======================================================================================================================
  1292                                  ;
  1293                                  ;	OS.COM
  1294                                  ;
  1295                                  ;	The operating system file is assembled at the start of the data area of the floppy disk image, which
  1296                                  ;	immediately follows the directory. This corresponds to logical cluster 2, even though the physical address of
  1297                                  ;	this sector on the disk varies depending on the disk type. The os.com file consists of two parts, the OS loader
  1298                                  ;	and the OS kernel. The Loader is 16-bit code that receives control directly from the boot sector code after the
  1299                                  ;	OS.COM file is loaded into memory. The kernel is 32-bit code that receives control after the Loader has
  1300                                  ;	initialized protected-mode tables and 32-bit interrupt handlers and switched the CPU into protected mode.
  1301                                  ;
  1302                                  ;	Our loader addressability is set up according to the following diagram.
  1303                                  ;
  1304                                  ;	SS -----------> 007b00	+-----------------------------------------------+ SS:0000
  1305                                  ;				|  Boot Stack & Boot PSP (Unused)		|
  1306                                  ;				|  256 = 100h bytes				|
  1307                                  ;	SS:SP -------->	007c00	+-----------------------------------------------+ SS:0100  07b0:0100
  1308                                  ;				|  Boot Sector (vstart=0100h)			|
  1309                                  ;				|  1 sector = 512 = 200h bytes			|
  1310                                  ;			007e00	+-----------------------------------------------+
  1311                                  ;				|  File Allocation Table (FAT) I/O Buffer	|
  1312                                  ;				|  9 x 512-byte sectors = 4,608 = 1200h bytes	|
  1313                                  ;				|						|
  1314                                  ;	CS,DS,ES ----->	008f00	|  Loader PSP (Unused)				| DS:0000
  1315                                  ;				|						|
  1316                                  ;	CS:IP -------->	009000	+-----------------------------------------------+ DS:0100  08f0:0100
  1317                                  ;				|  Loader Code					|
  1318                                  ;				|  1 sector = 512 = 200h bytes			|
  1319                                  ;			009200	+-----------------------------------------------+ DS:0300
  1320                                  ;
  1321                                  ;=======================================================================================================================
  1322                                  ;-----------------------------------------------------------------------------------------------------------------------
  1323                                  ;
  1324                                  ;	OS Loader								@disk: 004200	@mem: 009000
  1325                                  ;
  1326                                  ;	This code is the operating system loader. It resides on the boot disk at the start of the data area, following
  1327                                  ;	the directory. The loader occupies several clusters that are mapped in the file allocation tables above.
  1328                                  ;	The loader executes 16-bit instructions in real mode. It performs several initialization functions such as
  1329                                  ;	determining whether the CPU and other resources are sufficient to run the operating system. If all minimum
  1330                                  ;	resources are present, the loader initializes protected mode tables, places the CPU into protected mode and
  1331                                  ;	starts the console task. Since the loader was called either from the bootstrap or as a .com file on the boot
  1332                                  ;	disk, we can assume that the initial ip is 0x100 and not perform any absolute address fix-ups on our segment
  1333                                  ;	registers.
  1334                                  ;
  1335                                  ;-----------------------------------------------------------------------------------------------------------------------
  1336                                  			cpu	8086						;assume minimal CPU
  1337                                  section			loader	vstart=0100h					;use .COM compatible addressing
  1338                                  			bits	16						;this is 16-bit code
  1339                                  Loader			push	cs						;use the code segment
  1340                                  			pop	ds						;...as our data segment
  1341                                  			push	cs						;use the code segment
  1342                                  			pop	es						;...as our extra segment
  1343                                  ;
  1344                                  ;	Write a message to the console so we know we have our addressability established.
  1345                                  ;
  1346                                  			mov	si,czStartingMsg				;starting message
  1347                                  			call	PutTTYString					;display loader message
  1348                                  ;
  1349                                  ;	Determine the CPU type, generally. Exit if the CPU is not at least an 80386.
  1350                                  ;
  1351                                  			call	GetCPUType					;AL = cpu type
  1352                                  			mov	si,czCPUErrorMsg				;loader error message
  1353                                  			cmp	al,3						;80386+?
  1354                                  			jb	LoaderExit					;no, exit with error message
  1355                                  			cpu	386						;allow 80386 instructions
  1356                                  			mov	si,czCPUOKMsg					;cpu ok message
  1357                                  			call	PutTTYString					;display message
  1358                                  ;
  1359                                  ;	Initialize kernel data areas. The task queue is initialized here because as soon as we enter protected mode,
  1360                                  ;	the timer interrupt code will begin inspecting the task queue to determine if a task switch must be made. To
  1361                                  ;	start with, we set every 16th queue element to reference the background task selector. This will ensure that
  1362                                  ;	the background task, which updates the visible clock on the console, will be called at least once per second.
  1363                                  ;
  1364                                  			push	EKRNDATASEG					;load kernel data segment address ...
  1365                                  			pop	es						;... into extra segment reg
  1366                                  			mov	di,wwTaskQueue					;task queue address
  1367                                  			mov	cx,64						;outer loop
  1368                                  .10			push	cx						;save remaining outer iterations
  1369                                  			mov	cx,3						;inner loop
  1370                                  			mov	ax,ESELCONSOLETSS				;console task state segment selector
  1371                                  			cld							;forward strings
  1372                                  			rep	stosw						;store selectors in task queue
  1373                                  			mov	ax,ESELBACKGROUNDTSS				;background task state segment selector
  1374                                  			stosw							;store selector in task queue
  1375                                  			pop	cx						;restore remaining outer iterations
  1376                                  			loop	.10						;next
  1377                                  			xor	ax,ax						;zero register
  1378                                  			mov	cl,4						;remaining words to reset
  1379                                  			rep	stosw						;reset remaining kernel data
  1380                                  ;
  1381                                  ;	Fixup the GDT descriptor for the current (loader) code segment.
  1382                                  ;
  1383                                  			mov	si,0300h					;GDT offset
  1384                                  			mov	ax,cs						;AX:SI = gdt source
  1385                                  			rol	ax,4						;AX = phys addr bits 11-0,15-12
  1386                                  			mov	cl,al						;CL = phys addr bits 3-0,15-12
  1387                                  			and	al,0F0h						;AL = phys addr bits 11-0
  1388                                  			and	cl,00Fh						;CL = phys addr bits 15-12
  1389                                  			mov	word [si+030h+2],ax				;lo-order loader code (0-15)
  1390                                  			mov	byte [si+030h+4],cl				;lo-order loader code (16-23)
  1391                                  			mov	si,czGDTOKMsg					;GDT prepared message
  1392                                  			call	PutTTYString					;display message
  1393                                  ;
  1394                                  ;	Move the 32-bit kernel to its appropriate memory location.
  1395                                  ;
  1396                                  			push	EKRNCODESEG					;use kernel code segment ...
  1397                                  			pop	es						;... as target segment
  1398                                  			xor	di,di						;ES:DI = target address
  1399                                  			mov	si,0300h					;DS:SI = source address
  1400                                  			mov	cx,07000h					;CX = kernel size
  1401                                  			cld							;forward strings
  1402                                  			rep	movsb						;copy kernel image
  1403                                  			mov	si,czKernelLoadedMsg				;kernel moved message
  1404                                  			call	PutTTYString					;display message
  1405                                  ;
  1406                                  ;	Switch to protected mode.
  1407                                  ;
  1408                                  			xor	si,si						;ES:SI = gdt addr
  1409                                  			mov	ss,si						;protected mode ss
  1410                                  			mov	sp,EKRNCODEADR					;initial stack immediate before code
  1411                                  			mov	ah,EBIOSFNINITPROTMODE				;initialize protected mode fn.
  1412                                  			mov	bx,02028h					;BH,BL = IRQ int bases
  1413                                  			mov	dx,001Fh					;outer delay loop count
  1414                                  .20			mov	cx,0FFFFh					;inner delay loop count
  1415                                  			loop	$						;wait out pending interrupts
  1416                                  			dec	dx						;restore outer loop count
  1417                                  			jnz	.20						;continue outer loop
  1418                                  			int	EBIOSINTMISC					;call BIOS to set protected mode
  1419                                  ;
  1420                                  ;	Enable hardware and maskable interrupts
  1421                                  ;
  1422                                  			xor	al,al						;enable all registers code
  1423                                  			out	EPICPORTPRI1,al					;enable all primary 8259A ints
  1424                                  			out	EPICPORTSEC1,al					;enable all secondary 8259A ints
  1425                                  			sti							;enable maskable interrupts
  1426                                  ;
  1427                                  ;	Load the Task State Segment (TSS) and Local Descriptor Table (LDT) registers and jump to the initial task.
  1428                                  ;
  1429                                  			ltr	[cs:cwLoaderTSS]				;load task register
  1430                                  			lldt	[cs:cwLoaderLDT]				;load local descriptor table register
  1431                                  			jmp	ESELCONSOLETSS:0				;jump to task state segment selector
  1432                                  ;-----------------------------------------------------------------------------------------------------------------------
  1433                                  ;
  1434                                  ;	Routine:	LoaderExit
  1435                                  ;
  1436                                  ;	Description:	This routine displays the message at DS:SI, waits for a keypress and resets the system.
  1437                                  ;
  1438                                  ;	In:		DS:SI	string address
  1439                                  ;
  1440                                  ;-----------------------------------------------------------------------------------------------------------------------
  1441                                  LoaderExit		call	PutTTYString					;display error message
  1442                                  ;
  1443                                  ;	Now we want to wait for a keypress. We can use a keyboard interrupt function for this (INT 16h, AH=0).
  1444                                  ;	However, some hypervisor BIOS implementations have been seen to implement the "wait" as simply a fast
  1445                                  ;	iteration of the keyboard status function call (INT 16h, AH=1), causing a CPU race condition. So, instead
  1446                                  ;	we will use the keyboard status call and iterate over a halt (HLT) instruction until a key is pressed.
  1447                                  ;	By convention, we enable maskable interrupts with STI before issuing HLT, so as not to catch fire.
  1448                                  ;
  1449                                  .30			mov	ah,EBIOSFNKEYSTATUS				;keyboard status function
  1450                                  			int	EBIOSINTKEYBOARD				;call BIOS keyboard interrupt
  1451                                  			jnz	.40						;exit if key pressed
  1452                                  			sti							;enable maskable interrupts
  1453                                  			hlt							;wait for interrupt
  1454                                  			jmp	.30						;repeat until keypress
  1455                                  ;
  1456                                  ;	Now that a key has been pressed, we signal the system to restart by driving the B0 line on the 8042
  1457                                  ;	keyboard controller low (OUT 64h,0feh). The restart may take some microseconds to kick in, so we issue
  1458                                  ;	HLT until the system resets.
  1459                                  ;
  1460                                  .40			mov	al,EKEYBCMDRESET				;8042 pulse output port pin
  1461                                  			out	EKEYBPORTSTAT,al				;drive B0 low to restart
  1462                                  .50			sti							;enable maskable interrupts
  1463                                  			hlt							;stop until reset, int, nmi
  1464                                  			jmp	.50						;loop until restart kicks in
  1465                                  ;-----------------------------------------------------------------------------------------------------------------------
  1466                                  ;
  1467                                  ;	Routine:	GetCPUType
  1468                                  ;
  1469                                  ;	Description:	The loader needs only to determine that the cpu is at least an 80386 or an equivalent. Note that
  1470                                  ;			the CPUID instruction was not introduced until the SL-enhanced 80486 and Pentium processors, so
  1471                                  ;			to distinguish whether we have at least an 80386, other means must be used.
  1472                                  ;
  1473                                  ;	Out:		AX	0 = 808x, v20, etc.
  1474                                  ;				1 = 80186
  1475                                  ;				2 = 80286
  1476                                  ;				3 = 80386
  1477                                  ;
  1478                                  ;-----------------------------------------------------------------------------------------------------------------------
  1479                                  GetCPUType		mov	al,1						;AL = 1
  1480                                  			mov	cl,32						;shift count
  1481                                  			shr	al,cl						;try a 32-bit shift
  1482                                  			or	al,al						;did the shift happen?
  1483                                  			jz	.10						;yes, cpu is 808x, v20, etc.
  1484                                  			cpu	186
  1485                                  			push	sp						;save stack pointer
  1486                                  			pop	cx						;...into cx
  1487                                  			cmp	cx,sp						;did sp decrement before push?
  1488                                  			jne	.10						;yes, cpu is 80186
  1489                                  			cpu	286
  1490                                  			inc	ax						;AX = 2
  1491                                  			sgdt	[cbLoaderGDT]					;store gdt reg in work area
  1492                                  			mov	cl,[cbLoaderGDTHiByte]				;CL = hi-order byte
  1493                                  			inc	cl						;was hi-byte of GDTR 0xff?
  1494                                  			jz	.10						;yes, cpu is 80286
  1495                                  			inc	ax						;AX = 3
  1496                                  .10			ret							;return
  1497                                  ;-----------------------------------------------------------------------------------------------------------------------
  1498                                  ;
  1499                                  ;	Routine:	PutTTYString
  1500                                  ;
  1501                                  ;	Description:	This routine sends a NUL-terminated string of characters to the TTY output device. We use the
  1502                                  ;			TTY output function of the BIOS video interrupt, passing the address of the string in DS:SI
  1503                                  ;			and the BIOS teletype function code in AH. After a return from the BIOS interrupt, we repeat
  1504                                  ;			for the next string character until a NUL is found. Note that we clear the direction flag (DF)
  1505                                  ;			with CLD before each LODSB. This is just in case the direction flag is ever returned as set
  1506                                  ;			by the video interrupt. This is a precaution since a well-written BIOS should preserve all
  1507                                  ;			registers and flags unless used to indicate return status.
  1508                                  ;
  1509                                  ;	In:		DS:SI	address of string
  1510                                  ;
  1511                                  ;-----------------------------------------------------------------------------------------------------------------------
  1512                                  PutTTYString		cld							;forward strings
  1513                                  			lodsb							;load next byte at DS:SI in AL
  1514                                  			test	al,al						;end of string?
  1515                                  			jz	.10						;... yes, exit our loop
  1516                                  			mov	ah,EBIOSFNTTYOUTPUT				;BIOS teletype function
  1517                                  			int	EBIOSINTVIDEO					;call BIOS display interrupt
  1518                                  			jmp	PutTTYString					;repeat until done
  1519                                  .10			ret							;return
  1520                                  ;-----------------------------------------------------------------------------------------------------------------------
  1521                                  ;
  1522                                  ;	Loader Data
  1523                                  ;
  1524                                  ;	The loader data is updated to include constants defining the initial (Loader) TSS and LDT selectors in the
  1525                                  ;	GDT, a work area to build the GDTR, and additional text messages.
  1526                                  ;
  1527                                  ;-----------------------------------------------------------------------------------------------------------------------
  1528                                  			align	2
  1529                                  cwLoaderLDT		dw	ESELLOADERLDT					;loader local descriptor table selector
  1530                                  cwLoaderTSS		dw	ESELLOADERTSS					;loader task state segment selector
  1531                                  cbLoaderGDT		times	5 db 0						;6-byte GDTR work area
  1532                                  cbLoaderGDTHiByte	db	0						;hi-order byte
  1533                                  czCPUErrorMsg		db	"The operating system requires an i386 or later processor.",13,10
  1534                                  			db	"Please press any key to restart the computer.",13,10,0
  1535                                  czCPUOKMsg		db	"CPU OK",13,10,0
  1536                                  czGDTOKMsg		db	"GDT prepared",13,10,0
  1537                                  czKernelLoadedMsg	db	"Kernel loaded",13,10,0
  1538                                  czStartingMsg		db	"Starting OS",13,10,0				;starting message
  1539                                  			times	510-($-$$) db 0h				;zero fill to end of sector
  1540                                  			db	055h,0AAh					;end of sector signature
  1541                                  ;=======================================================================================================================
  1542                                  ;
  1543                                  ;	OS Kernel								@disk: 004400	@mem: 001000
  1544                                  ;
  1545                                  ;	This code is the operating system kernel. It resides on the boot disk image as part of the OS.COM file,
  1546                                  ;	following the 16-bit loader code above. The Kernel executes only 32-bit code in protected mode and contains one
  1547                                  ;	task, the Console, which performs a loop accepting user input from external devices (keyboard, etc.), processes
  1548                                  ;	commands and displays ouput to video memory. The Kernel also includes a library of system functions accessible
  1549                                  ;	through software interrupt 58 (30h). Finally, the Kernel provides CPU and hardware interrupt handlers.
  1550                                  ;
  1551                                  ;=======================================================================================================================
  1552                                  ;=======================================================================================================================
  1553                                  ;
  1554                                  ;	Kernel Tables
  1555                                  ;
  1556                                  ;=======================================================================================================================
  1557                                  ;-----------------------------------------------------------------------------------------------------------------------
  1558                                  ;
  1559                                  ;	Global Descriptor Table							@disk: 004400	@mem: 001000
  1560                                  ;
  1561                                  ;	The Global Descriptor Table (GDT) consists of eight-byte descriptors that define reserved memory areas. The
  1562                                  ;	first descriptor must be all nulls.
  1563                                  ;
  1564                                  ;	6   5         4         3         2         1         0
  1565                                  ;	3210987654321098765432109876543210987654321098765432109876543210
  1566                                  ;	----------------------------------------------------------------
  1567                                  ;	h......hffffmmmma......ab......................bn..............n
  1568                                  ;	00000000			all areas have base addresses below 2^24
  1569                                  ;	        0100     		(0x4) 32-bit single-byte granularity
  1570                                  ;		1100    		(0xC) 32-bit 4KB granularity
  1571                                  ;	            1001		present, ring-0, selector
  1572                                  ;
  1573                                  ;	h...h	hi-order base address (bits 24-31)
  1574                                  ;	ffff	flags
  1575                                  ;	mmmm	hi-order limit (bits 16-19)
  1576                                  ;	a...a	access
  1577                                  ;	b...b	lo-order base address (bits 0-23)
  1578                                  ;	n...n	lo-order limit (bits 0-15)
  1579                                  ;
  1580                                  ;-----------------------------------------------------------------------------------------------------------------------
  1581                                  section			gdt							;global descriptor table
  1582                                  			dq	0000000000000000h				;00 required null selector
  1583                                  			dq	00409300100007FFh				;08 2KB  writable data  (GDT alias)
  1584                                  			dq	00409300180007FFh				;10 2KB  writable data  (IDT alias)
  1585                                  			dq	00CF93000000FFFFh				;18 4GB  writable data  (kernel)     DS:
  1586                                  			dq	0040930B80000FFFh				;20 4KB  writable data  (CGA)        ES:
  1587                                  			dq	0040930000000FFFh				;28 4KB  writable stack (Loader)     SS:
  1588                                  			dq	00009B000000FFFFh				;30 64KB readable code  (loader)     CS:
  1589                                  			dq	00009BFF0000FFFFh				;38 64KB readable code  (BIOS)
  1590                                  			dq	004093000400FFFFh				;40 64KB writable data  (BIOS)
  1591                                  			dq	00409B0020001FFFh				;48 8KB  readable code  (kernel)
  1592                                  			dq	004082000F00007Fh				;50 80B  writable LDT   (loader)
  1593                                  			dq	004089000F80007Fh				;58 80B  writable TSS   (loader)
  1594                                  			dq	004082004700007Fh				;60 80B  writable LDT   (console)
  1595                                  			dq	004089004780007Fh				;88 80B  writable TSS   (console)
  1596                                  			dq	004082006700007Fh				;70 80B  writable LDT   (background)
  1597                                  			dq	004089006780007Fh				;78 80B  writable TSS   (background)
  1598                                  			dq	00409300480007FFh				;80 2KB  foreground task message queue
  1599                                  			times	2048-($-$$) db 0h				;zero fill to end of section
  1600                                  ;-----------------------------------------------------------------------------------------------------------------------
  1601                                  ;
  1602                                  ;	Interrupt Descriptor Table						@disk: 004c00	@mem: 001800
  1603                                  ;
  1604                                  ;	The Interrupt Descriptor Table (IDT) consists of one eight-byte entry (descriptor) for each interrupt. The
  1605                                  ;	descriptors here are of two kinds, interrupt gates and trap gates. The "mint" and "mtrap" macros define the
  1606                                  ;	descriptors, taking only the name of the entry point for the code handling the interrupt.
  1607                                  ;
  1608                                  ;	6   5         4         3         2         1         0
  1609                                  ;	3210987654321098765432109876543210987654321098765432109876543210
  1610                                  ;	----------------------------------------------------------------
  1611                                  ;	h..............hPzzStttt00000000S..............Sl..............l
  1612                                  ;
  1613                                  ;	h...h	high-order offset (bits 16-31)
  1614                                  ;	P	present (0=unused interrupt)
  1615                                  ;	zz	descriptor privilege level
  1616                                  ;	S	storage segment (must be zero for IDT)
  1617                                  ;	tttt	type: 0101=task, 1110=int, 1111=trap
  1618                                  ;	S...S	handling code selector in GDT
  1619                                  ;	l...l	lo-order offset (bits 0-15)
  1620                                  ;
  1621                                  ;-----------------------------------------------------------------------------------------------------------------------
  1622                                  section			idt							;interrupt descriptor table
  1623                                  			mint	dividebyzero					;00 divide by zero
  1624                                  			mint	singlestep					;01 single step
  1625                                  			mint	nmi						;02 non-maskable
  1626                                  			mint	break						;03 break
  1627                                  			mint	into						;04 into
  1628                                  			mint	bounds						;05 bounds
  1629                                  			mint	badopcode					;06 bad op code
  1630                                  			mint	nocoproc					;07 no coprocessor
  1631                                  			mint	doublefault					;08 double-fault
  1632                                  			mint	operand						;09 operand
  1633                                  			mint	badtss						;0a bad TSS
  1634                                  			mint	notpresent					;0b not-present
  1635                                  			mint	stacklimit					;0c stack limit
  1636                                  			mint	protection					;0d general protection fault
  1637                                  			mint	int14						;0e (reserved)
  1638                                  			mint	int15						;0f (reserved)
  1639                                  			mint	coproccalc					;10 (reserved)
  1640                                  			mint	int17						;11 (reserved)
  1641                                  			mint	int18						;12 (reserved)
  1642                                  			mint	int19						;13 (reserved)
  1643                                  			mint	int20						;14 (reserved)
  1644                                  			mint	int21						;15 (reserved)
  1645                                  			mint	int22						;16 (reserved)
  1646                                  			mint	int23						;17 (reserved)
  1647                                  			mint	int24						;18 (reserved)
  1648                                  			mint	int25						;19 (reserved)
  1649                                  			mint	int26						;1a (reserved)
  1650                                  			mint	int27						;1b (reserved)
  1651                                  			mint	int28						;1c (reserved)
  1652                                  			mint	int29						;1d (reserved)
  1653                                  			mint	int30						;1e (reserved)
  1654                                  			mint	int31						;1f (reserved)
  1655                                  			mtrap	clocktick					;20 IRQ0 clock tick
  1656                                  			mtrap	keyboard					;21 IRQ1 keyboard
  1657                                  			mtrap	iochannel					;22 IRQ2 second 8259A cascade
  1658                                  			mtrap	com2						;23 IRQ3 com2
  1659                                  			mtrap	com1						;24 IRQ4 com1
  1660                                  			mtrap	lpt2						;25 IRQ5 lpt2
  1661                                  			mtrap	diskette					;26 IRQ6 diskette
  1662                                  			mtrap	lpt1						;27 IRQ7 lpt1
  1663                                  			mtrap	rtclock						;28 IRQ8 real-time clock
  1664                                  			mtrap	retrace						;29 IRQ9 CGA vertical retrace
  1665                                  			mtrap	irq10						;2a IRQA (reserved)
  1666                                  			mtrap	irq11						;2b IRQB (reserved)
  1667                                  			mtrap	ps2mouse					;2c IRQC ps/2 mouse
  1668                                  			mtrap	coprocessor					;2d IRQD coprocessor
  1669                                  			mtrap	fixeddisk					;2e IRQE fixed disk
  1670                                  			mtrap	irq15						;2f IRQF (reserved)
  1671                                  			mtrap	svc						;30 OS services
  1672                                  			times	2048-($-$$) db 0h				;zero fill to end of section
  1673                                  ;=======================================================================================================================
  1674                                  ;
  1675                                  ;	Interrupt Handlers							@disk: 005400	@mem:  002000
  1676                                  ;
  1677                                  ;	Interrupt handlers are 32-bit routines that receive control either in response to events or by direct
  1678                                  ;	invocation from other kernel code. The interrupt handlers are of three basic types. CPU interrupts occur when a
  1679                                  ;	CPU exception is detected. Hardware interrupts occur when an external device (timer, keyboard, disk, etc.)
  1680                                  ;	signals the CPU on an interrupt request line (IRQ). Software interrupts occur when directly called by other code
  1681                                  ;	using the INT instruction. Each interrupt handler routine is defined by using our "menter" macro, which simply
  1682                                  ;	establishes a label defining the offset address of the entry point from the start of the kernel section. This
  1683                                  ;	label is referenced in the "mint" and "mtrap" macros found in the IDT to specify the address of the handlers.
  1684                                  ;
  1685                                  ;=======================================================================================================================
  1686                                  section			kernel	vstart=0h					;data offsets relative to 0
  1687                                  			cpu	386						;allow 80386 instructions
  1688                                  			bits	32						;this is 32-bit code
  1689                                  ;=======================================================================================================================
  1690                                  ;
  1691                                  ;	CPU Interrupt Handlers
  1692                                  ;
  1693                                  ;	The first 32 entries in the Interrupt Descriptor Table are reserved for use by CPU interrupts. The handling
  1694                                  ;	of these interrupts is expanded here to display the contents of registers at the time of the interrupt.
  1695                                  ;
  1696                                  ;=======================================================================================================================
  1697                                  ;-----------------------------------------------------------------------------------------------------------------------
  1698                                  ;
  1699                                  ;	INT0	Divide By Zero
  1700                                  ;
  1701                                  ;-----------------------------------------------------------------------------------------------------------------------
  1702                                  			menter	dividebyzero					;divide by zero
  1703                                  			push	0						;store interrupt nbr
  1704                                  			push	czIntDivideByZero				;store message offset
  1705                                  			jmp	ReportInterrupt					;report interrupt
  1706                                  ;-----------------------------------------------------------------------------------------------------------------------
  1707                                  ;
  1708                                  ;	INT1	Single Step
  1709                                  ;
  1710                                  ;-----------------------------------------------------------------------------------------------------------------------
  1711                                  			menter	singlestep					;single step
  1712                                  			push	1						;store interrupt nbr
  1713                                  			push	czIntSingleStep					;store message offset
  1714                                  			jmp	ReportInterrupt					;report interrupt
  1715                                  ;-----------------------------------------------------------------------------------------------------------------------
  1716                                  ;
  1717                                  ;	INT2	Non-Maskable Interrupt
  1718                                  ;
  1719                                  ;-----------------------------------------------------------------------------------------------------------------------
  1720                                  			menter	nmi						;non-maskable
  1721                                  			push	2						;store interrupt nbr
  1722                                  			push	czIntNonMaskable				;store message offset
  1723                                  			jmp	ReportInterrupt					;report interrupt
  1724                                  ;-----------------------------------------------------------------------------------------------------------------------
  1725                                  ;
  1726                                  ;	INT3	Break
  1727                                  ;
  1728                                  ;-----------------------------------------------------------------------------------------------------------------------
  1729                                  			menter	break						;break
  1730                                  			push	3						;store interrupt nbr
  1731                                  			push	czIntBreak					;store message offset
  1732                                  			jmp	ReportInterrupt					;report interrupt
  1733                                  ;-----------------------------------------------------------------------------------------------------------------------
  1734                                  ;
  1735                                  ;	INT4	Into
  1736                                  ;
  1737                                  ;-----------------------------------------------------------------------------------------------------------------------
  1738                                  			menter	into						;into
  1739                                  			push	4						;store interrupt nbr
  1740                                  			push	czIntInto					;store message offset
  1741                                  			jmp	ReportInterrupt					;report interrupt
  1742                                  ;-----------------------------------------------------------------------------------------------------------------------
  1743                                  ;
  1744                                  ;	INT5	Bounds
  1745                                  ;
  1746                                  ;-----------------------------------------------------------------------------------------------------------------------
  1747                                  			menter	bounds						;bounds
  1748                                  			push	5						;store interrupt nbr
  1749                                  			push	czIntBounds					;store message offset
  1750                                  			jmp	ReportInterrupt					;report interrupt
  1751                                  ;-----------------------------------------------------------------------------------------------------------------------
  1752                                  ;
  1753                                  ;	INT6	Bad Operation Code
  1754                                  ;
  1755                                  ;-----------------------------------------------------------------------------------------------------------------------
  1756                                  			menter	badopcode					;bad opcode interrupt
  1757                                  			push	6						;store interrupt nbr
  1758                                  			push	czIntBadOpCode					;store message offset
  1759                                  			jmp	ReportInterrupt					;report interrupt
  1760                                  ;-----------------------------------------------------------------------------------------------------------------------
  1761                                  ;
  1762                                  ;	INT7	No Coprocessor
  1763                                  ;
  1764                                  ;-----------------------------------------------------------------------------------------------------------------------
  1765                                  			menter	nocoproc					;no coprocessor interrupt
  1766                                  			push	7						;store interrupt nbr
  1767                                  			push	czIntNoCoprocessor				;store message offset
  1768                                  			jmp	ReportInterrupt					;report interrupt
  1769                                  ;-----------------------------------------------------------------------------------------------------------------------
  1770                                  ;
  1771                                  ;	INT8	Double Fault
  1772                                  ;
  1773                                  ;-----------------------------------------------------------------------------------------------------------------------
  1774                                  			menter	doublefault					;doublefault interrupt
  1775                                  			push	8						;store interrupt nbr
  1776                                  			push	czIntDoubleFault				;store message offset
  1777                                  			jmp	ReportInterrupt					;report interrupt
  1778                                  ;-----------------------------------------------------------------------------------------------------------------------
  1779                                  ;
  1780                                  ;	INT9	Operand
  1781                                  ;
  1782                                  ;-----------------------------------------------------------------------------------------------------------------------
  1783                                  			menter	operand						;operand interrupt
  1784                                  			push	9						;store interrupt nbr
  1785                                  			push	czIntOperand					;store message offset
  1786                                  			jmp	ReportInterrupt					;report interrupt
  1787                                  ;-----------------------------------------------------------------------------------------------------------------------
  1788                                  ;
  1789                                  ;	INT10	Bad Task State Segment
  1790                                  ;
  1791                                  ;-----------------------------------------------------------------------------------------------------------------------
  1792                                  			menter	badtss						;bad tss interrupt
  1793                                  			push	10						;store interrupt nbr
  1794                                  			push	czIntBadTSS					;store message offset
  1795                                  			jmp	ReportInterrupt					;report interrupt
  1796                                  ;-----------------------------------------------------------------------------------------------------------------------
  1797                                  ;
  1798                                  ;	INT11	Not Present
  1799                                  ;
  1800                                  ;-----------------------------------------------------------------------------------------------------------------------
  1801                                  			menter	notpresent					;not present interrupt
  1802                                  			push	11						;store interrupt nbr
  1803                                  			push	czIntNotPresent					;store message offset
  1804                                  			jmp	ReportInterrupt					;report interrupt
  1805                                  ;-----------------------------------------------------------------------------------------------------------------------
  1806                                  ;
  1807                                  ;	INT12	Stack Limit
  1808                                  ;
  1809                                  ;-----------------------------------------------------------------------------------------------------------------------
  1810                                  			menter	stacklimit					;stack limit interrupt
  1811                                  			push	12						;store interrupt nbr
  1812                                  			push	czIntStackLimit					;store message offset
  1813                                  			jmp	ReportInterrupt					;report interrupt
  1814                                  ;-----------------------------------------------------------------------------------------------------------------------
  1815                                  ;
  1816                                  ;	INT13	General Protection Fault
  1817                                  ;
  1818                                  ;-----------------------------------------------------------------------------------------------------------------------
  1819                                  			menter	protection					;protection fault interrupt
  1820                                  			push	13						;store interrupt nbr
  1821                                  			push	czIntProtection					;store message offset
  1822                                  			jmp	ReportInterrupt					;report interrupt
  1823                                  ;-----------------------------------------------------------------------------------------------------------------------
  1824                                  ;
  1825                                  ;	INT14	Reserved
  1826                                  ;
  1827                                  ;-----------------------------------------------------------------------------------------------------------------------
  1828                                  			menter	int14						;(reserved)
  1829                                  			push	14						;store interrupt nbr
  1830                                  			push	czIntReserved					;store message offset
  1831                                  			jmp	ReportInterrupt					;report interrupt
  1832                                  ;-----------------------------------------------------------------------------------------------------------------------
  1833                                  ;
  1834                                  ;	INT15	Reserved
  1835                                  ;
  1836                                  ;-----------------------------------------------------------------------------------------------------------------------
  1837                                  			menter	int15						;(reserved)
  1838                                  			push	15						;store interrupt nbr
  1839                                  			push	czIntReserved					;store message offset
  1840                                  			jmp	ReportInterrupt					;report interrupt
  1841                                  ;-----------------------------------------------------------------------------------------------------------------------
  1842                                  ;
  1843                                  ;	INT16	Coprocessor Calculation
  1844                                  ;
  1845                                  ;-----------------------------------------------------------------------------------------------------------------------
  1846                                  			menter	coproccalc					;coprocessor calculation
  1847                                  			push	16						;store interrupt nbr
  1848                                  			push	czIntCoprocessorCalc				;store message offset
  1849                                  			jmp	ReportInterrupt					;report interrupt
  1850                                  ;-----------------------------------------------------------------------------------------------------------------------
  1851                                  ;
  1852                                  ;	INT17	Reserved
  1853                                  ;
  1854                                  ;-----------------------------------------------------------------------------------------------------------------------
  1855                                  			menter	int17						;(reserved)
  1856                                  			push	17						;store interrupt nbr
  1857                                  			push	czIntReserved					;store message offset
  1858                                  			jmp	ReportInterrupt					;report interrupt
  1859                                  ;-----------------------------------------------------------------------------------------------------------------------
  1860                                  ;
  1861                                  ;	INT18	Reserved
  1862                                  ;
  1863                                  ;-----------------------------------------------------------------------------------------------------------------------
  1864                                  			menter	int18						;(reserved)
  1865                                  			push	18						;store interrupt nbr
  1866                                  			push	czIntReserved					;store message offset
  1867                                  			jmp	ReportInterrupt					;report interrupt
  1868                                  ;-----------------------------------------------------------------------------------------------------------------------
  1869                                  ;
  1870                                  ;	INT19	Reserved
  1871                                  ;
  1872                                  ;-----------------------------------------------------------------------------------------------------------------------
  1873                                  			menter	int19						;(reserved)
  1874                                  			push	19						;store interrupt nbr
  1875                                  			push	czIntReserved					;store message offset
  1876                                  			jmp	ReportInterrupt					;report interrupt
  1877                                  ;-----------------------------------------------------------------------------------------------------------------------
  1878                                  ;
  1879                                  ;	INT20	Reserved
  1880                                  ;
  1881                                  ;-----------------------------------------------------------------------------------------------------------------------
  1882                                  			menter	int20						;(reserved)
  1883                                  			push	20						;store interrupt nbr
  1884                                  			push	czIntReserved					;store message offset
  1885                                  			jmp	ReportInterrupt					;report interrupt
  1886                                  ;-----------------------------------------------------------------------------------------------------------------------
  1887                                  ;
  1888                                  ;	INT21	Reserved
  1889                                  ;
  1890                                  ;-----------------------------------------------------------------------------------------------------------------------
  1891                                  			menter	int21						;(reserved)
  1892                                  			push	21						;store interrupt nbr
  1893                                  			push	czIntReserved					;store message offset
  1894                                  			jmp	ReportInterrupt					;report interrupt
  1895                                  ;-----------------------------------------------------------------------------------------------------------------------
  1896                                  ;
  1897                                  ;	INT22	Reserved
  1898                                  ;
  1899                                  ;-----------------------------------------------------------------------------------------------------------------------
  1900                                  			menter	int22						;(reserved)
  1901                                  			push	22						;store interrupt nbr
  1902                                  			push	czIntReserved					;store message offset
  1903                                  			jmp	ReportInterrupt					;report interrupt
  1904                                  ;-----------------------------------------------------------------------------------------------------------------------
  1905                                  ;
  1906                                  ;	INT23	Reserved
  1907                                  ;
  1908                                  ;-----------------------------------------------------------------------------------------------------------------------
  1909                                  			menter	int23						;(reserved)
  1910                                  			push	23						;store interrupt nbr
  1911                                  			push	czIntReserved					;store message offset
  1912                                  			jmp	ReportInterrupt					;report interrupt
  1913                                  ;-----------------------------------------------------------------------------------------------------------------------
  1914                                  ;
  1915                                  ;	INT24	Reserved
  1916                                  ;
  1917                                  ;-----------------------------------------------------------------------------------------------------------------------
  1918                                  			menter	int24						;(reserved)
  1919                                  			push	24						;store interrupt nbr
  1920                                  			push	czIntReserved					;store message offset
  1921                                  			jmp	ReportInterrupt					;report interrupt
  1922                                  ;-----------------------------------------------------------------------------------------------------------------------
  1923                                  ;
  1924                                  ;	INT25	Reserved
  1925                                  ;
  1926                                  ;-----------------------------------------------------------------------------------------------------------------------
  1927                                  			menter	int25						;(reserved)
  1928                                  			push	25						;store interrupt nbr
  1929                                  			push	czIntReserved					;store message offset
  1930                                  			jmp	ReportInterrupt					;report interrupt
  1931                                  ;-----------------------------------------------------------------------------------------------------------------------
  1932                                  ;
  1933                                  ;	INT26	Reserved
  1934                                  ;
  1935                                  ;-----------------------------------------------------------------------------------------------------------------------
  1936                                  			menter	int26						;(reserved)
  1937                                  			push	26						;store interrupt nbr
  1938                                  			push	czIntReserved					;store message offset
  1939                                  			jmp	ReportInterrupt					;report interrupt
  1940                                  ;-----------------------------------------------------------------------------------------------------------------------
  1941                                  ;
  1942                                  ;	INT27	Reserved
  1943                                  ;
  1944                                  ;-----------------------------------------------------------------------------------------------------------------------
  1945                                  			menter	int27						;(reserved)
  1946                                  			push	27						;store interrupt nbr
  1947                                  			push	czIntReserved					;store message offset
  1948                                  			jmp	ReportInterrupt					;report interrupt
  1949                                  ;-----------------------------------------------------------------------------------------------------------------------
  1950                                  ;
  1951                                  ;	INT28	Reserved
  1952                                  ;
  1953                                  ;-----------------------------------------------------------------------------------------------------------------------
  1954                                  			menter	int28						;(reserved)
  1955                                  			push	28						;store interrupt nbr
  1956                                  			push	czIntReserved					;store message offset
  1957                                  			jmp	ReportInterrupt					;report interrupt
  1958                                  ;-----------------------------------------------------------------------------------------------------------------------
  1959                                  ;
  1960                                  ;	INT29	Reserved
  1961                                  ;
  1962                                  ;-----------------------------------------------------------------------------------------------------------------------
  1963                                  			menter	int29						;(reserved)
  1964                                  			push	29						;store interrupt nbr
  1965                                  			push	czIntReserved					;store message offset
  1966                                  			jmp	ReportInterrupt					;report interrupt
  1967                                  ;-----------------------------------------------------------------------------------------------------------------------
  1968                                  ;
  1969                                  ;	INT30	Reserved
  1970                                  ;
  1971                                  ;-----------------------------------------------------------------------------------------------------------------------
  1972                                  			menter	int30						;(reserved)
  1973                                  			push	30						;store interrupt nbr
  1974                                  			push	czIntReserved					;store message offset
  1975                                  			jmp	ReportInterrupt					;report interrupt
  1976                                  ;-----------------------------------------------------------------------------------------------------------------------
  1977                                  ;
  1978                                  ;	INT31	Reserved
  1979                                  ;
  1980                                  ;-----------------------------------------------------------------------------------------------------------------------
  1981                                  			menter	int31						;(reserved)
  1982                                  			push	31						;store interrupt nbr
  1983                                  			push	czIntReserved					;store message offset
  1984                                  			jmp	ReportInterrupt					;report interrupt
  1985                                  ;-----------------------------------------------------------------------------------------------------------------------
  1986                                  ;
  1987                                  ;	Routine:	ReportInterrupt
  1988                                  ;
  1989                                  ;	Description:	This routine will be used to respond to processor interrupts that are not otherwise handled.
  1990                                  ;			At this stage, we simply restore the stack and return from the interrupt.
  1991                                  ;
  1992                                  ;	In:		[esp+16]	eflags					stored by interrupt call
  1993                                  ;			[esp+12]	cs					stored by interrupt call
  1994                                  ;			[esp+8]		eip					stored by interrupt call
  1995                                  ;			[esp+4]		interrupt number (0-31)			stored by push instruction
  1996                                  ;			[esp+0]		error message address			stored by push instructions
  1997                                  ;
  1998                                  ;	Out:		N/A		This routine does not exit.
  1999                                  ;
  2000                                  ;-----------------------------------------------------------------------------------------------------------------------
  2001                                  ReportInterrupt		push	ds						;save DS at time of interrupt
  2002                                  			push	es						;save ES at time of interrupt
  2003                                  			pushad							;save EAX,ECX,EDX,EBX,EBP,ESP,ESI,EDI
  2004                                  			mov	ebp,esp						;ebp --> [EDI]
  2005                                  ;
  2006                                  ;	Addressability to registers at the time of the interrupt is now established as:
  2007                                  ;
  2008                                  ;			[ebp+56]	eflags
  2009                                  ;			[ebp+52]	cs
  2010                                  ;			[ebp+48]	eip
  2011                                  ;			[ebp+44]	interrupt number (0-31)
  2012                                  ;			[ebp+40]	error message address
  2013                                  ;			[ebp+36]	ds
  2014                                  ;			[ebp+32]	es
  2015                                  ;			[ebp+28]	eax
  2016                                  ;			[ebp+24]	ecx
  2017                                  ;			[ebp+20]	edx
  2018                                  ;			[ebp+16]	ebx
  2019                                  ;			[ebp+12]	esp
  2020                                  ;			[ebp+8]		ebp
  2021                                  ;			[ebp+4]		esi
  2022                                  ;			[ebp+0]		edi
  2023                                  ;
  2024                                  			push	cs						;load code selector ...
  2025                                  			pop	ds						;... into DS
  2026                                  			push	ESELCGA						;load CGA memory selector ...
  2027                                  			pop	es						;... into ES
  2028                                  ;
  2029                                  ;	Display the interrupt report boundary box
  2030                                  ;
  2031                                  			mov	cl,13						;column
  2032                                  			mov	ch,6						;row
  2033                                  			mov	dl,50						;width
  2034                                  			mov	dh,8						;height
  2035                                  			mov	bh,07h						;attribute
  2036                                  			call	DrawTextDialogBox				;draw text dialog box
  2037                                  ;
  2038                                  ;	Display the report header
  2039                                  ;
  2040                                  			mov	cl,15						;column
  2041                                  			mov	ch,7						;row
  2042                                  			mov	esi,czIntHeader					;interrupt message header
  2043                                  			call	SetConsoleString				;draw text string
  2044                                  ;
  2045                                  ;	Display the interrupt description label
  2046                                  ;
  2047                                  			mov	cl,15						;column
  2048                                  			mov	ch,8						;row
  2049                                  			mov	esi,czIntLabel					;interrupt message description lead
  2050                                  			call	SetConsoleString				;draw text string
  2051                                  ;
  2052                                  ;	Display the interrupt number
  2053                                  ;
  2054                                  			mov	eax,[ebp+44]					;interrupt number
  2055                                  			mov	cl,26						;column
  2056                                  			mov	ch,8						;row
  2057                                  			call	PutConsoleHexByte				;draw ASCII hex byte
  2058                                  ;
  2059                                  ;	Display the interrupt name
  2060                                  ;
  2061                                  			mov	cl,29						;column
  2062                                  			mov	ch,8						;row
  2063                                  			mov	esi,[ebp+40]					;interrupt-specific message
  2064                                  			call	SetConsoleString				;display interrupt description
  2065                                  ;
  2066                                  ;	Display the register values header
  2067                                  ;
  2068                                  			mov	cl,15						;column
  2069                                  			mov	ch,10						;row
  2070                                  			mov	esi,czIntRegsHeader				;interrupt registers header
  2071                                  			call	SetConsoleString				;draw text string
  2072                                  ;
  2073                                  ;	Display the EAX register label and value
  2074                                  ;
  2075                                  			mov	cl,15						;column
  2076                                  			mov	ch,11						;row
  2077                                  			mov	esi,czIntEAX					;register EAX label
  2078                                  			call	SetConsoleString				;draw label
  2079                                  			mov	eax,[ebp+28]					;EAX value at interrupt
  2080                                  			mov	cl,19						;column
  2081                                  			mov	ch,11						;row
  2082                                  			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2083                                  ;
  2084                                  ;	Display the ECX register label and value
  2085                                  ;
  2086                                  			mov	cl,15						;column
  2087                                  			mov	ch,12						;row
  2088                                  			mov	esi,czIntECX					;label
  2089                                  			call	SetConsoleString				;draw label
  2090                                  			mov	eax,[ebp+24]					;ECX value at interrupt
  2091                                  			mov	cl,19						;column
  2092                                  			mov	ch,12						;row
  2093                                  			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2094                                  ;
  2095                                  ;	Display the EDX register label and value
  2096                                  ;
  2097                                  			mov	cl,15						;column
  2098                                  			mov	ch,13						;row
  2099                                  			mov	esi,czIntEDX					;label
  2100                                  			call	SetConsoleString				;draw label
  2101                                  			mov	eax,[ebp+20]					;EDX value at interrupt
  2102                                  			mov	cl,19						;column
  2103                                  			mov	ch,13						;row
  2104                                  			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2105                                  ;
  2106                                  ;	Display the EBX register label and value
  2107                                  ;
  2108                                  			mov	cl,15						;column
  2109                                  			mov	ch,14						;row
  2110                                  			mov	esi,czIntEBX					;label
  2111                                  			call	SetConsoleString				;draw label
  2112                                  			mov	eax,[ebp+16]					;EBX value at interrupt
  2113                                  			mov	cl,19						;column
  2114                                  			mov	ch,14						;row
  2115                                  			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2116                                  ;
  2117                                  ;	Display the ESI register label and value
  2118                                  ;
  2119                                  			mov	cl,29						;column
  2120                                  			mov	ch,11						;row
  2121                                  			mov	esi,czIntESI					;label
  2122                                  			call	SetConsoleString				;draw label
  2123                                  			mov	eax,[ebp+4]					;ESI
  2124                                  			mov	cl,33						;column
  2125                                  			mov	ch,11						;row
  2126                                  			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2127                                  ;
  2128                                  ;	Display the EDI register label and value
  2129                                  ;
  2130                                  			mov	cl,29						;column
  2131                                  			mov	ch,12						;row
  2132                                  			mov	esi,czIntEDI					;label
  2133                                  			call	SetConsoleString				;draw label
  2134                                  			mov	eax,[ebp+0]					;EDI
  2135                                  			mov	cl,33						;column
  2136                                  			mov	ch,12						;row
  2137                                  			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2138                                  ;
  2139                                  ;	Display the EBP register label and value
  2140                                  ;
  2141                                  			mov	cl,29						;column
  2142                                  			mov	ch,13						;row
  2143                                  			mov	esi,czIntEBP					;label
  2144                                  			call	SetConsoleString				;draw label
  2145                                  			mov	eax,[ebp+8]					;EBP
  2146                                  			mov	cl,33						;column
  2147                                  			mov	ch,13						;row
  2148                                  			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2149                                  ;
  2150                                  ;	Display the DS register label and value
  2151                                  ;
  2152                                  			mov	cl,42						;column
  2153                                  			mov	ch,11						;row
  2154                                  			mov	esi,czIntDS					;label
  2155                                  			call	SetConsoleString				;draw label
  2156                                  			xor	eax,eax						;zero register
  2157                                  			mov	ax,[ebp+36]					;DS
  2158                                  			mov	cl,46						;column
  2159                                  			mov	ch,11						;row
  2160                                  			call	PutConsoleHexWord				;draw ASCII hex word
  2161                                  ;
  2162                                  ;	Display the ES register label and value
  2163                                  ;
  2164                                  			mov	cl,42						;column
  2165                                  			mov	ch,12						;row
  2166                                  			mov	esi,czIntES					;label
  2167                                  			call	SetConsoleString				;draw label
  2168                                  			xor	eax,eax						;zero register
  2169                                  			mov	ax,[ebp+32]					;ES
  2170                                  			mov	cl,46						;column
  2171                                  			mov	ch,12						;row
  2172                                  			call	PutConsoleHexWord				;draw ASCII hex word
  2173                                  ;
  2174                                  ;	Display the SS register label and value
  2175                                  ;
  2176                                  			mov	cl,42						;column
  2177                                  			mov	ch,13						;row
  2178                                  			mov	esi,czIntSS					;label
  2179                                  			call	SetConsoleString				;draw label
  2180                                  			xor	eax,eax						;zero register
  2181                                  			mov	ax,ss						;SS
  2182                                  			mov	cl,46						;column
  2183                                  			mov	ch,13						;row
  2184                                  			call	PutConsoleHexWord				;draw ASCII hex word
  2185                                  ;
  2186                                  ;	Display the CS register lable and value
  2187                                  ;
  2188                                  			mov	cl,42						;column
  2189                                  			mov	ch,14						;row
  2190                                  			mov	esi,czIntCS					;label
  2191                                  			call	SetConsoleString				;draw label
  2192                                  			xor	eax,eax						;zero register
  2193                                  			mov	ax,[ebp+52]					;CS
  2194                                  			mov	cl,46						;column
  2195                                  			mov	ch,14						;row
  2196                                  			call	PutConsoleHexWord				;draw ASCII hex word
  2197                                  ;
  2198                                  ;	Display the EFLAGS register label and value
  2199                                  ;
  2200                                  			mov	cl,51						;column
  2201                                  			mov	ch,11						;row
  2202                                  			mov	esi,czIntEFLAGS					;label
  2203                                  			call	SetConsoleString				;draw label
  2204                                  			mov	eax,[ebp+56]					;EFLAGS
  2205                                  			mov	cl,55						;column
  2206                                  			mov	ch,11						;row
  2207                                  			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2208                                  ;
  2209                                  ;	Display the ESP register label and value
  2210                                  ;
  2211                                  			mov	cl,51						;column
  2212                                  			mov	ch,13						;row
  2213                                  			mov	esi,czIntESP					;label
  2214                                  			call	SetConsoleString				;draw label
  2215                                  			mov	eax,[ebp+12]					;ESP
  2216                                  			mov	cl,55						;column
  2217                                  			mov	ch,13						;row
  2218                                  			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2219                                  ;
  2220                                  ;	Display the EIP register label and value
  2221                                  ;
  2222                                  			mov	cl,51						;column
  2223                                  			mov	ch,14						;row
  2224                                  			mov	esi,czIntEIP					;label
  2225                                  			call	SetConsoleString				;draw label
  2226                                  			mov	eax,[ebp+48]					;EIP
  2227                                  			mov	cl,55						;column
  2228                                  			mov	ch,14						;row
  2229                                  			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2230                                  ;
  2231                                  ;	Halt and loop until reset
  2232                                  ;
  2233                                  .10			sti							;enable maskable interrupts
  2234                                  			hlt							;halt processor
  2235                                  			jmp	.10						;resume on interrupt
  2236                                  ;-----------------------------------------------------------------------------------------------------------------------
  2237                                  ;
  2238                                  ;	Processor Interrupt Name Strings
  2239                                  ;
  2240                                  ;-----------------------------------------------------------------------------------------------------------------------
  2241                                  czIntDivideByZero	db	"Division by zero",0
  2242                                  czIntSingleStep		db	"Single step",0
  2243                                  czIntNonMaskable	db	"Non-maskable interrupt",0
  2244                                  czIntBreak		db	"Break",0
  2245                                  czIntInto		db	"Into",0
  2246                                  czIntBounds		db	"Bounds",0
  2247                                  czIntBadOpCode		db	"Bad Operation Code",0
  2248                                  czIntNoCoprocessor	db	"No Coprocessor",0
  2249                                  czIntDoubleFault	db	"Double Fault",0
  2250                                  czIntOperand		db	"Operand",0
  2251                                  czIntBadTSS		db	"Bad Task State Segment",0
  2252                                  czIntNotPresent		db	"Not Present",0
  2253                                  czIntStackLimit		db	"Stack Limit",0
  2254                                  czIntProtection		db	"General Protection Fault",0
  2255                                  czIntCoprocessorCalc	db	"Coprocessor Calculation",0
  2256                                  czIntReserved		db	"Reserved",0
  2257                                  ;-----------------------------------------------------------------------------------------------------------------------
  2258                                  ;
  2259                                  ;	Processor Interrupt Handling Strings
  2260                                  ;
  2261                                  ;-----------------------------------------------------------------------------------------------------------------------
  2262                                  czIntHeader		db	"An unhandled processor interrupt has occurred:",0
  2263                                  czIntLabel		db	"Interrupt #",0
  2264                                  czIntRegsHeader		db	"Registers at the time of the interrupt:",0
  2265                                  czIntEAX		db	"EAX:",0
  2266                                  czIntECX		db	"ECX:",0
  2267                                  czIntEDX		db	"EDX:",0
  2268                                  czIntEBX		db	"EBX:",0
  2269                                  czIntESI		db	"ESI:",0
  2270                                  czIntEDI		db	"EDI:",0
  2271                                  czIntEBP		db	"EBP:",0
  2272                                  czIntESP		db	"ESP:",0
  2273                                  czIntDS			db	" DS:",0
  2274                                  czIntES			db	" ES:",0
  2275                                  czIntSS			db	" SS:",0
  2276                                  czIntCS			db	" CS:",0
  2277                                  czIntEFLAGS		db	"FLG:",0
  2278                                  czIntEIP		db	"EIP:",0
  2279                                  ;-----------------------------------------------------------------------------------------------------------------------
  2280                                  ;
  2281                                  ;	Routine:	DrawTextDialogBox
  2282                                  ;
  2283                                  ;	Description:	This routine opens a text-mode dialog box with an ASCII border.
  2284                                  ;
  2285                                  ;	In:		CL	upper left column (0-79)
  2286                                  ;			CH	upper left row (0-24)
  2287                                  ;			DL	column width, excluding border
  2288                                  ;			DH	row height, excluding border
  2289                                  ;			BH	color attribute
  2290                                  ;
  2291                                  ;-----------------------------------------------------------------------------------------------------------------------
  2292                                  DrawTextDialogBox	push	ecx						;save non-volatile regs
  2293                                  			push	esi						;
  2294                                  			push	edi						;
  2295                                  			push	es						;
  2296                                  			push	ESELCGA						;load CGA selector ...
  2297                                  			pop	es						;... into ES
  2298                                  ;
  2299                                  ;	Compute target display offset
  2300                                  ;
  2301                                  			xor	eax,eax						;zero register
  2302                                  			mov	al,ch						;row
  2303                                  			mov	ah,ECONROWBYTES					;mulitplicand
  2304                                  			mul	ah						;row offset
  2305                                  			add	al,cl						;add column
  2306                                  			adc	ah,0						;add overflow
  2307                                  			add	al,cl						;add column
  2308                                  			adc	ah,0						;add overflow
  2309                                  			mov	edi,eax						;target row offset
  2310                                  ;
  2311                                  ;	Display top border row
  2312                                  ;
  2313                                  			push	edi						;save target row offset
  2314                                  			mov	ah,bh						;attribute
  2315                                  			mov	al,EASCIIBORDSGLUPRLFT				;upper-left single border
  2316                                  			stosw							;display character and attribute
  2317                                  			mov	al,EASCIIBORDSGLHORZ				;horizontal single border
  2318                                  			xor	ecx,ecx						;zero register
  2319                                  			mov	cl,dl						;width, excluding border
  2320                                  			rep	stosw						;display horizontal border
  2321                                  			mov	al,EASCIIBORDSGLUPRRGT				;upper-right single border
  2322                                  			stosw							;display character and attribute
  2323                                  			pop	edi						;restore target row offset
  2324                                  			add	edi,ECONROWBYTES				;next row
  2325                                  ;
  2326                                  ;	Display dialog box body rows
  2327                                  ;
  2328                                  			xor	ecx,ecx						;zero register
  2329                                  			mov	cl,dh						;height, excluding border
  2330                                  .10			push	ecx						;save remaining rows
  2331                                  			push	edi						;save target row offset
  2332                                  			mov	ah,bh						;attribute
  2333                                  			mov	al,EASCIIBORDSGLVERT				;vertical single border
  2334                                  			stosw							;display character and attribute
  2335                                  			mov	al,EASCIISPACE					;space
  2336                                  			xor	ecx,ecx						;zero register
  2337                                  			mov	cl,dl						;width, excluding border
  2338                                  			rep	stosw						;display row
  2339                                  			mov	al,EASCIIBORDSGLVERT				;vertical single border
  2340                                  			stosw							;display character and attribute
  2341                                  			pop	edi						;restore target row offset
  2342                                  			add	edi,ECONROWBYTES				;next row
  2343                                  			pop	ecx						;remaining rows
  2344                                  			loop	.10						;next row
  2345                                  ;
  2346                                  ;	Display bottom border row
  2347                                  ;
  2348                                  			push	edi						;save target row offset
  2349                                  			mov	ah,bh						;attribute
  2350                                  			mov	al,EASCIIBORDSGLLWRLFT				;lower-left single border
  2351                                  			stosw							;display character and attribute
  2352                                  			mov	al,EASCIIBORDSGLHORZ				;horizontal single border
  2353                                  			xor	ecx,ecx						;zero register
  2354                                  			mov	cl,dl						;width, excluding border
  2355                                  			rep	stosw						;display horizontal border
  2356                                  			mov	al,EASCIIBORDSGLLWRRGT				;lower-right single border
  2357                                  			stosw							;display character and attribute
  2358                                  			pop	edi						;restore target row offset
  2359                                  			add	edi,ECONROWBYTES				;next row
  2360                                  ;
  2361                                  ;	Restore and return
  2362                                  ;
  2363                                  			pop	es						;restore non-volatile regs
  2364                                  			pop	edi						;
  2365                                  			pop	esi						;
  2366                                  			pop	ecx						;
  2367                                  			ret							;return
  2368                                  ;=======================================================================================================================
  2369                                  ;
  2370                                  ;	Hardware Device Interupts
  2371                                  ;
  2372                                  ;	The next 16 interrupts are defined as our hardware interrupts. These interrupts vectors (20h-2Fh) are mapped to
  2373                                  ;	the hardware interrupts IRQ0-IRQF by the BIOS when the call to the BIOS is made invoking BIOS function 89h
  2374                                  ;	(BX=2028h).
  2375                                  ;
  2376                                  ;=======================================================================================================================
  2377                                  ;-----------------------------------------------------------------------------------------------------------------------
  2378                                  ;
  2379                                  ;	IRQ0	Clock Tick Interrupt
  2380                                  ;
  2381                                  ;	PC compatible systems contain or emulate the function of the Intel 8253 Programmable Interval Timer (PIT).
  2382                                  ;	Channel 0 of this chip decrements an internal counter to zero and then issues a hardware interrupt. The default
  2383                                  ;	rate at which IRQ0 occurs is approximately 18.2 times per second or, more accurately, 1,573,040 times per day.
  2384                                  ;
  2385                                  ;	Every time IRQ0 occurs, a counter at 40:6c is incremented. When the number of ticks reaches the maximum for one
  2386                                  ;	day, the counter is set to zero and the number of days counter at 40:70 is incremented.
  2387                                  ;
  2388                                  ;	This handler also decrements the floppy drive motor count at 40:40 if it is not zero. When this count reaches
  2389                                  ;	zero, the floppy disk motors are turned off.
  2390                                  ;
  2391                                  ;-----------------------------------------------------------------------------------------------------------------------
  2392                                  			menter	clocktick					;clock tick interrupt
  2393                                  			push	eax						;save modified regs
  2394                                  			push	edx						;
  2395                                  			push	ds						;
  2396                                  ;
  2397                                  ;	Update the clock tick count and the elapsed days as needed
  2398                                  ;
  2399                                  			push	ESELDAT						;load OS data selector ...
  2400                                  			pop	ds						;... into data segment register
  2401                                  			mov	eax,[wdClockTicks]				;eax = clock ticks
  2402                                  			inc	eax						;increment clock ticks
  2403                                  			cmp	eax,EPITDAYTICKS				;clock ticks per day?
  2404                                  			jb	irq0.10						;no, skip ahead
  2405                                  			inc	byte [wbClockDays]				;increment clock days
  2406                                  			xor	eax,eax						;reset clock ticks
  2407                                  irq0.10			mov	dword [wdClockTicks],eax			;save clock ticks
  2408                                  ;
  2409                                  ;	Decrement floppy disk motor timeout
  2410                                  ;
  2411                                  			cmp	byte [wbFDCMotor],0				;floppy motor timeout?
  2412                                  			je	irq0.20						;yes, skip ahead
  2413                                  			dec	byte [wbFDCMotor]				;decrement motor timeout
  2414                                  			jnz	irq0.20						;skip ahead if non-zero
  2415                                  ;
  2416                                  ;	Turn off the floppy disk motor if appropriate
  2417                                  ;
  2418                                  			sti							;enable maskable interrupts
  2419                                  irq0.15 		mov	dh,EFDCPORTHI					;FDC controller port hi
  2420                                  			mov	dl,EFDCPORTLOSTAT				;FDC main status register
  2421                                  			in	al,dx						;FDC main status byte
  2422                                  			test	al,EFDCSTATBUSY					;test FDC main status for busy
  2423                                  			jnz	irq0.15						;wait while busy
  2424                                  			mov	al,EFDCMOTOROFF					;motor-off / enable/ DMA setting
  2425                                  			mov	byte [wbFDCControl],al				;save motor-off setting
  2426                                  			mov	dh,EFDCPORTHI					;fdc port hi
  2427                                  			mov	dl,EFDCPORTLOOUT				;fdc digital output register
  2428                                  			out	dx,al						;turn motor off
  2429                                  ;
  2430                                  ;	Signal the end of the hardware interrupt
  2431                                  ;
  2432                                  irq0.20			call	PutPrimaryEndOfInt				;send end-of-interrupt to PIC
  2433                                  ;
  2434                                  ;	Determine if a task switch is appropriate
  2435                                  ;
  2436                                  			cmp	byte [wbInCriticalSection],0			;any task holding a critical section?
  2437                                  			jne	irq0.30						;yes, do not switch tasks
  2438                                  			inc	byte [wbTaskIndex]				;increment task queue index (0-255)
  2439                                  			movzx	eax,byte [wbTaskIndex]				;load task queue index
  2440                                  			mov	dx,[wwTaskQueue+eax*2]				;next task selector
  2441                                  			str	ax						;current task selector
  2442                                  			cmp	dx,ax						;next task same is current task?
  2443                                  			je	irq0.30						;yes, skip task switch
  2444                                  ;
  2445                                  ;	Switch task
  2446                                  ;
  2447                                  			push	es						;save extra segment register
  2448                                  			push	ESELGDT						;load GDT alias selector ...
  2449                                  			pop	es						;... into extra segment reg
  2450                                  			and	byte [es:eax+5],0FDh				;reset task-busy bit of current task
  2451                                  			pop	es						;restore extra segment register
  2452                                  			mov	word [wwFarJumpSelector],dx			;set next task selector in jmp instr
  2453                                  			jmp	far [wdFarJumpEIP]				;jump to next task
  2454                                  ;
  2455                                  ;	Restore and return
  2456                                  ;
  2457                                  irq0.30			pop	ds						;restore modified regs
  2458                                  			pop	edx						;
  2459                                  			pop	eax						;
  2460                                  			iretd							;return
  2461                                  ;-----------------------------------------------------------------------------------------------------------------------
  2462                                  ;
  2463                                  ;	IRQ1	Keyboard Interrupt
  2464                                  ;
  2465                                  ;	This handler is called when an IRQ1 hardware interrupt occurs, caused by a keyboard event. The scan-code(s)
  2466                                  ;	corresponding to the keyboard event are read and message events are appended to the message queue. Since this
  2467                                  ;	code is called in response to a hardware interrupt, no task switch occurs. We need to preseve the state of
  2468                                  ;	ALL modified registers upon return. Note that keyboard messages are added to the keyboard focus message queue.
  2469                                  ;	This is a queue referenced in the global descriptor table and must always reference the message queue for the
  2470                                  ;	task that has the keyboard focus. To direct keyboard messages to another task, update the GDT descriptor to
  2471                                  ;	point to the message queue for that task.
  2472                                  ;
  2473                                  ;-----------------------------------------------------------------------------------------------------------------------
  2474                                  			menter	keyboard					;keyboard interrrupt
  2475                                  			push	eax						;save non-volatile regs
  2476                                  			push	ebx						;
  2477                                  			push	ecx						;
  2478                                  			push	esi						;
  2479                                  			push	ds						;
  2480                                  			push	ESELDAT						;load OS data selector ...
  2481                                  			pop	ds						;... into data segment register
  2482                                  			xor	al,al						;zero
  2483                                  			mov	[wbConsoleScan0],al				;clear scan code 0
  2484                                  			mov	[wbConsoleScan1],al				;clear scan code 1
  2485                                  			mov	[wbConsoleScan2],al				;clear scan code 2
  2486                                  			mov	[wbConsoleScan3],al				;clear scan code 3
  2487                                  			mov	[wbConsoleScan4],al				;clear scan code 4
  2488                                  			mov	[wbConsoleScan5],al				;clear scan code 5
  2489                                  			mov	al,' '						;space
  2490                                  			mov	[wbConsoleChar],al				;set character to space
  2491                                  			mov	al,EKEYFTIMEOUT					;controller timeout flag
  2492                                  			not	al						;controller timeout mask
  2493                                  			and	[wbConsoleStatus],al				;clear controller timeout flag
  2494                                  			mov	bl,[wbConsoleShift]				;shift flags
  2495                                  			mov	bh,[wbConsoleLock]				;lock flags
  2496                                  			call	WaitForKeyOutBuffer				;controller timeout?
  2497                                  			jz	irq1.140					;yes, skip ahead
  2498                                  			in	al,EKEYBPORTDATA				;read scan code 0
  2499                                  			mov	[wbConsoleScan0],al				;save scan code 0
  2500                                  			mov	ah,al						;copy scan code 0
  2501                                  			mov	al,EKEYFSHIFTLEFT				;left shift flag
  2502                                  			cmp	ah,EKEYBSHIFTLDOWN				;left shift key down code?
  2503                                  			je	irq1.30						;yes, set flag
  2504                                  			cmp	ah,EKEYBSHIFTLUP				;left shift key up code?
  2505                                  			je	irq1.40						;yes, reset flag
  2506                                  			mov	al,EKEYFSHIFTRIGHT				;right shift flag
  2507                                  			cmp	ah,EKEYBSHIFTRDOWN				;right shift key down code?
  2508                                  			je	irq1.30						;yes, set flag
  2509                                  			cmp	ah,EKEYBSHIFTRUP				;right shift key up code?
  2510                                  			je	irq1.40						;yes, reset flag
  2511                                  			mov	al,EKEYFCTRLLEFT				;left control flag
  2512                                  			cmp	ah,EKEYBCTRLDOWN				;control key down code?
  2513                                  			je	irq1.30						;yes, set flag
  2514                                  			cmp	ah,EKEYBCTRLUP					;control key up code?
  2515                                  			je	irq1.40						;yes, reset flag
  2516                                  			mov	al,EKEYFALTLEFT					;left alt flag
  2517                                  			cmp	ah,EKEYBALTDOWN					;alt key down code?
  2518                                  			je	irq1.30						;yes, set flag
  2519                                  			cmp	ah,EKEYBALTUP					;alt key up code?
  2520                                  			je	irq1.40						;yes, reset flag
  2521                                  			mov	al,EKEYFLOCKCAPS				;caps-lock flag
  2522                                  			cmp	ah,EKEYBCAPSDOWN				;caps-lock key down code?
  2523                                  			je	irq1.50						;yes, toggle lamps and flags
  2524                                  			mov	al,EKEYFLOCKNUM					;num-lock flag
  2525                                  			cmp	ah,EKEYBNUMDOWN					;num-lock key down code?
  2526                                  			je	irq1.50						;yes, toggle lamps and flags
  2527                                  			mov	al,EKEYFLOCKSCROLL				;scroll-lock flag
  2528                                  			cmp	ah,EKEYBSCROLLDOWN				;scroll-lock key down code?
  2529                                  			je	irq1.50						;yes, toggle lamps and flags
  2530                                  			cmp	ah,EKEYBCODEEXT0				;extended scan code 0?
  2531                                  			jne	irq1.70 					;no, skip ahead
  2532                                  			call	WaitForKeyOutBuffer				;controller timeout?
  2533                                  			jz	irq1.140					;yes, skip ahead
  2534                                  			in	al,EKEYBPORTDATA				;read scan code 1
  2535                                  			mov	[wbConsoleScan1],al				;save scan code 1
  2536                                  			mov	ah,al						;copy scan code 1
  2537                                  			mov	al,EKEYFCTRLRIGHT				;right control flag
  2538                                  			cmp	ah,EKEYBCTRLDOWN				;control key down code?
  2539                                  			je	irq1.30						;yes, set flag
  2540                                  			cmp	ah,EKEYBCTRLUP					;control key up code?
  2541                                  			je	irq1.40						;yes, reset flag
  2542                                  			mov	al,EKEYFALTRIGHT				;right alt flag
  2543                                  			cmp	ah,EKEYBALTDOWN					;alt key down code?
  2544                                  			je	irq1.30						;yes, set flag
  2545                                  			cmp	ah,EKEYBALTUP					;alt key up code?
  2546                                  			je	irq1.40						;yes, reset flag
  2547                                  			cmp	ah,EKEYBSLASH					;slash down code?
  2548                                  			je	irq1.80						;yes, skip ahead
  2549                                  			cmp	ah,EKEYBSLASHUP					;slash up code?
  2550                                  			je	irq1.80						;yes, skip ahead
  2551                                  			cmp	ah,EKEYBPRTSCRDOWN				;print screen down code?
  2552                                  			je	irq1.10						;yes, continue
  2553                                  			cmp	ah,EKEYBPRTSCRUP				;print screen up code?
  2554                                  			jne	irq1.20						;no, skip ahead
  2555                                  irq1.10			call	WaitForKeyOutBuffer				;controller timeout?
  2556                                  			jz	irq1.140					;yes, skip ahead
  2557                                  			in	al,EKEYBPORTDATA				;read scan code 2
  2558                                  			mov	[wbConsoleScan2],al				;save scan code 2
  2559                                  			call	WaitForKeyOutBuffer				;controller timeout?
  2560                                  			jz	irq1.140					;yes, skip ahead
  2561                                  			in	al,EKEYBPORTDATA				;read scan code 3
  2562                                  			mov	[wbConsoleScan3],al				;read scan code 3
  2563                                  irq1.20			jmp	irq1.150					;finish keyboard handling
  2564                                  irq1.30			or	bl,al						;set shift flag
  2565                                  			jmp	irq1.60						;skip ahead
  2566                                  irq1.40			not	al						;convert flag to mask
  2567                                  			and	bl,al						;reset shift flag
  2568                                  			jmp	irq1.60						;skip ahead
  2569                                  irq1.50			xor	bh,al						;toggle lock flag
  2570                                  			call	SetKeyboardLamps				;update keyboard lamps
  2571                                  irq1.60			mov	[wbConsoleShift],bl				;save shift flags
  2572                                  			mov	[wbConsoleLock],bh				;save lock flags
  2573                                  			call	PutConsoleOIAShift				;update OIA indicators
  2574                                  			jmp	irq1.150					;finish keyboard handling
  2575                                  irq1.70			cmp	ah,EKEYBCODEEXT1				;extended scan code 1?
  2576                                  			jne	irq1.80						;no continue
  2577                                  			call	WaitForKeyOutBuffer				;controller timeout?
  2578                                  			jz	irq1.140					;yes, skip ahead
  2579                                  			in	al,EKEYBPORTDATA				;read scan code 1
  2580                                  			mov	[wbConsoleScan1],al				;save scan code 1
  2581                                  			mov	ah,al						;copy scan code 1
  2582                                  			cmp	ah,EKEYBPAUSEDOWN				;pause key down code?
  2583                                  			jne	irq1.150					;no, finish keyboard handling
  2584                                  			call	WaitForKeyOutBuffer				;controller timeout?
  2585                                  			jz	irq1.140					;yes, skip ahead
  2586                                  			in	al,EKEYBPORTDATA				;read scan code 2
  2587                                  			mov	[wbConsoleScan2],al				;save scan code 2
  2588                                  			call	WaitForKeyOutBuffer				;controller timeout?
  2589                                  			jz	irq1.140					;yes, skip ahead
  2590                                  			in	al,EKEYBPORTDATA				;read scan code 3
  2591                                  			mov	[wbConsoleScan3],al				;save scan code 3
  2592                                  			call	WaitForKeyOutBuffer				;controller timeout?
  2593                                  			jz	irq1.140					;yes, skip ahead
  2594                                  			in	al,EKEYBPORTDATA				;read scan code 4
  2595                                  			mov	[wbConsoleScan4],al				;save scan code 4
  2596                                  			call	WaitForKeyOutBuffer				;controller timeout?
  2597                                  			jz	irq1.140					;yes, skip ahead
  2598                                  			in	al,EKEYBPORTDATA				;read scan code 5
  2599                                  			mov	[wbConsoleScan5],al				;save scan code 5
  2600                                  			jmp	irq1.150					;continue
  2601                                  irq1.80			xor	al,al						;assume no ASCII translation
  2602                                  			test	ah,EKEYBUP					;release code?
  2603                                  			jnz	irq1.130					;yes, skip ahead
  2604                                  			mov	esi,tscan2ascii					;scan-to-ascii table address
  2605                                  			test	bl,EKEYFSHIFT					;either shift key down?
  2606                                  			jz	irq1.90						;no, skip ahead
  2607                                  			mov	esi,tscan2shift					;scan-to-shifted table address
  2608                                  irq1.90			movzx	ecx,ah						;scan code offset
  2609                                  			mov	al,[cs:ecx+esi]					;al = ASCII code
  2610                                  			test	bh,EKEYFLOCKCAPS				;caps-lock on?
  2611                                  			jz	irq1.100					;no skip ahead
  2612                                  			mov	cl,al						;copy ASCII code
  2613                                  			and	cl,EASCIICASEMASK				;clear case mask of copy
  2614                                  			cmp	cl,EASCIIUPPERA					;less than 'A'?
  2615                                  			jb	irq1.100					;yes, skip ahead
  2616                                  			cmp	cl,EASCIIUPPERZ					;greater than 'Z'?
  2617                                  			ja	irq1.100					;yes, skip ahead
  2618                                  			xor	al,EASCIICASE					;switch case
  2619                                  irq1.100		mov	[wbConsoleChar],al				;save ASCII code
  2620                                  irq1.110		mov	edx,EMSGKEYDOWN					;assume key-down event
  2621                                  			test	ah,EKEYBUP					;release scan-code?
  2622                                  			jz	irq1.120					;no, skip ahead
  2623                                  			mov	edx,EMSGKEYUP					;key-up event
  2624                                  irq1.120		and	eax,0FFFFh					;clear high-order word
  2625                                  			or	edx,eax						;msg id and codes
  2626                                  			xor	ecx,ecx						;null param
  2627                                  			push	eax						;save codes
  2628                                  			mov	eax,ESELKEYBOARDMQ				;keyboard focus message queue
  2629                                  			call	PutMessage					;put message to console
  2630                                  			pop	eax						;restore codes
  2631                                  			test	al,al						;ASCII translation?
  2632                                  			jz	irq1.130					;no, skip ahead
  2633                                  			mov	edx,EMSGKEYCHAR					;key-character event
  2634                                  			and	eax,0FFFFh					;clear high-order word
  2635                                  			or	edx,eax						;msg id and codes
  2636                                  			xor	ecx,ecx						;null param
  2637                                  			mov	eax,ESELKEYBOARDMQ				;keyboard focus message queue
  2638                                  			call	PutMessage					;put message to console
  2639                                  irq1.130		jmp	irq1.150					;finish keyboard handling
  2640                                  irq1.140		mov	al,EKEYFTIMEOUT					;controller timeout flag
  2641                                  			or	[wbConsoleStatus],al				;set controller timeout flag
  2642                                  irq1.150		call	PutConsoleOIAChar				;update operator info area
  2643                                  			call	PutPrimaryEndOfInt				;send end-of-interrupt to PIC
  2644                                  			pop	ds						;restore non-volatile regs
  2645                                  			pop	esi						;
  2646                                  			pop	ecx						;
  2647                                  			pop	ebx						;
  2648                                  			pop	eax						;
  2649                                  			iretd							;return
  2650                                  ;-----------------------------------------------------------------------------------------------------------------------
  2651                                  ;	Scan-Code to ASCII Translation Tables
  2652                                  ;-----------------------------------------------------------------------------------------------------------------------
  2653                                  tscan2ascii		db	000h,01Bh,031h,032h,033h,034h,035h,036h		;00-07
  2654                                  			db	037h,038h,039h,030h,02Dh,03Dh,008h,009h		;08-0F
  2655                                  			db	071h,077h,065h,072h,074h,079h,075h,069h		;10-17
  2656                                  			db	06Fh,070h,05Bh,05Dh,00Dh,000h,061h,073h		;18-1F
  2657                                  			db	064h,066h,067h,068h,06Ah,06Bh,06Ch,03Bh		;20-27
  2658                                  			db	027h,060h,000h,05Ch,07Ah,078h,063h,076h		;28-2F
  2659                                  			db	062h,06Eh,06Dh,02Ch,02Eh,02Fh,000h,02Ah		;30-37
  2660                                  			db	000h,020h,000h,000h,000h,000h,000h,000h		;38-3F
  2661                                  			db	000h,000h,000h,000h,000h,000h,000h,037h		;40-47
  2662                                  			db	038h,039h,02Dh,034h,035h,036h,02Bh,031h		;48-4F
  2663                                  			db	032h,033h,030h,02Eh,000h,000h,000h,000h		;50-57
  2664                                  			db	000h,000h,000h,000h,000h,000h,000h,000h		;58-5F
  2665                                  			db	000h,000h,000h,000h,000h,000h,000h,000h		;60-67
  2666                                  			db	000h,000h,000h,000h,000h,000h,000h,000h		;68-6F
  2667                                  			db	000h,000h,000h,000h,000h,000h,000h,000h		;70-77
  2668                                  			db	000h,000h,000h,000h,000h,000h,000h,000h		;78-7F
  2669                                  tscan2shift		db	000h,01Bh,021h,040h,023h,024h,025h,05Eh		;80-87
  2670                                  			db	026h,02Ah,028h,029h,05Fh,02Bh,008h,000h		;88-8F
  2671                                  			db	051h,057h,045h,052h,054h,059h,055h,049h		;90-97
  2672                                  			db	04Fh,050h,07Bh,07Dh,00Dh,000h,041h,053h		;98-9F
  2673                                  			db	044h,046h,047h,048h,04Ah,04Bh,04Ch,03Ah		;A0-A7
  2674                                  			db	022h,07Eh,000h,07Ch,05Ah,058h,043h,056h		;A8-AF
  2675                                  			db	042h,04Eh,04Dh,03Ch,03Eh,03Fh,000h,02Ah		;B0-B7
  2676                                  			db	000h,020h,000h,000h,000h,000h,000h,000h		;B8-BF
  2677                                  			db	000h,000h,000h,000h,000h,000h,000h,037h		;C0-C7
  2678                                  			db	038h,039h,02Dh,034h,035h,036h,02Bh,031h		;C8-CF
  2679                                  			db	032h,033h,030h,02Eh,000h,000h,000h,000h		;D0-D7
  2680                                  			db	000h,000h,000h,000h,000h,000h,000h,000h		;D8-DF
  2681                                  			db	000h,000h,000h,000h,000h,000h,000h,000h		;E0-E7
  2682                                  			db	000h,000h,000h,000h,000h,000h,000h,000h		;E8-EF
  2683                                  			db	000h,000h,000h,000h,000h,000h,000h,000h		;F0-F7
  2684                                  			db	000h,000h,000h,000h,000h,000h,000h,000h		;F8-FF
  2685                                  ;-----------------------------------------------------------------------------------------------------------------------
  2686                                  ;
  2687                                  ;	IRQ2	Secondary 8259A Cascade Hardware Interrupt
  2688                                  ;
  2689                                  ;-----------------------------------------------------------------------------------------------------------------------
  2690                                  			menter	iochannel					;secondary 8259A cascade
  2691                                  			push	eax						;save modified regs
  2692                                  			jmp	hwint						;end interrupt and return
  2693                                  ;-----------------------------------------------------------------------------------------------------------------------
  2694                                  ;
  2695                                  ;	IRQ3	Communication Port 2 Hardware Interrupt
  2696                                  ;
  2697                                  ;-----------------------------------------------------------------------------------------------------------------------
  2698                                  			menter	com2						;serial port 2 interrupt
  2699                                  			push	eax						;save modified regs
  2700                                  			jmp	hwint						;end interrupt and return
  2701                                  ;-----------------------------------------------------------------------------------------------------------------------
  2702                                  ;
  2703                                  ;	IRQ4	Communication Port 1 Hardware Interrupt
  2704                                  ;
  2705                                  ;-----------------------------------------------------------------------------------------------------------------------
  2706                                  			menter	com1						;serial port 1 interrupt
  2707                                  			push	eax						;save modified regs
  2708                                  			jmp	hwint						;end interrupt and return
  2709                                  ;-----------------------------------------------------------------------------------------------------------------------
  2710                                  ;
  2711                                  ;	IRQ5	Parallel Port 2 Hardware Interrupt
  2712                                  ;
  2713                                  ;-----------------------------------------------------------------------------------------------------------------------
  2714                                  			menter	lpt2						;parallel port 2 interrupt
  2715                                  			push	eax						;save modified regs
  2716                                  			jmp	hwint						;end interrupt and return
  2717                                  ;-----------------------------------------------------------------------------------------------------------------------
  2718                                  ;
  2719                                  ;	IRQ6	Diskette Hardware Interrupt
  2720                                  ;
  2721                                  ;-----------------------------------------------------------------------------------------------------------------------
  2722                                  			menter	diskette					;floppy disk interrupt
  2723                                  			push	eax						;save non-volatile regs
  2724                                  			push	ds						;
  2725                                  			push	ESELDAT						;load OS data selector ...
  2726                                  			pop	ds						;... into DS register
  2727                                  			mov	al,[wbFDCStatus]				;al = FDC calibration status
  2728                                  			or	al,10000000b					;set IRQ flag
  2729                                  			mov	[wbFDCStatus],al				;update FDC calibration status
  2730                                  			pop	ds						;restore non-volatile regs
  2731                                  			jmp	hwint						;end primary PIC interrupt
  2732                                  ;-----------------------------------------------------------------------------------------------------------------------
  2733                                  ;
  2734                                  ;	IRQ7	Parallel Port 1 Hardware Interrupt
  2735                                  ;
  2736                                  ;-----------------------------------------------------------------------------------------------------------------------
  2737                                  			menter	lpt1						;parallel port 1 interrupt
  2738                                  			push	eax						;save modified regs
  2739                                  			jmp	hwint						;end interrupt and return
  2740                                  ;-----------------------------------------------------------------------------------------------------------------------
  2741                                  ;
  2742                                  ;	IRQ8	Real-time Clock Hardware Interrupt
  2743                                  ;
  2744                                  ;-----------------------------------------------------------------------------------------------------------------------
  2745                                  			menter	rtclock						;real-time clock interrupt
  2746                                  			push	eax						;save modified regs
  2747                                  			jmp	hwwint						;end interrupt and return
  2748                                  ;-----------------------------------------------------------------------------------------------------------------------
  2749                                  ;
  2750                                  ;	IRQ9	CGA Vertical Retrace Hardware Interrupt
  2751                                  ;
  2752                                  ;-----------------------------------------------------------------------------------------------------------------------
  2753                                  			menter	retrace						;CGA vertical retrace interrupt
  2754                                  			push	eax						;save modified regs
  2755                                  			jmp	hwwint						;end interrupt and return
  2756                                  ;-----------------------------------------------------------------------------------------------------------------------
  2757                                  ;
  2758                                  ;	IRQ10	Reserved Hardware Interrupt
  2759                                  ;
  2760                                  ;-----------------------------------------------------------------------------------------------------------------------
  2761                                  			menter	irq10						;reserved
  2762                                  			push	eax						;save modified regs
  2763                                  			jmp	hwwint						;end interrupt and return
  2764                                  ;-----------------------------------------------------------------------------------------------------------------------
  2765                                  ;
  2766                                  ;	IRQ11	Reserved Hardware Interrupt
  2767                                  ;
  2768                                  ;-----------------------------------------------------------------------------------------------------------------------
  2769                                  			menter	irq11						;reserved
  2770                                  			push	eax						;save modified regs
  2771                                  			jmp	hwwint						;end interrupt and return
  2772                                  ;-----------------------------------------------------------------------------------------------------------------------
  2773                                  ;
  2774                                  ;	IRQ12	PS/2 Mouse Hardware Interrupt
  2775                                  ;
  2776                                  ;-----------------------------------------------------------------------------------------------------------------------
  2777                                  			menter	ps2mouse					;PS/2 mouse interrupt
  2778                                  			push	eax						;save modified regs
  2779                                  			jmp	hwwint						;end interrupt and return
  2780                                  ;-----------------------------------------------------------------------------------------------------------------------
  2781                                  ;
  2782                                  ;	IRQ13	Coprocessor Hardware Interrupt
  2783                                  ;
  2784                                  ;-----------------------------------------------------------------------------------------------------------------------
  2785                                  			menter	coprocessor					;coprocessor interrupt
  2786                                  			push	eax						;save modified regs
  2787                                  			jmp	hwwint						;end interrupt and return
  2788                                  ;-----------------------------------------------------------------------------------------------------------------------
  2789                                  ;
  2790                                  ;	IRQ14	Fixed Disk Hardware Interrupt
  2791                                  ;
  2792                                  ;-----------------------------------------------------------------------------------------------------------------------
  2793                                  			menter	fixeddisk					;fixed disk interrupt
  2794                                  			push	eax						;save modified regs
  2795                                  			jmp	hwwint						;end interrupt and return
  2796                                  ;-----------------------------------------------------------------------------------------------------------------------
  2797                                  ;
  2798                                  ;	IRQ15	Reserved Hardware Interrupt
  2799                                  ;
  2800                                  ;-----------------------------------------------------------------------------------------------------------------------
  2801                                  			menter	irq15						;reserved
  2802                                  			push	eax						;save modified regs
  2803                                  			jmp	hwwint						;end interrupt and return
  2804                                  ;-----------------------------------------------------------------------------------------------------------------------
  2805                                  ;
  2806                                  ;	Exit from hardware interrupt
  2807                                  ;
  2808                                  ;-----------------------------------------------------------------------------------------------------------------------
  2809                                  hwwint			call	PutSecondaryEndOfInt				;send EOI to secondary PIC
  2810                                  			jmp	hwint90						;skip ahead
  2811                                  hwint			call	PutPrimaryEndOfInt				;send EOI to primary PIC
  2812                                  hwint90			pop	eax						;restore modified regs
  2813                                  			iretd							;return from interrupt
  2814                                  ;-----------------------------------------------------------------------------------------------------------------------
  2815                                  ;
  2816                                  ;	INT 30h Operating System Software Service Interrupt
  2817                                  ;
  2818                                  ;	Interrupt 30h is used by our operating system as an entry point for many commonly-used subroutines reusable by
  2819                                  ;	any task. These routines include low-level i/o functions that shield applications from having to handle
  2820                                  ;	device-specific communications. On entry to this interrupt, AL contains a function number that is used to load
  2821                                  ;	the entry address of the specific function from a table.
  2822                                  ;
  2823                                  ;-----------------------------------------------------------------------------------------------------------------------
  2824                                  			menter	svc
  2825                                  			cmp	al,maxtsvc					;is our function out of range?
  2826                                  			jae	svc90						;yes, skip ahead
  2827                                  			movzx	eax,al						;function
  2828                                  			shl	eax,2						;offset into table
  2829                                  			call	dword [cs:tsvc+eax]				;far call to indirect address
  2830                                  svc90			iretd							;return from interrupt
  2831                                  ;-----------------------------------------------------------------------------------------------------------------------
  2832                                  ;
  2833                                  ;	Service Request Table
  2834                                  ;
  2835                                  ;
  2836                                  ;	These tsvce macros expand to define an address vector table for the service request interrupt (int 30h).
  2837                                  ;
  2838                                  ;-----------------------------------------------------------------------------------------------------------------------
  2839                                  tsvc			tsvce	AllocateMemory					;allocate memory block
  2840                                  			tsvce	ByteToDecimalString				;convert byte to decimal string
  2841                                  			tsvce	ClearConsoleScreen				;clear console screen
  2842                                  			tsvce	CompareMemory					;compare memory
  2843                                  			tsvce	CopyMemory					;copy memory
  2844                                  			tsvce	DecimalToUnsigned				;convert decimal string to unsigned integer
  2845                                  			tsvce	FreeMemory					;free memory block
  2846                                  			tsvce	GetConsoleString				;get string input
  2847                                  			tsvce	HexadecimalToUnsigned				;convert hexadecimal string to unsigned integer
  2848                                  			tsvce	IsLeapYear					;return ecx=1 if leap year
  2849                                  			tsvce	PlaceCursor					;place the cursor at the current loc
  2850                                  			tsvce	PutConsoleString				;tty output asciiz string
  2851                                  			tsvce	PutDateString					;put MM/DD/YYYY string
  2852                                  			tsvce	PutDayString					;put DD string
  2853                                  			tsvce	PutHourString					;put hh string
  2854                                  			tsvce	PutMinuteString					;put mm string
  2855                                  			tsvce	PutMonthString					;put MM string
  2856                                  			tsvce	PutMonthNameString				;put name(MM) string
  2857                                  			tsvce	PutSecondString					;put ss string
  2858                                  			tsvce	PutTimeString					;put HH:MM:SS string
  2859                                  			tsvce	PutWeekdayString				;put weekday string
  2860                                  			tsvce	PutWeekdayNameString				;put name(weekday) string
  2861                                  			tsvce	PutYearString					;put YYYY string
  2862                                  			tsvce	ReadRealTimeClock				;get real-time clock date and time
  2863                                  			tsvce	ResetSystem					;reset system using 8042 chip
  2864                                  			tsvce	SetConsoleString				;set console string
  2865                                  			tsvce	UnsignedToDecimalString 			;convert unsigned integer to decimal string
  2866                                  			tsvce	UnsignedToHexadecimal				;convert unsigned integer to hexadecimal string
  2867                                  			tsvce	UpperCaseString					;upper-case string
  2868                                  			tsvce	Yield						;halt until interrupt
  2869                                  maxtsvc			equ	($-tsvc)/4					;function out of range
  2870                                  ;-----------------------------------------------------------------------------------------------------------------------
  2871                                  ;
  2872                                  ;	Service Request Macros
  2873                                  ;
  2874                                  ;	These macros provide positional parameterization of service request calls.
  2875                                  ;
  2876                                  ;-----------------------------------------------------------------------------------------------------------------------
  2877                                  %macro			allocateMemory 1
  2878                                  			mov	ecx,%1						;bytes to allocate
  2879                                  			mov	al,eAllocateMemory				;allocate memory fn.
  2880                                  			int	_svc						;invoke OS service
  2881                                  %endmacro
  2882                                  %macro			byteToDecimalString 0
  2883                                  			mov	al,eByteToDecimalString				;function code
  2884                                  			int	_svc						;invoke OS service
  2885                                  %endmacro
  2886                                  %macro			clearConsoleScreen 0
  2887                                  			mov	al,eClearConsoleScreen				;function code
  2888                                  			int	_svc						;invoke OS service
  2889                                  %endmacro
  2890                                  %macro			compareMemory 0
  2891                                  			mov	al,eCompareMemory				;function code
  2892                                  			int	_svc						;invoke OS service
  2893                                  %endmacro
  2894                                  %macro			compareMemory 3
  2895                                  			mov	edx,%1						;first memory address
  2896                                  			mov	ebx,%2						;second memory address
  2897                                  			mov	ecx,%3						;length
  2898                                  			mov	al,eCompareMemory				;function code
  2899                                  			int	_svc						;invoke OS service
  2900                                  %endmacro
  2901                                  %macro			copyMemory 3
  2902                                  			mov	edx,%1						;first memory address
  2903                                  			mov	ebx,%2						;second memory address
  2904                                  			mov	ecx,%3						;length
  2905                                  			mov	al,eCopyMemory					;function code
  2906                                  			int	_svc						;invoke OS service
  2907                                  %endmacro
  2908                                  %macro			decimalToUnsigned 0
  2909                                  			mov	al,eDecimalToUnsigned				;function code
  2910                                  			int	_svc						;invoke OS servie
  2911                                  %endmacro
  2912                                  %macro			freeMemory 1
  2913                                  			mov	edx,%1						;address of memory block
  2914                                  			mov	al,eFreeMemory					;function code
  2915                                  			int	_svc						;invoke OS service
  2916                                  %endmacro
  2917                                  %macro			getConsoleString 4
  2918                                  			mov	edx,%1						;buffer address
  2919                                  			mov	ecx,%2						;max characters
  2920                                  			mov	bh,%3						;echo indicator
  2921                                  			mov	bl,%4						;terminator
  2922                                  			mov	al,eGetConsoleString				;function code
  2923                                  			int	_svc						;invoke OS service
  2924                                  %endmacro
  2925                                  %macro			hexadecimalToUnsigned 0
  2926                                  			mov	al,eHexadecimalToUnsigned			;function code
  2927                                  			int	_svc						;invoke OS service
  2928                                  %endmacro
  2929                                  %macro			isLeapYear 1
  2930                                  			mov	ebx,%1						;DATETIME addr
  2931                                  			mov	al,eIsLeapYear					;function code
  2932                                  			int	_svc						;invoke OS service
  2933                                  %endmacro
  2934                                  %macro			placeCursor 0
  2935                                  			mov	al,ePlaceCursor					;function code
  2936                                  			int	_svc						;invoke OS service
  2937                                  %endmacro
  2938                                  %macro			putConsoleString 1
  2939                                  			mov	edx,%1						;string address
  2940                                  			mov	al,ePutConsoleString				;function code
  2941                                  			int	_svc						;invoke OS service
  2942                                  %endmacro
  2943                                  %macro			putDateString 0
  2944                                  			mov	al,ePutDateString				;function code
  2945                                  			int	_svc						;invoke OS service
  2946                                  %endmacro
  2947                                  %macro			putDateString 2
  2948                                  			mov	ebx,%1						;DATETIME addr
  2949                                  			mov	edx,%2						;output buffer addr
  2950                                  			mov	al,ePutDateString				;function code
  2951                                  			int	_svc						;invoke OS service
  2952                                  %endmacro
  2953                                  %macro			putDayString 2
  2954                                  			mov	ebx,%1						;DATETIME addr
  2955                                  			mov	edx,%2						;output buffer addr
  2956                                  			mov	al,ePutDayString				;function code
  2957                                  			int	_svc						;invoke OS service
  2958                                  %endmacro
  2959                                  %macro			putHourString 2
  2960                                  			mov	ebx,%1						;DATETIME addr
  2961                                  			mov	edx,%2						;output buffer addr
  2962                                  			mov	al,ePutHourString				;function code
  2963                                  			int	_svc						;invoke OS service
  2964                                  %endmacro
  2965                                  %macro			putMinuteString 2
  2966                                  			mov	ebx,%1						;DATETIME addr
  2967                                  			mov	edx,%2						;output buffer addr
  2968                                  			mov	al,ePutMinuteString				;function code
  2969                                  			int	_svc						;invoke OS service
  2970                                  %endmacro
  2971                                  %macro			putMonthString 2
  2972                                  			mov	ebx,%1						;DATETIME addr
  2973                                  			mov	edx,%2						;output buffer addr
  2974                                  			mov	al,ePutMonthString				;function code
  2975                                  			int	_svc						;invoke OS service
  2976                                  %endmacro
  2977                                  %macro			putMonthNameString 2
  2978                                  			mov	ebx,%1						;DATETIME addr
  2979                                  			mov	edx,%2						;output buffer addr
  2980                                  			mov	al,ePutMonthNameString				;function code
  2981                                  			int	_svc						;invoke OS service
  2982                                  %endmacro
  2983                                  %macro			putSecondString 2
  2984                                  			mov	ebx,%1						;DATETIME addr
  2985                                  			mov	edx,%2						;output buffer addr
  2986                                  			mov	al,ePutSecondString				;function code
  2987                                  			int	_svc						;invoke OS service
  2988                                  %endmacro
  2989                                  %macro			putTimeString 0
  2990                                  			mov	al,ePutTimeString				;function code
  2991                                  			int	_svc						;invoke OS service
  2992                                  %endmacro
  2993                                  %macro			putTimeString 2
  2994                                  			mov	ebx,%1						;DATETIME addr
  2995                                  			mov	edx,%2						;output buffer addr
  2996                                  			mov	al,ePutTimeString				;function code
  2997                                  			int	_svc						;invoke OS service
  2998                                  %endmacro
  2999                                  %macro			putWeekdayString 2
  3000                                  			mov	ebx,%1						;DATETIME addr
  3001                                  			mov	edx,%2						;output buffer addr
  3002                                  			mov	al,ePutWeekdayString				;function code
  3003                                  			int	_svc						;invoke OS service
  3004                                  %endmacro
  3005                                  %macro			putWeekdayNameString 2
  3006                                  			mov	ebx,%1						;DATETIME addr
  3007                                  			mov	edx,%2						;output buffer addr
  3008                                  			mov	al,ePutWeekdayNameString			;function code
  3009                                  			int	_svc						;invoke OS service
  3010                                  %endmacro
  3011                                  %macro			putYearString 2
  3012                                  			mov	ebx,%1						;DATETIME addr
  3013                                  			mov	edx,%2						;output buffer addr
  3014                                  			mov	al,ePutYearString				;function code
  3015                                  			int	_svc						;invoke OS service
  3016                                  %endmacro
  3017                                  %macro			readRealTimeClock 0
  3018                                  			mov	al,eReadRealTimeClock				;function code
  3019                                  			int	_svc						;invoke OS service
  3020                                  %endmacro
  3021                                  %macro			readRealTimeClock 1
  3022                                  			mov	ebx,%1						;DATETIME addr
  3023                                  			mov	al,eReadRealTimeClock				;function code
  3024                                  			int	_svc						;invoke OS service
  3025                                  %endmacro
  3026                                  %macro			resetSystem 0
  3027                                  			mov	al,eResetSystem					;function code
  3028                                  			int	_svc						;invoke OS service
  3029                                  %endmacro
  3030                                  %macro			setConsoleString 0
  3031                                  			mov	al,eSetConsoleString				;function code
  3032                                  			int	_svc						;invoke OS service
  3033                                  %endmacro
  3034                                  %macro			unsignedToDecimalString 0
  3035                                  			mov	al,eUnsignedToDecimalString			;function code
  3036                                  			int	_svc						;invoke OS service
  3037                                  %endmacro
  3038                                  %macro			unsignedToHexadecimal 0
  3039                                  			mov	al,eUnsignedToHexadecimal			;function code
  3040                                  			int	_svc						;invoke OS service
  3041                                  %endmacro
  3042                                  %macro			upperCaseString 0
  3043                                  			mov	al,eUpperCaseString				;function code
  3044                                  			int	_svc						;invoke OS service
  3045                                  %endmacro
  3046                                  %macro			yield 0
  3047                                  			mov	al,eYield					;function code
  3048                                  			int	_svc						;invoke OS service
  3049                                  %endmacro
  3050                                  ;=======================================================================================================================
  3051                                  ;
  3052                                  ;	Kernel Function Library
  3053                                  ;
  3054                                  ;=======================================================================================================================
  3055                                  ;=======================================================================================================================
  3056                                  ;
  3057                                  ;	Memory Helper Routines
  3058                                  ;
  3059                                  ;	AllocateMemory
  3060                                  ;	FreeMemory
  3061                                  ;
  3062                                  ;=======================================================================================================================
  3063                                  ;-----------------------------------------------------------------------------------------------------------------------
  3064                                  ;
  3065                                  ;	Routine:	AllocateMemory
  3066                                  ;
  3067                                  ;	Description:	This routine allocates a memory block for the given task.
  3068                                  ;
  3069                                  ;	In:		ECX	bytes of memory to allocate
  3070                                  ;
  3071                                  ;	Out:		EAX	!0	address of user portion of newly allocated memory block
  3072                                  ;				0	unable to allocate memory
  3073                                  ;
  3074                                  ;-----------------------------------------------------------------------------------------------------------------------
  3075                                  AllocateMemory		push	ebx						;save non-volatile regs
  3076                                  			push	ecx						;
  3077                                  			push	esi						;
  3078                                  			push	ds						;
  3079                                  ;
  3080                                  ;	Address kernel memory structures
  3081                                  ;
  3082                                  			push	ESELDAT						;load OS data GDT selector ...
  3083                                  			pop	ds						;... into data segment reg
  3084                                  			mov	esi,wsMemRoot					;memory root structure address
  3085                                  ;
  3086                                  ;	Set requested size to minimum block size if requested size is too small.
  3087                                  ;
  3088                                  			cmp	ecx,EMEMMINSIZE					;is requested size too small?
  3089                                  			jae	.10						;no, branch
  3090                                  			mov	ecx,EMEMMINSIZE					;set requested size to minimum
  3091                                  .10			add	ecx,EMEMBLOCKLEN				;add header block length
  3092                                  ;
  3093                                  ;	Find the first free memory block large enough to satisfy the request.
  3094                                  ;
  3095                                  			mov	eax,[esi+MEMROOT.firstfree]			;first free block ptr
  3096                                  .20			test	eax,eax						;end of free block chain?
  3097                                  			jz	.220						;yes, branch
  3098                                  			cmp	ecx,[eax+MEMBLOCK.bytes]			;free block big enough?
  3099                                  			jbe	.30						;yes, branch
  3100                                  			mov	eax,[eax+MEMBLOCK.nextblock]			;next free block addr
  3101                                  			jmp	.20						;continue
  3102                                  ;-----------------------------------------------------------------------------------------------------------------------
  3103                                  ;
  3104                                  ;	Address the previous and next free memory blocks.
  3105                                  ;
  3106                                  .30			mov	ebx,[eax+MEMBLOCK.previousblock]		;previous free block addr
  3107                                  			mov	edx,[eax+MEMBLOCK.nextblock]			;next free block addr
  3108                                  ;
  3109                                  ;	Remove the free memory block from the forward free memory block chain.
  3110                                  ;
  3111                                  			test	ebx,ebx						;any previous free memory block?
  3112                                  			jz	.40						;no, branch
  3113                                  			mov	[ebx+MEMBLOCK.nextblock],edx			;remove free block from forwrad chain
  3114                                  			jmp	.50						;continue
  3115                                  .40			mov	[esi+MEMROOT.firstfree],edx			;next free is now also the first free
  3116                                  ;
  3117                                  ;	Remove the free memory block from the reverse free memory block chain.
  3118                                  ;
  3119                                  .50			test	edx,edx						;any next free memory block?
  3120                                  			jz	.60						;no, branch
  3121                                  			mov	[edx+MEMBLOCK.previousblock],ebx		;remove free block from reverse chain
  3122                                  			jmp	.70						;continue
  3123                                  .60			mov	[esi+MEMROOT.lastfree],ebx			;previous free is now also the last free
  3124                                  ;-----------------------------------------------------------------------------------------------------------------------
  3125                                  ;
  3126                                  ;	Determine if the free memory block can be split.
  3127                                  ;
  3128                                  .70			mov	ebx,[eax+MEMBLOCK.bytes]			;size of free memory block
  3129                                  			sub	ebx,ecx						;subtract requested memory size
  3130                                  			cmp	ebx,EMEMMINSIZE					;remaining block can stand alone?
  3131                                  			jb	.150						;no, branch
  3132                                  ;
  3133                                  ;	We know that our block can be split to create a new free memory block. We update the size of our free memory
  3134                                  ;	block to the requested memory size. We update the next contiguous block pointer to point just past the end
  3135                                  ;	of the requested memory size.
  3136                                  ;
  3137                                  			mov	[eax+MEMBLOCK.bytes],ecx			;shorten memory block size
  3138                                  			mov	edx,eax						;memory block address
  3139                                  			add	edx,ecx						;address new new next contig block
  3140                                  			mov	ecx,[eax+MEMBLOCK.nextcontig]			;next contig block address
  3141                                  			mov	[eax+MEMBLOCK.nextcontig],edx			;update next contig block address
  3142                                  ;
  3143                                  ;	If there is a next contiguous block, we update that memory block's previous contig pointer to point to the new
  3144                                  ;	free block we are splitting off. If there is no next contiguous block, we update the last contig block pointer.
  3145                                  ;
  3146                                  			jecxz	.80						;no next contig, branch
  3147                                  			mov	[ecx+MEMBLOCK.previouscontig],edx		;update previous contig pointer
  3148                                  			jmp	.90						;continue
  3149                                  .80			mov	[esi+MEMROOT.lastcontig],edx			;update last contig pointer
  3150                                  ;
  3151                                  ;	Now that the contig block pointers have been updated, we initialize the new free block members.
  3152                                  ;
  3153                                  .90			mov	[edx+MEMBLOCK.bytes],ebx			;set the block size
  3154                                  			mov	[edx+MEMBLOCK.nextcontig],ecx			;set the next contig block addr
  3155                                  			mov	[edx+MEMBLOCK.previouscontig],eax		;set the previous contig block addr
  3156                                  			mov	ebx,EMEMFREECODE				;free memory signature
  3157                                  			mov	[edx+MEMBLOCK.signature],ebx			;set the block signature
  3158                                  			xor	ebx,ebx						;zero register
  3159                                  			mov	[edx+MEMBLOCK.reserved],ebx			;set reserved
  3160                                  			mov	[edx+MEMBLOCK.owner],ebx			;set the owner
  3161                                  ;
  3162                                  ;	Find the proper location in the free block chain for the new free block
  3163                                  ;
  3164                                  			mov	ebx,[edx+MEMBLOCK.bytes]			;free block size
  3165                                  			mov	ecx,[esi+MEMROOT.firstfree]			;first free block addr
  3166                                  .100			jecxz	.110						;branch if at end of chain
  3167                                  			cmp	ebx,[ecx+MEMBLOCK.bytes]			;new block smaller or equal?
  3168                                  			jbe	.110						;yes, branch
  3169                                  			mov	ecx,[ecx+MEMBLOCK.nextblock]			;next free block addr
  3170                                  			jmp	.100						;continue
  3171                                  ;
  3172                                  ;	Having found the proper location for our new free block, we store the address of the following free block, or
  3173                                  ;	zero if our new free block is larger than any other, as our next free block. Then, we take the address of our
  3174                                  ;	next block's previous block or the global last-free block as our new previous block and update the previous
  3175                                  ;	block of hte next block, if there is one.
  3176                                  ;
  3177                                  .110			mov	[edx+MEMBLOCK.nextblock],ecx			;set the new free block's next ptr
  3178                                  			mov	ebx,[esi+MEMROOT.lastfree]			;last free block addr
  3179                                  			jecxz	.120						;branch if no next block
  3180                                  			mov	ebx,[ecx+MEMBLOCK.previousblock]		;next block's previous block
  3181                                  			mov	[ecx+MEMBLOCK.previousblock],edx		;set the next block's previous block
  3182                                  			jmp	.130						;continue
  3183                                  .120			mov	[esi+MEMROOT.lastfree],edx			;set the new last free block
  3184                                  ;
  3185                                  ;	Store our previous block pointer. If we have a previous free block, update that block's next block pointer to
  3186                                  ;	point to the new block. Since the new block may now be the first or last user block, we update the first and/or
  3187                                  ;	last user block pointers if necessary.
  3188                                  ;
  3189                                  .130			mov	[edx+MEMBLOCK.previousblock],ebx		;set the previous block pointer
  3190                                  			test	ebx,ebx						;is there a previous block?
  3191                                  			jz	.140						;no, branch
  3192                                  			mov	[ebx+MEMBLOCK.nextblock],edx			;set the previous block's next ptr
  3193                                  			jmp	.150						;continue
  3194                                  .140			mov	[esi+MEMROOT.firstfree],edx			;set the new first free ptr
  3195                                  ;
  3196                                  ;	Update the newly allocated block's owner and signature.
  3197                                  ;
  3198                                  .150			mov	edx,EMEMUSERCODE				;user memory signature
  3199                                  			mov	[eax+MEMBLOCK.signature],edx			;set the block signature
  3200                                  			xor	edx,edx						;zero register
  3201                                  			str	dx						;load the task state register
  3202                                  			mov	[eax+MEMBLOCK.owner],edx			;set the block owner
  3203                                  ;
  3204                                  ;	Remove the allocated block from the free block chain and insert it into the user block chain.
  3205                                  ;
  3206                                  			mov	ecx,[esi+MEMROOT.firsttask]			;first task block
  3207                                  .160			jecxz	.180						;branch if at end of chain
  3208                                  			cmp	edx,[ecx+MEMBLOCK.owner]			;does this block belong to the task?
  3209                                  			jb	.180						;branch if block belongs to next task
  3210                                  			je	.170						;branch if block belongs to this task
  3211                                  			mov	ecx,[ecx+MEMBLOCK.nextblock]			;next task block
  3212                                  			jmp	.160						;continue
  3213                                  ;
  3214                                  ;	We have found the start of our task's user block chain or the start of the next task's user block chain. If we
  3215                                  ;	have found the next task's chain, then we have no other user memory for this task and we can simply add the
  3216                                  ;	block here. If we are at the start of our task's user block chain, then we need to further seek for the proper
  3217                                  ;	place to insert the block.
  3218                                  ;
  3219                                  .170			mov	edx,[eax+MEMBLOCK.bytes]			;size of block in bytes
  3220                                  			cmp	edx,[ecx+MEMBLOCK.bytes]			;less or equal to chain block?
  3221                                  			jbe	.180						;yes, branch
  3222                                  			mov	ecx,[ecx+MEMBLOCK.nextblock]			;next chain block address
  3223                                  			test	ecx,ecx						;end of chain?
  3224                                  			jz	.180						;yes, branch
  3225                                  			mov	edx,[eax+MEMBLOCK.owner]			;owning task
  3226                                  			cmp	edx,[ecx+MEMBLOCK.owner]			;same task?
  3227                                  			je	.170						;yes, continue search
  3228                                  ;
  3229                                  ;	We have found the proper place in our task's user-block chain to insert our new user block. It may also be the
  3230                                  ;	end of the user-block chain. To insert our new user block, first we update the next-block pointer. Then, we load
  3231                                  ;	the next-block's previous-block pointer or the global last-user block pointer if we have no next-block. If we
  3232                                  ;	do have a previous-block, we update that block's next-block pointer.
  3233                                  ;
  3234                                  .180			mov	[eax+MEMBLOCK.nextblock],ecx			;set the next task block
  3235                                  			mov	ebx,[esi+MEMROOT.lasttask]			;last task block
  3236                                  			jecxz	.190						;branch if no next-task block
  3237                                  			mov	ebx,[ecx+MEMBLOCK.previousblock]		;next-task's previous-task block
  3238                                  			mov	[ecx+MEMBLOCK.previousblock],eax		;update next-task block's previous-task
  3239                                  			jmp	.200						;continue
  3240                                  .190			mov	[esi+MEMROOT.lasttask],eax			;new block is the last user-block
  3241                                  ;
  3242                                  ;	Now wes tore our previous-block pointer and, if we have a previous-free block, we update that block's next-
  3243                                  ;	block pointer to point to our block. Since our block may now be the first or last user-block, we update the
  3244                                  ;	global first and/or last user-block pointers if necessary.
  3245                                  ;
  3246                                  .200			mov	[eax+MEMBLOCK.previousblock],ebx		;set the previous task block
  3247                                  			test	ebx,ebx						;do we have a previous task block?
  3248                                  			jz	.210						;no, branch
  3249                                  			mov	[ebx+MEMBLOCK.nextblock],eax			;set previous-block's next-task block
  3250                                  			jmp	.220						;continue
  3251                                  .210			mov	[esi+MEMROOT.firsttask],eax			;new block is the first user-block
  3252                                  ;
  3253                                  ;	Restore registers and return to caller.
  3254                                  ;
  3255                                  .220			pop	ds						;restore non-volatie regs
  3256                                  			pop	esi						;
  3257                                  			pop	ecx						;
  3258                                  			pop	ebx						;
  3259                                  			ret							;return
  3260                                  ;-----------------------------------------------------------------------------------------------------------------------
  3261                                  ;
  3262                                  ;	Routine:	FreeMemory
  3263                                  ;
  3264                                  ;	Description:	This routine frees a memory block for the given task. The address provided in EDX points to the
  3265                                  ;			memory block header. The memory block must be USER memory, not a FREE memory block. If the block
  3266                                  ;			is adjacent to a contiguous FREE memory block, then the blocks are merged. The residual FREE
  3267                                  ;			memory is repositioned in the FREE memory block chain according to size. The user portion of the
  3268                                  ;			block, following the block header, is reset (wiped) with the memory wipe value.
  3269                                  ;
  3270                                  ;	In:		EDX	memory block to free, relative to ESELDAT
  3271                                  ;
  3272                                  ;	Out:		EAX	-1	invalid memory block
  3273                                  ;				0	memory block freed
  3274                                  ;
  3275                                  ;-----------------------------------------------------------------------------------------------------------------------
  3276                                  FreeMemory		push	ebx						;save non-volatile regs
  3277                                  			push	ecx						;
  3278                                  			push	esi						;
  3279                                  			push	edi						;
  3280                                  			push	ds						;
  3281                                  			push	es						;
  3282                                  ;
  3283                                  ;	Address the root memory structure
  3284                                  ;
  3285                                  			push	ESELDAT						;load OS data selector ...
  3286                                  			pop	es						;... into extra segment reg
  3287                                  			push	ESELDAT						;load OS data selector ...
  3288                                  			pop	ds						;... into data segment reg
  3289                                  			mov	esi,wsMemRoot					;memory root structure
  3290                                  			mov	edi,edx						;memory block address
  3291                                  ;
  3292                                  ;	If the block is FREE, return success. Otherwise, if it is not USER, return with error.
  3293                                  ;
  3294                                  			xor	eax,eax						;indicate success
  3295                                  			cmp	dword [edi+MEMBLOCK.signature],EMEMFREECODE	;is the block FREE?
  3296                                  			je	.240						;yes, branch
  3297                                  			dec	eax						;indicate failure
  3298                                  			cmp	dword [edi+MEMBLOCK.signature],EMEMUSERCODE	;is the block USER?
  3299                                  			jne	.240						;no, branch
  3300                                  ;-----------------------------------------------------------------------------------------------------------------------
  3301                                  ;
  3302                                  ;	Unlink the USER memory block.
  3303                                  ;
  3304                                  ;-----------------------------------------------------------------------------------------------------------------------
  3305                                  ;
  3306                                  ;	Set the block signature. Reset owner.
  3307                                  ;
  3308                                  			mov	dword [edi+MEMBLOCK.signature],EMEMFREECODE	;set FREE block signature
  3309                                  			xor	eax,eax						;zero register
  3310                                  			mov	[edi+MEMBLOCK.owner],eax			;zero block owner
  3311                                  ;
  3312                                  ;	Wipe user area.
  3313                                  ;
  3314                                  			push	edi						;save block address
  3315                                  			mov	ecx,[edi+MEMBLOCK.bytes]			;block size
  3316                                  			sub	ecx,EMEMBLOCKLEN				;subtract header size
  3317                                  			add	edi,EMEMBLOCKLEN				;point to user area
  3318                                  			mov	al,EMEMWIPEBYTE					;memory wipe byte
  3319                                  			rep	stosb						;clear memory
  3320                                  			pop	edi						;restore block address
  3321                                  ;
  3322                                  ;	Address the preceding and following USER memory blocks
  3323                                  ;
  3324                                  			mov	ebx,[edi+MEMBLOCK.previousblock]		;previous block pointer
  3325                                  			mov	ecx,[edi+MEMBLOCK.nextblock]			;next block pointer
  3326                                  ;
  3327                                  ;	If a USER block precedes this block, update that block's next pointer. Otherwise, update the first task
  3328                                  ;	pointer to point to the USER block following this block.
  3329                                  ;
  3330                                  			test	ebx,ebx						;is there a previous block?
  3331                                  			jz	.10						;no, branch
  3332                                  			mov	[ebx+MEMBLOCK.nextblock],ecx			;update previous block's next pointer
  3333                                  			jmp	.20						;continue
  3334                                  .10			mov	[esi+MEMROOT.firsttask],ecx			;update first USER pointer
  3335                                  ;
  3336                                  ;	If a USER block follows this block, update that block's previous pointer. Otherwise, update the last task
  3337                                  ;	pointer to point to the USER block preceding this block.
  3338                                  ;
  3339                                  .20			jecxz	.30						;branch if no next block
  3340                                  			mov	[ecx+MEMBLOCK.previousblock],ebx		;update next block's previous pointer
  3341                                  			jmp	.40						;continue
  3342                                  .30			mov	[esi+MEMROOT.lasttask],ebx			;update last USER pointer
  3343                                  ;-----------------------------------------------------------------------------------------------------------------------
  3344                                  ;
  3345                                  ;	Merge with a previous contiguous FREE memory block.
  3346                                  ;
  3347                                  ;-----------------------------------------------------------------------------------------------------------------------
  3348                                  ;
  3349                                  ;	Address the preceding and following contiguous memory blocks.
  3350                                  ;
  3351                                  .40			mov	ebx,[edi+MEMBLOCK.previouscontig]		;previous contiguous block ptr
  3352                                  			mov	ecx,[edi+MEMBLOCK.nextcontig]			;next contiguous block ptr
  3353                                  ;
  3354                                  ;	Verify we have a previous contiguous FREE block.
  3355                                  ;
  3356                                  			test	ebx,ebx						;is there a previous block?
  3357                                  			jz	.100						;no, branch
  3358                                  			cmp	dword [ebx+MEMBLOCK.signature],EMEMFREECODE	;is the previous block FREE?
  3359                                  			jne	.100						;no, branch
  3360                                  ;
  3361                                  ;	Update adjacent block's contiguous pointers.
  3362                                  ;
  3363                                  			mov	[ebx+MEMBLOCK.nextcontig],ecx			;update previous contig's next contig
  3364                                  			jecxz	.50						;branch if no next contiguous block
  3365                                  			mov	[ecx+MEMBLOCK.previouscontig],ebx		;update next congit's previous contig
  3366                                  			jmp	.60						;continue
  3367                                  .50			mov	[esi+MEMROOT.lastcontig],ebx			;update last contig pointer
  3368                                  ;
  3369                                  ;	Update the size of the merged FREE block.
  3370                                  ;
  3371                                  .60			mov	eax,[edi+MEMBLOCK.bytes]			;current block size
  3372                                  			add	[ebx+MEMBLOCK.bytes],eax			;update previous block's size
  3373                                  ;
  3374                                  ;	Having merged our new free block into the previous free block, make the previous free block the current block
  3375                                  ;
  3376                                  			mov	ecx,EMEMBLOCKLEN				;block header length
  3377                                  			mov	al,EMEMWIPEBYTE					;memory wipe byte
  3378                                  			rep	stosb						;clear memory header
  3379                                  			mov	edi,ebx						;current block is now previous block
  3380                                  ;-----------------------------------------------------------------------------------------------------------------------
  3381                                  ;
  3382                                  ;	Unlink the previous contiguous FREE memory block
  3383                                  ;
  3384                                  ;-----------------------------------------------------------------------------------------------------------------------
  3385                                  ;
  3386                                  ;	Address the preceding and following USER memory blocks
  3387                                  ;
  3388                                  			mov	ebx,[edi+MEMBLOCK.previousblock]		;previous block pointer
  3389                                  			mov	ecx,[edi+MEMBLOCK.nextblock]			;next block pointer
  3390                                  ;
  3391                                  ;	Update the previous block's next-block pointer if there is a previous block. Otherwise, update the first free
  3392                                  ;	block pointer.
  3393                                  ;
  3394                                  			test	ebx,ebx						;is there a previous block?
  3395                                  			jz	.70						;no, branch
  3396                                  			mov	[ebx+MEMBLOCK.nextblock],ecx			;update previous block's next pointer
  3397                                  			jmp	.80						;branch
  3398                                  .70			mov	[esi+MEMROOT.firstfree],ecx			;update first FREE block pointer
  3399                                  ;
  3400                                  ;	Update the next block's previous-block pointer if there is a next block. Otherwise, update the last free block
  3401                                  ;	pointer.
  3402                                  ;
  3403                                  .80			jecxz	.90						;branch if no next block
  3404                                  			mov	[ecx+MEMBLOCK.previousblock],ebx		;update next block's previous pointer
  3405                                  			jmp	.100						;continue
  3406                                  .90			mov	[esi+MEMROOT.lastfree],ebx			;update last FREE block pointer
  3407                                  ;-----------------------------------------------------------------------------------------------------------------------
  3408                                  ;
  3409                                  ;	Merge with a following contiguous FREE memory block.
  3410                                  ;
  3411                                  ;-----------------------------------------------------------------------------------------------------------------------
  3412                                  ;
  3413                                  ;	Verify we have a following contiguous FREE block.
  3414                                  ;
  3415                                  .100			mov	ecx,[edi+MEMBLOCK.nextcontig]			;next contiguous block ptr
  3416                                  			jecxz	.170						;branch if no next contiguous block
  3417                                  			cmp	dword [ecx+MEMBLOCK.signature],EMEMFREECODE	;is the next-contiguous block free?
  3418                                  			jne	.170						;no, branch
  3419                                  ;
  3420                                  ;	Add the size of the following adjacent FREE block to this block's size.
  3421                                  ;
  3422                                  			mov	eax,[ecx+MEMBLOCK.bytes]			;next contiguous (free) block size
  3423                                  			add	[edi+MEMBLOCK.bytes],eax			;add size to this block's size
  3424                                  ;
  3425                                  ;	Unlink the following contiguous FREE block from the contiguous block chain.
  3426                                  ;
  3427                                  			mov	eax,[ecx+MEMBLOCK.nextcontig]			;following block's next-contig ptr
  3428                                  			mov	[edi+MEMBLOCK.nextcontig],eax			;update this block's next-contig ptr
  3429                                  			test	eax,eax						;does a block follow the next contig blk
  3430                                  			jz	.110						;no, branch
  3431                                  			mov	[eax+MEMBLOCK.previouscontig],edi		;update following block's prev contig
  3432                                  			jmp	.120						;continue
  3433                                  .110			mov	[esi+MEMROOT.lastcontig],edi			;update last contig block ptr
  3434                                  ;-----------------------------------------------------------------------------------------------------------------------
  3435                                  ;
  3436                                  ;	Unlink the following contiguous FREE memory block
  3437                                  ;
  3438                                  ;-----------------------------------------------------------------------------------------------------------------------
  3439                                  ;
  3440                                  ;	Unlink the following adjacent FREE block from the FREE block chain.
  3441                                  ;
  3442                                  .120			push	edi						;save this block
  3443                                  			mov	edi,ecx						;next contiguous block
  3444                                  			push	ecx						;save next contiguous block
  3445                                  ;
  3446                                  ;	Address the preceding and following USER memory blocks
  3447                                  ;
  3448                                  			mov	ebx,[edi+MEMBLOCK.previousblock]		;next contig's previous block pointer
  3449                                  			mov	ecx,[edi+MEMBLOCK.nextblock]			;next contig's next block pointer
  3450                                  ;
  3451                                  ;	Update the previous block's next-block pointer if there is a previous block. Otherwise, update the first free
  3452                                  ;	block pointer.
  3453                                  ;
  3454                                  			test	ebx,ebx						;is there a previous block?
  3455                                  			jz	.130						;no, branch
  3456                                  			mov	[ebx+MEMBLOCK.nextblock],ecx			;update next contig's prev blk next-ptr
  3457                                  			jmp	.140						;branch
  3458                                  .130			mov	[esi+MEMROOT.firstfree],ecx			;update first FREE block pointer
  3459                                  ;
  3460                                  ;	Update the next block's previous-block pointer if there is a next block. Otherwise, update the last free block
  3461                                  ;	pointer.
  3462                                  ;
  3463                                  .140			jecxz	.150						;branch if no next block
  3464                                  			mov	[ecx+MEMBLOCK.previousblock],ebx		;update next contig's next blk prev-ptr
  3465                                  			jmp	.160						;continue
  3466                                  .150			mov	[esi+MEMROOT.lastfree],ebx			;update last FREE block pointer
  3467                                  ;
  3468                                  ;	Clear next contiguous block's header
  3469                                  ;
  3470                                  .160			pop	edi						;next congiguous block pointer
  3471                                  			mov	ecx,EMEMBLOCKLEN				;memory block header length
  3472                                  			mov	al,EMEMWIPEBYTE					;memory wipe byte
  3473                                  			rep	stosb						;clear memory header
  3474                                  			pop	edi						;this block's pointer
  3475                                  ;-----------------------------------------------------------------------------------------------------------------------
  3476                                  ;
  3477                                  ;	Insert the final FREE block back into the block chain.
  3478                                  ;
  3479                                  ;-----------------------------------------------------------------------------------------------------------------------
  3480                                  ;
  3481                                  ;	Walk the FREE memory chain until a block is found that is larger than or equal in size to the block being
  3482                                  ;	inserted. The block being inserted will be inserted before that block or after the last block found if none
  3483                                  ;	all are smaller in size.
  3484                                  ;
  3485                                  .170			mov	ebx,[edi+MEMBLOCK.bytes]			;size of block
  3486                                  			mov	ecx,[esi+MEMROOT.firstfree]			;first free block ptr
  3487                                  .180			jecxz	.190						;exit if no ptr
  3488                                  			cmp	ebx,[ecx+MEMBLOCK.bytes]			;next block bigger?
  3489                                  			jb	.190						;yes, branch
  3490                                  			mov	ecx,[ecx+MEMBLOCK.nextblock]			;next free memory block
  3491                                  			jmp	.180						;continue
  3492                                  ;
  3493                                  ;	Set the next-block pointer. Determine the previous-block, which may be the last FREE block if we found no
  3494                                  ;	larger free block. Update the next block's previous block pointer.
  3495                                  ;
  3496                                  .190			mov	[edi+MEMBLOCK.nextblock],ecx			;set the next block ptr
  3497                                  			mov	ebx,[esi+MEMROOT.lastfree]			;assume all blocks smaller
  3498                                  			jecxz	.200						;branch if no block found
  3499                                  			mov	ebx,[ecx+MEMBLOCK.previousblock]		;next block's previous block ptr
  3500                                  			mov	[ecx+MEMBLOCK.previousblock],edi		;update next block's previous ptr
  3501                                  			jmp	.210						;continue
  3502                                  .200			mov	[esi+MEMROOT.lastfree],edi			;this block is now the last free
  3503                                  ;
  3504                                  ;	Set our previous block pointer to either the previous pointer of the found block or the last free block.
  3505                                  ;	If there is no previous block pointer, then this block now the first FREE block. Otherwise update that block's
  3506                                  ;	next pointer.
  3507                                  ;
  3508                                  .210			mov	[edi+MEMBLOCK.previousblock],ebx		;set the previous block ptr
  3509                                  			test	ebx,ebx						;do we have a previous block?
  3510                                  			jz	.220						;no, branch
  3511                                  			mov	[ebx+MEMBLOCK.nextblock],edi			;update previous block's next block ptr
  3512                                  			jmp	.230						;continue
  3513                                  .220			mov	[esi+MEMROOT.firstfree],edi			;update first free ptr
  3514                                  ;
  3515                                  ;	The memory free has completed.
  3516                                  ;
  3517                                  .230			xor	eax,eax						;indicate success
  3518                                  ;
  3519                                  ;	Restore and return.
  3520                                  ;
  3521                                  .240			pop	es						;restore non-volatile regs
  3522                                  			pop	ds						;
  3523                                  			pop	edi						;
  3524                                  			pop	esi						;
  3525                                  			pop	ecx						;
  3526                                  			pop	ebx						;
  3527                                  			ret							;return
  3528                                  ;=======================================================================================================================
  3529                                  ;
  3530                                  ;	Date and Time Helper Routines
  3531                                  ;
  3532                                  ;	GetYear
  3533                                  ;	IsLeapYear
  3534                                  ;	PutDateString
  3535                                  ;	PutDayString
  3536                                  ;	PutHourString
  3537                                  ;	PutMinuteString
  3538                                  ;	PutMonthString
  3539                                  ;	PutMonthNameString
  3540                                  ;	PutSecondString
  3541                                  ;	PutTimeString
  3542                                  ;	PutWeekdayString
  3543                                  ;	PutWeekdayNameString
  3544                                  ;	PutYearString
  3545                                  ;
  3546                                  ;=======================================================================================================================
  3547                                  ;-----------------------------------------------------------------------------------------------------------------------
  3548                                  ;
  3549                                  ;	Routine:	GetYear
  3550                                  ;
  3551                                  ;	Description:	Return the four-digit year (century * 100 + year of century)
  3552                                  ;
  3553                                  ;	In:		DS:EBX	DATETIME address
  3554                                  ;
  3555                                  ;	Out:		ECX	year
  3556                                  ;
  3557                                  ;-----------------------------------------------------------------------------------------------------------------------
  3558                                  GetYear			movzx	ecx,byte [ebx+DATETIME.century]			;century
  3559                                  			imul	ecx,100						;century * 100
  3560                                  			movzx	eax,byte [ebx+DATETIME.year]			;year of century
  3561                                  			add	ecx,eax						;year (YYYY)
  3562                                  			ret							;return
  3563                                  ;-----------------------------------------------------------------------------------------------------------------------
  3564                                  ;
  3565                                  ;	Routine:	IsLeapYear
  3566                                  ;
  3567                                  ;	Description:	This routine returns an indicator if the current year is a leap year.
  3568                                  ;
  3569                                  ;	In:		DS:EBX	DATETIME ADDRESS
  3570                                  ;
  3571                                  ;	Out:		ECX	0 = not a leap year
  3572                                  ;				1 = leap year
  3573                                  ;
  3574                                  ;-----------------------------------------------------------------------------------------------------------------------
  3575                                  IsLeapYear		call	GetYear						;ECX = YYYY
  3576                                  			mov	eax,ecx						;EAX = YYYY
  3577                                  			xor	ecx,ecx						;assume not leap year
  3578                                  			test	al,00000011b					;multiple of four?
  3579                                  			jnz	.no						;no, branch
  3580                                  			mov	dl,100						;divisor
  3581                                  			div	dl						;divide by 100
  3582                                  			test	ah,ah						;multiple of 100?
  3583                                  			jnz	.yes						;yes, branch
  3584                                  			test	al,00000011b					;multiple of 400?
  3585                                  			jnz	.no						;no, branch
  3586                                  .yes			inc	ecx						;indicate leap
  3587                                  .no			ret							;return
  3588                                  ;-----------------------------------------------------------------------------------------------------------------------
  3589                                  ;
  3590                                  ;	Routine:	PutDateString
  3591                                  ;
  3592                                  ;	Description:	This routine returns an ASCIIZ mm/dd/yyyy string at ds:edx from the date in the DATETIME
  3593                                  ;			structure at ds:ebx.
  3594                                  ;
  3595                                  ;	In:		DS:EBX	DATETIME address
  3596                                  ;			DS:EDX	output buffer address
  3597                                  ;
  3598                                  ;-----------------------------------------------------------------------------------------------------------------------
  3599                                  PutDateString		push	ecx						;save non-volatile regs
  3600                                  			push	edi						;
  3601                                  			push	es						;
  3602                                  			push	ds						;store data selector ...
  3603                                  			pop	es						;... in extra segment reg
  3604                                  			mov	edi,edx						;output buffer address
  3605                                  			mov	cl,10						;divisor
  3606                                  			mov	edx,0002F3030h					;ASCIIZ "00/" (reversed)
  3607                                  			movzx	eax,byte [ebx+DATETIME.month]			;month
  3608                                  			div	cl						;AH = rem; AL = quotient
  3609                                  			or	eax,edx						;apply ASCII zones and delimiter
  3610                                  			cld							;forward strings
  3611                                  			stosd							;store "mm/"nul
  3612                                  			dec	edi						;address of terminator
  3613                                  			movzx	eax,byte [ebx+DATETIME.day]			;day
  3614                                  			div	cl						;AH = rem; AL = quotient
  3615                                  			or	eax,edx						;apply ASCII zones and delimiter
  3616                                  			stosd							;store "dd/"nul
  3617                                  			dec	edi						;address of terminator
  3618                                  			movzx	eax,byte [ebx+DATETIME.century]			;century
  3619                                  			div	cl						;AH = rem; AL = quotient
  3620                                  			or	eax,edx						;apply ASCII zones and delimiter
  3621                                  			stosd							;store "cc/"null
  3622                                  			dec	edi						;address of terminator
  3623                                  			dec	edi						;address of delimiter
  3624                                  			movzx	eax,byte [ebx+DATETIME.year]			;year (yy)
  3625                                  			div	cl						;AH = rem; AL = quotient
  3626                                  			or	eax,edx						;apply ASCII zones and delimiter
  3627                                  			stosb							;store quotient
  3628                                  			mov	al,ah						;remainder
  3629                                  			stosb							;store remainder
  3630                                  			xor	al,al						;null terminator
  3631                                  			stosb							;store terminator
  3632                                  			pop	es						;restore non-volatile regs
  3633                                  			pop	edi						;
  3634                                  			pop	ecx						;
  3635                                  			ret							;return
  3636                                  ;-----------------------------------------------------------------------------------------------------------------------
  3637                                  ;
  3638                                  ;	Routine:	PutDayString
  3639                                  ;
  3640                                  ;	Description:	This routine returns an ASCIIZ dd string at ds:edx from the date in the DATETIME
  3641                                  ;			structure at ds:ebx.
  3642                                  ;
  3643                                  ;	In:		DS:EBX	DATETIME address
  3644                                  ;			DS:EDX	output buffer address
  3645                                  ;
  3646                                  ;-----------------------------------------------------------------------------------------------------------------------
  3647                                  PutDayString		push	ecx						;save non-volatile regs
  3648                                  			movzx	ecx,byte [ebx+DATETIME.day]			;day
  3649                                  			mov	bh,1						;trim leading zeros; no commas
  3650                                  			call	UnsignedToDecimalString				;store ASCII decimal string
  3651                                  			pop	ecx						;
  3652                                  			ret							;return
  3653                                  ;-----------------------------------------------------------------------------------------------------------------------
  3654                                  ;
  3655                                  ;	Routine:	PutHourString
  3656                                  ;
  3657                                  ;	Description:	This routine returns an ASCIIZ hh string at ds:edx from the date in the DATETIME
  3658                                  ;			structure at ds:ebx.
  3659                                  ;
  3660                                  ;	In:		DS:EBX	DATETIME address
  3661                                  ;			DS:EDX	output buffer address
  3662                                  ;
  3663                                  ;-----------------------------------------------------------------------------------------------------------------------
  3664                                  PutHourString		push	ecx						;save non-volatile regs
  3665                                  			movzx	ecx,byte [ebx+DATETIME.hour]			;hour
  3666                                  			mov	bh,1						;trim leading zeros; no commas
  3667                                  			call	UnsignedToDecimalString				;store ASCII decimal string
  3668                                  			pop	ecx						;
  3669                                  			ret							;return
  3670                                  ;-----------------------------------------------------------------------------------------------------------------------
  3671                                  ;
  3672                                  ;	Routine:	PutMinuteString
  3673                                  ;
  3674                                  ;	Description:	This routine returns an ASCIIZ mm string at ds:edx from the date in the DATETIME
  3675                                  ;			structure at ds:ebx.
  3676                                  ;
  3677                                  ;	In:		DS:EBX	DATETIME address
  3678                                  ;			DS:EDX	output buffer address
  3679                                  ;
  3680                                  ;-----------------------------------------------------------------------------------------------------------------------
  3681                                  PutMinuteString		push	ecx						;save non-volatile regs
  3682                                  			movzx	ecx,byte [ebx+DATETIME.minute]			;minute
  3683                                  			mov	bh,1						;trim leading zeros; no commas
  3684                                  			call	UnsignedToDecimalString				;store ASCII decimal string
  3685                                  			pop	ecx						;
  3686                                  			ret							;return
  3687                                  ;-----------------------------------------------------------------------------------------------------------------------
  3688                                  ;
  3689                                  ;	Routine:	PutMonthString
  3690                                  ;
  3691                                  ;	Description:	This routine returns an ASCIIZ mm string at ds:edx from the date in the DATETIME
  3692                                  ;			structure at ds:ebx.
  3693                                  ;
  3694                                  ;	In:		DS:EBX	DATETIME address
  3695                                  ;			DS:EDX	output buffer address
  3696                                  ;
  3697                                  ;-----------------------------------------------------------------------------------------------------------------------
  3698                                  PutMonthString		push	ecx						;save non-volatile regs
  3699                                  			movzx	ecx,byte [ebx+DATETIME.month]			;month
  3700                                  			mov	bh,1						;trim leading zeros; no commas
  3701                                  			call	UnsignedToDecimalString				;store ASCII decimal string
  3702                                  			pop	ecx						;
  3703                                  			ret							;return
  3704                                  ;-----------------------------------------------------------------------------------------------------------------------
  3705                                  ;
  3706                                  ;	Routine:	PutMonthNameString
  3707                                  ;
  3708                                  ;	Description:	This routine returns an ASCIIZ name(mm) string at ds:edx from the date in the DATETIME
  3709                                  ;			structure at ds:ebx.
  3710                                  ;
  3711                                  ;	In:		DS:EBX	DATETIME address
  3712                                  ;			DS:EDX	output buffer address
  3713                                  ;
  3714                                  ;-----------------------------------------------------------------------------------------------------------------------
  3715                                  PutMonthNameString	push	esi						;save non-volatile regs
  3716                                  			push	edi						;
  3717                                  			push	ds						;
  3718                                  			push	es						;
  3719                                  			push	ds						;load data selector ...
  3720                                  			pop	es						;... into extra segment
  3721                                  			mov	edi,edx						;output buffer address
  3722                                  			movzx	eax,byte [ebx+DATETIME.month]			;month (1-12)
  3723                                  			dec	eax						;month (0-11)
  3724                                  			shl	eax,2						;offset into month name lookup table
  3725                                  			push	cs						;load code selector ...
  3726                                  			pop	ds						;... into data segment
  3727                                  			mov	esi,[tMonthNames+eax]				;month name address
  3728                                  			cld							;forward strings
  3729                                  .10			lodsb							;name character
  3730                                  			stosb							;store in output buffer
  3731                                  			test	al,al						;end of string?
  3732                                  			jnz	.10						;no, continue
  3733                                  			pop	es						;restore non-volatile regs
  3734                                  			pop	ds						;
  3735                                  			pop	edi						;
  3736                                  			pop	esi						;
  3737                                  			ret							;return
  3738                                  ;-----------------------------------------------------------------------------------------------------------------------
  3739                                  ;
  3740                                  ;	Routine:	PutSecondString
  3741                                  ;
  3742                                  ;	Description:	This routine returns an ASCIIZ ss string at ds:edx from the date in the DATETIME
  3743                                  ;			structure at ds:ebx.
  3744                                  ;
  3745                                  ;	In:		DS:EBX	DATETIME address
  3746                                  ;			DS:EDX	output buffer address
  3747                                  ;
  3748                                  ;-----------------------------------------------------------------------------------------------------------------------
  3749                                  PutSecondString		push	ecx						;save non-volatile regs
  3750                                  			movzx	ecx,byte [ebx+DATETIME.second]			;second
  3751                                  			mov	bh,1						;trim leading zeros; no commas
  3752                                  			call	UnsignedToDecimalString				;store ASCII decimal string
  3753                                  			pop	ecx						;
  3754                                  			ret							;return
  3755                                  ;-----------------------------------------------------------------------------------------------------------------------
  3756                                  ;
  3757                                  ;	Routine:	PutTimeString
  3758                                  ;
  3759                                  ;	Description:	This routine returns an ASCIIZ hh:mm:ss string at ds:edx from the date in the DATETIME
  3760                                  ;			structure at ds:ebx.
  3761                                  ;
  3762                                  ;	In:		DS:EBX	DATETIME address
  3763                                  ;			DS:EDX	output buffer address
  3764                                  ;
  3765                                  ;-----------------------------------------------------------------------------------------------------------------------
  3766                                  PutTimeString		push	ecx						;save non-volatile regs
  3767                                  			push	edi						;
  3768                                  			push	es						;
  3769                                  			push	ds						;store data selector ...
  3770                                  			pop	es						;... in extra segment reg
  3771                                  			mov	edi,edx						;output buffer address
  3772                                  			mov	cl,10						;divisor
  3773                                  			mov	edx,003a3030h					;ASCIIZ "00:" (reversed)
  3774                                  			movzx	eax,byte [ebx+DATETIME.hour]			;hour
  3775                                  			div	cl						;ah = rem; al = quotient
  3776                                  			or	eax,edx						;apply ASCII zones and delimiter
  3777                                  			cld							;forward strings
  3778                                  			stosd							;store "mm/"nul
  3779                                  			dec	edi						;address of terminator
  3780                                  			movzx	eax,byte [ebx+DATETIME.minute]			;minute
  3781                                  			div	cl						;ah = rem; al = quotient
  3782                                  			or	eax,edx						;apply ASCII zones and delimiter
  3783                                  			stosd							;store "dd/"nul
  3784                                  			dec	edi						;address of terminator
  3785                                  			movzx	eax,byte [ebx+DATETIME.second]			;second
  3786                                  			div	cl						;ah = rem; al = quotient
  3787                                  			or	eax,edx						;apply ASCII zones and delimiter
  3788                                  			stosb							;store quotient
  3789                                  			mov	al,ah						;remainder
  3790                                  			stosb							;store remainder
  3791                                  			xor	al,al						;null terminator
  3792                                  			stosb							;store terminator
  3793                                  			pop	es						;restore non-volatile regs
  3794                                  			pop	edi						;
  3795                                  			pop	ecx						;
  3796                                  			ret							;return
  3797                                  ;-----------------------------------------------------------------------------------------------------------------------
  3798                                  ;
  3799                                  ;	Routine:	PutWeekdayString
  3800                                  ;
  3801                                  ;	Description:	This routine returns an ASCIIZ weekday string at ds:edx from the date in the DATETIME
  3802                                  ;			structure at ds:ebx.
  3803                                  ;
  3804                                  ;	In:		DS:EBX	DATETIME address
  3805                                  ;			DS:EDX	output buffer address
  3806                                  ;
  3807                                  ;-----------------------------------------------------------------------------------------------------------------------
  3808                                  PutWeekdayString	push	ecx						;save non-volatile regs
  3809                                  			movzx	ecx,byte [ebx+DATETIME.weekday]			;weekday
  3810                                  			mov	bh,1						;trim leading zeros; no commas
  3811                                  			call	UnsignedToDecimalString				;store ASCII decimal string
  3812                                  			pop	ecx						;
  3813                                  			ret							;return
  3814                                  ;-----------------------------------------------------------------------------------------------------------------------
  3815                                  ;
  3816                                  ;	Routine:	PutWeekdayNameString
  3817                                  ;
  3818                                  ;	Description:	This routine returns an ASCIIZ name(weekday) string at ds:edx from the date in the DATETIME
  3819                                  ;			structure at ds:ebx.
  3820                                  ;
  3821                                  ;	In:		DS:EBX	DATETIME address
  3822                                  ;			DS:EDX	output buffer address
  3823                                  ;
  3824                                  ;-----------------------------------------------------------------------------------------------------------------------
  3825                                  PutWeekdayNameString	push	esi						;save non-volatile regs
  3826                                  			push	edi						;
  3827                                  			push	ds						;
  3828                                  			push	es						;
  3829                                  			push	ds						;load data selector ...
  3830                                  			pop	es						;... into extra segment
  3831                                  			mov	edi,edx						;output buffer address
  3832                                  			movzx	eax,byte [ebx+DATETIME.weekday]			;weekday (0-6)
  3833                                  			shl	eax,2						;offset into day name lookup table
  3834                                  			push	cs						;load code selector ...
  3835                                  			pop	ds						;... into data segment
  3836                                  			mov	esi,[tDayNames+eax]				;day name address
  3837                                  			cld							;forward strings
  3838                                  .10			lodsb							;name character
  3839                                  			stosb							;store in output buffer
  3840                                  			test	al,al						;end of string?
  3841                                  			jnz	.10						;no, continue
  3842                                  			pop	es						;restore non-volatile regs
  3843                                  			pop	ds						;
  3844                                  			pop	edi						;
  3845                                  			pop	esi						;
  3846                                  			ret							;return
  3847                                  ;-----------------------------------------------------------------------------------------------------------------------
  3848                                  ;
  3849                                  ;	Routine:	PutYearString
  3850                                  ;
  3851                                  ;	Description:	This routine returns an ASCIIZ yyyy string at ds:edx from the date in the DATETIME
  3852                                  ;			structure at ds:ebx.
  3853                                  ;
  3854                                  ;	In:		DS:EBX	DATETIME address
  3855                                  ;			DS:EDX	output buffer address
  3856                                  ;
  3857                                  ;-----------------------------------------------------------------------------------------------------------------------
  3858                                  PutYearString		push	ecx						;save non-volatile regs
  3859                                  			call	GetYear						;ECX = YYYY
  3860                                  			mov	bh,1						;trim leading zeros; no commas
  3861                                  			call	UnsignedToDecimalString				;store decimal string at DS:EDX
  3862                                  			pop	ecx						;restore non-volatile regs
  3863                                  			ret							;return
  3864                                  ;-----------------------------------------------------------------------------------------------------------------------
  3865                                  ;
  3866                                  ;	Day Names
  3867                                  ;
  3868                                  ;-----------------------------------------------------------------------------------------------------------------------
  3869                                  czSunday		db	"Sunday",0
  3870                                  czMonday		db	"Monday",0
  3871                                  czTuesday		db	"Tuesday",0
  3872                                  czWednesday		db	"Wednesday",0
  3873                                  czThursday		db	"Thursday",0
  3874                                  czFriday		db	"Friday",0
  3875                                  czSaturday		db	"Saturday",0
  3876                                  ;-----------------------------------------------------------------------------------------------------------------------
  3877                                  ;
  3878                                  ;	Month Names
  3879                                  ;
  3880                                  ;-----------------------------------------------------------------------------------------------------------------------
  3881                                  czJanuary		db	"January",0
  3882                                  czFebruary		db	"February",0
  3883                                  czMarch			db	"March",0
  3884                                  czApril			db	"April",0
  3885                                  czMay			db	"May",0
  3886                                  czJune			db	"June",0
  3887                                  czJuly			db	"July",0
  3888                                  czAugust		db	"August",0
  3889                                  czSeptember		db	"September",0
  3890                                  czOctober		db	"October",0
  3891                                  czNovember		db	"November",0
  3892                                  czDecember		db	"December",0
  3893                                  ;-----------------------------------------------------------------------------------------------------------------------
  3894                                  ;
  3895                                  ;	Day Names Lookup Table
  3896                                  ;
  3897                                  ;-----------------------------------------------------------------------------------------------------------------------
  3898                                  			align	4
  3899                                  tDayNames		equ	$
  3900                                  			dd	czSunday
  3901                                  			dd	czMonday
  3902                                  			dd	czTuesday
  3903                                  			dd	czWednesday
  3904                                  			dd	czThursday
  3905                                  			dd	czFriday
  3906                                  			dd	czSaturday
  3907                                  EDAYNAMESTBLL		equ	($-tDayNames)
  3908                                  EDAYNAMESTBLCNT		equ	EDAYNAMESTBLL/4
  3909                                  ;-----------------------------------------------------------------------------------------------------------------------
  3910                                  ;
  3911                                  ;	Month Names Lookup Table
  3912                                  ;
  3913                                  ;-----------------------------------------------------------------------------------------------------------------------
  3914                                  			align	4
  3915                                  tMonthNames		equ	$
  3916                                  			dd	czJanuary
  3917                                  			dd	czFebruary
  3918                                  			dd	czMarch
  3919                                  			dd	czApril
  3920                                  			dd	czMay
  3921                                  			dd	czJune
  3922                                  			dd	czJuly
  3923                                  			dd	czAugust
  3924                                  			dd	czSeptember
  3925                                  			dd	czOctober
  3926                                  			dd	czNovember
  3927                                  			dd	czDecember
  3928                                  EMONTHNAMESTBLL		equ	($-tMonthNames)
  3929                                  EMONTHNAMESTBLCNT	equ	EMONTHNAMESTBLL/4
  3930                                  ;=======================================================================================================================
  3931                                  ;
  3932                                  ;	String Helper Routines
  3933                                  ;
  3934                                  ;	UpperCaseString
  3935                                  ;	CompareMemory
  3936                                  ;	CopyMemory
  3937                                  ;
  3938                                  ;=======================================================================================================================
  3939                                  ;-----------------------------------------------------------------------------------------------------------------------
  3940                                  ;
  3941                                  ;	Routine:	UpperCaseString
  3942                                  ;
  3943                                  ;	Description:	This routine places all characters in the given string to upper case.
  3944                                  ;
  3945                                  ;	In:		DS:EDX	string address
  3946                                  ;
  3947                                  ;	Out:		EDX	string address
  3948                                  ;
  3949                                  ;-----------------------------------------------------------------------------------------------------------------------
  3950                                  UpperCaseString		push	esi						;save non-volatile regs
  3951                                  			mov	esi,edx						;string address
  3952                                  			cld							;forward strings
  3953                                  .10			lodsb							;string character
  3954                                  			test	al,al						;null?
  3955                                  			jz	.20						;yes, skip ahead
  3956                                  			cmp	al,EASCIILOWERA					;lower-case? (lower bounds)
  3957                                  			jb	.10						;no, continue
  3958                                  			cmp	al,EASCIILOWERZ					;lower-case? (upper bounds)
  3959                                  			ja	.10						;no, continue
  3960                                  			and	al,EASCIICASEMASK				;mask for upper case
  3961                                  			mov	[esi-1],al					;upper character
  3962                                  			jmp	.10						;continue
  3963                                  .20			pop	esi						;restore non-volatile regs
  3964                                  			ret							;return
  3965                                  ;-----------------------------------------------------------------------------------------------------------------------
  3966                                  ;
  3967                                  ;	Routine:	CompareMemory
  3968                                  ;
  3969                                  ;	Description:	This routine compares two byte arrays.
  3970                                  ;
  3971                                  ;	In:		DS:EDX	first source address
  3972                                  ;			DS:EBX	second source address
  3973                                  ;			ECX	comparison length
  3974                                  ;
  3975                                  ;	Out:		EDX	first source address
  3976                                  ;			EBX	second source address
  3977                                  ;			ECX	0	array 1 = array 2
  3978                                  ;				<0	array 1 < array 2
  3979                                  ;				>0	array 1 > array 2
  3980                                  ;
  3981                                  ;-----------------------------------------------------------------------------------------------------------------------
  3982                                  CompareMemory		push	esi						;save non-volatile regs
  3983                                  			push	edi						;
  3984                                  			push	es						;
  3985                                  			push	ds						;copy DS
  3986                                  			pop	es						;... to ES
  3987                                  			mov	esi,edx						;first source address
  3988                                  			mov	edi,ebx						;second source address
  3989                                  			cld							;forward strings
  3990                                  			rep	cmpsb						;compare bytes
  3991                                  			mov	al,0						;default result
  3992                                  			jz	.10						;branch if arrays equal
  3993                                  			mov	al,1						;positive result
  3994                                  			jnc	.10						;branch if target > source
  3995                                  			mov	al,-1						;negative result
  3996                                  .10			movsx	ecx,al						;extend sign
  3997                                  			pop	es						;restore non-volatile regs
  3998                                  			pop	edi						;
  3999                                  			pop	esi						;
  4000                                  			ret							;return
  4001                                  ;-----------------------------------------------------------------------------------------------------------------------
  4002                                  ;
  4003                                  ;	Routine:	CopyMemory
  4004                                  ;
  4005                                  ;	Description:	This routine copies a byte array.
  4006                                  ;
  4007                                  ;	In:		DS:EDX	first source address
  4008                                  ;			DS:EBX	second source address
  4009                                  ;			ECX	copy length
  4010                                  ;
  4011                                  ;-----------------------------------------------------------------------------------------------------------------------
  4012                                  CopyMemory		push	ecx						;save non-volatile regs
  4013                                  			push	esi						;
  4014                                  			push	edi						;
  4015                                  			push	es						;
  4016                                  ;
  4017                                  ;	Compare byte array
  4018                                  ;
  4019                                  			push	ds						;load data selector
  4020                                  			pop	es						;... into ES register
  4021                                  			mov	esi,edx						;first source address
  4022                                  			mov	edi,ebx						;second source address
  4023                                  			cld							;forward strings
  4024                                  			rep	movsb						;copy bytes
  4025                                  ;
  4026                                  ;	Restore and return
  4027                                  ;
  4028                                  			pop	es						;restore non-volatile regs
  4029                                  			pop	edi						;
  4030                                  			pop	esi						;
  4031                                  			pop	ecx						;
  4032                                  			ret							;return
  4033                                  ;=======================================================================================================================
  4034                                  ;
  4035                                  ;	Console Helper Routines
  4036                                  ;
  4037                                  ;	PutConsoleString
  4038                                  ;	GetConsoleString
  4039                                  ;	GetConsoleChar
  4040                                  ;	Yield
  4041                                  ;	PreviousConsoleColumn
  4042                                  ;	NextConsoleColumn
  4043                                  ;	FirstConsoleColumn
  4044                                  ;	NextConsoleRow
  4045                                  ;	PutConsoleChar
  4046                                  ;	PutConsoleOIAShift
  4047                                  ;	PutConsoleOIAChar
  4048                                  ;	PutConsoleHexByte
  4049                                  ;
  4050                                  ;=======================================================================================================================
  4051                                  ;-----------------------------------------------------------------------------------------------------------------------
  4052                                  ;
  4053                                  ;	Routine:	PutConsoleString
  4054                                  ;
  4055                                  ;	Description:	This routine writes a sequence of ASCII characters to the console until null and updates the
  4056                                  ;			console position as needed.
  4057                                  ;
  4058                                  ;	In:		EDX	source address
  4059                                  ;			DS	OS data selector
  4060                                  ;
  4061                                  ;-----------------------------------------------------------------------------------------------------------------------
  4062                                  PutConsoleString	push	esi						;save non-volatile regs
  4063                                  			mov	esi,edx						;source address
  4064                                  			cld							;forward strings
  4065                                  .10			lodsb							;ASCII character
  4066                                  			or	al,al						;end of string?
  4067                                  			jz	.40						;yes, skip ahead
  4068                                  			cmp	al,EASCIIRETURN					;carriage return?
  4069                                  			jne	.20						;no, skip ahead
  4070                                  			call	FirstConsoleColumn				;move to start of row
  4071                                  			jmp	.10						;next character
  4072                                  .20			cmp	al,EASCIILINEFEED				;line feed?
  4073                                  			jne	.30						;no, skip ahead
  4074                                  			call	NextConsoleRow					;move to next row
  4075                                  			jmp	.10						;next character
  4076                                  .30			call	PutConsoleChar					;output character to console
  4077                                  			call	NextConsoleColumn				;advance to next column
  4078                                  			jmp	.10						;next character
  4079                                  .40			pop	esi						;restore non-volatile regs
  4080                                  			ret							;return
  4081                                  ;-----------------------------------------------------------------------------------------------------------------------
  4082                                  ;
  4083                                  ;	Routine:	GetConsoleString
  4084                                  ;
  4085                                  ;	Description:	This routine accepts keyboard input into a buffer.
  4086                                  ;
  4087                                  ;	In:		DS:EDX	target buffer address
  4088                                  ;			ECX	maximum number of characters to accept
  4089                                  ;			BH	echo to terminal
  4090                                  ;			BL	terminating character
  4091                                  ;
  4092                                  ;-----------------------------------------------------------------------------------------------------------------------
  4093                                  GetConsoleString	push	ecx						;save non-volatile regs
  4094                                  			push	esi						;
  4095                                  			push	edi						;
  4096                                  			push	es						;
  4097                                  			push	ds						;load data segment selector ...
  4098                                  			pop	es						;... into extra segment register
  4099                                  			mov	edi,edx						;edi = target buffer
  4100                                  			push	ecx						;save maximum characters
  4101                                  			xor	al,al						;zero register
  4102                                  			cld							;forward strings
  4103                                  			rep	stosb						;zero fill buffer
  4104                                  			pop	ecx						;maximum characters
  4105                                  			mov	edi,edx						;edi = target buffer
  4106                                  			mov	esi,edx						;esi = target buffer
  4107                                  .10			jecxz	.50						;exit if max-length is zero
  4108                                  .20			call	GetConsoleChar					;al = next input char
  4109                                  			cmp	al,bl						;is this the terminator?
  4110                                  			je	.50						;yes, exit
  4111                                  			cmp	al,EASCIIBACKSPACE				;is this a backspace?
  4112                                  			jne	.30						;no, skip ahead
  4113                                  			cmp	esi,edi						;at start of buffer?
  4114                                  			je	.20						;yes, get next character
  4115                                  			dec	edi						;backup target pointer
  4116                                  			mov	byte [edi],0					;zero previous character
  4117                                  			inc	ecx						;increment remaining chars
  4118                                  			test	bh,1						;echo to console?
  4119                                  			jz	.20						;no, get next character
  4120                                  			call	PreviousConsoleColumn				;backup console position
  4121                                  			mov	al,EASCIISPACE					;ASCII space
  4122                                  			call	PutConsoleChar					;write space to console
  4123                                  			call	PlaceCursor					;position the cursor
  4124                                  			jmp	.20						;get next character
  4125                                  .30			cmp	al,EASCIISPACE					;printable? (lower bounds)
  4126                                  			jb	.20						;no, get another character
  4127                                  			cmp	al,EASCIITILDE					;printable? (upper bounds)
  4128                                  			ja	.20						;no, get another character
  4129                                  			stosb							;store character in buffer
  4130                                  			test	bh,1						;echo to console?
  4131                                  			jz	.40						;no, skip ahead
  4132                                  			call	PutConsoleChar					;write character to console
  4133                                  			call	NextConsoleColumn				;advance console position
  4134                                  			call	PlaceCursor					;position the cursor
  4135                                  .40			dec	ecx						;decrement remaining chars
  4136                                  			jmp	.10						;next
  4137                                  .50			xor	al,al						;null
  4138                                  			stosb							;terminate buffer
  4139                                  			pop	es						;restore non-volatile regs
  4140                                  			pop	edi						;
  4141                                  			pop	esi						;
  4142                                  			pop	ecx						;
  4143                                  			ret							;return
  4144                                  ;-----------------------------------------------------------------------------------------------------------------------
  4145                                  ;
  4146                                  ;	Routine:	GetConsoleChar
  4147                                  ;
  4148                                  ;	Description:	This routine waits for EMSGKEYCHAR message and return character code.
  4149                                  ;
  4150                                  ;	Out:		AL	ASCII character code
  4151                                  ;			AH	keyboard scan code
  4152                                  ;
  4153                                  ;-----------------------------------------------------------------------------------------------------------------------
  4154                                  GetConsoleChar.10	call	Yield						;pass control or halt
  4155                                  GetConsoleChar		call	GetMessage					;get the next message
  4156                                  			or	eax,eax						;do we have a message?
  4157                                  			jz	GetConsoleChar.10				;no, skip ahead
  4158                                  			push	eax						;save key codes
  4159                                  			and	eax,0FFFF0000h					;mask for message type
  4160                                  			cmp	eax,EMSGKEYCHAR					;key-char message?
  4161                                  			pop	eax						;restore key codes
  4162                                  			jne	GetConsoleChar					;no, try again
  4163                                  			and	eax,0000ffffh					;mask for key codes
  4164                                  			ret							;return
  4165                                  ;-----------------------------------------------------------------------------------------------------------------------
  4166                                  ;
  4167                                  ;	Routine:	Yield
  4168                                  ;
  4169                                  ;	Description:	This routine passes control to the next ready task or enter halt.
  4170                                  ;
  4171                                  ;-----------------------------------------------------------------------------------------------------------------------
  4172                                  Yield			sti							;enable maskagle interrupts
  4173                                  			hlt							;halt until external interrupt
  4174                                  			ret							;return
  4175                                  ;-----------------------------------------------------------------------------------------------------------------------
  4176                                  ;
  4177                                  ;	Routine:	PreviousConsoleColumn
  4178                                  ;
  4179                                  ;	Description:	This routine retreats the cursor one logical column. If the cursor was at the start of a row,
  4180                                  ;			the column is set to the last position in the row and the row is decremented.
  4181                                  ;
  4182                                  ;	In:		DS	OS data selector
  4183                                  ;
  4184                                  ;-----------------------------------------------------------------------------------------------------------------------
  4185                                  PreviousConsoleColumn	mov	al,[wbConsoleColumn]				;current column
  4186                                  			or	al,al						;start of row?
  4187                                  			jnz	.10						;no, skip ahead
  4188                                  			mov	ah,[wbConsoleRow]				;current row
  4189                                  			or	ah,ah						;top of screen?
  4190                                  			jz	.20						;yes, exit with no change
  4191                                  			dec	ah						;decrement row
  4192                                  			mov	[wbConsoleRow],ah				;save row
  4193                                  			mov	al,ECONCOLS					;set maximum column
  4194                                  .10			dec	al						;decrement column
  4195                                  			mov	[wbConsoleColumn],al				;save column
  4196                                  .20			ret							;return
  4197                                  ;-----------------------------------------------------------------------------------------------------------------------
  4198                                  ;
  4199                                  ;	Routine:	NextConsoleColumn
  4200                                  ;
  4201                                  ;	Description:	This routine advances the console position one column. The columnn is reset to zero and the row
  4202                                  ;			incremented if the end of the current row is reached.
  4203                                  ;
  4204                                  ;	In:		DS	OS data selector
  4205                                  ;
  4206                                  ;-----------------------------------------------------------------------------------------------------------------------
  4207                                  NextConsoleColumn	mov	al,[wbConsoleColumn]				;current column
  4208                                  			inc	al						;increment column
  4209                                  			mov	[wbConsoleColumn],al				;save column
  4210                                  			cmp	al,ECONCOLS					;end of row?
  4211                                  			jb	.10						;no, skip ahead
  4212                                  			call	FirstConsoleColumn				;reset column to start of row
  4213                                  			call	NextConsoleRow					;line feed to next row
  4214                                  .10			ret							;return
  4215                                  ;-----------------------------------------------------------------------------------------------------------------------
  4216                                  ;
  4217                                  ;	Routine:	FirstConsoleColumn
  4218                                  ;
  4219                                  ;	Description:	This routine resets the console column to start of the row.
  4220                                  ;
  4221                                  ;	In:		DS	OS data selector
  4222                                  ;
  4223                                  ;-----------------------------------------------------------------------------------------------------------------------
  4224                                  FirstConsoleColumn	xor	al,al						;zero column
  4225                                  			mov	[wbConsoleColumn],al				;save column
  4226                                  			ret							;return
  4227                                  ;-----------------------------------------------------------------------------------------------------------------------
  4228                                  ;
  4229                                  ;	Routine:	NextConsoleRow
  4230                                  ;
  4231                                  ;	Description:	This routine advances the console position one line. Scroll the screen one row if needed.
  4232                                  ;
  4233                                  ;	In:		DS	OS data selector
  4234                                  ;
  4235                                  ;-----------------------------------------------------------------------------------------------------------------------
  4236                                  NextConsoleRow		mov	al,[wbConsoleRow]				;current row
  4237                                  			inc	al						;increment row
  4238                                  			mov	[wbConsoleRow],al				;save row
  4239                                  			cmp	al,ECONROWS					;end of screen?
  4240                                  			jb	.10						;no, skip ahead
  4241                                  			call	ScrollConsoleRow				;scroll up one row
  4242                                  			mov	al,[wbConsoleRow]				;row
  4243                                  			dec	al						;decrement row
  4244                                  			mov	[wbConsoleRow],al				;save row
  4245                                  .10			ret							;return
  4246                                  ;-----------------------------------------------------------------------------------------------------------------------
  4247                                  ;
  4248                                  ;	Routine:	PutConsoleChar
  4249                                  ;
  4250                                  ;	Description:	This routine writes one ASCII character to the console screen.
  4251                                  ;
  4252                                  ;	In:		AL	ASCII character
  4253                                  ;			DS	OS data selector
  4254                                  ;
  4255                                  ;-----------------------------------------------------------------------------------------------------------------------
  4256                                  PutConsoleChar		push	ecx						;save non-volatile regs
  4257                                  			push	es						;
  4258                                  			push	ESELCGA						;load CGA selector ...
  4259                                  			pop	es						;... into extra segment reg
  4260                                  			mov	cl,[wbConsoleColumn]				;column
  4261                                  			mov	ch,[wbConsoleRow]				;row
  4262                                  			call	SetConsoleChar					;put character at row, column
  4263                                  			pop	es						;restore non-volatile regs
  4264                                  			pop	ecx						;
  4265                                  			ret							;return
  4266                                  ;-----------------------------------------------------------------------------------------------------------------------
  4267                                  ;
  4268                                  ;	Routine:	PutConsoleOIAShift
  4269                                  ;
  4270                                  ;	Description:	This routine updates the shift/ctrl/alt/lock indicators in the operator information area (OIA).
  4271                                  ;
  4272                                  ;	In:		BL	shift flags
  4273                                  ;			BH	lock flags
  4274                                  ;			DS	OS data selector
  4275                                  ;
  4276                                  ;-----------------------------------------------------------------------------------------------------------------------
  4277                                  PutConsoleOIAShift	push	ecx						;save non-volatile regs
  4278                                  			push	es						;
  4279                                  			push	ESELCGA						;load CGA selector ...
  4280                                  			pop	es						;... into ES register
  4281                                  			mov	ch,ECONOIAROW					;OIA row
  4282                                  			mov	al,EASCIISPACE					;space is default character
  4283                                  			test	bl,EKEYFSHIFTLEFT				;left-shift indicated?
  4284                                  			jz	.10						;no, skip ahead
  4285                                  			mov	al,'S'						;yes, indicate with 'S'
  4286                                  .10			mov	cl,14						;indicator column
  4287                                  			call	SetConsoleChar					;display ASCII character
  4288                                  			mov	al,EASCIISPACE					;ASCII space
  4289                                  			test	bl,EKEYFSHIFTRIGHT				;right-shift indicated?
  4290                                  			jz	.20						;no, skip ahead
  4291                                  			mov	al,'S'						;yes, indicate with 'S'
  4292                                  .20			mov	cl,64						;indicator column
  4293                                  			call	SetConsoleChar					;display ASCII character
  4294                                  			mov	al,EASCIISPACE					;ASCII space
  4295                                  			test	bl,EKEYFCTRLLEFT				;left-ctrl indicated?
  4296                                  			jz	.30						;no, skip ahead
  4297                                  			mov	al,'C'						;yes, indicate with 'C'
  4298                                  .30			mov	cl,15						;indicator column
  4299                                  			call	SetConsoleChar					;display ASCII character
  4300                                  			mov	al,EASCIISPACE					;ASCII space
  4301                                  			test	bl,EKEYFCTRLRIGHT				;right-ctrl indicated?
  4302                                  			jz	.40						;no, skip ahead
  4303                                  			mov	al,'C'						;yes, indicate with 'C'
  4304                                  .40			mov	cl,63						;indicator column
  4305                                  			call	SetConsoleChar					;display ASCII character
  4306                                  			mov	al,EASCIISPACE					;ASCII space
  4307                                  			test	bl,EKEYFALTLEFT					;left-alt indicated?
  4308                                  			jz	.50						;no, skip ahead
  4309                                  			mov	al,'A'						;yes, indicate with 'A'
  4310                                  .50			mov	cl,16						;indicator column
  4311                                  			call	SetConsoleChar					;display ASCII character
  4312                                  			mov	al,EASCIISPACE					;ASCII space
  4313                                  			test	bl,EKEYFALTRIGHT				;right-alt indicated?
  4314                                  			jz	.60						;no, skip ahead
  4315                                  			mov	al,'A'						;yes, indicate with 'A'
  4316                                  .60			mov	cl,62						;indicator column
  4317                                  			call	SetConsoleChar					;display ASCII character
  4318                                  			mov	al,EASCIISPACE					;ASCII space
  4319                                  			test	bh,EKEYFLOCKCAPS				;caps-lock indicated?
  4320                                  			jz	.70						;no, skip ahead
  4321                                  			mov	al,'C'						;yes, indicate with 'C'
  4322                                  .70			mov	cl,78						;indicator column
  4323                                  			call	SetConsoleChar					;display ASCII character
  4324                                  			mov	al,EASCIISPACE					;ASCII space
  4325                                  			test	bh,EKEYFLOCKNUM					;num-lock indicated?
  4326                                  			jz	.80						;no, skip ahead
  4327                                  			mov	al,'N'						;yes, indicate with 'N'
  4328                                  .80			mov	cl,77						;indicator column
  4329                                  			call	SetConsoleChar					;display ASCII character
  4330                                  			mov	al,EASCIISPACE					;ASCII space
  4331                                  			test	bh,EKEYFLOCKSCROLL				;scroll-lock indicated?
  4332                                  			jz	.90						;no, skip ahead
  4333                                  			mov	al,'S'						;yes, indicate with 'S'
  4334                                  .90			mov	cl,76						;indicator column
  4335                                  			call	SetConsoleChar					;display ASCII character
  4336                                  			pop	es						;restore non-volatile regs
  4337                                  			pop	ecx						;
  4338                                  			ret							;return
  4339                                  ;-----------------------------------------------------------------------------------------------------------------------
  4340                                  ;
  4341                                  ;	Routine:	PutConsoleOIAChar
  4342                                  ;
  4343                                  ;	Description:	This routine updates the Operator Information Area (OIA).
  4344                                  ;
  4345                                  ;	In:		DS	OS data selector
  4346                                  ;
  4347                                  ;-----------------------------------------------------------------------------------------------------------------------
  4348                                  PutConsoleOIAChar	push	ebx						;save non-volatile regs
  4349                                  			push	ecx						;
  4350                                  			push	esi						;
  4351                                  			push	ds						;
  4352                                  			push	es						;
  4353                                  			push	ESELDAT						;load OS data selector ...
  4354                                  			pop	ds						;... into data segment register
  4355                                  			push	ESELCGA						;load CGA selector ...
  4356                                  			pop	es						;... into extra segment register
  4357                                  			mov	esi,wbConsoleScan0				;scan codes address
  4358                                  			mov	bh,ECONOIAROW					;OIA row
  4359                                  			mov	bl,0						;starting column
  4360                                  			mov	ecx,6						;maximum scan codes
  4361                                  .10			push	ecx						;save remaining count
  4362                                  			mov	ecx,ebx						;row, column
  4363                                  			lodsb							;read scan code
  4364                                  			or	al,al						;scan code present?
  4365                                  			jz	.20						;no, skip ahead
  4366                                  			call	PutConsoleHexByte				;display scan code
  4367                                  			jmp	.30						;continue
  4368                                  .20			mov	al,' '						;ASCII space
  4369                                  			call	SetConsoleChar					;display space
  4370                                  			mov	al,' '						;ASCII space
  4371                                  			call	SetConsoleChar					;display space
  4372                                  .30			add	bl,2						;next column (+2)
  4373                                  			pop	ecx						;restore remaining
  4374                                  			loop	.10						;next code
  4375                                  			mov	al,[wbConsoleChar]				;console ASCII character
  4376                                  			cmp	al,32						;printable? (lower-bounds)
  4377                                  			jb	.40						;no, skip ahead
  4378                                  			cmp	al,126						;printable? (upper-bounds)
  4379                                  			ja	.40						;no, skip ahead
  4380                                  			mov	ch,bh						;OIA row
  4381                                  			mov	cl,40						;character display column
  4382                                  			call	SetConsoleChar					;display ASCII character
  4383                                  .40			pop	es						;restore non-volatile regs
  4384                                  			pop	ds						;
  4385                                  			pop	esi						;
  4386                                  			pop	ecx						;
  4387                                  			pop	ebx						;
  4388                                  			ret							;return
  4389                                  ;-----------------------------------------------------------------------------------------------------------------------
  4390                                  ;
  4391                                  ;	Routine:	PutConsoleHexDword
  4392                                  ;
  4393                                  ;	Description:	This routine writes eight ASCII characters to the console representing a doubleword value.
  4394                                  ;
  4395                                  ;	In:		EAX	value
  4396                                  ;			CL	column
  4397                                  ;			CH	row
  4398                                  ;			DS	OS data selector
  4399                                  ;			ES	CGA selector
  4400                                  ;
  4401                                  ;-----------------------------------------------------------------------------------------------------------------------
  4402                                  PutConsoleHexDword	push	eax
  4403                                  			shr	eax,16
  4404                                  			call	PutConsoleHexWord
  4405                                  			pop	eax
  4406                                  			call	PutConsoleHexWord
  4407                                  			ret
  4408                                  ;-----------------------------------------------------------------------------------------------------------------------
  4409                                  ;
  4410                                  ;	Routine:	PutConsoleHexWord
  4411                                  ;
  4412                                  ;	Description:	This routine writes four ASCII characters to the console representing a word value.
  4413                                  ;
  4414                                  ;	In:		EAX	value
  4415                                  ;			CL	column
  4416                                  ;			CH	row
  4417                                  ;			DS	OS data selector
  4418                                  ;			ES	CGA selector
  4419                                  ;
  4420                                  ;-----------------------------------------------------------------------------------------------------------------------
  4421                                  PutConsoleHexWord	push	eax
  4422                                  			shr	eax,8
  4423                                  			call	PutConsoleHexByte
  4424                                  			pop	eax
  4425                                  			call	PutConsoleHexByte
  4426                                  			ret
  4427                                  ;-----------------------------------------------------------------------------------------------------------------------
  4428                                  ;
  4429                                  ;	Routine:	PutConsoleHexByte
  4430                                  ;
  4431                                  ;	Description:	This routine writes two ASCII characters to the console representing a byte value.
  4432                                  ;
  4433                                  ;	In:		AL	byte value
  4434                                  ;			CL	column
  4435                                  ;			CH	row
  4436                                  ;			DS	OS data selector
  4437                                  ;			ES	CGA selector
  4438                                  ;
  4439                                  ;-----------------------------------------------------------------------------------------------------------------------
  4440                                  PutConsoleHexByte	push	ebx						;save non-volatile regs
  4441                                  			mov	bl,al						;save byte value
  4442                                  			shr	al,4						;hi-order nybble
  4443                                  			or	al,030h						;apply ASCII zone
  4444                                  			cmp	al,03ah						;numeric?
  4445                                  			jb	.10						;yes, skip ahead
  4446                                  			add	al,7						;add ASCII offset for alpha
  4447                                  .10			call	SetConsoleChar					;display ASCII character
  4448                                  			mov	al,bl						;byte value
  4449                                  			and	al,0fh						;lo-order nybble
  4450                                  			or	al,30h						;apply ASCII zone
  4451                                  			cmp	al,03ah						;numeric?
  4452                                  			jb	.20						;yes, skip ahead
  4453                                  			add	al,7						;add ASCII offset for alpha
  4454                                  .20			call	SetConsoleChar					;display ASCII character
  4455                                  			pop	ebx						;restore non-volatile regs
  4456                                  			ret							;return
  4457                                  ;=======================================================================================================================
  4458                                  ;
  4459                                  ;	Data-Type Conversion Helper Routines
  4460                                  ;
  4461                                  ;	UnsignedToDecimalString
  4462                                  ;	ByteToDecimalString
  4463                                  ;	UnsignedToHexadecimal
  4464                                  ;	DecimalToUnsigned
  4465                                  ;	HexadecimalToUnsigned
  4466                                  ;
  4467                                  ;=======================================================================================================================
  4468                                  ;-----------------------------------------------------------------------------------------------------------------------
  4469                                  ;
  4470                                  ;	Routine:	UnsignedToDecimalString
  4471                                  ;
  4472                                  ;	Description:	This routine creates an ASCIIZ string representing the decimal value of 32-bit binary input.
  4473                                  ;
  4474                                  ;	Input:		BH	flags		bit 0: 1 = trim leading zeros
  4475                                  ;						bit 1: 1 = include comma grouping delimiters
  4476                                  ;						bit 4: 1 = non-zero digit found (internal)
  4477                                  ;			ECX	32-bit binary
  4478                                  ;			DS:EDX	output buffer address
  4479                                  ;
  4480                                  ;-----------------------------------------------------------------------------------------------------------------------
  4481                                  UnsignedToDecimalString push	ebx						;save non-volatile regs
  4482                                  			push	ecx						;
  4483                                  			push	edi						;
  4484                                  			push	es						;
  4485                                  			push	ds						;load data selector
  4486                                  			pop	es						;... into extra segment reg
  4487                                  			mov	edi,edx 					;output buffer address
  4488                                  			and	bh,00001111b					;zero internal flags
  4489                                  			mov	edx,ecx 					;binary
  4490                                  			mov	ecx,1000000000					;10^9 divisor
  4491                                  			call	.30						;divide and store
  4492                                  			mov	ecx,100000000					;10^8 divisor
  4493                                  			call	.10						;divide and store
  4494                                  			mov	ecx,10000000					;10^7 divisor
  4495                                  			call	.30						;divide and store
  4496                                  			mov	ecx,1000000					;10^6 divisor
  4497                                  			call	.30						;divide and store
  4498                                  			mov	ecx,100000					;10^5 divisor
  4499                                  			call	.10						;divide and store
  4500                                  			mov	ecx,10000					;10^4 divisor
  4501                                  			call	.30						;divide and store
  4502                                  			mov	ecx,1000					;10^3 divisor
  4503                                  			call	.30						;divide and store
  4504                                  			mov	ecx,100 					;10^2 divisor
  4505                                  			call	.10						;divide and store
  4506                                  			mov	ecx,10						;10^2 divisor
  4507                                  			call	.30						;divide and store
  4508                                  			mov	eax,edx 					;10^1 remainder
  4509                                  			call	.40						;store
  4510                                  			xor	al,al						;null terminator
  4511                                  			stosb
  4512                                  			pop	es						;restore non-volatile regs
  4513                                  			pop	edi						;
  4514                                  			pop	ecx						;
  4515                                  			pop	ebx						;
  4516                                  			ret							;return
  4517                                  .10			test	bh,00000010b					;comma group delims?
  4518                                  			jz	.30						;no, branch
  4519                                  			test	bh,00000001b					;trim leading zeros?
  4520                                  			jz	.20						;no, store delim
  4521                                  			test	bh,00010000b					;non-zero found?
  4522                                  			jz	.30						;no, branch
  4523                                  .20			mov	al,','						;delimiter
  4524                                  			stosb							;store delimiter
  4525                                  .30			mov	eax,edx 					;lo-orer dividend
  4526                                  			xor	edx,edx 					;zero hi-order
  4527                                  			div	ecx						;divide by power of 10
  4528                                  			test	al,al						;zero?
  4529                                  			jz	.50						;yes, branch
  4530                                  			or	bh,00010000b					;non-zero found
  4531                                  .40			or	al,30h						;ASCII zone
  4532                                  			stosb							;store digit
  4533                                  			ret							;return
  4534                                  .50			test	bh,00000001b					;trim leading zeros?
  4535                                  			jz	.40						;no, store and continue
  4536                                  			test	bh,00010000b					;non-zero found?
  4537                                  			jnz	.40						;yes, store and continue
  4538                                  			ret							;return
  4539                                  ;-----------------------------------------------------------------------------------------------------------------------
  4540                                  ;
  4541                                  ;	Routine:	ByteToDecimalString
  4542                                  ;
  4543                                  ;	Description:	This routine outputs an ASCIIZ string representing the decimal value of 8-bit binary input
  4544                                  ;
  4545                                  ;	Input:		BH	flags		bit 0: 1 = trim leading zeros
  4546                                  ;						bit 1: 1 = left pad with spaces
  4547                                  ;						bit 4: 1 = non-zero digit found (internal)
  4548                                  ;			CL	8-bit binary
  4549                                  ;			DS:EDX	output buffer address
  4550                                  ;
  4551                                  ;-----------------------------------------------------------------------------------------------------------------------
  4552                                  ByteToDecimalString	push	ebx						;save non-volatile regs
  4553                                  			push	ecx						;
  4554                                  			push	edi						;
  4555                                  			push	es						;
  4556                                  			push	ds						;copy data segment selector
  4557                                  			pop	es						;... into extra segment selector
  4558                                  			mov	edi,edx						;output buffer address
  4559                                  			and	bh,00001111b					;zero internal flags
  4560                                  			mov	ah,cl						;8-bit binary value
  4561                                  			mov	cl,100						;divisor
  4562                                  			cld							;forward strings
  4563                                  			call	.10						;divide and store
  4564                                  			mov	cl,10						;divisor
  4565                                  			call	.10						;divide and store
  4566                                  			mov	al,ah						;remainder
  4567                                  			call	.20						;store
  4568                                  			xor	al,al						;null
  4569                                  			stosb							;terminate string
  4570                                  			pop	es						;restore non-volatile regs
  4571                                  			pop	edi						;
  4572                                  			pop	ecx						;
  4573                                  			pop	ebx						;
  4574                                  			ret							;return
  4575                                  .10			mov	al,ah						;last remainder (or starting value)
  4576                                  			xor	ah,ah						;zero hi-order dividend
  4577                                  			div	cl						;divide by power or 10
  4578                                  			test	al,al						;zero?
  4579                                  			jz	.40						;yes, branch
  4580                                  			or	bh,00010000b					;non-zero found
  4581                                  .20			or	al,30h						;ASCII zone
  4582                                  .30			stosb							;store digit
  4583                                  			ret							;return
  4584                                  .40			test	bh,00000001b					;trim leading zeros?
  4585                                  			jz	.20						;no, store and continue
  4586                                  			test	bh,00010000b					;non-zero found?
  4587                                  			jnz	.20						;yes, store and continue
  4588                                  			mov	al,' '						;space
  4589                                  			test	bh,00000010b					;left pad with spaces?
  4590                                  			jnz	.30						;yes, store space and continue
  4591                                  			ret							;return
  4592                                  ;-----------------------------------------------------------------------------------------------------------------------
  4593                                  ;
  4594                                  ;	Routine:	UnsignedToHexadecimal
  4595                                  ;
  4596                                  ;	Description:	This routine creates an ASCIIZ string representing the hexadecimal value of binary input
  4597                                  ;
  4598                                  ;	Input:		DS:EDX	output buffer address
  4599                                  ;			ECX	32-bit binary
  4600                                  ;
  4601                                  ;-----------------------------------------------------------------------------------------------------------------------
  4602                                  UnsignedToHexadecimal	push	edi						;store non-volatile regs
  4603                                  			mov	edi,edx						;output buffer address
  4604                                  			mov	edx,ecx						;32-bit unsigned
  4605                                  			xor	ecx,ecx						;zero register
  4606                                  			mov	cl,8						;nybble count
  4607                                  .10			rol	edx,4						;next hi-order nybble in bits 0-3
  4608                                  			mov	al,dl						;????bbbb
  4609                                  			and	al,0fh						;mask out bits 4-7
  4610                                  			or	al,30h						;mask in ascii zone
  4611                                  			cmp	al,3ah						;A through F?
  4612                                  			jb	.20						;no, skip ahead
  4613                                  			add	al,7						;41h through 46h
  4614                                  .20			stosb							;store hexnum
  4615                                  			loop	.10						;next nybble
  4616                                  			xor	al,al						;zero reg
  4617                                  			stosb							;null terminate
  4618                                  			pop	edi						;restore non-volatile regs
  4619                                  			ret							;return
  4620                                  ;-----------------------------------------------------------------------------------------------------------------------
  4621                                  ;
  4622                                  ;	Routine:	DecimalToUnsigned
  4623                                  ;
  4624                                  ;	Description:	This routine returns an unsigned integer of the value of the input ASCIIZ decimal string.
  4625                                  ;
  4626                                  ;	Input:		DS:EDX	null-terminated decimal string address
  4627                                  ;
  4628                                  ;	Output: 	EAX	unsigned integer value
  4629                                  ;
  4630                                  ;-----------------------------------------------------------------------------------------------------------------------
  4631                                  DecimalToUnsigned	push	esi						;save non-volatile regs
  4632                                  			mov	esi,edx						;source address
  4633                                  			xor	edx,edx						;zero total
  4634                                  .10			lodsb							;source byte
  4635                                  			cmp	al,','						;comma?
  4636                                  			je	.10						;yes, ignore
  4637                                  			test	al,al						;end of string?
  4638                                  			jz	.30						;yes, done
  4639                                  			cmp	al,'.'						;decimal point?
  4640                                  			je	.30						;yes, done
  4641                                  			cmp	al,'0'						;numeral?
  4642                                  			jb	.20						;no, invalid string
  4643                                  			cmp	al,'9'						;numeral?
  4644                                  			ja	.20						;no, invalid string
  4645                                  			and	al,00Fh						;mask ASCII zone
  4646                                  			push	eax						;save numeral
  4647                                  			shl	edx,1						;total * 2
  4648                                  			mov	eax,edx						;total * 2
  4649                                  			shl	edx,2						;total * 8
  4650                                  			add	edx,eax						;total * 10
  4651                                  			pop	eax						;restore numeral
  4652                                  			add	edx,eax						;accumulate decimal digit
  4653                                  			xor	eax,eax						;zero register
  4654                                  			jmp	.10						;next
  4655                                  .20			xor	edx,edx						;zero result on error
  4656                                  .30			mov	eax,edx						;result
  4657                                  			pop	esi						;restore non-volatile regs
  4658                                  			ret							;return
  4659                                  ;-----------------------------------------------------------------------------------------------------------------------
  4660                                  ;
  4661                                  ;	Routine:	HexadecimalToUnsigned
  4662                                  ;
  4663                                  ;	Description:	This routine returns an unsigned integer of the value of the input ASCIIZ hexadecimal string.
  4664                                  ;
  4665                                  ;	Input:		DS:EDX	null-terminated hexadecimal string address
  4666                                  ;
  4667                                  ;	Output: 	EAX	unsigned integer value
  4668                                  ;
  4669                                  ;-----------------------------------------------------------------------------------------------------------------------
  4670                                  HexadecimalToUnsigned	push	esi						;save non-volatile regs
  4671                                  			mov	esi,edx						;source address
  4672                                  			xor	edx,edx						;zero register
  4673                                  .10			lodsb							;source byte
  4674                                  			test	al,al						;end of string?
  4675                                  			jz	.30						;yes, branch
  4676                                  			cmp	al,'9'						;hexadecimal?
  4677                                  			jna	.20						;no, skip ahead
  4678                                  			sub	al,37h						;'A' = 41h, less 37h = 0Ah
  4679                                  .20			and	eax,0fh						;remove ascii zone
  4680                                  			shl	edx,4						;previous total x 16
  4681                                  			add	edx,eax						;add prior value x 16
  4682                                  			jmp	.10						;next
  4683                                  .30			mov	eax,edx						;result
  4684                                  			pop	esi						;restore non-volatile regs
  4685                                  			ret							;return
  4686                                  ;=======================================================================================================================
  4687                                  ;
  4688                                  ;	Message Queue Helper Routines
  4689                                  ;
  4690                                  ;	PutMessage
  4691                                  ;	GetMessage
  4692                                  ;
  4693                                  ;=======================================================================================================================
  4694                                  ;-----------------------------------------------------------------------------------------------------------------------
  4695                                  ;
  4696                                  ;	Routine:	PutMessage
  4697                                  ;
  4698                                  ;	Description:	This routine adda a message to the message queue.
  4699                                  ;
  4700                                  ;	In:		EAX	message queue selector
  4701                                  ;			ECX	hi-order data word
  4702                                  ;			EDX	lo-order data word
  4703                                  ;
  4704                                  ;	Out:		CY	0 = success
  4705                                  ;				1 = fail: queue is full
  4706                                  ;
  4707                                  ;-----------------------------------------------------------------------------------------------------------------------
  4708                                  PutMessage		push	ds						;save non-volatile regs
  4709                                  			push	eax						;load task message queue selector ...
  4710                                  			pop	ds						;... into data segment register
  4711                                  			mov	eax,[MQTail]					;tail ptr
  4712                                  			cmp	dword [eax],0					;is queue full?
  4713                                  			stc							;assume failure
  4714                                  			jne	.20						;yes, cannot store
  4715                                  			mov	[eax],edx					;store lo-order data
  4716                                  			mov	[eax+4],ecx					;store hi-order data
  4717                                  			add	eax,8						;next queue element adr
  4718                                  			and	eax,03fch					;at end of queue?
  4719                                  			jnz	.10						;no, skip ahead
  4720                                  			mov	al,8						;reset to top of queue
  4721                                  .10			mov	[MQTail],eax					;save new tail ptr
  4722                                  			clc							;indicate success
  4723                                  .20			pop	ds						;restore non-volatile regs
  4724                                  			ret							;return
  4725                                  ;-----------------------------------------------------------------------------------------------------------------------
  4726                                  ;
  4727                                  ;	Routine:	GetMessage
  4728                                  ;
  4729                                  ;	Description:	This routine reads and removes a message from the message queue.
  4730                                  ;
  4731                                  ;	Out:		EAX	lo-order message data
  4732                                  ;			EDX	hi-order message data
  4733                                  ;
  4734                                  ;			CY	0 = message read
  4735                                  ;				1 = no message to read
  4736                                  ;
  4737                                  ;-----------------------------------------------------------------------------------------------------------------------
  4738                                  GetMessage		push	ebx						;save non-volatile regs
  4739                                  			push	ecx						;
  4740                                  			push	ds						;
  4741                                  			push	ESELMQ						;load message queue selector ...
  4742                                  			pop	ds						;... into data segment register
  4743                                  			mov	ebx,[MQHead]					;head ptr
  4744                                  			mov	eax,[ebx]					;lo-order 32 bits
  4745                                  			mov	edx,[ebx+4]					;hi-order 32 bits
  4746                                  			or	eax,edx						;is queue empty?
  4747                                  			stc							;assume queue is emtpy
  4748                                  			jz	.20						;yes, skip ahead
  4749                                  			xor	ecx,ecx						;store zero
  4750                                  			mov	[ebx],ecx					;... in lo-order dword
  4751                                  			mov	[ebx+4],ecx					;... in hi-order dword
  4752                                  			add	ebx,8						;next queue element
  4753                                  			and	ebx,03fch					;at end of queue?
  4754                                  			jnz	.10						;no, skip ahead
  4755                                  			mov	bl,8						;reset to 1st entry
  4756                                  .10			mov	[MQHead],ebx					;save new head ptr
  4757                                  			clc							;indicate message read
  4758                                  .20			pop	ds						;restore non-volatile regs
  4759                                  			pop	ecx						;
  4760                                  			pop	ebx						;
  4761                                  			ret							;return
  4762                                  ;=======================================================================================================================
  4763                                  ;
  4764                                  ;	Memory-Mapped Video Routines
  4765                                  ;
  4766                                  ;	These routines read and/or write directly to CGA video memory (B800:0)
  4767                                  ;
  4768                                  ;	ClearConsoleScreen
  4769                                  ;	ScrollConsoleRow
  4770                                  ;	SetConsoleChar
  4771                                  ;
  4772                                  ;=======================================================================================================================
  4773                                  ;-----------------------------------------------------------------------------------------------------------------------
  4774                                  ;
  4775                                  ;	Routine:	ClearConsoleScreen
  4776                                  ;
  4777                                  ;	Description:	This routine clears the console (CGA) screen.
  4778                                  ;
  4779                                  ;-----------------------------------------------------------------------------------------------------------------------
  4780                                  ClearConsoleScreen	push	ecx						;save non-volatile regs
  4781                                  			push	edi						;
  4782                                  			push	ds						;
  4783                                  			push	es						;
  4784                                  			push	ESELDAT						;load OS Data selector ...
  4785                                  			pop	ds						;... into DS register
  4786                                  			push	ESELCGA						;load CGA selector ...
  4787                                  			pop	es						;... into ES register
  4788                                  			mov	eax,ECONCLEARDWORD				;initializtion value
  4789                                  			mov	ecx,ECONROWDWORDS*(ECONROWS)			;double-words to clear
  4790                                  			xor	edi,edi						;target offset
  4791                                  			cld							;forward strings
  4792                                  			rep	stosd						;reset screen body
  4793                                  			mov	eax,ECONOIADWORD				;OIA attribute and space
  4794                                  			mov	ecx,ECONROWDWORDS				;double-words per row
  4795                                  			rep	stosd						;reset OIA line
  4796                                  			xor	al,al						;zero register
  4797                                  			mov	[wbConsoleRow],al				;reset console row
  4798                                  			mov	[wbConsoleColumn],al				;reset console column
  4799                                  			call	PlaceCursor					;place cursor at current position
  4800                                  			pop	es						;restore non-volatile regs
  4801                                  			pop	ds						;
  4802                                  			pop	edi						;
  4803                                  			pop	ecx						;
  4804                                  			ret							;return
  4805                                  ;-----------------------------------------------------------------------------------------------------------------------
  4806                                  ;
  4807                                  ;	Routine:	ScrollConsoleRow
  4808                                  ;
  4809                                  ;	Description:	This routine scrolls the console (text) screen up one row.
  4810                                  ;
  4811                                  ;-----------------------------------------------------------------------------------------------------------------------
  4812                                  ScrollConsoleRow	push	ecx						;save non-volatile regs
  4813                                  			push	esi						;
  4814                                  			push	edi						;
  4815                                  			push	ds						;
  4816                                  			push	es						;
  4817                                  			push	ESELCGA						;load CGA video selector ...
  4818                                  			pop	ds						;... into DS
  4819                                  			push	ESELCGA						;load CGA video selector ...
  4820                                  			pop	es						;... into ES
  4821                                  			mov	ecx,ECONROWDWORDS*(ECONROWS-1)			;double-words to move
  4822                                  			mov	esi,ECONROWBYTES				;esi = source (line 2)
  4823                                  			xor	edi,edi						;edi = target (line 1)
  4824                                  			cld							;forward strings
  4825                                  			rep	movsd						;move 24 lines up
  4826                                  			mov	eax,ECONCLEARDWORD				;attribute and ASCII space
  4827                                  			mov	ecx,ECONROWDWORDS				;double-words per row
  4828                                  			rep	stosd						;clear bottom row
  4829                                  			pop	es						;restore non-volatile regs
  4830                                  			pop	ds						;
  4831                                  			pop	edi						;
  4832                                  			pop	esi						;
  4833                                  			pop	ecx						;
  4834                                  			ret							;return
  4835                                  ;-----------------------------------------------------------------------------------------------------------------------
  4836                                  ;
  4837                                  ;	Routine:	SetConsoleString
  4838                                  ;
  4839                                  ;	Description:	This routine outputs a sequence of ASCII character at the given row and column.
  4840                                  ;
  4841                                  ;	In:		ESI	source offset (DS:)
  4842                                  ;			CL	column
  4843                                  ;			CH	row
  4844                                  ;			ES	CGA selector
  4845                                  ;
  4846                                  ;-----------------------------------------------------------------------------------------------------------------------
  4847                                  SetConsoleString	push	esi						;save non-volatile regs
  4848                                  			cld							;forward strings
  4849                                  .10			lodsb							;next ASCII character
  4850                                  			test	al,al						;end of string?
  4851                                  			jz	.20						;yes, branch
  4852                                  			call	SetConsoleChar					;store character
  4853                                  			jmp	.10						;continue
  4854                                  .20			pop	esi						;restore non-volatile regs
  4855                                  			ret							;return
  4856                                  ;-----------------------------------------------------------------------------------------------------------------------
  4857                                  ;
  4858                                  ;	Routine:	SetConsoleChar
  4859                                  ;
  4860                                  ;	Description:	This routine outputs an ASCII character at the given row and column.
  4861                                  ;
  4862                                  ;	In:		AL	ASCII character
  4863                                  ;			CL	column
  4864                                  ;			CH	row
  4865                                  ;			ES	CGA selector
  4866                                  ;
  4867                                  ;	Out:		EAX	last target address written (ES:)
  4868                                  ;			CL	column + 1
  4869                                  ;
  4870                                  ;-----------------------------------------------------------------------------------------------------------------------
  4871                                  SetConsoleChar		mov	dl,al						;ASCII character
  4872                                  			movzx	eax,ch						;row
  4873                                  			mov	ah,ECONCOLS					;cols/row
  4874                                  			mul	ah						;row * cols/row
  4875                                  			add	al,cl						;add column
  4876                                  			adc	ah,0						;handle carry
  4877                                  			shl	eax,1						;screen offset
  4878                                  			mov	[es:eax],dl					;store character
  4879                                  			inc	cl						;next column
  4880                                  			ret							;return
  4881                                  ;=======================================================================================================================
  4882                                  ;
  4883                                  ;	Input/Output Routines
  4884                                  ;
  4885                                  ;	These routines read and/or write directly to ports.
  4886                                  ;
  4887                                  ;	PlaceCursor
  4888                                  ;	PutPrimaryEndOfInt
  4889                                  ;	PutSecondaryEndOfInt
  4890                                  ;	ReadRealTimeClock
  4891                                  ;	ResetSystem
  4892                                  ;	SetKeyboardLamps
  4893                                  ;	WaitForKeyInBuffer
  4894                                  ;	WaitForKeyOutBuffer
  4895                                  ;
  4896                                  ;=======================================================================================================================
  4897                                  ;-----------------------------------------------------------------------------------------------------------------------
  4898                                  ;
  4899                                  ;	Routine:	PlaceCursor
  4900                                  ;
  4901                                  ;	Description:	This routine positions the cursor on the console.
  4902                                  ;
  4903                                  ;	In:		DS	OS data selector
  4904                                  ;
  4905                                  ;-----------------------------------------------------------------------------------------------------------------------
  4906                                  PlaceCursor		push	ecx						;save non-volatile regs
  4907                                  			mov	al,[wbConsoleRow]				;al = row
  4908                                  			mov	ah,ECONCOLS					;ah = cols/row
  4909                                  			mul	ah						;row offset
  4910                                  			add	al,[wbConsoleColumn]				;add column
  4911                                  			adc	ah,0						;add overflow
  4912                                  			mov	ecx,eax						;screen offset
  4913                                  			mov	dl,ECRTPORTLO					;crt controller port lo
  4914                                  			mov	dh,ECRTPORTHI					;crt controller port hi
  4915                                  			mov	al,ECRTCURLOCHI					;crt cursor loc reg hi
  4916                                  			out	dx,al						;select register
  4917                                  			inc	edx						;data port
  4918                                  			mov	al,ch						;hi-order cursor loc
  4919                                  			out	dx,al						;store hi-order loc
  4920                                  			dec	edx						;register select port
  4921                                  			mov	al,ECRTCURLOCLO					;crt cursor loc reg lo
  4922                                  			out	dx,al						;select register
  4923                                  			inc	edx						;data port
  4924                                  			mov	al,cl						;lo-order cursor loc
  4925                                  			out	dx,al						;store lo-order loc
  4926                                  			pop	ecx						;restore non-volatile regs
  4927                                  			ret							;return
  4928                                  ;-----------------------------------------------------------------------------------------------------------------------
  4929                                  ;
  4930                                  ;	Routine:	PutPrimaryEndOfInt
  4931                                  ;
  4932                                  ;	Description:	This routine sends a non-specific end-of-interrupt signal to the primary PIC.
  4933                                  ;
  4934                                  ;-----------------------------------------------------------------------------------------------------------------------
  4935                                  PutPrimaryEndOfInt	sti							;enable maskable interrupts
  4936                                  			mov	al,EPICEOI					;non-specific end-of-interrupt
  4937                                  			out	EPICPORTPRI,al					;send EOI to primary PIC
  4938                                  			ret							;return
  4939                                  ;-----------------------------------------------------------------------------------------------------------------------
  4940                                  ;
  4941                                  ;	Routine:	PutSecondaryEndOfInt
  4942                                  ;
  4943                                  ;	Description:	This routine sends a non-specific end-of-interrupt signal to the secondary PIC.
  4944                                  ;
  4945                                  ;-----------------------------------------------------------------------------------------------------------------------
  4946                                  PutSecondaryEndOfInt	sti							;enable maskable interrupts
  4947                                  			mov	al,EPICEOI					;non-specific end-of-interrupt
  4948                                  			out	EPICPORTSEC,al					;send EOI to secondary PIC
  4949                                  			ret							;return
  4950                                  ;-----------------------------------------------------------------------------------------------------------------------
  4951                                  ;
  4952                                  ;	Routine:	ReadRealTimeClock
  4953                                  ;
  4954                                  ;	Description:	This routine gets current date time from the real-time clock.
  4955                                  ;
  4956                                  ;	In:		DS:EBX	DATETIME structure
  4957                                  ;
  4958                                  ;-----------------------------------------------------------------------------------------------------------------------
  4959                                  ReadRealTimeClock	push	esi						;save non-volatile regs
  4960                                  			push	edi						;
  4961                                  			push	es						;
  4962                                  			push	ds						;store data selector ...
  4963                                  			pop	es						;... in es register
  4964                                  			mov	edi,ebx						;date-time structure
  4965                                  			mov	al,ERTCSECONDREG				;second register
  4966                                  			out	ERTCREGPORT,al					;select second register
  4967                                  			in	al,ERTCDATAPORT					;read second register
  4968                                  			cld							;forward strings
  4969                                  			stosb							;store second value
  4970                                  			mov	al,ERTCMINUTEREG				;minute register
  4971                                  			out	ERTCREGPORT,al					;select minute register
  4972                                  			in	al,ERTCDATAPORT					;read minute register
  4973                                  			stosb							;store minute value
  4974                                  			mov	al,ERTCHOURREG					;hour register
  4975                                  			out	ERTCREGPORT,al					;select hour register
  4976                                  			in	al,ERTCDATAPORT					;read hour register
  4977                                  			stosb							;store hour value
  4978                                  			mov	al,ERTCWEEKDAYREG				;weekday register
  4979                                  			out	ERTCREGPORT,al					;select weekday register
  4980                                  			in	al,ERTCDATAPORT					;read weekday register
  4981                                  			stosb							;store weekday value
  4982                                  			mov	al,ERTCDAYREG					;day register
  4983                                  			out	ERTCREGPORT,al					;select day register
  4984                                  			in	al,ERTCDATAPORT					;read day register
  4985                                  			stosb							;store day value
  4986                                  			mov	al,ERTCMONTHREG					;month register
  4987                                  			out	ERTCREGPORT,al					;select month register
  4988                                  			in	al,ERTCDATAPORT					;read month register
  4989                                  			stosb							;store month value
  4990                                  			mov	al,ERTCYEARREG					;year register
  4991                                  			out	ERTCREGPORT,al					;select year register
  4992                                  			in	al,ERTCDATAPORT					;read year register
  4993                                  			stosb							;store year value
  4994                                  			mov	al,ERTCCENTURYREG				;century register
  4995                                  			out	ERTCREGPORT,al					;select century register
  4996                                  			in	al,ERTCDATAPORT					;read century register
  4997                                  			stosb							;store century value
  4998                                  			mov	al,ERTCSTATUSREG				;status register
  4999                                  			out	ERTCREGPORT,al					;select status register
  5000                                  			in	al,ERTCDATAPORT					;read status register
  5001                                  			test	al,ERTCBINARYVALS				;test if values are binary
  5002                                  			jnz	.20						;skip ahead if binary values
  5003                                  			mov	esi,ebx						;date-time structure address
  5004                                  			mov	edi,ebx						;date-time structure address
  5005                                  			mov	ecx,8						;loop counter
  5006                                  .10			lodsb							;BCD value
  5007                                  			mov	ah,al						;BCD value
  5008                                  			and	al,00001111b					;low-order decimal zone
  5009                                  			and	ah,11110000b					;hi-order decimal zone
  5010                                  			shr	ah,1						;hi-order decimal * 8
  5011                                  			add	al,ah						;low-order + hi-order * 8
  5012                                  			shr	ah,2						;hi-order decimal * 2
  5013                                  			add	al,ah						;low-order + hi-order * 10
  5014                                  			stosb							;replace BCD with binary
  5015                                  			loop	.10						;next value
  5016                                  .20			pop	es						;restore non-volatile regs
  5017                                  			pop	edi						;
  5018                                  			pop	esi						;
  5019                                  			ret							;return
  5020                                  ;-----------------------------------------------------------------------------------------------------------------------
  5021                                  ;
  5022                                  ;	Routine:	ResetSystem
  5023                                  ;
  5024                                  ;	Description:	This routine restarts the system using the 8042 controller.
  5025                                  ;
  5026                                  ;	Out:		N/A	This routine does not return.
  5027                                  ;
  5028                                  ;-----------------------------------------------------------------------------------------------------------------------
  5029                                  ResetSystem		mov	ecx,001fffffh					;delay to clear ints
  5030                                  			loop	$						;clear interrupts
  5031                                  			mov	al,EKEYBCMDRESET				;mask out bit zero
  5032                                  			out	EKEYBPORTSTAT,al				;drive bit zero low
  5033                                  .10			sti							;enable maskable interrupts
  5034                                  			hlt							;halt until interrupt
  5035                                  			jmp	.10						;repeat until reset kicks in
  5036                                  ;-----------------------------------------------------------------------------------------------------------------------
  5037                                  ;
  5038                                  ;	Routine:	SetKeyboardLamps
  5039                                  ;
  5040                                  ;	Description:	This routine sends the set/reset mode indicators command to the keyboard device.
  5041                                  ;
  5042                                  ;	In:		BH	00000CNS (C:Caps Lock,N:Num Lock,S:Scroll Lock)
  5043                                  ;
  5044                                  ;-----------------------------------------------------------------------------------------------------------------------
  5045                                  SetKeyboardLamps	call	WaitForKeyInBuffer				;wait for input buffer ready
  5046                                  			mov	al,EKEYBCMDLAMPS				;set/reset lamps command
  5047                                  			out	EKEYBPORTDATA,al				;send command to 8042
  5048                                  			call	WaitForKeyOutBuffer				;wait for 8042 result
  5049                                  			in	al,EKEYBPORTDATA				;read 8042 'ACK' (0fah)
  5050                                  			call	WaitForKeyInBuffer				;wait for input buffer ready
  5051                                  			mov	al,bh						;set/reset lamps value
  5052                                  			out	EKEYBPORTDATA,al				;send lamps value
  5053                                  			call	WaitForKeyOutBuffer				;wait for 8042 result
  5054                                  			in	al,EKEYBPORTDATA				;read 8042 'ACK' (0fah)
  5055                                  			ret							;return
  5056                                  ;-----------------------------------------------------------------------------------------------------------------------
  5057                                  ;
  5058                                  ;	Routine:	WaitForKeyInBuffer
  5059                                  ;
  5060                                  ;	Description:	This routine waits for keyboard input buffer to be ready for input.
  5061                                  ;
  5062                                  ;	Out:		ZF	1 = Input buffer ready
  5063                                  ;				0 = Input buffer not ready after timeout
  5064                                  ;
  5065                                  ;-----------------------------------------------------------------------------------------------------------------------
  5066                                  WaitForKeyInBuffer	push	ecx						;save non-volatile regs
  5067                                  			mov	ecx,EKEYBWAITLOOP				;keyboard controller timeout
  5068                                  .10			in	al,EKEYBPORTSTAT				;keyboard status byte
  5069                                  			test	al,EKEYBBITIN					;is input buffer still full?
  5070                                  			loopnz	.10						;yes, repeat till timeout
  5071                                  			pop	ecx						;restore non-volatile regs
  5072                                  			ret							;return
  5073                                  ;-----------------------------------------------------------------------------------------------------------------------
  5074                                  ;
  5075                                  ;	Routine:	WaitForKeyOutBuffer
  5076                                  ;
  5077                                  ;	Description:	This routine waits for keyboard output buffer to have data to read.
  5078                                  ;
  5079                                  ;	Out:		ZF	1 = Output buffer has data from controller
  5080                                  ;				0 = Output buffer empty after timeout
  5081                                  ;
  5082                                  ;-----------------------------------------------------------------------------------------------------------------------
  5083                                  WaitForKeyOutBuffer	push	ecx						;save non-volatile regs
  5084                                  			mov	ecx,EKEYBWAITLOOP				;keyboard controller timeout
  5085                                  .10			in	al,EKEYBPORTSTAT				;keyboard status byte
  5086                                  			test	al,EKEYBBITOUT					;output buffer status bit
  5087                                  			loopz	.10						;loop until output buffer bit
  5088                                  			pop	ecx						;restore non-volatile regs
  5089                                  			ret							;return
  5090                                  ;-----------------------------------------------------------------------------------------------------------------------
  5091                                  ;
  5092                                  ;	End of the Kernel Function Library
  5093                                  ;
  5094                                  ;-----------------------------------------------------------------------------------------------------------------------
  5095                                  			times	8190-($-$$) db 0h				;zero fill to end of section
  5096                                  			db	055h,0AAh					;end of segment
  5097                                  ;=======================================================================================================================
  5098                                  ;
  5099                                  ;	Console Task
  5100                                  ;
  5101                                  ;	The only task defined in the kernel is the console task. This task consists of code, data, stack, and task state
  5102                                  ;	segments and a local descriptor table. The console task accepts and echos user keyboard input to the console
  5103                                  ;	screen and responds to user commands.
  5104                                  ;
  5105                                  ;=======================================================================================================================
  5106                                  ;-----------------------------------------------------------------------------------------------------------------------
  5107                                  ;
  5108                                  ;	Console Stack								@disk: 007400	@mem:  004000
  5109                                  ;
  5110                                  ;	This is the stack for the console task. It supports 448 nested calls.
  5111                                  ;
  5112                                  ;-----------------------------------------------------------------------------------------------------------------------
  5113                                  section			constack						;console task stack
  5114                                  			times	1792-($-$$) db 0h				;zero fill to end of section
  5115                                  ;-----------------------------------------------------------------------------------------------------------------------
  5116                                  ;
  5117                                  ;	Console Local Descriptor Table						@disk: 007B00	@mem:  004700
  5118                                  ;
  5119                                  ;	This is the LDT for the console task. It defines the stack, code, data and queue segments as well as data
  5120                                  ;	aliases for the TSS LDT. Data aliases allow inspection and altering of the TSS and LDT. This LDT can hold up to
  5121                                  ;	16 descriptors. Six are initially defined.
  5122                                  ;
  5123                                  ;-----------------------------------------------------------------------------------------------------------------------
  5124                                  section			conldt							;console local descriptors
  5125                                  			dq	004093004780007Fh				;04 TSS alias
  5126                                  			dq	004093004700007Fh				;0C LDT alias
  5127                                  			dq	00409300400006FFh				;14 stack
  5128                                  			dq	00CF93000000FFFFh				;1C data
  5129                                  			dq	00409B0050000FFFh				;24 code
  5130                                  			dq	00409300480007FFh				;2C message queue
  5131                                  			times	128-($-$$) db 0h				;zero fill to end of section
  5132                                  ;-----------------------------------------------------------------------------------------------------------------------
  5133                                  ;
  5134                                  ;	Console Task State Segment						@disk: 007B80	@mem:  004780
  5135                                  ;
  5136                                  ;	This is the TSS for the console task. All rings share the same stack. DS and ES are set to the console data
  5137                                  ;	segment. CS to console code.
  5138                                  ;
  5139                                  ;-----------------------------------------------------------------------------------------------------------------------
  5140                                  section			contss							;console task state segment
  5141                                  			dd	0						;00 back-link tss
  5142                                  			dd	0700h						;04 esp ring 0
  5143                                  			dd	0014h						;08 ss ring 0
  5144                                  			dd	0700h						;0C esp ring 1
  5145                                  			dd	0014h						;10 es ring 1
  5146                                  			dd	0700h						;14 esp ring 2
  5147                                  			dd	0014h						;18 ss ring 2
  5148                                  			dd	0						;1C cr ring 3
  5149                                  			dd	0						;20 eip
  5150                                  			dd	0200h						;24 eflags
  5151                                  			dd	0						;28 eax
  5152                                  			dd	0						;2C ecx
  5153                                  			dd	0						;30 edx
  5154                                  			dd	0						;34 ebx
  5155                                  			dd	0700h						;38 esp ring 3
  5156                                  			dd	0						;3C ebp
  5157                                  			dd	0						;40 esi
  5158                                  			dd	0						;44 edi
  5159                                  			dd	001Ch						;48 es
  5160                                  			dd	0024h						;4C cs
  5161                                  			dd	0014h						;50 ss ring 3
  5162                                  			dd	001Ch						;54 ds
  5163                                  			dd	0						;58 fs
  5164                                  			dd	0						;5c gs
  5165                                  			dd	ESELCONSOLELDT					;60 ldt selector in gdt
  5166                                  			times	128-($-$$) db 0h				;zero fill to end of section
  5167                                  ;-----------------------------------------------------------------------------------------------------------------------
  5168                                  ;
  5169                                  ;	Console Message Queue							@disk: 007C00	@mem: 004800
  5170                                  ;
  5171                                  ;	The console message queue is 2048 bytes of memory organized as a queue of 510 double words (4 bytes each) and
  5172                                  ;	two double word values that act as indices. The queue is a FIFO that is fed by the keyboard hardware interrupt
  5173                                  ;	handler and consumed by a service routine called from a task. Each queue entry defines an input (keystroke)
  5174                                  ;	event.
  5175                                  ;
  5176                                  ;-----------------------------------------------------------------------------------------------------------------------
  5177                                  section			conmque							;console message queue
  5178                                  			dd	8						;head pointer
  5179                                  			dd	8						;tail pointer
  5180                                  			times	510 dd 0					;queue elements
  5181                                  ;-----------------------------------------------------------------------------------------------------------------------
  5182                                  ;
  5183                                  ;	Console Code								@disk: 008400	@mem: 005000
  5184                                  ;
  5185                                  ;	This is the code for the console task. The task is defined in the GDT in two descriptors, the Local Descriptor
  5186                                  ;	Table (LDT) at 0050h and the Task State Segment (TSS) at 0058h. Jumping to or calling a TSS selector causes a
  5187                                  ;	task switch, giving control to the code for the task at the CS:IP defined in the TSS for the current ring level.
  5188                                  ;	The initial CS:IP in the Console TSS is 24h:0, where 24h is a selector in the LDT. This selector points to the
  5189                                  ;	concode section, loaded into memory 5000h by the Loader. The console task is dedicated to accepting user key-
  5190                                  ;	board input, echoing to the console screen and responding to user commands.
  5191                                  ;
  5192                                  ;	When control reaches this section, our addressability is set up according to the following diagram.
  5193                                  ;
  5194                                  ;	DS,ES --------> 000000	+-----------------------------------------------+ DS,ES:0000
  5195                                  ;				|  Real Mode Interrupt Vectors			|
  5196                                  ;			000400	+-----------------------------------------------+ DS,ES:0400
  5197                                  ;				|  Reserved BIOS Memory Area			|
  5198                                  ;			000800	+-----------------------------------------------+ DS,ES:0800
  5199                                  ;				|  Shared Kernel Memory Area			|
  5200                                  ;			001000	+-----------------------------------------------+		<-- GDTR
  5201                                  ;				|  Global Descriptor Table (GDT)		|
  5202                                  ;			001800	+-----------------------------------------------+		<-- IDTR
  5203                                  ;				|  Interrupt Descriptor Table (IDT)		|
  5204                                  ;			002000	+-----------------------------------------------+
  5205                                  ;				|  Interrupt Handlers				|
  5206                                  ;				|  Kernel Function Library			|
  5207                                  ;	SS ----------->	004000	+===============================================+ SS:0000
  5208                                  ;				|  Console Task Stack Area			|
  5209                                  ;	SS:SP --------> 004700	+-----------------------------------------------+ SS:0700	<-- LDTR = GDT.SEL 0050h
  5210                                  ;				|  Console Task Local Descriptor Table (LDT)	|
  5211                                  ;			004780	+-----------------------------------------------+		<-- TR  = GDT.SEL 0058h
  5212                                  ;				|  Console Task Task State Segment (TSS)	|
  5213                                  ;			004800	+-----------------------------------------------+
  5214                                  ;				|  Console Task Message Queue			|
  5215                                  ;	CS,CS:IP ----->	005000	+-----------------------------------------------+ CS:0000
  5216                                  ;				|  Console Task Code				|
  5217                                  ;				|  Console Task Constants			|
  5218                                  ;			006000	+===============================================+
  5219                                  ;
  5220                                  ;-----------------------------------------------------------------------------------------------------------------------
  5221                                  section			concode	vstart=05000h					;labels relative to 5000h
  5222                                  ConCode			call	ConInitializeData				;initialize console variables
  5223                                  
  5224                                  			clearConsoleScreen					;clear the console screen
  5225                                  			putConsoleString czTitle				;display startup message
  5226                                  .10			putConsoleString czPrompt				;display input prompt
  5227                                  			placeCursor						;set CRT cursor location
  5228                                  			getConsoleString wzConsoleInBuffer,79,1,13		;accept keyboard input
  5229                                  			putConsoleString czNewLine				;newline
  5230                                  
  5231                                  			mov	byte [wzConsoleToken],0				;null-terminate token buffer
  5232                                  			mov	edx,wzConsoleInBuffer				;console input buffer
  5233                                  			mov	ebx,wzConsoleToken				;token buffer
  5234                                  			call	ConTakeToken					;handle console input
  5235                                  			mov	edx,wzConsoleToken				;token buffer
  5236                                  			call	ConDetermineCommand				;determine command number
  5237                                  			cmp	eax,ECONJMPTBLCNT				;valid command number?
  5238                                  			jb	.20						;yes, branch
  5239                                  
  5240                                  			putConsoleString czUnknownCommand			;display error message
  5241                                  
  5242                                  			jmp	.10						;next command
  5243                                  .20			shl	eax,2						;index into jump table
  5244                                  			mov	edx,tConJmpTbl					;jump table base address
  5245                                  			mov	eax,[edx+eax]					;command handler routine address
  5246                                  			call	eax						;call command handler
  5247                                  			jmp	.10						;next command
  5248                                  ;-----------------------------------------------------------------------------------------------------------------------
  5249                                  ;
  5250                                  ;	Routine:	ConInitializeData
  5251                                  ;
  5252                                  ;	Description:	This routine initializes console task variables.
  5253                                  ;
  5254                                  ;-----------------------------------------------------------------------------------------------------------------------
  5255                                  ConInitializeData	push	ecx						;save non-volatile regs
  5256                                  			push	edi						;
  5257                                  			push	es						;
  5258                                  ;
  5259                                  ;	Initialize console work areas
  5260                                  ;
  5261                                  			push	ESELDAT						;load OS data selector ...
  5262                                  			pop	es						;... into extra segment register
  5263                                  			mov	edi,ECONDATA					;OS console data address
  5264                                  			xor	al,al						;initialization value
  5265                                  			mov	ecx,ECONDATALEN					;size of OS console data
  5266                                  			cld							;forward strings
  5267                                  			rep	stosb						;initialize data
  5268                                  ;
  5269                                  ;	Initialize heap size
  5270                                  ;
  5271                                  			mov	eax,EMEMHEAPSIZE				;heap size (temporary)
  5272                                  			mov	[wfHeapSize],eax				;set heap size
  5273                                  ;
  5274                                  ;	Initialize MEMROOT structure
  5275                                  ;
  5276                                  			mov	edi,wsMemRoot					;memory root structure address
  5277                                  			mov	eax,EMEMBASE					;base address of heap storage
  5278                                  			xor	ecx,ecx						;zero register
  5279                                  			mov	cl,4						;count
  5280                                  			rep	stosd						;store first/last contig and free addrs
  5281                                  			xor	eax,eax						;zero register
  5282                                  			stosd							;zero first task block
  5283                                  			stosd							;zero last task block
  5284                                  ;
  5285                                  ;	Initialize MEMBLOCK structure at EMEMBASE
  5286                                  ;
  5287                                  			mov	edi,EMEMBASE					;memory block structure address
  5288                                  			mov	eax,EMEMFREECODE				;free memory signature
  5289                                  			stosd							;store signature
  5290                                  			mov	eax,[wfHeapSize]				;heap size
  5291                                  			stosd							;store block size
  5292                                  			xor	eax,eax						;zero register
  5293                                  			xor	ecx,ecx						;zero register
  5294                                  			mov	cl,6						;count
  5295                                  			rep	stosd						;zero owner, reserved, pointers
  5296                                  ;
  5297                                  ;	Restore and return
  5298                                  ;
  5299                                  			pop	es						;restore non-volatile regs
  5300                                  			pop	edi						;
  5301                                  			pop	ecx						;
  5302                                  			ret							;return
  5303                                  ;-----------------------------------------------------------------------------------------------------------------------
  5304                                  ;
  5305                                  ;	Routine:	ConTakeToken
  5306                                  ;
  5307                                  ;	Description:	This routine extracts the next token from the given source buffer.
  5308                                  ;
  5309                                  ;	In:		DS:EDX	source buffer address
  5310                                  ;			DS:EBX	target buffer address
  5311                                  ;
  5312                                  ;	Out:		DS:EDX	source buffer address
  5313                                  ;			DS:EBX	target buffer address
  5314                                  ;
  5315                                  ;	Command Form:	Line	= *3( *SP 1*ALNUM )
  5316                                  ;
  5317                                  ;-----------------------------------------------------------------------------------------------------------------------
  5318                                  ConTakeToken		push	esi						;save non-volatile regs
  5319                                  			push	edi						;
  5320                                  			mov	esi,edx						;source buffer address
  5321                                  			mov	edi,ebx						;target buffer address
  5322                                  			cld							;forward strings
  5323                                  .10			lodsb							;load byte
  5324                                  			cmp	al,EASCIISPACE					;space?
  5325                                  			je	.10						;yes, continue
  5326                                  			test	al,al						;end of line?
  5327                                  			jz	.40						;yes, branch
  5328                                  .20			stosb							;store byte
  5329                                  			lodsb							;load byte
  5330                                  			test	al,al						;end of line?
  5331                                  			jz	.40						;no, continue
  5332                                  			cmp	al,EASCIISPACE					;space?
  5333                                  			jne	.20						;no, continue
  5334                                  .30			lodsb							;load byte
  5335                                  			cmp	al,EASCIISPACE					;space?
  5336                                  			je	.30						;yes, continue
  5337                                  			dec	esi						;pre-position
  5338                                  .40			mov	byte [edi],0					;terminate buffer
  5339                                  			mov	edi,edx						;source buffer address
  5340                                  .50			lodsb							;remaining byte
  5341                                  			stosb							;move to front of buffer
  5342                                  			test	al,al						;end of line?
  5343                                  			jnz	.50						;no, continue
  5344                                  			pop	edi						;restore non-volatile regs
  5345                                  			pop	esi						;
  5346                                  			ret							;return
  5347                                  ;-----------------------------------------------------------------------------------------------------------------------
  5348                                  ;
  5349                                  ;	Routine:	ConDetermineCommand
  5350                                  ;
  5351                                  ;	Description:	This routine determines the command number for the command at DS:EDX.
  5352                                  ;
  5353                                  ;	input:		DS:EDX	command address
  5354                                  ;
  5355                                  ;	output:		EAX	>=0	= command nbr
  5356                                  ;				0	= unknown command
  5357                                  ;
  5358                                  ;-----------------------------------------------------------------------------------------------------------------------
  5359                                  ConDetermineCommand	push	ebx						;save non-volatile regs
  5360                                  			push	ecx						;
  5361                                  			push	esi						;
  5362                                  			push	edi						;
  5363                                  
  5364                                  			upperCaseString						;upper-case string at EDX
  5365                                  
  5366                                  			mov	esi,tConCmdTbl					;commands table
  5367                                  			xor	edi,edi						;intialize command number
  5368                                  			cld							;forward strings
  5369                                  .10			lodsb							;command length
  5370                                  			movzx	ecx,al						;command length
  5371                                  			jecxz	.20						;branch if end of table
  5372                                  			mov	ebx,esi						;table entry address
  5373                                  			add	esi,ecx						;next table entry address
  5374                                  
  5375                                  			compareMemory						;compare byte arrays at EDX, EBX
  5376                                  
  5377                                  			jecxz	.20						;branch if equal
  5378                                  			inc	edi						;increment command nbr
  5379                                  			jmp	.10						;repeat
  5380                                  .20			mov	eax,edi						;command number
  5381                                  			pop	edi						;restore non-volatile regs
  5382                                  			pop	esi						;
  5383                                  			pop	ecx						;
  5384                                  			pop	ebx						;
  5385                                  			ret							;return
  5386                                  ;-----------------------------------------------------------------------------------------------------------------------
  5387                                  ;
  5388                                  ;	Routine:	ConClear
  5389                                  ;
  5390                                  ;	Description:	This routine handles the CLEAR command and its CLS alias.
  5391                                  ;
  5392                                  ;-----------------------------------------------------------------------------------------------------------------------
  5393                                  ConClear		clearConsoleScreen					;clear console screen
  5394                                  			ret							;return
  5395                                  ;-----------------------------------------------------------------------------------------------------------------------
  5396                                  ;
  5397                                  ;	Routine:	ConDate
  5398                                  ;
  5399                                  ;	Description:	This routine handles the DATE command.
  5400                                  ;
  5401                                  ;-----------------------------------------------------------------------------------------------------------------------
  5402                                  ConDate			readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5403                                  			putDateString	  wsConsoleDateTime,wzConsoleOutBuffer	;format date string
  5404                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5405                                  			putConsoleString  czNewLine				;write newline to console
  5406                                  			ret							;return
  5407                                  ;-----------------------------------------------------------------------------------------------------------------------
  5408                                  ;
  5409                                  ;	Routine:	ConDay
  5410                                  ;
  5411                                  ;	Description:	This routine handles the DAY command.
  5412                                  ;
  5413                                  ;-----------------------------------------------------------------------------------------------------------------------
  5414                                  ConDay			readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5415                                  			putDayString      wsConsoleDateTime,wzConsoleOutBuffer	;format day string
  5416                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5417                                  			putConsoleString  czNewLine				;write newline to console
  5418                                  			ret							;return
  5419                                  ;-----------------------------------------------------------------------------------------------------------------------
  5420                                  ;
  5421                                  ;	Routine:	ConExit
  5422                                  ;
  5423                                  ;	Description:	This routine handles the EXIT command and its SHUTDOWN and QUIT aliases.
  5424                                  ;
  5425                                  ;-----------------------------------------------------------------------------------------------------------------------
  5426                                  ConExit			resetSystem						;issue system reset
  5427                                  			ret							;return
  5428                                  ;-----------------------------------------------------------------------------------------------------------------------
  5429                                  ;
  5430                                  ;	Routine:	ConFree
  5431                                  ;
  5432                                  ;	Description:	This routine handles the FREE command.
  5433                                  ;
  5434                                  ;	Input:		wzConsoleInBuffer contains parameter(s)
  5435                                  ;
  5436                                  ;-----------------------------------------------------------------------------------------------------------------------
  5437                                  ConFree			push	ebx						;save non-volatile regs
  5438                                  			push	ecx						;
  5439                                  			push	esi						;
  5440                                  			push	edi						;
  5441                                  ;
  5442                                  ;	Get address parameter
  5443                                  ;
  5444                                  			mov	edx,wzConsoleInBuffer				;console input buffer address (param)
  5445                                  			mov	ebx,wzConsoleToken				;console command token address
  5446                                  			call	ConTakeToken					;take first param as token
  5447                                  ;
  5448                                  ;	Convert input parameter from hexadecimal string to binary
  5449                                  ;
  5450                                  			cmp	byte [wzConsoleToken],0				;token found?
  5451                                  			je	.10						;no, branch
  5452                                  			mov	edx,wzConsoleToken				;first param as token address
  5453                                  
  5454                                  			hexadecimalToUnsigned					;convert string token to unsigned
  5455                                  
  5456                                  			test	eax,eax						;valid parameter?
  5457                                  			jz	.10						;no, branch
  5458                                  ;
  5459                                  ;	Free memory block
  5460                                  ;
  5461                                  			freeMemory eax						;free memory
  5462                                  
  5463                                  			cmp	eax,-1						;memory freed?
  5464                                  			je	.10						;no, branch
  5465                                  ;
  5466                                  ;	Indicate memory freed
  5467                                  ;
  5468                                  			putConsoleString czOK					;indicate success
  5469                                  ;
  5470                                  ;	Restore and return
  5471                                  ;
  5472                                  .10			pop	edi						;restore non-volatile regs
  5473                                  			pop	esi						;
  5474                                  			pop	ecx						;
  5475                                  			pop	ebx						;
  5476                                  			ret							;return
  5477                                  ;-----------------------------------------------------------------------------------------------------------------------
  5478                                  ;
  5479                                  ;	Routine:	ConHour
  5480                                  ;
  5481                                  ;	Description:	This routine Handles the HOUR command.
  5482                                  ;
  5483                                  ;-----------------------------------------------------------------------------------------------------------------------
  5484                                  ConHour			readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5485                                  			putHourString     wsConsoleDateTime,wzConsoleOutBuffer	;format hour string
  5486                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5487                                  			putConsoleString  czNewLine				;write newline to console
  5488                                  			ret							;return
  5489                                  ;-----------------------------------------------------------------------------------------------------------------------
  5490                                  ;
  5491                                  ;	Routine:	ConInt6
  5492                                  ;
  5493                                  ;	Description:	This routine issues an interrupt 6 to exercise the interrupt handler.
  5494                                  ;
  5495                                  ;-----------------------------------------------------------------------------------------------------------------------
  5496                                  ConInt6			ud2							;raise bad opcode exception
  5497                                  			ret							;return (not executed)
  5498                                  ;-----------------------------------------------------------------------------------------------------------------------
  5499                                  ;
  5500                                  ;	Routine:	ConMalloc
  5501                                  ;
  5502                                  ;	Description:	This routine handles the MALLOC command.
  5503                                  ;
  5504                                  ;	Input:		wzConsoleInBuffer contains parameter(s)
  5505                                  ;
  5506                                  ;-----------------------------------------------------------------------------------------------------------------------
  5507                                  ConMalloc		push	ebx						;save non-volatile regs
  5508                                  			push	ecx						;
  5509                                  			push	esi						;
  5510                                  			push	edi						;
  5511                                  ;
  5512                                  ;	Get size parameter
  5513                                  ;
  5514                                  			mov	edx,wzConsoleInBuffer				;console input buffer address (params)
  5515                                  			mov	ebx,wzConsoleToken				;console command token address
  5516                                  			call	ConTakeToken					;take first param as token
  5517                                  ;
  5518                                  ;	Convert input parameter from decimal string to binary
  5519                                  ;
  5520                                  			cmp	byte [wzConsoleToken],0				;token found?
  5521                                  			je	.10						;no, branch
  5522                                  			mov	edx,wzConsoleToken				;first param as token address
  5523                                  
  5524                                  			decimalToUnsigned					;convert string token to unsigned
  5525                                  
  5526                                  			test	eax,eax						;valid parameter?
  5527                                  			jz	.10						;no, branch
  5528                                  ;
  5529                                  ;	Allocate memory block
  5530                                  ;
  5531                                  			allocateMemory eax					;allocate memory
  5532                                  
  5533                                  			test	eax,eax						;memory allocated?
  5534                                  			jz	.10						;no, branch
  5535                                  ;
  5536                                  ;	Report allocated memory block address
  5537                                  ;
  5538                                  			mov	edx,wzConsoleOutBuffer				;output buffer address
  5539                                  			mov	ecx,eax						;memory address
  5540                                  
  5541                                  			unsignedToHexadecimal					;convert memory address to hex
  5542                                  			putConsoleString wzConsoleOutBuffer			;display memory address
  5543                                  			putConsoleString czNewLine				;display new line
  5544                                  
  5545                                  .10			pop	edi						;restore non-volatile regs
  5546                                  			pop	esi						;
  5547                                  			pop	ecx						;
  5548                                  			pop	ebx						;
  5549                                  			ret							;return
  5550                                  ;-----------------------------------------------------------------------------------------------------------------------
  5551                                  ;
  5552                                  ;	Routine:	ConMem
  5553                                  ;
  5554                                  ;	Description:	This routine handles the MEMORY command and its MEM alias.
  5555                                  ;
  5556                                  ;	Input:		wzConsoleInBuffer contains parameter(s)
  5557                                  ;
  5558                                  ;-----------------------------------------------------------------------------------------------------------------------
  5559                                  ConMem			push	ebx						;save non-volatile regs
  5560                                  			push	esi						;
  5561                                  			push	edi						;
  5562                                  ;
  5563                                  ;			update the source address if a parameter is given
  5564                                  ;
  5565                                  			mov	edx,wzConsoleInBuffer				;console input buffer address (params)
  5566                                  			mov	ebx,wzConsoleToken				;console command token address
  5567                                  			call	ConTakeToken					;take first param as token
  5568                                  			cmp	byte [wzConsoleToken],0				;token found?
  5569                                  			je	.10						;no, branch
  5570                                  			mov	edx,wzConsoleToken				;first param as token address
  5571                                  
  5572                                  			hexadecimalToUnsigned					;convert string token to unsigned
  5573                                  
  5574                                  			mov	[wfConsoleMemAddr],eax				;save console memory address
  5575                                  ;
  5576                                  ;			setup source address and row count
  5577                                  ;
  5578                                  .10			mov	esi,[wfConsoleMemAddr]				;source memory address
  5579                                  			xor	ecx,ecx						;zero register
  5580                                  			mov	cl,16						;row count
  5581                                  ;
  5582                                  ;			start the row with the source address in hexadecimal
  5583                                  ;
  5584                                  .20			push	ecx						;save remaining rows
  5585                                  			mov	edi,wzConsoleOutBuffer				;output buffer address
  5586                                  			mov	edx,edi						;output buffer address
  5587                                  			mov	ecx,esi						;console memory address
  5588                                  
  5589                                  			unsignedToHexadecimal					;convert unsigned address to hex string
  5590                                  
  5591                                  			add	edi,8						;end of memory addr hexnum
  5592                                  			mov	al,' '						;ascii space
  5593                                  			stosb							;store delimiter
  5594                                  ;
  5595                                  ;			output 16 ASCII hexadecimal byte values for the row
  5596                                  ;
  5597                                  			xor	ecx,ecx						;zero register
  5598                                  			mov	cl,16						;loop count
  5599                                  .30			push	ecx						;save loop count
  5600                                  			lodsb							;memory byte
  5601                                  			mov	ah,al						;memory byte
  5602                                  			shr	al,4						;high-order in bits 3-0
  5603                                  			or	al,30h						;apply ascii numeric zone
  5604                                  			cmp	al,3ah						;numeric range?
  5605                                  			jb	.40						;yes, skip ahead
  5606                                  			add	al,7						;adjust ascii for 'A'-'F'
  5607                                  .40			stosb							;store ascii hexadecimal of high-order
  5608                                  			mov	al,ah						;low-order in bits 3-0
  5609                                  			and	al,0fh						;mask out high-order bits
  5610                                  			or	al,30h						;apply ascii numeric zone
  5611                                  			cmp	al,3ah						;numeric range?
  5612                                  			jb	.50						;yes, skip ahead
  5613                                  			add	al,7						;adjust ascii for 'A'-'F'
  5614                                  .50			stosb							;store ascii hexadecimal of low-order
  5615                                  			mov	al,' '						;ascii space
  5616                                  			stosb							;store ascii space delimiter
  5617                                  			pop	ecx						;loop count
  5618                                  			loop	.30						;next
  5619                                  ;
  5620                                  ;			output printable ASCII character section for the row
  5621                                  ;
  5622                                  			sub	esi,16						;reset source pointer
  5623                                  			mov	cl,16						;loop count
  5624                                  .60			lodsb							;source byte
  5625                                  			cmp	al,32						;printable? (low-range test)
  5626                                  			jb	.70						;no, skip ahead
  5627                                  			cmp	al,128						;printable? (high-range test)
  5628                                  			jb	.80						;yes, skip ahead
  5629                                  .70			mov	al,' '						;display space instead of printable
  5630                                  .80			stosb							;store printable ascii byte
  5631                                  			loop	.60						;next source byte
  5632                                  			xor	al,al						;nul-terminator
  5633                                  			stosb							;terminate output line
  5634                                  ;
  5635                                  ;			display constructed output buffer and newline
  5636                                  ;
  5637                                  			putConsoleString wzConsoleOutBuffer			;display constructed output
  5638                                  			putConsoleString czNewLine				;display new line
  5639                                  ;
  5640                                  ;			repeat until all lines displayed and preserve source address
  5641                                  ;
  5642                                  			pop	ecx						;remaining rows
  5643                                  			loop	.20						;next row
  5644                                  			mov	[wfConsoleMemAddr],esi				;update console memory address
  5645                                  			pop	edi						;restore regs
  5646                                  			pop	esi						;
  5647                                  			pop	ebx						;
  5648                                  			ret							;return
  5649                                  ;-----------------------------------------------------------------------------------------------------------------------
  5650                                  ;
  5651                                  ;	Routine:	ConMinute
  5652                                  ;
  5653                                  ;	Description:	This routine Handles the MINUTE command.
  5654                                  ;
  5655                                  ;-----------------------------------------------------------------------------------------------------------------------
  5656                                  ConMinute		readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5657                                  			putMinuteString   wsConsoleDateTime,wzConsoleOutBuffer	;format minute string
  5658                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5659                                  			putConsoleString  czNewLine				;write newline to console
  5660                                  			ret							;return
  5661                                  ;-----------------------------------------------------------------------------------------------------------------------
  5662                                  ;
  5663                                  ;	Routine:	ConMonth
  5664                                  ;
  5665                                  ;	Description:	This routine Handles the MONTH command.
  5666                                  ;
  5667                                  ;-----------------------------------------------------------------------------------------------------------------------
  5668                                  ConMonth		readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5669                                  			putMonthString    wsConsoleDateTime,wzConsoleOutBuffer	;format month string
  5670                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5671                                  			putConsoleString  czNewLine				;write newline to console
  5672                                  			ret							;return
  5673                                  ;-----------------------------------------------------------------------------------------------------------------------
  5674                                  ;
  5675                                  ;	Routine:	ConMonthName
  5676                                  ;
  5677                                  ;	Description:	This routine Handles the MONTH.NAME command.
  5678                                  ;
  5679                                  ;-----------------------------------------------------------------------------------------------------------------------
  5680                                  ConMonthName		readRealTimeClock  wsConsoleDateTime			;read RTC data into structure
  5681                                  			putMonthNameString wsConsoleDateTime,wzConsoleOutBuffer	;format month name string
  5682                                  			putConsoleString   wzConsoleOutBuffer			;write string to console
  5683                                  			putConsoleString   czNewLine				;write newline to console
  5684                                  			ret							;return
  5685                                  ;-----------------------------------------------------------------------------------------------------------------------
  5686                                  ;
  5687                                  ;	Routine:	ConPCIProbe
  5688                                  ;
  5689                                  ;	Description:	This routine handles the PCIProbe command.
  5690                                  ;
  5691                                  ;-----------------------------------------------------------------------------------------------------------------------
  5692                                  ConPCIProbe		push	ebx						;save non-volatile regs
  5693                                  ;
  5694                                  ;			initialize variables
  5695                                  ;
  5696                                  			xor	al,al						;zero register
  5697                                  			mov	[wbConsolePCIBus],al				;initialize bus
  5698                                  			mov	[wbConsolePCIDevice],al				;initialize device
  5699                                  			mov	[wbConsolePCIFunction],al			;initialize function
  5700                                  ;
  5701                                  ;			construct PCI selector
  5702                                  ;
  5703                                  .10			mov	ah,[wbConsolePCIBus]				;AH = bbbb bbbb
  5704                                  			mov	dl,[wbConsolePCIDevice]				;DL = ???d dddd
  5705                                  			shl	dl,3						;DL = dddd d000
  5706                                  			mov	al,[wbConsolePCIFunction]			;AL = ???? ?fff
  5707                                  			and	al,007h						;AL = 0000 0fff
  5708                                  			or	al,dl						;AL = dddd dfff
  5709                                  			movzx	eax,ax						;0000 0000 0000 0000 bbbb bbbb dddd dfff
  5710                                  			shl	eax,8						;0000 0000 bbbb bbbb dddd dfff 0000 0000
  5711                                  			or	eax,80000000h					;1000 0000 bbbb bbbb dddd dfff 0000 0000
  5712                                  			mov	[wfConsolePCISelector],eax			;save selector
  5713                                  ;
  5714                                  ;			read PCI data register
  5715                                  ;
  5716                                  			mov	dx,0cf8h					;register port
  5717                                  			out	dx,eax						;select device
  5718                                  			mov	dx,0cfch					;data port
  5719                                  			in	eax,dx						;read register data
  5720                                  			mov	[wfConsolePCIData],eax				;save data
  5721                                  ;
  5722                                  ;			interpret PCI data value and display finding
  5723                                  ;
  5724                                  			cmp	eax,0ffffffffh					;not defined?
  5725                                  			je	.20						;yes, branch
  5726                                  			mov	edx,wzConsoleToken				;output buffer
  5727                                  			call	ConBuildPCIIdent				;build PCI bus, device, function ident
  5728                                  
  5729                                  			putConsoleString wzConsoleToken				;display bus as decimal
  5730                                  
  5731                                  			call	ConInterpretPCIData				;update flags based on data
  5732                                  
  5733                                  			putConsoleString czSpace
  5734                                  			putConsoleString [wfConsolePCIVendorStr]
  5735                                  			putConsoleString czSpace
  5736                                  			putConsoleString [wfConsolePCIChipStr]
  5737                                  			putConsoleString czNewLine				;display new line
  5738                                  ;
  5739                                  ;			step to next function, device, bus
  5740                                  ;
  5741                                  .20			inc	byte [wbConsolePCIFunction]			;next function
  5742                                  			cmp	byte [wbConsolePCIFunction],8			;at limit?
  5743                                  			jb	.10						;no, continue
  5744                                  			mov	byte [wbConsolePCIFunction],0			;zero function
  5745                                  			inc	byte [wbConsolePCIDevice]			;next device
  5746                                  			cmp	byte [wbConsolePCIDevice],32			;at limit?
  5747                                  			jb	.10						;no, continue
  5748                                  			mov	byte [wbConsolePCIDevice],0			;zero device
  5749                                  			inc	byte [wbConsolePCIBus]				;next bus
  5750                                  			cmp	byte [wbConsolePCIBus],0			;at limit?
  5751                                  			jb	.10						;no, continue
  5752                                  
  5753                                  			jmp	.30
  5754                                  
  5755                                  ;
  5756                                  ;			report if ethernet adapter found
  5757                                  ;
  5758                                  			test	byte [wbConsoleHWFlags],EHWETHERNET		;ethernet h/w switch set?
  5759                                  			jz	.30						;branch if no
  5760                                  
  5761                                  			putConsoleString czEthernetAdapterFound			;report adapter found
  5762                                  ;
  5763                                  ;			read base address register 0 at offset 10h
  5764                                  ;
  5765                                  			mov	eax,[wfConsoleEthernetDevice]			;adapter PCI selector
  5766                                  			or	eax,10h						;set function bits
  5767                                  			mov	dx,0cf8h					;register port
  5768                                  			out	dx,eax						;select register
  5769                                  			mov	dx,0cfch					;data port
  5770                                  			in	eax,dx						;register data
  5771                                  			mov	[wfConsoleEthernetMem],eax			;save ethernet memory mapped i/o addr
  5772                                  ;
  5773                                  ;			report base address register 0 value
  5774                                  ;
  5775                                  			mov	ecx,eax						;unsigned integer param
  5776                                  			mov	edx,wzConsoleToken				;target buffer address
  5777                                  
  5778                                  			unsignedToHexadecimal					;convert unsigned to ASCII hex string
  5779                                  			putConsoleString wzConsoleToken				;output string to console
  5780                                  			putConsoleString czNewLine				;output newline to console
  5781                                  ;
  5782                                  ;			read base address register 2 at offset 18h
  5783                                  ;
  5784                                  			mov	eax,[wfConsoleEthernetDevice]			;adapter PCI selector
  5785                                  			or	eax,18h						;set function bits
  5786                                  			mov	dx,0cf8h					;register port
  5787                                  			out	dx,eax						;select register
  5788                                  			mov	dx,0cfch					;data port
  5789                                  			in	eax,dx						;register data
  5790                                  			and	al,0feh						;clear bit zero
  5791                                  			mov	[wfConsoleEthernetPort],eax			;save ethernet i/o port
  5792                                  ;
  5793                                  ;			report base address register 2 value
  5794                                  ;
  5795                                  			mov	ecx,eax						;unsigned integer param
  5796                                  			mov	edx,wzConsoleToken				;target buffer address
  5797                                  
  5798                                  			unsignedToHexadecimal					;convert unsigned to ASCII hex string
  5799                                  			putConsoleString wzConsoleToken				;output string to console
  5800                                  			putConsoleString czNewLine				;output newline to console
  5801                                  ;
  5802                                  ;			read ethernet control register using port i/o
  5803                                  ;
  5804                                  			mov	eax,[wfConsoleEthernetPort]			;ethernet i/o port
  5805                                  			mov	dx,ax						;ethernet i/o port
  5806                                  			xor	eax,eax						;control register (zero)
  5807                                  			out	dx,eax						;select register
  5808                                  			add	dx,4						;data register
  5809                                  			in	eax,dx						;read register data
  5810                                  			mov	[wfConsoleEthernetCtrl],eax			;save ethernet control register value
  5811                                  ;
  5812                                  ;			report adapter control register value
  5813                                  ;
  5814                                  			mov	ecx,eax						;unsigned integer param
  5815                                  			mov	edx,wzConsoleToken				;target buffer address
  5816                                  
  5817                                  			unsignedToHexadecimal					;convert unsigned to ASCII hex string
  5818                                  			putConsoleString wzConsoleToken				;output string to console
  5819                                  			putConsoleString czNewLine				;output newline to console
  5820                                  
  5821                                  .30			pop	ebx						;restore non-volatile regs
  5822                                  			ret							;return
  5823                                  ;-----------------------------------------------------------------------------------------------------------------------
  5824                                  ;
  5825                                  ;	Routine:	ConBuildPCIIdent
  5826                                  ;
  5827                                  ;	Description:	This routine constructs a PCI identification string from the current PCI Bus, Device, and
  5828                                  ;			Function code values.
  5829                                  ;
  5830                                  ;	In:		DS:EDX	output buffer address
  5831                                  ;
  5832                                  ;-----------------------------------------------------------------------------------------------------------------------
  5833                                  ConBuildPCIIdent	push	edi						;save non-volatile regs
  5834                                  			mov	edi,edx						;output buffer address
  5835                                  			mov	al,[wbConsolePCIBus]				;current PCI bus (0-255)
  5836                                  			xor	ah,ah						;zero high-order dividend
  5837                                  			mov	cl,100						;divisor (10^2)
  5838                                  			div	cl						;AL=100's, AH=bus MOD 100
  5839                                  			or	al,30h						;apply ASCII zone
  5840                                  			cld							;forward strings
  5841                                  			stosb							;store 100's digit
  5842                                  			mov	al,ah						;bus MOD 100
  5843                                  			xor	ah,ah						;zero high-order dividend
  5844                                  			mov	cl,10						;divisor (10^1)
  5845                                  			div	cl						;AL=10's, AH=1's
  5846                                  			or	ax,3030h					;apply ASCII zone
  5847                                  			stosw							;store 10's and 1's
  5848                                  			mov	al,EASCIIPERIOD					;ASCII period delimiter
  5849                                  			stosb							;store delimiter
  5850                                  			mov	al,[wbConsolePCIDevice]				;current PCI device (0-15)
  5851                                  			xor	ah,ah						;zero high order dividend
  5852                                  			mov	cl,10						;divisor (10^1)
  5853                                  			div	cl						;AL=10's, AH=1's
  5854                                  			or	ax,3030h					;apply ASCII zone
  5855                                  			stosw							;store 10's and 1's
  5856                                  			mov	al,EASCIIPERIOD					;ASCII period delimiter
  5857                                  			stosb							;store delimiter
  5858                                  			mov	al,[wbConsolePCIFunction]			;current PCI function (0-7)
  5859                                  			or	al,30h						;apply ASCII zone
  5860                                  			stosb							;store 1's
  5861                                  			xor	al,al						;null terminator
  5862                                  			stosb							;store terminator
  5863                                  			pop	edi						;restore non-volatile regs
  5864                                  			ret							;return
  5865                                  ;-----------------------------------------------------------------------------------------------------------------------
  5866                                  ;
  5867                                  ;	Routine:	ConInterpretPCIData
  5868                                  ;
  5869                                  ;	Description:	This routine interprets the PCI vendor and device IDs.
  5870                                  ;
  5871                                  ;-----------------------------------------------------------------------------------------------------------------------
  5872                                  ConInterpretPCIData	mov	eax,czApple
  5873                                  			cmp	word [wwConsolePCIVendor],EPCIVENDORAPPLE	;Apple?
  5874                                  			jne	.10						;no, branch
  5875                                  			mov	edx,czUSBController
  5876                                  			cmp	word [wwConsolePCIChip],EPCIAPPLEUSB		;USB?
  5877                                  			je	.80						;yes, branch
  5878                                  			mov	edx,czOther					;other
  5879                                  			jmp	.80						;continue
  5880                                  .10			mov	eax,czIntel					;Intel
  5881                                  			cmp	word [wwConsolePCIVendor],EPCIVENDORINTEL	;Intel?
  5882                                  			jne	.20						;no, branch
  5883                                  			mov	edx,czPro1000MT					;Pro/1000 MT
  5884                                  			cmp	word [wwConsolePCIChip],EPCIINTELPRO1000MT	;Pro/1000 MT?
  5885                                  			je	.80						;yes, branch
  5886                                  			mov	edx,czPCIAndMem					;PCI and Memory
  5887                                  			cmp	word [wwConsolePCIChip],EPCIINTELPCIMEM		;PCI and Memory?
  5888                                  			je	.80						;yes, branch
  5889                                  			mov	edx,czAurealAD1881				;Aureal 1881 SOUNDMAX
  5890                                  			cmp	word [wwConsolePCIChip],EPCIINTELAD1881		;Aureal 1881 SOUNDMAX?
  5891                                  			je	.80						;yes, branch
  5892                                  			mov	edx,czPIIX3PCItoIDEBridge			;PIIX3 PCI-to-IDE Bridge
  5893                                  			cmp	word [wwConsolePCIChip],EPCIINTELPIIX3		;PIIX3 PCI-to-IDE Bridge?
  5894                                  			je	.80						;yes, branch
  5895                                  			mov	edx,cz82371ABBusMaster				;82371AB Bus Master
  5896                                  			cmp	word [wwConsolePCIChip],EPCIINTEL82371AB	;82371AB Bus Master?
  5897                                  			je	.80						;yes, branch
  5898                                  			mov	edx,czPIIX4PowerMgmt				;PIIX4/4E/4M Power Mgmt Controller
  5899                                  			cmp	word [wwConsolePCIChip],EPCIINTELPIIX4		;PIIX4/4E/4M Power Mgmt Controller?
  5900                                  			je	.80						;yes, branch
  5901                                  			mov	edx,czOther					;other
  5902                                  			jmp	.80						;continue
  5903                                  .20			mov	eax,czOracle					;Oracle
  5904                                  			cmp	word [wwConsolePCIVendor],EPCIVENDORORACLE	;Oracle?
  5905                                  			jne	.30						;no, branch
  5906                                  			mov	edx,czVirtualBoxGA				;VirtulaBox Graphics Adapter
  5907                                  			cmp	word [wwConsolePCIChip],EPCIORACLEVBOXGA	;VirtualBox Graphics Adapter?
  5908                                  			je	.80						;yes, branch
  5909                                  			mov	edx,czVirtualBoxDevice				;VirtualBox Device
  5910                                  			cmp	word [wwConsolePCIChip],EPCIORACLEVBOXDEVICE	;VirtualBox Device?
  5911                                  			je	.80						;yes, branch
  5912                                  			mov	edx,czOther					;other
  5913                                  			jmp	.80						;continue
  5914                                  .30			mov	eax,czOther					;other
  5915                                  			mov	edx,czOther					;other
  5916                                  .80			mov	[wfConsolePCIVendorStr],eax			;save vendor string
  5917                                  			mov	[wfConsolePCIChipStr],edx			;save chip string
  5918                                  			cmp	word [wwConsolePCIChip],EPCIINTELPRO1000MT	;Pro/1000 MT Ethernet Adapter
  5919                                  			jne	.90						;no, branch
  5920                                  			or	byte [wbConsoleHWFlags],EHWETHERNET		;ethernet adapter found
  5921                                  			mov	eax,[wfConsolePCISelector]			;PCI selector
  5922                                  			mov	[wfConsoleEthernetDevice],eax			;save as ethernet device selector
  5923                                  .90			ret							;return
  5924                                  ;-----------------------------------------------------------------------------------------------------------------------
  5925                                  ;
  5926                                  ;	Routine:	ConSecond
  5927                                  ;
  5928                                  ;	Description:	This routine Handles the SECOND command.
  5929                                  ;
  5930                                  ;-----------------------------------------------------------------------------------------------------------------------
  5931                                  ConSecond		readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5932                                  			putSecondString   wsConsoleDateTime,wzConsoleOutBuffer	;format second string
  5933                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5934                                  			putConsoleString  czNewLine				;write newline to console
  5935                                  			ret							;return
  5936                                  ;-----------------------------------------------------------------------------------------------------------------------
  5937                                  ;
  5938                                  ;	Routine:	ConTime
  5939                                  ;
  5940                                  ;	Description:	This routine Handles the TIME command.
  5941                                  ;
  5942                                  ;-----------------------------------------------------------------------------------------------------------------------
  5943                                  ConTime			readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5944                                  			putTimeString	  wsConsoleDateTime,wzConsoleOutBuffer	;format time string
  5945                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5946                                  			putConsoleString  czNewLine				;write newline to console
  5947                                  			ret							;return
  5948                                  ;-----------------------------------------------------------------------------------------------------------------------
  5949                                  ;
  5950                                  ;	Routine:	ConWeekday
  5951                                  ;
  5952                                  ;	Description:	This routine handles the WEEKDAY command.
  5953                                  ;
  5954                                  ;-----------------------------------------------------------------------------------------------------------------------
  5955                                  ConWeekday		readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5956                                  			putWeekdayString  wsConsoleDateTime,wzConsoleOutBuffer	;format weekday string
  5957                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5958                                  			putConsoleString  czNewLine				;write newline to console
  5959                                  			ret							;return
  5960                                  ;-----------------------------------------------------------------------------------------------------------------------
  5961                                  ;
  5962                                  ;	Routine:	ConWeekdayName
  5963                                  ;
  5964                                  ;	Description:	This routine Handles the WEEKDAY.NAME command.
  5965                                  ;
  5966                                  ;-----------------------------------------------------------------------------------------------------------------------
  5967                                  ConWeekdayName		readRealTimeClock    wsConsoleDateTime				;read RTC data into structure
  5968                                  			putWeekdayNameString wsConsoleDateTime,wzConsoleOutBuffer	;format day name string
  5969                                  			putConsoleString     wzConsoleOutBuffer				;write string to console
  5970                                  			putConsoleString     czNewLine					;write newline to console
  5971                                  			ret								;return
  5972                                  ;-----------------------------------------------------------------------------------------------------------------------
  5973                                  ;
  5974                                  ;	Routine:	ConYear
  5975                                  ;
  5976                                  ;	Description:	This routine Handles the YEAR command.
  5977                                  ;
  5978                                  ;-----------------------------------------------------------------------------------------------------------------------
  5979                                  ConYear			readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5980                                  			putYearString	  wsConsoleDateTime,wzConsoleOutBuffer	;format year string
  5981                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5982                                  			putConsoleString  czNewLine				;write newline to console
  5983                                  			ret							;return
  5984                                  ;-----------------------------------------------------------------------------------------------------------------------
  5985                                  ;
  5986                                  ;	Routine:	ConYearIsLeap
  5987                                  ;
  5988                                  ;	Description:	This routine handles the YEAR.ISLEAP command
  5989                                  ;
  5990                                  ;-----------------------------------------------------------------------------------------------------------------------
  5991                                  ConYearIsLeap		readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5992                                  			isLeapYear        wsConsoleDateTime			;indicate if year is leap year
  5993                                  
  5994                                  			jecxz	.10						;branch if not leap
  5995                                  
  5996                                  			putConsoleString  czYearIsLeap				;display year is leap message
  5997                                  
  5998                                  			jmp	.20						;continue
  5999                                  
  6000                                  .10			putConsoleString  czYearIsNotLeap			;display year is not leap mesage
  6001                                  .20			ret							;return
  6002                                  ;-----------------------------------------------------------------------------------------------------------------------
  6003                                  ;
  6004                                  ;	Routine:	ConVersion
  6005                                  ;
  6006                                  ;	Description:	This routine handles the VERSION command and its alias, VER.
  6007                                  ;
  6008                                  ;-----------------------------------------------------------------------------------------------------------------------
  6009                                  ConVersion		putConsoleString czTitle				;display version message
  6010                                  			ret							;return
  6011                                  ;-----------------------------------------------------------------------------------------------------------------------
  6012                                  ;
  6013                                  ;	Tables
  6014                                  ;
  6015                                  ;-----------------------------------------------------------------------------------------------------------------------
  6016                                  										;---------------------------------------
  6017                                  										;  Command Jump Table
  6018                                  										;---------------------------------------
  6019                                  tConJmpTbl		equ	$						;command jump table
  6020                                  			dd	ConWeekdayName	- ConCode			;weekday.name command routine offset
  6021                                  			dd	ConYearIsLeap	- ConCode			;year.isleap command routine offset
  6022                                  			dd	ConMonthName	- ConCode			;month.name command routine offset
  6023                                  			dd	ConPCIProbe	- ConCode			;pciprobe command routine offset
  6024                                  			dd	ConExit		- ConCode			;shutdown command routine offset
  6025                                  			dd	ConVersion	- ConCode			;version command routine offset
  6026                                  			dd	ConWeekday	- ConCode			;weekday command routine offset
  6027                                  			dd	ConMalloc	- ConCode			;malloc command routine offset
  6028                                  			dd	ConMem		- ConCode			;memory command routine offset
  6029                                  			dd	ConMinute	- ConCode			;minute command routine offset
  6030                                  			dd	ConSecond	- ConCode			;second command routine offset
  6031                                  			dd	ConClear	- ConCode			;clear command routine offset
  6032                                  			dd	ConPCIProbe	- ConCode			;lspci command routine offset
  6033                                  			dd	ConMonth	- ConCode			;month command routine offset
  6034                                  			dd	ConDate		- ConCode			;date command routine offset
  6035                                  			dd	ConExit		- ConCode			;exit command routine offset
  6036                                  			dd	ConFree		- ConCode			;free command routine offset
  6037                                  			dd	ConHour		- ConCode			;hour command routine offset
  6038                                  			dd	ConInt6		- ConCode			;int6 command routine offset
  6039                                  			dd	ConExit		- ConCode			;quit command routine offset
  6040                                  			dd	ConTime		- ConCode			;time command routine offset
  6041                                  			dd	ConYear		- ConCode			;year command routine offset
  6042                                  			dd	ConClear	- ConCode			;cls command routine offset
  6043                                  			dd	ConDay		- ConCode			;day command routine offset
  6044                                  			dd	ConMem		- ConCode			;mem command routine offset
  6045                                  			dd	ConVersion	- ConCode			;ver command routine offset
  6046                                  ECONJMPTBLL		equ	($-tConJmpTbl)					;table length
  6047                                  ECONJMPTBLCNT		equ	ECONJMPTBLL/4					;table entries
  6048                                  										;---------------------------------------
  6049                                  										;  Command Name Table
  6050                                  										;---------------------------------------
  6051                                  tConCmdTbl		equ	$						;command name table
  6052                                  			db	13,"WEEKDAY.NAME",0				;weekday.name command
  6053                                  			db	12,"YEAR.ISLEAP",0				;year.isleap command
  6054                                  			db	11,"MONTH.NAME",0				;month.name command
  6055                                  			db	9,"PCIPROBE",0					;pciprobe command
  6056                                  			db	9,"SHUTDOWN",0					;shutdown command
  6057                                  			db	8,"VERSION",0					;version command
  6058                                  			db	8,"WEEKDAY",0					;weekday command
  6059                                  			db	7,"MALLOC",0					;malloc command
  6060                                  			db	7,"MEMORY",0					;memory command
  6061                                  			db	7,"MINUTE",0					;minute command
  6062                                  			db	7,"SECOND",0					;second command
  6063                                  			db	6,"CLEAR",0					;clear command
  6064                                  			db	6,"LSPCI",0					;lspci command (pciprobe alias)
  6065                                  			db	6,"MONTH",0					;month command
  6066                                  			db	5,"DATE",0					;date command
  6067                                  			db	5,"EXIT",0					;exit command
  6068                                  			db	5,"FREE",0					;free command
  6069                                  			db	5,"HOUR",0					;hour command
  6070                                  			db	5,"INT6",0					;int6 command
  6071                                  			db	5,"QUIT",0					;quit command
  6072                                  			db	5,"TIME",0					;time command
  6073                                  			db	5,"YEAR",0					;year command
  6074                                  			db	4,"CLS",0					;cls command
  6075                                  			db	4,"DAY",0					;day command
  6076                                  			db	4,"MEM",0					;mem command
  6077                                  			db	4,"VER",0					;ver command
  6078                                  			db	0						;end of table
  6079                                  ;-----------------------------------------------------------------------------------------------------------------------
  6080                                  ;
  6081                                  ;	Constants
  6082                                  ;
  6083                                  ;-----------------------------------------------------------------------------------------------------------------------
  6084                                  czApple			db	"Apple",0					;vendor name string
  6085                                  czAurealAD1881		db	"Aureal AD1881 SOUNDMAX",0			;soundmax string
  6086                                  czEthernetAdapterFound	db	"Ethernet adapter found",13,10,0		;adapter found message
  6087                                  czIntel			db	"Intel",0					;vendor name string
  6088                                  czNewLine		db	13,10,0						;new line string
  6089                                  czOK			db	"ok",13,10,0					;ok string
  6090                                  czOracle		db	"Oracle",0					;vendor name string
  6091                                  czOther			db	"Other",0					;default name string
  6092                                  czPCIAndMem		db	"PCI & Memory",0				;PCI and Memory string
  6093                                  czPeriod		db	".",0						;period delimiter
  6094                                  czPIIX3PCItoIDEBridge	db	"PIIX3 PCI-to-ISA Bridge",0			;pci-to-isa bridge string
  6095                                  czPIIX4PowerMgmt	db	"PIIX4/4E/4M Power Management Controller",0	;power management controller string
  6096                                  czPrompt		db	":",0						;prompt string
  6097                                  czPro1000MT		db	"Pro/1000 MT Ethernet Adapter",0		;Intel Pro/1000 MT Ethernet adapter strg
  6098                                  czSpace			db	" ",0						;space delimiter
  6099                                  czTitle			db	"Custom Operating System 1.0",13,10,0		;version string
  6100                                  czUnknownCommand	db	"Unknown command",13,10,0			;unknown command response string
  6101                                  czUSBController		db	"USB Controller",0				;USB controller string
  6102                                  czVirtualBoxDevice	db	"VirtualBox Device",0				;Virtual Box device string
  6103                                  czVirtualBoxGA		db	"VirtualBox Graphics Adapter",0			;Virtual Box graphics adapter string
  6104                                  czYearIsLeap		db	"The year is a leap year.",13,10,0		;leap year message
  6105                                  czYearIsNotLeap		db	"The year is not a leap year.",13,10,0		;not leap year message
  6106                                  cz82371ABBusMaster	db	"82371AB/EB PCI Bus Master IDE Controller",0	;bus-master strin
  6107                                  			times	4094-($-$$) db 0h				;zero fill to end of section
  6108                                  			db	055h,0AAh					;end of section
  6109                                  ;=======================================================================================================================
  6110                                  ;
  6111                                  ;	Background Task								@disk: 009400	@mem: 006000
  6112                                  ;
  6113                                  ;	This task executes monitoring and self-correcting functions.
  6114                                  ;
  6115                                  ;			000000	+-----------------------------------------------+
  6116                                  ;				|  Real Mode Interrupt Vectors			|
  6117                                  ;			000400	+-----------------------------------------------+ DS,ES:0400
  6118                                  ;				|  Reserved BIOS Memory Area			|
  6119                                  ;			000800	+-----------------------------------------------+ DS,ES:0800
  6120                                  ;				|  Shared Kernel Memory Area			|
  6121                                  ;			001000	+-----------------------------------------------+		<-- GDTR
  6122                                  ;				|  Global Descriptor Table (GDT)		|
  6123                                  ;			001800	+-----------------------------------------------+		<-- IDTR
  6124                                  ;				|  Interrupt Descriptor Table (IDT)		|
  6125                                  ;			002000	+-----------------------------------------------+
  6126                                  ;				|  Interrupt Handlers				|
  6127                                  ;				|  Kernel Function Library			|
  6128                                  ;			004000	+===============================================+
  6129                                  ;				|  Console Task Stack Area			|
  6130                                  ;			004700	+-----------------------------------------------+
  6131                                  ;				|  Console Task Local Descriptor Table (LDT)	|
  6132                                  ;			004780	+-----------------------------------------------+
  6133                                  ;				|  Console Task Task State Segment (TSS)	|
  6134                                  ;			004800	+-----------------------------------------------+
  6135                                  ;				|  Console Task Message Queue			|
  6136                                  ;			005000	+-----------------------------------------------+
  6137                                  ;				|  Console Task Code				|
  6138                                  ;				|  Console Task Constants			|
  6139                                  ;			006000	+===============================================+
  6140                                  ;				|  Background Task Stack Area			|
  6141                                  ;	SS:SP --------> 006700	+-----------------------------------------------+ SS:0700	<-- LDTR = GDT.SEL 0060h
  6142                                  ;				|  Background Task Local Descriptor Table (LDT) |
  6143                                  ;			006780  +-----------------------------------------------+		<-- TR = GDT.SEL 0068h
  6144                                  ;				|  Background Task Task State Segment (TSS)	|
  6145                                  ;			006800	+-----------------------------------------------+
  6146                                  ;				|  Background Task Message Queue		|
  6147                                  ;	CS,CS:IP ----->	007000	+-----------------------------------------------+ CS:0000
  6148                                  ;				|  Background Task Code				|
  6149                                  ;				|  Background Task Constants			|
  6150                                  ;			008000	+===============================================+
  6151                                  ;
  6152                                  ;=======================================================================================================================
  6153                                  ;-----------------------------------------------------------------------------------------------------------------------
  6154                                  ;
  6155                                  ;	Background Task Stack							@disk: 009400	@mem:  006000
  6156                                  ;
  6157                                  ;	This is the stack for the background task. It supports 448 nested calls.
  6158                                  ;
  6159                                  ;-----------------------------------------------------------------------------------------------------------------------
  6160                                  section			bgstack							;background task stack
  6161                                  			times	1792-($-$$) db 0h				;zero fill to end of section
  6162                                  ;-----------------------------------------------------------------------------------------------------------------------
  6163                                  ;
  6164                                  ;	Background Task Local Descriptor Table					@disk: 009B00	@mem:  006700
  6165                                  ;
  6166                                  ;	This is the LDT for the background task. It defines the stack, code, data and queue segments as well as data
  6167                                  ;	aliases for the TSS LDT. Data aliases allow inspection and altering of the TSS and LDT. This LDT can hold up to
  6168                                  ;	16 descriptors. Six are initially defined.
  6169                                  ;
  6170                                  ;-----------------------------------------------------------------------------------------------------------------------
  6171                                  section			bgldt							;background task local descriptors
  6172                                  			dq	004093006780007Fh				;04 TSS alias		128B  @ 6780
  6173                                  			dq	004093006700007Fh				;0C LDT alias		128B  @ 6700
  6174                                  			dq	00409300600006FFh				;14 stack		1792B @ 6600
  6175                                  			dq	00CF93000000FFFFh				;1C data		4GB   @ 0000
  6176                                  			dq	00409B0070000FFFh				;24 code                4KB   @ 7000
  6177                                  			dq	00409300680007FFh				;2C message queue	2KB   @ 6800
  6178                                  			times	128-($-$$) db 0h				;zero fill to end of section
  6179                                  ;-----------------------------------------------------------------------------------------------------------------------
  6180                                  ;
  6181                                  ;	Background Task State Segment						@disk: 009B80	@mem:  006780
  6182                                  ;
  6183                                  ;	This is the TSS for the console task. All rings share the same stack. DS and ES are set to the console data
  6184                                  ;	segment. CS to console code.
  6185                                  ;
  6186                                  ;-----------------------------------------------------------------------------------------------------------------------
  6187                                  section			bgtss							;background task state segment
  6188                                  			dd	0						;00 back-link tss
  6189                                  			dd	0700h						;04 esp ring 0
  6190                                  			dd	0014h						;08 ss ring 0
  6191                                  			dd	0700h						;0C esp ring 1
  6192                                  			dd	0014h						;10 es ring 1
  6193                                  			dd	0700h						;14 esp ring 2
  6194                                  			dd	0014h						;18 ss ring 2
  6195                                  			dd	0						;1C cr ring 3
  6196                                  			dd	0						;20 eip
  6197                                  			dd	0200h						;24 eflags
  6198                                  			dd	0						;28 eax
  6199                                  			dd	0						;2C ecx
  6200                                  			dd	0						;30 edx
  6201                                  			dd	0						;34 ebx
  6202                                  			dd	0700h						;38 esp ring 3
  6203                                  			dd	0						;3C ebp
  6204                                  			dd	0						;40 esi
  6205                                  			dd	0						;44 edi
  6206                                  			dd	001Ch						;48 es
  6207                                  			dd	0024h						;4C cs
  6208                                  			dd	0014h						;50 ss ring 3
  6209                                  			dd	001Ch						;54 ds
  6210                                  			dd	0						;58 fs
  6211                                  			dd	0						;5c gs
  6212                                  			dd	ESELBACKGROUNDLDT				;60 ldt selector in gdt
  6213                                  			times	128-($-$$) db 0h				;zero fill to end of section
  6214                                  ;-----------------------------------------------------------------------------------------------------------------------
  6215                                  ;
  6216                                  ;	Background Task Message Queue						@disk: 009C00	@mem: 006800
  6217                                  ;
  6218                                  ;	The console message queue is 2048 bytes of memory organized as a queue of 510 double words (4 bytes each) and
  6219                                  ;	two double word values that act as indices. The queue is a FIFO that is fed by the keyboard hardware interrupt
  6220                                  ;	handler and consumed by a service routine called from a task. Each queue entry defines an input (keystroke)
  6221                                  ;	event.
  6222                                  ;
  6223                                  ;-----------------------------------------------------------------------------------------------------------------------
  6224                                  section			bgmque							;console message queue
  6225                                  			dd	8						;head pointer
  6226                                  			dd	8						;tail pointer
  6227                                  			times	510 dd 0					;queue elements
  6228                                  ;-----------------------------------------------------------------------------------------------------------------------
  6229                                  ;
  6230                                  ;	Background Task Code							@disk: 00A400	@mem: 007000
  6231                                  ;
  6232                                  ;-----------------------------------------------------------------------------------------------------------------------
  6233                                  section			bgcode	vstart=07000h					;labels relative to 7000h
  6234                                  BackgroundCode		call	BgInitializeData				;initialize the background variables
  6235                                  
  6236                                  .10			readRealTimeClock wsBgDateTime				;read real-time clock data
  6237                                  			putTimeString     wsBgDateTime,wzBgTime			;create ASCII time string
  6238                                  			compareMemory	  wzBgTime,wzBgTimeCmpr,EBGTIMELEN	;compare to previous time string
  6239                                  
  6240                                  			jecxz	.10						;repeat if equal
  6241                                  			push	es						;save non-volatile reg
  6242                                  			push	ESELCGA						;load CGA selector ...
  6243                                  			pop	es						;... into extra segment reg
  6244                                  			mov	esi,wzBgTime					;string address
  6245                                  			mov	ch,24						;OIA row
  6246                                  			mov	cl,67						;OIA column
  6247                                  
  6248                                  			setConsoleString					;display string
  6249                                  
  6250                                  			pop	es						;restore non-volatile reg
  6251                                  
  6252                                  			copyMemory	  wzBgTime,wzBgTimeCmpr,EBGTIMELEN	;copy to comparison string
  6253                                  			yield							;halt until interrupt
  6254                                  
  6255                                  			jmp	.10						;continue
  6256                                  ;-----------------------------------------------------------------------------------------------------------------------
  6257                                  ;
  6258                                  ;	Routine:	BgInitializeData
  6259                                  ;
  6260                                  ;	Description:	This routine initializes background task variables.
  6261                                  ;
  6262                                  ;-----------------------------------------------------------------------------------------------------------------------
  6263                                  BgInitializeData	push	ecx						;save non-volatile regs
  6264                                  			push	edi						;
  6265                                  			push	es						;
  6266                                  ;
  6267                                  ;	Initialize console work areas
  6268                                  ;
  6269                                  			push	ESELDAT						;load OS data selector ...
  6270                                  			pop	es						;... into extra segment register
  6271                                  			mov	edi,EBGDATA					;OS console data address
  6272                                  			xor	al,al						;initialization value
  6273                                  			mov	ecx,EBGDATALEN					;size of OS console data
  6274                                  			cld							;forward strings
  6275                                  			rep	stosb						;initialize data
  6276                                  ;
  6277                                  ;	Restore and return
  6278                                  ;
  6279                                  			pop	es						;restore non-volatile regs
  6280                                  			pop	edi						;
  6281                                  			pop	ecx						;
  6282                                  			ret							;return
  6283                                  ;-----------------------------------------------------------------------------------------------------------------------
  6284                                  ;
  6285                                  ;	Background Task Constants
  6286                                  ;
  6287                                  ;-----------------------------------------------------------------------------------------------------------------------
  6288                                  			times	4094-($-$$) db 0h				;zero fill to end of section
  6289                                  			db	055h,0AAh					;end of section
  6290                                  %endif
  6291                                  %ifdef BUILDDISK
  6292                                  ;-----------------------------------------------------------------------------------------------------------------------
  6293                                  ;
  6294                                  ;	Free Disk Space								@disk: 00B400	@mem:  n/a
  6295                                  ;
  6296                                  ;	Following the convention introduced by DOS, we use the value 'F6' to indicate unused floppy disk storage.
  6297                                  ;
  6298                                  ;-----------------------------------------------------------------------------------------------------------------------
  6299                                  section			unused							;unused disk space
  6300                                  			times	EBOOTDISKBYTES-0B400h db 0F6h			;fill to end of disk image
  6301                                  %endif
  6302                                  ;=======================================================================================================================
  6303                                  ;
  6304                                  ;	End of Program Code
  6305                                  ;
  6306                                  ;=======================================================================================================================
