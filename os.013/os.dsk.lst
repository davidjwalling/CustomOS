     1                                  ;=======================================================================================================================
     2                                  ;
     3                                  ;	File:		os.asm
     4                                  ;
     5                                  ;	Project:	os.013
     6                                  ;
     7                                  ;	Description:	In this sample, the console task is expanded to add a "pciprobe" command that searches the
     8                                  ;			system for PCI expansion BIOS.
     9                                  ;
    10                                  ;	Revised:	July 1, 2017
    11                                  ;
    12                                  ;	Assembly:	nasm os.asm -f bin -o os.dat     -l os.dat.lst     -DBUILDBOOT
    13                                  ;			nasm os.asm -f bin -o os.dsk     -l os.dsk.lst     -DBUILDDISK
    14                                  ;			nasm os.asm -f bin -o os.com     -l os.com.lst     -DBUILDCOM
    15                                  ;			nasm os.asm -f bin -o osprep.com -l osprep.com.lst -DBUILDPREP
    16                                  ;
    17                                  ;	Assembler:	Netwide Assembler (NASM) 2.13.01
    18                                  ;
    19                                  ;			Copyright (C) 2010-2017 by David J. Walling. All Rights Reserved.
    20                                  ;
    21                                  ;=======================================================================================================================
    22                                  ;-----------------------------------------------------------------------------------------------------------------------
    23                                  ;
    24                                  ;	Assembly Directives
    25                                  ;
    26                                  ;	Use one of the following as an assembly directive (-D) with NASM.
    27                                  ;
    28                                  ;	BUILDBOOT	Creates os.dat, a 512-byte boot sector as a standalone file.
    29                                  ;	BUILDDISK	Creates os.dsk, a 1.44MB (3.5") floppy disk image file.
    30                                  ;	BUILDCOM	Creates os.com, the OS loader and kernel as a standalone DOS program.
    31                                  ;	BUILDPREP	Creates osprep.com, a DOS program that prepares a floppy disk to boot the OS
    32                                  ;
    33                                  ;-----------------------------------------------------------------------------------------------------------------------
    34                                  %ifdef BUILDDISK
    35                                  %define BUILDBOOT
    36                                  %define BUILDCOM
    37                                  %endif
    38                                  %ifdef BUILDPREP
    39                                  %define BUILDBOOT
    40                                  %endif
    41                                  ;-----------------------------------------------------------------------------------------------------------------------
    42                                  ;
    43                                  ;	Conventions
    44                                  ;
    45                                  ;	Labels:		Labels within a routine are numeric and begin with a period (.10, .20).
    46                                  ;			Labels within a routine begin at ".10" and increment by 10.
    47                                  ;
    48                                  ;	Comments:	A comment that spans the entire line begins with a semicolon in column 1.
    49                                  ;			A comment that accompanies code on a line begins with a semicolon in column 81.
    50                                  ;			Register names in comments are in upper case.
    51                                  ;			Hexadecimal values in comments are in lower case.
    52                                  ;			Routines are preceded with a comment box that includes the routine name, description, and
    53                                  ;			register contents on entry and exit.
    54                                  ;
    55                                  ;	Alignment:	Assembly instructions (mnemonics) begin in column 25.
    56                                  ;			Assembly operands begin in column 33.
    57                                  ;			Lines should not extend beyond column 120.
    58                                  ;
    59                                  ;	Routines:	Routine names are in mixed case (GetYear, ReadRealTimeClock).
    60                                  ;			Routine names begin with a verb (Get, Read, etc.).
    61                                  ;			Routines should have a single entry address and a single exit instruction (ret, iretd, etc.).
    62                                  ;
    63                                  ;	Constants:	Symbolic constants (equates) are named in all-caps beginning with 'E' (EDATAPORT).
    64                                  ;			Constant stored values are named in camel case, starting with 'c'.
    65                                  ;			The 2nd letter of the constant label indicates the storage type.
    66                                  ;
    67                                  ;			cq......	constant quad-word (dq)
    68                                  ;			cd......	constant double-word (dd)
    69                                  ;			cw......	constant word (dw)
    70                                  ;			cb......	constant byte (db)
    71                                  ;			cz......	constant ASCIIZ (null-terminated) string
    72                                  ;
    73                                  ;	Variables:	Variables are named in camel case, starting with 'w'.
    74                                  ;			The 2nd letter of the variable label indicates the storage type.
    75                                  ;
    76                                  ;			wq......	variable quad-word (resq)
    77                                  ;			wd......	variable double-word (resd)
    78                                  ;			ww......	variable word (resw)
    79                                  ;			wb......	variable byte (resb)
    80                                  ;
    81                                  ;	Literals:	Literal values defined by external standards should be defined as symbolic constants (equates).
    82                                  ;			Hexadecimal literals in code are in upper case with a leading '0' and trailing 'h'. e.g. 01Fh.
    83                                  ;			Binary literal values in source code are encoded with a final 'b', e.g. 1010b.
    84                                  ;			Decimal literal values in source code are strictly numerals, e.g. 2048.
    85                                  ;			Octal literal values are avoided.
    86                                  ;			String literals are enclosed in double quotes, e.g. "Loading OS".
    87                                  ;			Single character literals are enclosed in single quotes, e.g. 'A'.
    88                                  ;
    89                                  ;	Structures:	Structure names are in all-caps (DATETIME).
    90                                  ;			Structure names do not begin with a verb.
    91                                  ;
    92                                  ;	Macros:		Macro names are in camel case (getDateString).
    93                                  ;			Macro names do begin with a verb.
    94                                  ;
    95                                  ;	Registers:	Register names in comments are in upper case.
    96                                  ;			Register names in source code are in lower case.
    97                                  ;
    98                                  ;	Usage:		Registers EBX, ECX, ESI, EDI, EBP, SS, CS, DS and ES are preserved by all OS routines.
    99                                  ;			Registers EAX and ECX are preferred for returning response/result values.
   100                                  ;			Register EBX is preferred for passing a context (structure) address parameter.
   101                                  ;			Registers EAX, EDX, ECX and EBX are preferred for passing integral parameters.
   102                                  ;
   103                                  ;-----------------------------------------------------------------------------------------------------------------------
   104                                  ;=======================================================================================================================
   105                                  ;
   106                                  ;	Equates
   107                                  ;
   108                                  ;	The equate (equ) statement defines a symbolic name for a fixed value so that such a value can be defined and
   109                                  ;	verified once and then used throughout the code. Using symbolic names simplifies searching for where logical
   110                                  ;	values are used. Equate names are in all-caps and begin with the letter 'E'. Equates are grouped into related
   111                                  ;	sets. Hardware-based values are listed first, followed by BIOS, protocol and application values.
   112                                  ;
   113                                  ;=======================================================================================================================
   114                                  ;-----------------------------------------------------------------------------------------------------------------------
   115                                  ;
   116                                  ;	8042 Keyboard Controller						EKEYB...
   117                                  ;
   118                                  ;	The 8042 Keyboard Controller (8042) is a programmable controller that accepts input signals from the keyboard
   119                                  ;	device. It also signals a hardware interrupt to the CPU when the low-order bit of I/O port 64h is set to zero.
   120                                  ;
   121                                  ;-----------------------------------------------------------------------------------------------------------------------
   122                                  EKEYBPORTDATA		equ	060h						;data port
   123                                  EKEYBPORTSTAT		equ	064h						;status port
   124                                  EKEYBCMDRESET		equ	0FEh						;reset bit 0 to restart system
   125                                  EKEYBBITOUT		equ	001h						;output buffer status bit
   126                                  EKEYBBITIN		equ	002h						;input buffer status bit
   127                                  EKEYBCMDLAMPS		equ	0EDh						;set/reset lamps command
   128                                  EKEYBWAITLOOP		equ	010000h						;wait loop
   129                                  										;---------------------------------------
   130                                  										;	Keyboard Scan Codes
   131                                  										;---------------------------------------
   132                                  EKEYBCTRLDOWN		equ	01Dh						;control key down
   133                                  EKEYBPAUSEDOWN		equ	01Dh						;pause key down (e1 1d ... )
   134                                  EKEYBSHIFTLDOWN		equ	02Ah						;left shift key down
   135                                  EKEYBPRTSCRDOWN		equ	02Ah						;print-screen key down (e0 2a ...)
   136                                  EKEYBSLASH		equ	035h						;slash
   137                                  EKEYBSHIFTRDOWN		equ	036h						;right shift key down
   138                                  EKEYBALTDOWN		equ	038h						;alt key down
   139                                  EKEYBCAPSDOWN		equ	03Ah						;caps-lock down
   140                                  EKEYBNUMDOWN		equ	045h						;num-lock down
   141                                  EKEYBSCROLLDOWN		equ	046h						;scroll-lock down
   142                                  EKEYBINSERTDOWN		equ	052h						;insert down (e0 52)
   143                                  EKEYBUP			equ	080h						;up
   144                                  EKEYBCTRLUP		equ	09Dh						;control key up
   145                                  EKEYBSHIFTLUP		equ	0AAh						;left shift key up
   146                                  EKEYBSLASHUP		equ	0B5h						;slash key up
   147                                  EKEYBSHIFTRUP		equ	0B6h						;right shift key up
   148                                  EKEYBPRTSCRUP		equ	0B7h						;print-screen key up (e0 b7 ...)
   149                                  EKEYBALTUP		equ	0B8h						;alt key up
   150                                  EKEYBCAPSUP		equ	0BAh						;caps-lock up
   151                                  EKEYBNUMUP		equ	0C5h						;num-lock up
   152                                  EKEYBSCROLLUP		equ	0C6h						;scroll-lock up
   153                                  EKEYBINSERTUP		equ	0D2h						;insert up (e0 d2)
   154                                  EKEYBCODEEXT0		equ	0E0h						;extended scan code 0
   155                                  EKEYBCODEEXT1		equ	0E1h						;extended scan code 1
   156                                  ;-----------------------------------------------------------------------------------------------------------------------
   157                                  ;
   158                                  ;	8253 Programmable Interrupt Timer					EPIT...
   159                                  ;
   160                                  ;	The Intel 8253 Programmable Interrupt Time (PIT) is a chip that produces a hardware interrupt (IRQ0)
   161                                  ;	approximately 18.2 times per second.
   162                                  ;
   163                                  ;-----------------------------------------------------------------------------------------------------------------------
   164                                  EPITDAYTICKS		equ	1800B0h						;ticks per day
   165                                  ;-----------------------------------------------------------------------------------------------------------------------
   166                                  ;
   167                                  ;	8259 Peripheral Interrupt Controller					EPIC...
   168                                  ;
   169                                  ;	The 8259 Peripheral Interrupt Controller (PIC) is a programmable controller that accepts interrupt signals from
   170                                  ;	external devices and signals a hardware interrupt to the CPU.
   171                                  ;
   172                                  ;-----------------------------------------------------------------------------------------------------------------------
   173                                  EPICPORTPRI		equ	020h						;primary control port 0
   174                                  EPICPORTPRI1		equ	021h						;primary control port 1
   175                                  EPICPORTSEC		equ	0A0h						;secondary control port 0
   176                                  EPICPORTSEC1		equ	0A1h						;secondary control port 1
   177                                  EPICEOI			equ	020h						;non-specific EOI code
   178                                  ;-----------------------------------------------------------------------------------------------------------------------
   179                                  ;
   180                                  ;	6845 Cathode Ray Tube (CRT) Controller					ECRT...
   181                                  ;
   182                                  ;	The Motorola 6845 CRT Controller (CRTC) is a programmable controller
   183                                  ;	for CGA, EGA, VGA and compatible video modes.
   184                                  ;
   185                                  ;-----------------------------------------------------------------------------------------------------------------------
   186                                  ECRTPORTHI		equ	003h						;controller port hi
   187                                  ECRTPORTLO		equ	0D4h						;controller port lo
   188                                  ECRTCURLOCHI		equ	00Eh						;cursor loc reg hi
   189                                  ECRTCURLOCLO		equ	00Fh						;cursor loc reg lo
   190                                  ;-----------------------------------------------------------------------------------------------------------------------
   191                                  ;
   192                                  ;	NEC 765 Floppy Disk Controller (FDC)					EFDC...
   193                                  ;
   194                                  ;	The NEC 765 FDC is a programmable controller for floppy disk drives.
   195                                  ;
   196                                  ;-----------------------------------------------------------------------------------------------------------------------
   197                                  EFDCPORTHI		equ	003h						;controller port hi
   198                                  EFDCPORTLOOUT		equ	0F2h						;digital output register lo
   199                                  EFDCPORTLOSTAT		equ	0F4h						;main status register lo
   200                                  EFDCSTATBUSY		equ	010h						;main status is busy
   201                                  EFDCMOTOROFF		equ	00Ch						;motor off / enable / DMA
   202                                  ;-----------------------------------------------------------------------------------------------------------------------
   203                                  ;
   204                                  ;	Motorola MC 146818 Real-Time Clock					ERTC...
   205                                  ;
   206                                  ;	The Motorola MC 146818 was the original real-time clock in PCs.
   207                                  ;
   208                                  ;-----------------------------------------------------------------------------------------------------------------------
   209                                  ERTCREGPORT		equ	70h						;register select port
   210                                  ERTCDATAPORT		equ	71h						;data port
   211                                  ERTCSECONDREG		equ	00h						;second
   212                                  ERTCMINUTEREG		equ	02h						;minute
   213                                  ERTCHOURREG		equ	04h						;hour
   214                                  ERTCWEEKDAYREG		equ	06h						;weekday
   215                                  ERTCDAYREG		equ	07h						;day
   216                                  ERTCMONTHREG		equ	08h						;month
   217                                  ERTCYEARREG		equ	09h						;year of the century
   218                                  ERTCSTATUSREG		equ	0bh						;status
   219                                  ERTCCENTURYREG		equ	32h						;century
   220                                  ERTCBINARYVALS		equ	00000100b					;values are binary
   221                                  ;-----------------------------------------------------------------------------------------------------------------------
   222                                  ;
   223                                  ;	x86 Descriptor Access Codes						EACC...
   224                                  ;
   225                                  ;	The x86 architecture supports the classification of memory areas or segments. Segment attributes are defined by
   226                                  ;	structures known as descriptors. Within a descriptor are access type codes that define the type of the segment.
   227                                  ;
   228                                  ;	0.......	Segment is not present in memory (triggers int 11)
   229                                  ;	1.......	Segment is present in memory
   230                                  ;	.LL.....	Segment is of privilege level LL (0,1,2,3)
   231                                  ;	...0....	Segment is a system segment
   232                                  ;	...00010		Local Descriptor Table
   233                                  ;	...00101		Task Gate
   234                                  ;	...010B1		Task State Segment (B:0=Available,1=Busy)
   235                                  ;	...01100		Call Gate (386)
   236                                  ;	...01110		Interrupt Gate (386)
   237                                  ;	...01111		Trap Gate (386)
   238                                  ;	...1...A	Segment is a code or data (A:1=Accesssed)
   239                                  ;	...10DW.		Data (D:1=Expand Down,W:1=Writable)
   240                                  ;	...11CR.		Code (C:1=Conforming,R:1=Readable)
   241                                  ;
   242                                  ;-----------------------------------------------------------------------------------------------------------------------
   243                                  EACCLDT			equ	10000010b					;local descriptor table
   244                                  EACCTASK		equ	10000101b					;task gate
   245                                  EACCTSS			equ	10001001b					;task-state segment
   246                                  EACCGATE		equ	10001100b					;call gate
   247                                  EACCINT			equ	10001110b					;interrupt gate
   248                                  EACCTRAP		equ	10001111b					;trap gate
   249                                  EACCDATA		equ	10010011b					;upward writable data
   250                                  EACCCODE		equ	10011011b					;non-conforming readable code
   251                                  ;-----------------------------------------------------------------------------------------------------------------------
   252                                  ;
   253                                  ;	BIOS Interrupts and Functions						EBIOS...
   254                                  ;
   255                                  ;	Basic Input/Output System (BIOS) functions are grouped and accessed by issuing an interrupt call. Each
   256                                  ;	BIOS interrupt supports several funtions. The function code is typically passed in the AH register.
   257                                  ;
   258                                  ;-----------------------------------------------------------------------------------------------------------------------
   259                                  EBIOSINTVIDEO		equ	010h						;video services interrupt
   260                                  EBIOSFNSETVMODE		equ	000h						;video set mode function
   261                                  EBIOSMODETEXT80		equ	003h						;video mode 80x25 text
   262                                  EBIOSFNTTYOUTPUT	equ	00Eh						;video TTY output function
   263                                  EBIOSINTDISKETTE	equ	013h						;diskette services interrupt
   264                                  EBIOSINTMISC		equ	015h						;miscellaneous services interrupt
   265                                  EBIOSFNINITPROTMODE	equ	089h						;initialize protected mode fn
   266                                  EBIOSINTKEYBOARD	equ	016h						;keyboard services interrupt
   267                                  EBIOSFNKEYSTATUS	equ	001h						;keyboard status function
   268                                  ;-----------------------------------------------------------------------------------------------------------------------
   269                                  ;
   270                                  ;	ASCII									EASCII...
   271                                  ;
   272                                  ;-----------------------------------------------------------------------------------------------------------------------
   273                                  EASCIIBACKSPACE		equ	008h						;backspace
   274                                  EASCIILINEFEED		equ	00Ah						;line feed
   275                                  EASCIIRETURN		equ	00Dh						;carriage return
   276                                  EASCIIESCAPE		equ	01Bh						;escape
   277                                  EASCIISPACE		equ	020h						;space
   278                                  EASCIIPERIOD		equ	02Eh						;period
   279                                  EASCIIUPPERA		equ	041h						;'A'
   280                                  EASCIIUPPERZ		equ	05Ah						;'Z'
   281                                  EASCIILOWERA		equ	061h						;'a'
   282                                  EASCIILOWERZ		equ	07Ah						;'z'
   283                                  EASCIITILDE		equ	07Eh						;'~'
   284                                  EASCIIBORDSGLVERT	equ	0B3h						;vertical single border
   285                                  EASCIIBORDSGLUPRRGT	equ	0BFh						;upper-right single border
   286                                  EASCIIBORDSGLLWRLFT	equ	0C0h						;lower-left single border
   287                                  EASCIIBORDSGLHORZ	equ	0C4h						;horizontal single border
   288                                  EASCIIBORDSGLLWRRGT	equ	0D9h						;lower-right single border
   289                                  EASCIIBORDSGLUPRLFT	equ	0DAh						;upper-left single border
   290                                  EASCIICASE		equ	00100000b					;case bit
   291                                  EASCIICASEMASK		equ	11011111b					;case mask
   292                                  ;-----------------------------------------------------------------------------------------------------------------------
   293                                  ;
   294                                  ;	PCI									EPCI...
   295                                  ;
   296                                  ;-----------------------------------------------------------------------------------------------------------------------
   297                                  EPCIVENDORAPPLE		equ	106Bh						;Apple
   298                                  EPCIVENDORINTEL		equ	8086h						;Intel
   299                                  EPCIVENDORORACLE	equ	80EEh						;Oracle
   300                                  EPCIAPPLEUSB		equ	003Fh						;USB Controller
   301                                  EPCIINTELPRO1000MT	equ	100Fh						;Pro/1000 MT Ethernet Adapter
   302                                  EPCIINTELPCIMEM		equ	1237h						;PCI & Memory
   303                                  EPCIINTELAD1881		equ	2415h						;Aureal AD1881 SOUNDMAX
   304                                  EPCIINTELPIIX3		equ	7000h						;PIIX3 PCI-to-ISA Bridge (Triton II)
   305                                  EPCIINTEL82371AB	equ	7111h						;82371AB/EB PCI Bus Master IDE Cntrlr
   306                                  EPCIINTELPIIX4		equ	7113h						;PIIX4/4E/4M Power Mgmt Cntrlr
   307                                  EPCIORACLEVBOXGA	equ	0BEEFh						;VirtualBox Graphics Adapter
   308                                  EPCIORACLEVBOXDEVICE	equ	0CAFEh						;VirtualBox Device
   309                                  ;-----------------------------------------------------------------------------------------------------------------------
   310                                  ;
   311                                  ;	Boot Sector and Loader Constants					EBOOT...
   312                                  ;
   313                                  ;	Equates in this section support the boot sector and the 16-bit operating system loader, which will be
   314                                  ;	responsible for placing the CPU into protected mode and calling the initial operating system task.
   315                                  ;
   316                                  ;-----------------------------------------------------------------------------------------------------------------------
   317                                  EBOOTSTACKTOP		equ	0100h						;boot sector stack top relative to DS
   318                                  EBOOTSECTORBYTES	equ	512						;bytes per sector
   319                                  EBOOTDISKSECTORS	equ	2880						;sectors per disk
   320                                  EBOOTDISKBYTES		equ	(EBOOTSECTORBYTES*EBOOTDISKSECTORS)		;bytes per disk
   321                                  EBOOTFATBASE		equ	(EBOOTSTACKTOP+EBOOTSECTORBYTES)		;offset of FAT I/O buffer rel to DS
   322                                  EBOOTMAXTRIES		equ	5						;max read retries
   323                                  ;-----------------------------------------------------------------------------------------------------------------------
   324                                  ;	Global Descriptor Table (GDT) Selectors					ESEL...
   325                                  ;-----------------------------------------------------------------------------------------------------------------------
   326                                  ESELGDT			equ	008h						;gdt alias selector
   327                                  ESELDAT			equ	018h						;kernel data selector
   328                                  ESELCGA			equ	020h						;cga video selector
   329                                  ESELOSCODE		equ	048h						;os kernel code selector
   330                                  ESELLOADERLDT		equ	050h						;loader local descriptor table selector
   331                                  ESELLOADERTSS		equ	058h						;loader task state segment selector
   332                                  ESELCONSOLELDT		equ	060h						;console local descriptor table selector
   333                                  ESELCONSOLETSS		equ	068h						;console task state segment selector
   334                                  ESELBACKGROUNDLDT	equ	070h						;background local descr table selector
   335                                  ESELBACKGROUNDTSS	equ	078h						;background task state segment selector
   336                                  ESELKEYBOARDMQ		equ	080h						;keyboard focus message queue (IRQ1)
   337                                  ;-----------------------------------------------------------------------------------------------------------------------
   338                                  ;	LDT Selectors								ESEL...
   339                                  ;-----------------------------------------------------------------------------------------------------------------------
   340                                  ESELMQ			equ	02Ch						;console task message queue
   341                                  ;-----------------------------------------------------------------------------------------------------------------------
   342                                  ;	Kernel Constants							EKRN...
   343                                  ;-----------------------------------------------------------------------------------------------------------------------
   344                                  EKRNDESLEN		equ	8						;size of descriptor
   345                                  EKRNDATASEG		equ	00000h						;kernel data segment (0000:0800)
   346                                  EKRNCODEADR		equ	01000h						;kernel base address (0000:1000)
   347                                  EKRNCODESEG		equ	(EKRNCODEADR >> 4)				;kernel code segment (0100:0000)
   348                                  ;-----------------------------------------------------------------------------------------------------------------------
   349                                  ;	Keyboard Flags								EKEYF...
   350                                  ;-----------------------------------------------------------------------------------------------------------------------
   351                                  EKEYFCTRLLEFT		equ	00000001b					;left control
   352                                  EKEYFSHIFTLEFT		equ	00000010b					;left shift
   353                                  EKEYFALTLEFT		equ	00000100b					;left alt
   354                                  EKEYFCTRLRIGHT		equ	00001000b					;right control
   355                                  EKEYFSHIFTRIGHT		equ	00010000b					;right shift
   356                                  EKEYFSHIFT		equ	00010010b					;left or right shift
   357                                  EKEYFALTRIGHT		equ	00100000b					;right alt
   358                                  EKEYFLOCKSCROLL		equ	00000001b					;scroll-lock flag
   359                                  EKEYFLOCKNUM		equ	00000010b					;num-lock flag
   360                                  EKEYFLOCKCAPS		equ	00000100b					;cap-lock flag
   361                                  EKEYFTIMEOUT		equ	10000000b					;controller timeout
   362                                  ;-----------------------------------------------------------------------------------------------------------------------
   363                                  ;	Hardware Flags
   364                                  ;-----------------------------------------------------------------------------------------------------------------------
   365                                  EHWETHERNET		equ	80h						;ethernet adapter found
   366                                  ;-----------------------------------------------------------------------------------------------------------------------
   367                                  ;	Console Constants							ECON...
   368                                  ;-----------------------------------------------------------------------------------------------------------------------
   369                                  ECONCOLS		equ	80						;columns per row
   370                                  ECONROWS		equ	24						;console rows
   371                                  ECONOIAROW		equ	24						;operator information area row
   372                                  ECONCOLBYTES		equ	2						;bytes per column
   373                                  ECONROWBYTES		equ	(ECONCOLS*ECONCOLBYTES)				;bytes per row
   374                                  ECONROWDWORDS		equ	(ECONROWBYTES/4)				;double-words per row
   375                                  ECONCLEARDWORD		equ	007200720h					;attribute and ASCII space
   376                                  ECONOIADWORD		equ	070207020h					;attribute and ASCII space
   377                                  ;-----------------------------------------------------------------------------------------------------------------------
   378                                  ;	Kernel Message Identifiers						EMSG...
   379                                  ;-----------------------------------------------------------------------------------------------------------------------
   380                                  EMSGKEYDOWN		equ	041000000h					;key-down
   381                                  EMSGKEYUP		equ	041010000h					;key-up
   382                                  EMSGKEYCHAR		equ	041020000h					;character
   383                                  ;-----------------------------------------------------------------------------------------------------------------------
   384                                  ;	Background Task Identifiers						EBG...
   385                                  ;-----------------------------------------------------------------------------------------------------------------------
   386                                  EBGTIMELEN		equ	9						;length of time string HH:MM:SS\0
   387                                  ;-----------------------------------------------------------------------------------------------------------------------
   388                                  ;	Memory Constants							EMEM...
   389                                  ;-----------------------------------------------------------------------------------------------------------------------
   390                                  EMEMBASE		equ	10000h						;heap base address
   391                                  EMEMMINSIZE		equ	256						;minimum heap block size (incl. hdr)
   392                                  EMEMFREECODE		equ	"FREE"						;free memory signature
   393                                  EMEMUSERCODE		equ	"USER"						;user memory signature
   394                                  EMEMHEAPSIZE		equ	80000000h					;heap size (temporary)
   395                                  EMEMWIPEBYTE		equ	000h						;byte value to wipe storage
   396                                  ;=======================================================================================================================
   397                                  ;
   398                                  ;	Structures
   399                                  ;
   400                                  ;=======================================================================================================================
   401                                  ;-----------------------------------------------------------------------------------------------------------------------
   402                                  ;
   403                                  ;	DATETIME
   404                                  ;
   405                                  ;	The DATETIME structure stores date and time values from the real-time clock.
   406                                  ;
   407                                  ;-----------------------------------------------------------------------------------------------------------------------
   408                                  struc			DATETIME
   409 00000000 <res 00000001>          .second			resb	1						;seconds
   410 00000001 <res 00000001>          .minute			resb	1						;minutes
   411 00000002 <res 00000001>          .hour			resb	1						;hours
   412 00000003 <res 00000001>          .weekday		resb	1						;day of week
   413 00000004 <res 00000001>          .day			resb	1						;day of month
   414 00000005 <res 00000001>          .month			resb	1						;month of year
   415 00000006 <res 00000001>          .year			resb	1						;year of century
   416 00000007 <res 00000001>          .century		resb	1						;century
   417                                  EDATETIMELEN		equ	($-.second)
   418                                  endstruc
   419                                  ;-----------------------------------------------------------------------------------------------------------------------
   420                                  ;
   421                                  ;	MEMBLOCK
   422                                  ;
   423                                  ;	The MEMBLOCK structure defines a memory block.
   424                                  ;
   425                                  ;-----------------------------------------------------------------------------------------------------------------------
   426                                  struc			MEMBLOCK
   427 00000000 <res 00000004>          .signature		resd	1						;starting signature
   428 00000004 <res 00000004>          .bytes			resd	1						;block size in bytes
   429 00000008 <res 00000004>          .owner			resd	1						;owning task
   430 0000000C <res 00000004>          .reserved		resd	1						;reserved
   431 00000010 <res 00000004>          .nextcontig		resd	1						;next contiguous block
   432 00000014 <res 00000004>          .previouscontig		resd	1						;previous contiguous block
   433 00000018 <res 00000004>          .nextblock		resd	1						;next free/task block
   434 0000001C <res 00000004>          .previousblock		resd	1						;previous free/task block
   435                                  EMEMBLOCKLEN		equ	($-.signature)
   436                                  endstruc
   437                                  ;-----------------------------------------------------------------------------------------------------------------------
   438                                  ;
   439                                  ;	MEMROOT
   440                                  ;
   441                                  ;	The MEMROOT structure defines starting and ending addresses of memory block chains.
   442                                  ;
   443                                  ;-----------------------------------------------------------------------------------------------------------------------
   444                                  struc			MEMROOT
   445 00000000 <res 00000004>          .firstcontig		resd	1						;first contiguous block
   446 00000004 <res 00000004>          .lastcontig		resd	1						;last contiguous block
   447 00000008 <res 00000004>          .firstfree		resd	1						;first free block
   448 0000000C <res 00000004>          .lastfree		resd	1						;last free block
   449 00000010 <res 00000004>          .firsttask		resd	1						;first task block
   450 00000014 <res 00000004>          .lasttask		resd	1						;last task block
   451                                  EMEMROOTLEN		equ	($-.firstcontig)
   452                                  endstruc
   453                                  ;-----------------------------------------------------------------------------------------------------------------------
   454                                  ;
   455                                  ;	MQUEUE
   456                                  ;
   457                                  ;	The MQUEUE structure maps memory used for a message queue.
   458                                  ;
   459                                  ;-----------------------------------------------------------------------------------------------------------------------
   460                                  struc			MQUEUE
   461 00000000 <res 00000004>          MQHead			resd	1						;000 head ptr
   462 00000004 <res 00000004>          MQTail			resd	1						;004 tail ptr
   463 00000008 <res 000003F8>          MQData			resd	254						;message queue
   464                                  endstruc
   465                                  ;-----------------------------------------------------------------------------------------------------------------------
   466                                  ;
   467                                  ;	OSDATA
   468                                  ;
   469                                  ;	The OSDATA structure maps low-memory addresses used by the OS. Some of these addresses are predetermined and
   470                                  ;	used by the BIOS.
   471                                  ;
   472                                  ;-----------------------------------------------------------------------------------------------------------------------
   473                                  struc			OSDATA
   474 00000000 <res 00000400>          			resb	0400h						;000 real mode interrupt vectors
   475 00000400 <res 00000002>          			resw	1						;400 COM1 port address
   476 00000402 <res 00000002>          			resw	1						;402 COM2 port address
   477 00000404 <res 00000002>          			resw	1						;404 COM3 port address
   478 00000406 <res 00000002>          			resw	1						;406 COM4 port address
   479 00000408 <res 00000002>          			resw	1						;408 LPT1 port address
   480 0000040A <res 00000002>          			resw	1						;40a LPT2 port address
   481 0000040C <res 00000002>          			resw	1						;40c LPT3 port address
   482 0000040E <res 00000002>          			resw	1						;40e LPT4 port address
   483 00000410 <res 00000002>          			resb	2						;410 equipment list flags
   484 00000412 <res 00000001>          			resb	1						;412 errors in PCjr infrared keybd link
   485 00000413 <res 00000002>          			resw	1						;413 memory size (kb) INT 12h
   486 00000415 <res 00000001>          			resb	1						;415 mfr error test scratchpad
   487 00000416 <res 00000001>          			resb	1						;416 PS/2 BIOS control flags
   488 00000417 <res 00000001>          			resb	1						;417 keyboard flag byte 0
   489 00000418 <res 00000001>          			resb	1						;418 keyboard flag byte 1
   490 00000419 <res 00000001>          			resb	1						;419 alternate keypad entry
   491 0000041A <res 00000002>          			resw	1						;41a keyboard buffer head offset
   492 0000041C <res 00000002>          			resw	1						;41c keyboard buffer tail offset
   493 0000041E <res 00000020>          			resb	32						;41e keyboard buffer
   494 0000043E <res 00000001>          wbFDCStatus		resb	1						;43e drive recalibration status
   495 0000043F <res 00000001>          wbFDCControl		resb	1						;43f FDC motor status/control byte
   496 00000440 <res 00000001>          wbFDCMotor		resb	1						;440 FDC motor timeout byte
   497 00000441 <res 00000001>          			resb	1						;441 status of last diskette operation
   498 00000442 <res 00000007>          			resb	7						;442 NEC diskette controller status
   499 00000449 <res 00000001>          			resb	1						;449 current video mode
   500 0000044A <res 00000002>          			resw	1						;44a screen columns
   501 0000044C <res 00000002>          			resw	1						;44c video regen buffer size
   502 0000044E <res 00000002>          			resw	1						;44e current video page offset
   503 00000450 <res 00000010>          			resw	8						;450 cursor postions of pages 1-8
   504 00000460 <res 00000001>          			resb	1						;460 cursor ending scanline
   505 00000461 <res 00000001>          			resb	1						;461 cursor start scanline
   506 00000462 <res 00000001>          			resb	1						;462 active display page number
   507 00000463 <res 00000002>          			resw	1						;463 CRTC base port address
   508 00000465 <res 00000001>          			resb	1						;465 CRT mode control register value
   509 00000466 <res 00000001>          			resb	1						;466 CGA current color palette mask
   510 00000467 <res 00000002>          			resw	1						;467 CS:IP for 286 return from PROT MODE
   511 00000469 <res 00000003>          			resb	3						;469 vague
   512 0000046C <res 00000004>          wdClockTicks		resd	1						;46c clock ticks
   513 00000470 <res 00000001>          wbClockDays		resb	1						;470 clock days
   514 00000471 <res 00000001>          			resb	1						;471 bios break flag
   515 00000472 <res 00000002>          			resw	1						;472 soft reset
   516 00000474 <res 00000001>          			resb	1						;474 last hard disk operation status
   517 00000475 <res 00000001>          			resb	1						;475 hard disks attached
   518 00000476 <res 00000001>          			resb	1						;476 XT fised disk drive control byte
   519 00000477 <res 00000001>          			resb	1						;477 port offset to current fixed disk adapter
   520 00000478 <res 00000004>          			resb	4						;478 LPT timeout values
   521 0000047C <res 00000004>          			resb	4						;47c COM timeout values
   522 00000480 <res 00000002>          			resw	1						;480 keyboard buffer start offset
   523 00000482 <res 00000002>          			resw	1						;482 keyboard buffer end offset
   524 00000484 <res 00000001>          			resb	1						;484 Rows on screen less 1 (EGA+)
   525 00000485 <res 00000001>          			resb	1						;485 point height of character matrix (EGA+)
   526 00000486 <res 00000001>          			resb	1						;486 PC Jr initial keybd delay
   527 00000487 <res 00000001>          			resb	1						;487 EGA+ video mode ops
   528 00000488 <res 00000001>          			resb	1						;488 EGA feature bit switches
   529 00000489 <res 00000001>          			resb	1						;489 VGA video display data area
   530 0000048A <res 00000001>          			resb	1						;48a EGA+ display combination code
   531 0000048B <res 00000001>          			resb	1						;48b last diskette data rate selected
   532 0000048C <res 00000001>          			resb	1						;48c hard disk status from controller
   533 0000048D <res 00000001>          			resb	1						;48d hard disk error from controller
   534 0000048E <res 00000001>          			resb	1						;48e hard disk interrupt control flag
   535 0000048F <res 00000001>          			resb	1						;48f combination hard/floppy disk card
   536 00000490 <res 00000004>          			resb	4						;490 drive 0,1,2,3 media state
   537 00000494 <res 00000001>          			resb	1						;494 track currently seeked to on drive 0
   538 00000495 <res 00000001>          			resb	1						;495 track currently seeked to on drive 1
   539 00000496 <res 00000001>          			resb	1						;496 keyboard mode/type
   540 00000497 <res 00000001>          			resb	1						;497 keyboard LED flags
   541 00000498 <res 00000004>          			resd	1						;498 pointer to user wait complete flag
   542 0000049C <res 00000004>          			resd	1						;49c user wait time-out value in microseconds
   543 000004A0 <res 00000001>          			resb	1						;4a0 RTC wait function flag
   544 000004A1 <res 00000001>          			resb	1						;4a1 LANA DMA channel flags
   545 000004A2 <res 00000002>          			resb	2						;4a2 status of LANA 0,1
   546 000004A4 <res 00000004>          			resd	1						;4a4 saved hard disk interrupt vector
   547 000004A8 <res 00000004>          			resd	1						;4a8 BIOS video save/override pointer table addr
   548 000004AC <res 00000008>          			resb	8						;4ac reserved
   549 000004B4 <res 00000001>          			resb	1						;4b4 keyboard NMI control flags
   550 000004B5 <res 00000004>          			resd	1						;4b5 keyboard break pending flags
   551 000004B9 <res 00000001>          			resb	1						;4b9 Port 60 single byte queue
   552 000004BA <res 00000001>          			resb	1						;4ba scan code of last key
   553 000004BB <res 00000001>          			resb	1						;4bb NMI buffer head pointer
   554 000004BC <res 00000001>          			resb	1						;4bc NMI buffer tail pointer
   555 000004BD <res 00000010>          			resb	16						;4bd NMI scan code buffer
   556 000004CD <res 00000001>          			resb	1						;4cd unknown
   557 000004CE <res 00000002>          			resw	1						;4de day counter
   558 000004D0 <res 00000020>          			resb	32						;4d0 unknown
   559 000004F0 <res 00000010>          			resb	16						;4f0 intra-app comm area
   560 00000500 <res 00000001>          			resb	1						;500 print-screen status byte
   561 00000501 <res 00000003>          			resb	3						;501 used by BASIC
   562 00000504 <res 00000001>          			resb	1						;504 DOS single diskette mode
   563 00000505 <res 0000000A>          			resb	10						;505 POST work area
   564 0000050F <res 00000001>          			resb	1						;50f BASIC shell flag
   565 00000510 <res 00000002>          			resw	1						;510 BASIC default DS (DEF SEG)
   566 00000512 <res 00000004>          			resd	1						;512 BASIC INT 1C interrupt handler
   567 00000516 <res 00000004>          			resd	1						;516 BASIC INT 23 interrupt handler
   568 0000051A <res 00000004>          			resd	1						;51a BASIC INT 24 interrupt handler
   569 0000051E <res 00000002>          			resw	1						;51e unknown
   570 00000520 <res 00000002>          			resw	1						;520 DOS dynamic storage
   571 00000522 <res 0000000E>          			resb	14						;522 DOS diskette initialization table (INT 1e)
   572 00000530 <res 00000004>          			resb	4						;530 MODE command
   573 00000534 <res 000001CC>          			resb	460						;534 unused
   574 00000700 <res 00000100>          			resb	256						;700 i/o drivers from io.sys/ibmbio.com
   575                                  ;-----------------------------------------------------------------------------------------------------------------------
   576                                  ;
   577                                  ;	OS Variables								@disk: N/A	@mem: 000800
   578                                  ;
   579                                  ;	Operating system variables are system global. They are defined at low memory address 800h and are typically
   580                                  ;	accessed using GDT selector 18H, which defines a 4GB address space at address 0:0. The variables defined here
   581                                  ;	are organized based on the task that usually accesses them.
   582                                  ;
   583                                  ;-----------------------------------------------------------------------------------------------------------------------
   584                                  ;-----------------------------------------------------------------------------------------------------------------------
   585                                  ;
   586                                  ;	Kernel Variables
   587                                  ;
   588                                  ;	These variables are not task-specific. They are initialized by the OS loader before the system is placed into
   589                                  ;	protected mode. This is necessary because as soon as the system enters protected mode, the timer interrupt
   590                                  ;	(IRQ0) will begin to reference the task selectors queue to implement task switching.
   591                                  ;
   592                                  ;-----------------------------------------------------------------------------------------------------------------------
   593                                  			align	4
   594                                  EKERNELDATA		equ	($)
   595 00000800 <res 00000200>          wwTaskQueue		resw	256						;task selector queue
   596 00000A00 <res 00000004>          wdFarJumpEIP		resd	1						;destination EIP of next task (ignored)
   597 00000A04 <res 00000002>          wwFarJumpSelector	resw	1						;destination task gate
   598 00000A06 <res 00000001>          wbTaskIndex		resb	1						;task selector index
   599 00000A07 <res 00000001>          wbInCriticalSection	resb	1						;task in critical section
   600                                  			align	4
   601 00000A08 <res 00000004>          wfHeapSize		resd	1						;heap size
   602 00000A0C <res 00000018>          wsMemRoot		resb	EMEMROOTLEN					;base memory map
   603                                  EKERNELDATALEN		equ	($-EKERNELDATA)
   604                                  ;-----------------------------------------------------------------------------------------------------------------------
   605                                  ;
   606                                  ;	Console Task Variables
   607                                  ;
   608                                  ;	These variables are exclusve to the console task. These variables are initialized by the console task when
   609                                  ;	the console task starts.
   610                                  ;
   611                                  ;-----------------------------------------------------------------------------------------------------------------------
   612                                  			align	4
   613                                  ECONDATA		equ	($)
   614 00000A24 <res 00000004>          wfConsoleMemAddr	resd	1						;console memory address
   615 00000A28 <res 00000004>          wfConsolePCISelector	resd	1						;PCI selector (bbbbbbbb dddddfff)
   616                                  wfConsolePCIData	equ	$						;PCI register data value
   617 00000A2C <res 00000002>          wwConsolePCIVendor	resw	1						;PCI data vendor
   618 00000A2E <res 00000002>          wwConsolePCIChip	resw	1						;PCI data chip
   619 00000A30 <res 00000004>          wfConsolePCIVendorStr	resd	1						;PCI vendor name string addr
   620 00000A34 <res 00000004>          wfConsolePCIChipStr	resd	1						;PCI device name string addr
   621 00000A38 <res 00000004>          wfConsoleEthernetDevice	resd	1						;PCI ethernet adapter selector
   622 00000A3C <res 00000004>          wfConsoleEthernetMem	resd	1						;PCI ethernet memory mapped i/o address
   623 00000A40 <res 00000004>          wfConsoleEthernetPort	resd	1						;PCI ethernet i/o port
   624 00000A44 <res 00000004>          wfConsoleEthernetCtrl	resd	1						;PCI ethernet control register value
   625 00000A48 <res 00000001>          wbConsoleColumn		resb	1						;console column
   626 00000A49 <res 00000001>          wbConsoleRow		resb	1						;console row
   627 00000A4A <res 00000001>          wbConsoleShift		resb	1						;console shift flags
   628 00000A4B <res 00000001>          wbConsoleLock		resb	1						;console lock flags
   629 00000A4C <res 00000001>          wbConsoleStatus		resb	1						;controller status
   630 00000A4D <res 00000001>          wbConsoleScan0		resb	1						;scan code
   631 00000A4E <res 00000001>          wbConsoleScan1		resb	1						;scan code
   632 00000A4F <res 00000001>          wbConsoleScan2		resb	1						;scan code
   633 00000A50 <res 00000001>          wbConsoleScan3		resb	1						;scan code
   634 00000A51 <res 00000001>          wbConsoleScan4		resb	1						;scan code
   635 00000A52 <res 00000001>          wbConsoleScan5		resb	1						;scan code
   636 00000A53 <res 00000001>          wbConsoleChar		resb	1						;ASCII code
   637 00000A54 <res 00000001>          wbConsolePCIBus		resb	1						;PCI bus
   638 00000A55 <res 00000001>          wbConsolePCIDevice	resb	1						;PCI device
   639 00000A56 <res 00000001>          wbConsolePCIFunction	resb	1						;PCI function
   640 00000A57 <res 00000001>          wbConsoleHWFlags	resb	1						;Hardware Flags
   641 00000A58 <res 00000050>          wzConsoleInBuffer	resb	80						;command input buffer
   642 00000AA8 <res 00000050>          wzConsoleToken		resb	80						;token buffer
   643 00000AF8 <res 00000050>          wzConsoleOutBuffer	resb	80						;response output buffer
   644 00000B48 <res 00000008>          wsConsoleDateTime	resb	EDATETIMELEN					;date-time buffer
   645                                  ECONDATALEN		equ	($-ECONDATA)					;size of console data area
   646                                  ;-----------------------------------------------------------------------------------------------------------------------
   647                                  ;
   648                                  ;	Background Task Variables
   649                                  ;
   650                                  ;	These variables are exclusve to the background task. These variables are initialized by the background task when
   651                                  ;	the task starts.
   652                                  ;
   653                                  ;-----------------------------------------------------------------------------------------------------------------------
   654                                  			align	4
   655                                  EBGDATA			equ	($)
   656 00000B50 <res 00000008>          wsBgDateTime		resb	EDATETIMELEN					;date-time buffer
   657 00000B58 <res 00000009>          wzBgTime		resb	EBGTIMELEN					;time string buffer
   658 00000B61 <res 00000009>          wzBgTimeCmpr		resb	EBGTIMELEN					;time string comparison buffer
   659                                  EBGDATALEN		equ	($-EBGDATA)
   660                                  ;-----------------------------------------------------------------------------------------------------------------------
   661                                  ;
   662                                  ;	End of OS Variables
   663                                  ;
   664                                  ;-----------------------------------------------------------------------------------------------------------------------
   665                                  endstruc
   666                                  ;-----------------------------------------------------------------------------------------------------------------------
   667                                  ;
   668                                  ;	Macros
   669                                  ;
   670                                  ;	These macros are used to assist in defining descriptor tables and interrupt table offsets.
   671                                  ;
   672                                  ;-----------------------------------------------------------------------------------------------------------------------
   673                                  %macro			mint	1
   674                                  _%1			equ	($-$$) / EKRNDESLEN
   675                                  			dq	((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
   676                                  %endmacro
   677                                  %macro			mtrap	1
   678                                  _%1			equ	($-$$) / EKRNDESLEN
   679                                  			dq	((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
   680                                  %endmacro
   681                                  %macro			menter	1
   682                                  ?%1			equ	($-$$)
   683                                  %endmacro
   684                                  %macro			tsvce	1
   685                                  e%1			equ	($-tsvc)/4
   686                                  			dd	%1
   687                                  %endmacro
   688                                  %ifdef BUILDBOOT
   689                                  ;=======================================================================================================================
   690                                  ;
   691                                  ;	Boot Sector								@disk: 000000	@mem: 007c00
   692                                  ;
   693                                  ;	The first sector of the disk is the boot sector. The BIOS will load the boot sector into memory and pass
   694                                  ;	control to the code at the start of the sector. The boot sector code is responsible for loading the operating
   695                                  ;	system into memory. The boot sector contains a disk parameter table describing the geometry and allocation
   696                                  ;	of the disk. Following the disk parameter table is code to load the operating system kernel into memory.
   697                                  ;
   698                                  ;	The 'cpu' directive limits emitted code to those instructions supported by the most primitive processor
   699                                  ;	we expect to ever execute our code. The 'vstart' parameter indicates addressability of symbols so as to
   700                                  ;	emulating the DOS .COM program model. Although the BIOS is expected to load the boot sector at address 7c00,
   701                                  ;	we do not make that assumption. The CPU starts in 16-bit addressing mode. A three-byte jump instruction is
   702                                  ;	immediately followed by a disk parameter table.
   703                                  ;
   704                                  ;=======================================================================================================================
   705                                  			cpu	8086						;assume minimal CPU
   706                                  section			boot	vstart=0100h					;emulate .COM (CS,DS,ES=PSP) addressing
   707                                  			bits	16						;16-bit code at power-up
   708                                  %ifdef BUILDPREP
   709                                  Boot			jmp	word Prep					;jump to preparation code
   710                                  %else
   711 00000000 E91B00                  Boot			jmp	word Boot.10					;jump over parameter table
   712                                  %endif
   713                                  ;-----------------------------------------------------------------------------------------------------------------------
   714                                  ;
   715                                  ;	Disk Parameter Table
   716                                  ;
   717                                  ;	The disk parameter table informs the BIOS of the floppy disk architecture. Here, we use parameters for the
   718                                  ;	3.5" 1.44MB floppy disk since this format is widely supported by virtual machine hypervisors.
   719                                  ;
   720                                  ;-----------------------------------------------------------------------------------------------------------------------
   721 00000003 437573746F6D4F53        			db	"CustomOS"					;eight-byte label
   722 0000000B 0002                    cwSectorBytes		dw	EBOOTSECTORBYTES				;bytes per sector
   723 0000000D 01                      cbClusterSectors	db	1						;sectors per cluster
   724 0000000E 0100                    cwReservedSectors	dw	1						;reserved sectors
   725 00000010 02                      cbFatCount		db	2						;file allocation table copies
   726 00000011 E000                    cwDirEntries		dw	224						;max directory entries
   727 00000013 400B                    cwDiskSectors		dw	EBOOTDISKSECTORS				;sectors per disk
   728 00000015 F0                      cbDiskType		db	0F0h						;1.44MB
   729 00000016 0900                    cwFatSectors		dw	9						;sectors per FAT copy
   730                                  cbTrackSectors		equ	$						;sectors per track (as byte)
   731 00000018 1200                    cwTrackSectors		dw	18						;sectors per track (as word)
   732 0000001A 0200                    cwDiskSides		dw	2						;sides per disk
   733 0000001C 0000                    cwSpecialSectors	dw	0						;special sectors
   734                                  ;
   735                                  ;	BIOS typically loads the boot sector at absolute address 7c00 and sets the stack pointer at 512 bytes past the
   736                                  ;	end of the boot sector. But, since BIOS code varies, we don't make any assumptions as to where our boot sector
   737                                  ;	is loaded. For example, the initial CS:IP could be 0:7c00, 700:c00, 7c0:0, etc. So, to avoid assumptions, we
   738                                  ;	first normalize CS:IP to get the absolute segment address in BX. The comments below show the effect of this code
   739                                  ;	given several possible starting values for CS:IP.
   740                                  ;
   741                                  										;CS:IP	 0:7c00 700:c00 7c0:0
   742 0000001E E80000                  Boot.10			call	word .20					;[ESP] =   7c21     c21    21
   743                                  .@20			equ	$-$$						;.@20 = 021h
   744 00000021 58                      .20			pop	ax						;AX =	   7c21     c21    21
   745 00000022 83E821                  			sub	ax,.@20						;BX =	   7c00     c00     0
   746 00000025 B104                    			mov	cl,4						;shift count
   747 00000027 D3E8                    			shr	ax,cl						;AX =	    7c0      c0     0
   748 00000029 8CCB                    			mov	bx,cs						;BX =	      0     700   7c0
   749 0000002B 01C3                    			add	bx,ax						;BX =	    7c0     7c0   7c0
   750                                  ;
   751                                  ;	Now, since we are assembling our boot code to emulate the addressing of a .COM file, we want the DS and ES
   752                                  ;	registers to be set to where a Program Segment Prefix (PSP) would be, exactly 100h (256) bytes prior to
   753                                  ;	the start of our code. This will correspond to our assembled data address offsets. Note that we instructed
   754                                  ;	the assembler to produce addresses for our symbols that are offset from our code by 100h. See the "vstart"
   755                                  ;	parameter for the "section" directive above. We also set SS to the PSP and SP to the address of our i/o
   756                                  ;	buffer. This leaves 256 bytes of usable stack from 7b0:300 to 7b0:400.
   757                                  ;
   758 0000002D 83EB10                  			sub	bx,16						;BX = 07b0
   759 00000030 8EDB                    			mov	ds,bx						;DS = 07b0 = psp
   760 00000032 8EC3                    			mov	es,bx						;ES = 07b0 = psp
   761 00000034 8ED3                    			mov	ss,bx						;SS = 07b0 = psp (ints disabled)
   762 00000036 BC0001                  			mov	sp,EBOOTSTACKTOP				;SP = 0100       (ints enabled)
   763                                  ;
   764                                  ;	Our boot addressability is now set up according to the following diagram.
   765                                  ;
   766                                  ;	DS,ES,SS ----->	007b00	+-----------------------------------------------+ DS:0000
   767                                  ;				|  Boot Stack & Boot PSP (Unused)		|
   768                                  ;				|  256 = 100h bytes				|
   769                                  ;	SS:SP -------->	007c00	+-----------------------------------------------+ DS:0100  07b0:0100
   770                                  ;				|  Boot Sector (vstart=0100h)			|
   771                                  ;				|  1 sector = 512 = 200h bytes			|
   772                                  ;			007e00	+-----------------------------------------------+ DS:0300
   773                                  ;				|  File Allocation Table (FAT) I/O Buffer	|
   774                                  ;				|  9x512-byte sectors = 4,608 = 1200h bytes	|
   775                                  ;			009000	+-----------------------------------------------+ DS:1500  08f0:0100
   776                                  ;				|  Directory Sector Buffer & Kernel Load Area	|
   777                                  ;			009200	+-----------------------------------------------+ DS:1700
   778                                  ;
   779                                  ;	On entry, DL indicates the drive being booted from.
   780                                  ;
   781 00000039 8816[F801]              			mov	[wbDrive],dl					;[drive] = drive being booted from
   782                                  ;
   783                                  ;	Compute directory i/o buffer address.
   784                                  ;
   785 0000003D A1[1600]                			mov	ax,[cwFatSectors]				;AX = 0009 = FAT sectors
   786 00000040 F726[0B00]              			mul	word [cwSectorBytes]				;DX:AX = 0000:1200 = FAT bytes
   787 00000044 050003                  			add	ax,EBOOTFATBASE					;AX = 1500 = end of FAT buffer
   788 00000047 A3[EC01]                			mov	[wwDirBuffer],ax				;[dirbuffer] = 1500
   789                                  ;
   790                                  ;	Compute segment where os.com will be loaded.
   791                                  ;
   792 0000004A D3E8                    			shr	ax,cl						;AX = 0150
   793 0000004C 01D8                    			add	ax,bx						;AX = 0150 + 07b0 = 0900
   794 0000004E 83E810                  			sub	ax,16						;AX = 08f0
   795 00000051 A3[3F01]                			mov	[wwLoadSegment],ax				;[loadsegment] = 08f0
   796                                  ;
   797                                  ;	Set the video mode to 80 column, 25 row, text.
   798                                  ;
   799 00000054 B80300                  			mov	ax,EBIOSFNSETVMODE<<8|EBIOSMODETEXT80		;set mode function, 80x25 text mode
   800 00000057 CD10                    			int	EBIOSINTVIDEO					;call BIOS display interrupt
   801                                  ;
   802                                  ;	Write a message to the console so we know we have our addressability established.
   803                                  ;
   804 00000059 BE[C501]                			mov	si,czLoadMsg					;loading message
   805 0000005C E84B01                  			call	BootPrint					;display loader message
   806                                  ;
   807                                  ;	Initialize the number of directory sectors to search.
   808                                  ;
   809 0000005F A1[1100]                			mov	ax,[cwDirEntries]				;AX = 224 = max dir entries
   810 00000062 A3[EE01]                			mov	[wwEntriesLeft],ax				;[entriesleft] = 224
   811                                  ;
   812                                  ;	Compute number of directory sectors and initialize overhead count.
   813                                  ;
   814 00000065 89C1                    			mov	cx,ax						;CX = 00e0 = 224 entries
   815 00000067 F726[B801]              			mul	word [cwEntryLen]				;DX:AX = 224 * 32 = 7168
   816 0000006B F736[0B00]              			div	word [cwSectorBytes]				;AX = 7168 / 512 = 14 = dir sectors
   817 0000006F A3[F001]                			mov	[wwOverhead],ax					;[overhead] = 000e
   818                                  ;
   819                                  ;	Compute directory entries per sector.
   820                                  ;
   821 00000072 91                      			xchg	ax,cx						;DX:AX = 0:00e0, DX = 0000e
   822 00000073 F7F1                    			div	cx						;AX = 0010 = entries per dir sector
   823 00000075 A3[F201]                			mov	[wwSectorEntries],ax				;[sectorentries] = 0010
   824                                  ;
   825                                  ;	Compute first logical directory sector and update overhead count.
   826                                  ;
   827 00000078 A1[1600]                			mov	ax,[cwFatSectors]				;AX = 0009 = FAT sectors per copy
   828 0000007B F626[1000]              			mul	byte [cbFatCount]				;AX = 0012 = FAT sectors
   829 0000007F 0306[0E00]              			add	ax,[cwReservedSectors]				;AX = 0013 = FAT plus reserved
   830 00000083 0306[1C00]              			add	ax,[cwSpecialSectors]				;AX = 0013 = FAT + reserved + special
   831 00000087 A3[F401]                			mov	[wwLogicalSector],ax				;[logicalsector] = 0013
   832 0000008A 0106[F001]              			add	[wwOverhead],ax					;[overhead] = 0021 = res+spec+FAT+dir
   833                                  ;
   834                                  ;	Read directory sector.
   835                                  ;
   836 0000008E B001                    .30			mov	al,1						;sector count
   837 00000090 A2[F601]                			mov	[wbReadCount],al				;[readcount] = 01
   838 00000093 8B1E[EC01]              			mov	bx,[wwDirBuffer]				;BX = 1500
   839 00000097 E8A700                  			call	ReadSector					;read sector into es:bx
   840                                  ;
   841                                  ;	Setup variables to search this directory sector.
   842                                  ;
   843 0000009A A1[EE01]                			mov	ax,[wwEntriesLeft]				;directory entries to search
   844 0000009D 3B06[F201]              			cmp	ax,[wwSectorEntries]				;need to search more sectors?
   845 000000A1 7603                    			jna	.40						;no, continue
   846 000000A3 A1[F201]                			mov	ax,[wwSectorEntries]				;yes, limit search to sector
   847 000000A6 2906[EE01]              .40			sub	[wwEntriesLeft],ax				;update entries left to searh
   848 000000AA BE[BA01]                			mov	si,cbKernelProgram				;program name
   849 000000AD 8B3E[EC01]              			mov	di,[wwDirBuffer]				;DI = 1500
   850                                  ;
   851                                  ;	Loop through directory sectors searching for kernel program.
   852                                  ;
   853 000000B1 56                      .50			push	si						;save kernel name address
   854 000000B2 57                      			push	di						;save dir i/o buffer address
   855 000000B3 B90B00                  			mov	cx,11						;length of 8+3 name
   856 000000B6 FC                      			cld							;forward strings
   857 000000B7 F3A6                    			repe	cmpsb						;compare entry name
   858 000000B9 5F                      			pop	di						;restore dir i/o buffer address
   859 000000BA 5E                      			pop	si						;restore kernel name address
   860 000000BB 7418                    			je	.60						;exit loop if found
   861 000000BD 033E[B801]              			add	di,[cwEntryLen]					;point to next dir entry
   862 000000C1 48                      			dec	ax						;decrement remaining entries
   863 000000C2 75ED                    			jnz	.50						;next entry
   864                                  ;
   865                                  ;	Repeat search if we are not at the end of the directory.
   866                                  ;
   867 000000C4 FF06[F401]              			inc	word [wwLogicalSector]				;increment logical sector
   868 000000C8 833E[EE01]00            			cmp	word [wwEntriesLeft],0				;done with directory?
   869 000000CD 75BF                    			jne	.30						;no, get next sector
   870 000000CF BE[E001]                			mov	si,czNoKernel					;missing kernel message
   871 000000D2 E9C000                  			jmp	BootExit					;display message and exit
   872                                  ;
   873                                  ;	If we find the kernel program in the directory, read the FAT.
   874                                  ;
   875 000000D5 A1[0E00]                .60			mov	ax,[cwReservedSectors]				;AX = 0001
   876 000000D8 A3[F401]                			mov	[wwLogicalSector],ax				;start past boot sector
   877 000000DB A1[1600]                			mov	ax,[cwFatSectors]				;AX = 0009
   878 000000DE A2[F601]                			mov	[wbReadCount],al				;[readcount] = 09
   879 000000E1 BB0003                  			mov	bx,EBOOTFATBASE					;BX = 0300
   880 000000E4 E85A00                  			call	ReadSector					;read FAT into buffer
   881                                  ;
   882                                  ;	Get the starting cluster of the kernel program and target address.
   883                                  ;
   884 000000E7 8B451A                  			mov	ax,[di+26]					;AX = starting cluster of file
   885 000000EA C41E[3D01]              			les	bx,[wwLoadOffset]				;ES:BX = kernel load add (08F0:0100)
   886                                  ;
   887                                  ;	Read each program cluster into RAM.
   888                                  ;
   889 000000EE 50                      .70			push	ax						;save cluster nbr
   890 000000EF 83E802                  			sub	ax,2						;AX = cluster nbr base 0
   891 000000F2 8A0E[0D00]              			mov	cl,[cbClusterSectors]				;CL = sectors per cluster
   892 000000F6 880E[F601]              			mov	[wbReadCount],cl				;save sectors to read
   893 000000FA 30ED                    			xor	ch,ch						;CX = sectors per cluster
   894 000000FC F7E1                    			mul	cx						;DX:AX = logical cluster sector
   895 000000FE 0306[F001]              			add	ax,[wwOverhead]					;AX = kernel sector nbr
   896 00000102 A3[F401]                			mov	[wwLogicalSector],ax				;save logical sector nbr
   897 00000105 E83900                  			call	ReadSector					;read sectors into ES:BX
   898                                  ;
   899                                  ;	Update buffer pointer for next cluster.
   900                                  ;
   901 00000108 A0[0D00]                			mov	al,[cbClusterSectors]				;AL = sectors per cluster
   902 0000010B 30E4                    			xor	ah,ah						;AX = sectors per cluster
   903 0000010D F726[0B00]              			mul	word [cwSectorBytes]				;DX:AX = cluster bytes
   904 00000111 01C3                    			add	bx,ax						;BX = next cluster target address
   905 00000113 58                      			pop	ax						;AX = restore cluster nbr
   906                                  ;
   907                                  ;	Compute next cluster number.
   908                                  ;
   909 00000114 89C1                    			mov	cx,ax						;CX = cluster nbr
   910 00000116 89C7                    			mov	di,ax						;DI = cluster nbr
   911 00000118 D1E8                    			shr	ax,1						;AX = cluster/2
   912 0000011A 89C2                    			mov	dx,ax						;DX = cluster/2
   913 0000011C 01D0                    			add	ax,dx						;AX = 2*(cluster/2)
   914 0000011E 01D0                    			add	ax,dx						;AX = 3*(cluster/2)
   915 00000120 83E701                  			and	di,1						;get low bit
   916 00000123 01C7                    			add	di,ax						;add one if cluster is odd
   917 00000125 81C70003                			add	di,EBOOTFATBASE					;add FAT buffer address
   918 00000129 8B05                    			mov	ax,[di]						;get cluster bytes
   919                                  ;
   920                                  ;	Adjust cluster nbr by 4 bits if cluster is odd; test for end of chain.
   921                                  ;
   922 0000012B F6C101                  			test	cl,1						;is cluster odd?
   923 0000012E 7404                    			jz	.80						;no, skip ahead
   924 00000130 B104                    			mov	cl,4						;shift count
   925 00000132 D3E8                    			shr	ax,cl						;shift nybble low
   926 00000134 25FF0F                  .80			and	ax,0FFFh					;mask for 24 bits; next cluster nbr
   927 00000137 3DFF0F                  			cmp	ax,0FFFh					;end of chain?
   928 0000013A 75B2                    			jne	.70						;no, continue
   929                                  ;
   930                                  ;	Transfer control to the operating system program.
   931                                  ;
   932 0000013C EA                      			db	0EAh						;jmp seg:offset
   933 0000013D 0001                    wwLoadOffset		dw	0100h						;kernel entry offset
   934 0000013F F008                    wwLoadSegment		dw	08F0h						;kernel entry segment (computed)
   935                                  ;
   936                                  ;	Read [readcount] disk sectors from [logicalsector] into ES:BX.
   937                                  ;
   938 00000141 A1[1800]                ReadSector		mov	ax,[cwTrackSectors]				;AX = sectors per track
   939 00000144 F726[1A00]              			mul	word [cwDiskSides]				;DX:AX = sectors per cylinder
   940 00000148 89C1                    			mov	cx,ax						;CX = sectors per cylinder
   941 0000014A A1[F401]                			mov	ax,[wwLogicalSector]				;DX:AX = logical sector
   942 0000014D F7F1                    			div	cx						;AX = cylinder; DX = cyl sector
   943 0000014F A2[FB01]                			mov	[wbTrack],al					;[track] = cylinder
   944 00000152 89D0                    			mov	ax,dx						;AX = cyl sector
   945 00000154 F636[1800]              			div	byte [cbTrackSectors]				;AH = sector, AL = head
   946 00000158 FEC4                    			inc	ah						;AH = sector (1,2,3,...)
   947 0000015A A3[F901]                			mov	[wbHead],ax					;[head]= head, [sector]= sector
   948                                  ;
   949                                  ;	Try maxtries times to read sector.
   950                                  ;
   951 0000015D B90500                  			mov	cx,EBOOTMAXTRIES				;CX = 0005
   952 00000160 53                      .10			push	bx						;save buffer address
   953 00000161 51                      			push	cx						;save retry count
   954 00000162 8B16[F801]              			mov	dx,[wwDriveHead]				;DH = head, DL = drive
   955 00000166 8B0E[FA01]              			mov	cx,[wwSectorTrack]				;CH = track, CL = sector
   956 0000016A A1[F601]                			mov	ax,[wwReadCountCommand]				;AH = fn., AL = sector count
   957 0000016D CD13                    			int	EBIOSINTDISKETTE				;read sector
   958 0000016F 59                      			pop	cx						;restore retry count
   959 00000170 5B                      			pop	bx						;restore buffer address
   960 00000171 7343                    			jnc	BootReturn					;skip ahead if done
   961 00000173 E2EB                    			loop	.10						;retry
   962                                  ;
   963                                  ;	Handle disk error: convert to ASCII and store in error string.
   964                                  ;
   965 00000175 88E0                    			mov	al,ah						;AL = bios error code
   966 00000177 30E4                    			xor	ah,ah						;AX = bios error code
   967 00000179 B210                    			mov	dl,16						;divisor for base 16
   968 0000017B F6F2                    			div	dl						;AL = hi order, AH = lo order
   969 0000017D 0D3030                  			or	ax,03030h					;apply ASCII zone bits
   970 00000180 80FC3A                  			cmp	ah,03Ah						;range test ASCII numeral
   971 00000183 7203                    			jb	.20						;continue if numeral
   972 00000185 80C407                  			add	ah,7						;adjust for ASCII 'A'-'F'
   973 00000188 3C3A                    .20			cmp	al,03Ah						;range test ASCII numeral
   974 0000018A 7203                    			jb	.30						;continue if numeral
   975 0000018C 80C407                  			add	ah,7						;adjust for ASCII 'A'-'F'
   976 0000018F A3[DD01]                .30			mov	[wzErrorCode],ax				;store ASCII error code
   977 00000192 BE[D201]                			mov	si,czErrorMsg					;error message address
   978 00000195 E81200                  BootExit		call	BootPrint					;display messge to console
   979 00000198 B401                    .10			mov	ah,EBIOSFNKEYSTATUS				;bios keyboard status function
   980 0000019A CD16                    			int	EBIOSINTKEYBOARD				;get keyboard status
   981 0000019C 7504                    			jnz	.20						;continue if key pressed
   982 0000019E FB                      			sti							;enable maskable interrupts
   983 0000019F F4                      			hlt							;wait for interrupt
   984 000001A0 EBF6                    			jmp	.10						;repeat
   985 000001A2 B0FE                    .20			mov	al,EKEYBCMDRESET				;8042 pulse output port pin
   986 000001A4 E664                    			out	EKEYBPORTSTAT,al				;drive B0 low to restart
   987 000001A6 FB                      .30			sti							;enable maskable interrupts
   988 000001A7 F4                      			hlt							;stop until reset, int, nmi
   989 000001A8 EBFC                    			jmp	.30						;loop until restart kicks in
   990                                  ;
   991                                  ;	Display text message.
   992                                  ;
   993 000001AA FC                      BootPrint		cld							;forward strings
   994 000001AB AC                      			lodsb							;load next byte at DS:SI in AL
   995 000001AC 84C0                    			test	al,al						;end of string?
   996 000001AE 7406                    			jz	BootReturn					;... yes, exit our loop
   997 000001B0 B40E                    			mov	ah,EBIOSFNTTYOUTPUT				;BIOS teletype function
   998 000001B2 CD10                    			int	EBIOSINTVIDEO					;call BIOS display interrupt
   999 000001B4 EBF4                    			jmp	BootPrint					;repeat until done
  1000 000001B6 C3                      BootReturn		ret							;return
  1001                                  ;-----------------------------------------------------------------------------------------------------------------------
  1002                                  ;
  1003                                  ;	Constants
  1004                                  ;
  1005                                  ;-----------------------------------------------------------------------------------------------------------------------
  1006 000001B7 90                      			align	2
  1007 000001B8 2000                    cwEntryLen		dw	32						;length of directory entry
  1008 000001BA 4F5320202020202043-     cbKernelProgram		db	"OS      COM"					;kernel program name
  1008 000001C3 4F4D               
  1009 000001C5 4C6F6164696E67204F-     czLoadMsg		db	"Loading OS",13,10,0				;loading message
  1009 000001CE 530D0A00           
  1010 000001D2 4469736B206572726F-     czErrorMsg		db	"Disk error "					;error message
  1010 000001DB 7220               
  1011 000001DD 202000                  wzErrorCode		db	020h,020h,0					;error code and null terminator
  1012 000001E0 4F53206D697373696E-     czNoKernel		db	"OS missing",0					;missing kernel message
  1012 000001E9 6700               
  1013                                  ;-----------------------------------------------------------------------------------------------------------------------
  1014                                  ;
  1015                                  ;	Work Areas
  1016                                  ;
  1017                                  ;-----------------------------------------------------------------------------------------------------------------------
  1018 000001EB 90                      			align	2
  1019 000001EC 0000                    wwDirBuffer		dw	0						;directory i/o buffer address
  1020 000001EE 0000                    wwEntriesLeft		dw	0						;directory entries to search
  1021 000001F0 0000                    wwOverhead		dw	0						;overhead sectors
  1022 000001F2 0000                    wwSectorEntries		dw	0						;directory entries per sector
  1023 000001F4 0000                    wwLogicalSector		dw	0						;current logical sector
  1024                                  wwReadCountCommand	equ	$						;read count and command
  1025 000001F6 00                      wbReadCount		db	0						;sectors to read
  1026 000001F7 02                      cbReadCommand		db	2						;BIOS read disk fn code
  1027                                  wwDriveHead		equ	$						;drive, head (word)
  1028 000001F8 00                      wbDrive			db	0						;drive
  1029 000001F9 00                      wbHead			db	0						;head
  1030                                  wwSectorTrack		equ	$						;sector, track (word)
  1031 000001FA 00                      			db	0						;sector
  1032 000001FB 00                      wbTrack			db	0						;track
  1033 000001FC 00<rept>                			times	510-($-$$) db 0h				;zero fill to end of sector
  1034 000001FE 55AA                    			db	055h,0AAh					;end of sector signature
  1035                                  %endif
  1036                                  %ifdef BUILDPREP
  1037                                  ;=======================================================================================================================
  1038                                  ;
  1039                                  ;	Diskette Preparation Code
  1040                                  ;
  1041                                  ;	This routine writes the OS boot sector code to a formatted floppy diskette. The diskette parameter table,
  1042                                  ;	which is located in the first 30 bytes of the boot sector is first read from the diskette and overlayed onto
  1043                                  ;	the OS bootstrap code so that the diskette format parameters are preserved.
  1044                                  ;
  1045                                  ;=======================================================================================================================
  1046                                  ;
  1047                                  ;	Query the user to insert a flopppy diskette and press enter or cancel.
  1048                                  ;
  1049                                  Prep			mov	si,czPrepMsg10					;starting message address
  1050                                  			call	BootPrint					;display message
  1051                                  ;
  1052                                  ;	Exit if the Escape key is pressed or loop until Enter is pressed.
  1053                                  ;
  1054                                  .10			mov	ah,EBIOSFNKEYSTATUS				;BIOS keyboard status function
  1055                                  			int	EBIOSINTKEYBOARD				;get keyboard status
  1056                                  			jnz	.12						;continue if key pressed
  1057                                  			sti							;enable interrupts
  1058                                  			hlt							;wait for interrupt
  1059                                  			jmp	.10						;repeat
  1060                                  .12			cmp	al,EASCIIRETURN					;Enter key pressed?
  1061                                  			je	.15						;yes, branch
  1062                                  			cmp	al,EASCIIESCAPE					;Escape key pressed?
  1063                                  			jne	.10						;no, repeat
  1064                                  			jmp	.90						;yes, exit program
  1065                                  ;
  1066                                  ;	Display writing-sector message and patch the JMP instruction.
  1067                                  ;
  1068                                  .15			mov	si,czPrepMsg12					;writing-sector message address
  1069                                  			call	BootPrint					;display message
  1070                                  			mov	bx,Boot+1					;address of JMP instruction operand
  1071                                  			mov	ax,01Bh						;address past disk parameter table
  1072                                  			mov	[bx],ax						;update the JMP instruction
  1073                                  ;
  1074                                  ;	Try to read the boot sector.
  1075                                  ;
  1076                                  			mov	cx,EBOOTMAXTRIES				;try up to five times
  1077                                  .20			push	cx						;save remaining tries
  1078                                  			mov	bx,wcPrepInBuf					;input buffer address
  1079                                  			mov	dx,0						;head zero, drive zero
  1080                                  			mov	cx,1						;track zero, sector one
  1081                                  			mov	ax,0201h					;read one sector
  1082                                  			int	EBIOSINTDISKETTE				;attempt the read
  1083                                  			pop	cx						;restore remaining retries
  1084                                  			jnc	.30						;skip ahead if successful
  1085                                  			loop	.20						;try again
  1086                                  			mov	si,czPrepMsg20					;read-error message address
  1087                                  			jmp	.50						;branch to error routine
  1088                                  ;
  1089                                  ;	Copy diskette parms from input buffer to output buffer.
  1090                                  ;
  1091                                  .30			mov	si,wcPrepInBuf					;input buffer address
  1092                                  			add	si,11						;skip over JMP and system ID
  1093                                  			mov	di,Boot						;output buffer address
  1094                                  			add	di,11						;skip over JMP and system ID
  1095                                  			mov	cx,19						;length of diskette parameters
  1096                                  			cld							;forward string copies
  1097                                  			rep	movsb						;copy diskette parameters
  1098                                  ;
  1099                                  ;	Try to write boot sector to diskette.
  1100                                  ;
  1101                                  			mov	cx,EBOOTMAXTRIES				;try up to five times
  1102                                  .40			push	cx						;save remaining tries
  1103                                  			mov	bx,Boot						;output buffer address
  1104                                  			mov	dx,0						;head zero, drive zero
  1105                                  			mov	cx,1						;track zero, sector one
  1106                                  			mov	ax,0301h					;write one sector
  1107                                  			int	EBIOSINTDISKETTE				;attempt the write
  1108                                  			pop	cx						;restore remaining retries
  1109                                  			jnc	.80						;skip ahead if successful
  1110                                  			loop	.40						;try again
  1111                                  			mov	si,czPrepMsg30					;write-error message address
  1112                                  ;
  1113                                  ;	Convert the error code to ASCII and display the error message.
  1114                                  ;
  1115                                  .50			push	ax						;save error code
  1116                                  			mov	al,ah						;copy error code
  1117                                  			mov	ah,0						;AX = error code
  1118                                  			mov	dl,10h						;hexadecimal divisor
  1119                                  			idiv	dl						;AL = hi-order, AH = lo-order
  1120                                  			or	ax,03030h					;add ASCII zone digits
  1121                                  			cmp	ah,03Ah						;AH ASCII numeral?
  1122                                  			jb	.60						;yes, continue
  1123                                  			add	ah,7						;no, make ASCII 'A'-'F'
  1124                                  .60			cmp	al,03Ah						;al ASCII numeral?
  1125                                  			jb	.70						;yes, continue
  1126                                  			add	al,7						;no, make ASCII
  1127                                  .70			mov	[si+17],ax					;put ASCII error code in message
  1128                                  			call	BootPrint					;write error message
  1129                                  			pop	ax						;restore error code
  1130                                  ;
  1131                                  ;	Display the completion message.
  1132                                  ;
  1133                                  .80			mov	si,czPrepMsgOK					;assume successful completion
  1134                                  			mov	al,ah						;BIOS return code
  1135                                  			cmp	al,0						;success?
  1136                                  			je	.85						;yes, continue
  1137                                  			mov	si,czPrepMsgErr1				;disk parameter error message
  1138                                  			cmp	al,1						;disk parameter error?
  1139                                  			je	.85						;yes, continue
  1140                                  			mov	si,czPrepMsgErr2				;address mark not found message
  1141                                  			cmp	al,2						;address mark not found?
  1142                                  			je	.85						;yes, continue
  1143                                  			mov	si,czPrepMsgErr3				;protected disk message
  1144                                  			cmp	al,3						;protected disk?
  1145                                  			je	.85						;yes, continue
  1146                                  			mov	si,czPrepMsgErr6				;diskette removed message
  1147                                  			cmp	al,6						;diskette removed?
  1148                                  			je	.85						;yes, continue
  1149                                  			mov	si,czPrepMsgErr80				;drive timed out message
  1150                                  			cmp	al,80H						;drive timed out?
  1151                                  			je	.85						;yes, continue
  1152                                  			mov	si,czPrepMsgErrXX				;unknown error message
  1153                                  .85			call	BootPrint					;display result message
  1154                                  .90			mov	ax,04C00H					;terminate with zero result code
  1155                                  			int	021h						;terminate DOS program
  1156                                  			ret							;return (should not execute)
  1157                                  ;-----------------------------------------------------------------------------------------------------------------------
  1158                                  ;
  1159                                  ;	Diskette Preparation Messages
  1160                                  ;
  1161                                  ;-----------------------------------------------------------------------------------------------------------------------
  1162                                  czPrepMsg10		db	13,10,"CustomOS Boot-Diskette Preparation Program"
  1163                                  			db	13,10,"Copyright (C) 2010-2017 David J. Walling. All rights reserved."
  1164                                  			db	13,10
  1165                                  			db	13,10,"This program overwrites the boot sector of a diskette with startup code that"
  1166                                  			db	13,10,"will load the operating system into memory when the computer is restarted."
  1167                                  			db	13,10,"To proceed, place a formatted diskette into drive A: and press the Enter key."
  1168                                  			db	13,10,"To exit this program without preparing a diskette, press the Escape key."
  1169                                  			db	13,10,0
  1170                                  czPrepMsg12		db	13,10,"Writing the boot sector to the diskette ..."
  1171                                  			db	13,10,0
  1172                                  czPrepMsg20		db	13,10,"The error-code .. was returned from the BIOS while reading from the disk."
  1173                                  			db	13,10,0
  1174                                  czPrepMsg30		db	13,10,"The error-code .. was returned from the BIOS while writing to the disk."
  1175                                  			db	13,10,0
  1176                                  czPrepMsgOK		db	13,10,"The boot-sector was written to the diskette. Before booting your computer with"
  1177                                  			db	13,10,"this diskette, make sure that the file OS.COM is copied onto the diskette."
  1178                                  			db	13,10,0
  1179                                  czPrepMsgErr1		db	13,10,"(01) Invalid Disk Parameter"
  1180                                  			db	13,10,"This is an internal error caused by an invalid value being passed to a system"
  1181                                  			db	13,10,"function. The OSBOOT.COM file may be corrupt. Copy or download the file again"
  1182                                  			db	13,10,"and retry."
  1183                                  			db	13,10,0
  1184                                  czPrepMsgErr2		db	13,10,"(02) Address Mark Not Found"
  1185                                  			db	13,10,"This error indicates a physical problem with the floppy diskette. Please retry"
  1186                                  			db	13,10,"using another diskette."
  1187                                  			db	13,10,0
  1188                                  czPrepMsgErr3		db	13,10,"(03) Protected Disk"
  1189                                  			db	13,10,"This error is usually caused by attempting to write to a write-protected disk."
  1190                                  			db	13,10,"Check the 'write-protect' setting on the disk or retry using using another disk."
  1191                                  			db	13,10,0
  1192                                  czPrepMsgErr6		db	13,10,"(06) Diskette Removed"
  1193                                  			db	13,10,"This error may indicate that the floppy diskette has been removed from the"
  1194                                  			db	13,10,"diskette drive. On some systems, this code may also occur if the diskette is"
  1195                                  			db	13,10,"'write protected.' Please verify that the diskette is not write-protected and"
  1196                                  			db	13,10,"is properly inserted in the diskette drive."
  1197                                  			db	13,10,0
  1198                                  czPrepMsgErr80		db	13,10,"(80) Drive Timed Out"
  1199                                  			db	13,10,"This error usually indicates that no diskette is in the diskette drive. Please"
  1200                                  			db	13,10,"make sure that the diskette is properly seated in the drive and retry."
  1201                                  			db	13,10,0
  1202                                  czPrepMsgErrXX		db	13,10,"(??) Unknown Error"
  1203                                  			db	13,10,"The error-code returned by the BIOS is not a recognized error. Please consult"
  1204                                  			db	13,10,"your computer's technical reference for a description of this error code."
  1205                                  			db	13,10,0
  1206                                  wcPrepInBuf		equ	$
  1207                                  %endif
  1208                                  %ifdef BUILDDISK
  1209                                  ;=======================================================================================================================
  1210                                  ;
  1211                                  ;	File Allocation Tables
  1212                                  ;
  1213                                  ;	The disk contains two copies of the File Allocation Table (FAT). On our disk, each FAT copy is 1200h bytes in
  1214                                  ;	length. Each FAT entry contains the logical number of the next cluster. The first two entries are reserved. Our
  1215                                  ;	OS.COM file will be 7200h bytes in length. The first 200h bytes is the 16-bit loader code. The remaining 7000h
  1216                                  ;	bytes is the 32-bit kernel code. Our disk parameter table defines a cluster as containing one sector and each
  1217                                  ;	sector having 200h bytes. Therefore, our FAT table must reserve 57 clusters for OS.COM. The clusters used by
  1218                                  ;	OS.COM, then, will be cluster 2 through 59. The entry for cluster 59 is set to "0FFFh" to indicate that it is
  1219                                  ;	the last cluster in the chain.
  1220                                  ;
  1221                                  ;	Every three bytes encode two FAT entries as follows:
  1222                                  ;
  1223                                  ;	db	0abh,0cdh,0efh	;even cluster: 0dabh, odd cluster: 0efch
  1224                                  ;
  1225                                  ;=======================================================================================================================
  1226                                  ;-----------------------------------------------------------------------------------------------------------------------
  1227                                  ;
  1228                                  ;	FAT copy 1								@disk: 000200	@mem: n/a
  1229                                  ;
  1230                                  ;-----------------------------------------------------------------------------------------------------------------------
  1231                                  section			fat1							;first copy of FAT
  1232 00000000 F0FFFF034000            			db	0F0h,0FFh,0FFh,	003h,040h,000h			;clusters 0-3		ff0 fff 003 004
  1233 00000006 056000078000            			db	005h,060h,000h,	007h,080h,000h			;custters 4-7   	005 006 007 008
  1234 0000000C 09A0000BC000            			db	009h,0A0h,000h,	00Bh,0C0h,000h			;clusters 8-11  	009 00a 00b 00c
  1235 00000012 0DE0000F0001            			db	00Dh,0E0h,000h,	00Fh,000h,001h			;clusters 12-15 	00d 00e 00f 010
  1236 00000018 112001134001            			db	011h,020h,001h,	013h,040h,001h			;clusters 16-19 	011 012 013 014
  1237 0000001E 156001178001            			db	015h,060h,001h,	017h,080h,001h			;clusters 20-23		015 016 017 018
  1238 00000024 19A0011BC001            			db	019h,0A0h,001h,	01Bh,0C0h,001h			;clusters 24-27		019 01a 01b 01c
  1239 0000002A 1DE0011F0002            			db	01Dh,0E0h,001h,	01Fh,000h,002h			;clusters 28-31		01d 01e 01f 020
  1240 00000030 212002234002            			db	021h,020h,002h,	023h,040h,002h			;clusters 32-35		021 022 023 024
  1241 00000036 256002278002            			db	025h,060h,002h,	027h,080h,002h			;clusters 36-39		025 026 027 028
  1242 0000003C 29A0022BC002            			db	029h,0A0h,002h,	02Bh,0C0h,002h			;clusters 40-43		029 02A 02B 02C
  1243 00000042 2DE0022F0003            			db	02Dh,0E0h,002h, 02Fh,000h,003h			;clusters 44-47		02D 02E 02F 030
  1244 00000048 312003334003            			db	031h,020h,003h, 033h,040h,003h			;clusters 48-51		031 032 033 034
  1245 0000004E 356003378003            			db	035h,060h,003h, 037h,080h,003h			;clusters 52-55		035 036 037 038
  1246 00000054 39A003FF0F00            			db	039h,0A0h,003h, 0FFh,00Fh,000h			;clusters 56-59		039 03A FFF 000
  1247 0000005A 00<rept>                			times	(9*512)-($-$$) db 0				;zero fill to end of section
  1248                                  ;-----------------------------------------------------------------------------------------------------------------------
  1249                                  ;
  1250                                  ;	FAT copy 2								@disk: 001400	@mem: n/a
  1251                                  ;
  1252                                  ;-----------------------------------------------------------------------------------------------------------------------
  1253                                  section			fat2							;second copy of FAT
  1254 00000000 F0FFFF034000            			db	0F0h,0FFh,0FFh,	003h,040h,000h			;clusters 0-3		ff0 fff 003 004
  1255 00000006 056000078000            			db	005h,060h,000h,	007h,080h,000h			;custters 4-7   	005 006 007 008
  1256 0000000C 09A0000BC000            			db	009h,0A0h,000h,	00Bh,0C0h,000h			;clusters 8-11  	009 00a 00b 00c
  1257 00000012 0DE0000F0001            			db	00Dh,0E0h,000h,	00Fh,000h,001h			;clusters 12-15 	00d 00e 00f 010
  1258 00000018 112001134001            			db	011h,020h,001h,	013h,040h,001h			;clusters 16-19 	011 012 013 014
  1259 0000001E 156001178001            			db	015h,060h,001h,	017h,080h,001h			;clusters 20-23		015 016 017 018
  1260 00000024 19A0011BC001            			db	019h,0A0h,001h,	01Bh,0C0h,001h			;clusters 24-27		019 01a 01b 01c
  1261 0000002A 1DE0011F0002            			db	01Dh,0E0h,001h,	01Fh,000h,002h			;clusters 28-31		01d 01e 01f 020
  1262 00000030 212002234002            			db	021h,020h,002h,	023h,040h,002h			;clusters 32-35		021 022 023 024
  1263 00000036 256002278002            			db	025h,060h,002h,	027h,080h,002h			;clusters 36-39		025 026 027 028
  1264 0000003C 29A0022BC002            			db	029h,0A0h,002h,	02Bh,0C0h,002h			;clusters 40-43		029 02A 02B 02C
  1265 00000042 2DE0022F0003            			db	02Dh,0E0h,002h, 02Fh,000h,003h			;clusters 44-47		02D 02E 02F 030
  1266 00000048 312003334003            			db	031h,020h,003h, 033h,040h,003h			;clusters 48-51		031 032 033 034
  1267 0000004E 356003378003            			db	035h,060h,003h, 037h,080h,003h			;clusters 52-55		035 036 037 038
  1268 00000054 39A003FF0F00            			db	039h,0A0h,003h, 0FFh,00Fh,000h			;clusters 56-59		039 03A FFF 000
  1269 0000005A 00<rept>                			times	(9*512)-($-$$) db 0				;zero fill to end of section
  1270                                  ;-----------------------------------------------------------------------------------------------------------------------
  1271                                  ;
  1272                                  ;	Diskette Directory							@disk: 002600	@mem: n/a
  1273                                  ;
  1274                                  ;	The disk contains one copy of the diskette directory. Each directory entry is 32 bytes long. Our directory
  1275                                  ;	contains only one entry. Unused entries are set to all nulls. The directory immediately follows the second FAT
  1276                                  ;	copy.
  1277                                  ;
  1278                                  ;-----------------------------------------------------------------------------------------------------------------------
  1279                                  section			dir							;diskette directory
  1280 00000000 4F5320202020202043-     			db	"OS      COM"					;file name (must contain spaces)
  1280 00000009 4F4D               
  1281 0000000B 20                      			db	020h						;attribute (archive bit set)
  1282 0000000C 00<rept>                			times	10 db 0						;unused
  1283 00000016 0000                    			dw	0h						;time
  1284 00000018 41                      			db	01000001b					;mmm = 10 MOD 8 = 2; ddddd = 1
  1285 00000019 49                      			db	01001001b					;yyyyyyy = 2016-1980 = 36 = 24h; m/8 = 1
  1286 0000001A 0200                    			dw	2						;first cluster
  1287 0000001C 00720000                			dd	07200h						;file size
  1288 00000020 00<rept>                			times	(224*32)-($-$$) db 0h				;zero fill to end of section
  1289                                  %endif
  1290                                  %ifdef BUILDCOM
  1291                                  ;=======================================================================================================================
  1292                                  ;
  1293                                  ;	OS.COM
  1294                                  ;
  1295                                  ;	The operating system file is assembled at the start of the data area of the floppy disk image, which
  1296                                  ;	immediately follows the directory. This corresponds to logical cluster 2, even though the physical address of
  1297                                  ;	this sector on the disk varies depending on the disk type. The os.com file consists of two parts, the OS loader
  1298                                  ;	and the OS kernel. The Loader is 16-bit code that receives control directly from the boot sector code after the
  1299                                  ;	OS.COM file is loaded into memory. The kernel is 32-bit code that receives control after the Loader has
  1300                                  ;	initialized protected-mode tables and 32-bit interrupt handlers and switched the CPU into protected mode.
  1301                                  ;
  1302                                  ;	Our loader addressability is set up according to the following diagram.
  1303                                  ;
  1304                                  ;	SS -----------> 007b00	+-----------------------------------------------+ SS:0000
  1305                                  ;				|  Boot Stack & Boot PSP (Unused)		|
  1306                                  ;				|  256 = 100h bytes				|
  1307                                  ;	SS:SP -------->	007c00	+-----------------------------------------------+ SS:0100  07b0:0100
  1308                                  ;				|  Boot Sector (vstart=0100h)			|
  1309                                  ;				|  1 sector = 512 = 200h bytes			|
  1310                                  ;			007e00	+-----------------------------------------------+
  1311                                  ;				|  File Allocation Table (FAT) I/O Buffer	|
  1312                                  ;				|  9 x 512-byte sectors = 4,608 = 1200h bytes	|
  1313                                  ;				|						|
  1314                                  ;	CS,DS,ES ----->	008f00	|  Loader PSP (Unused)				| DS:0000
  1315                                  ;				|						|
  1316                                  ;	CS:IP -------->	009000	+-----------------------------------------------+ DS:0100  08f0:0100
  1317                                  ;				|  Loader Code					|
  1318                                  ;				|  1 sector = 512 = 200h bytes			|
  1319                                  ;			009200	+-----------------------------------------------+ DS:0300
  1320                                  ;
  1321                                  ;=======================================================================================================================
  1322                                  ;-----------------------------------------------------------------------------------------------------------------------
  1323                                  ;
  1324                                  ;	OS Loader								@disk: 004200	@mem: 009000
  1325                                  ;
  1326                                  ;	This code is the operating system loader. It resides on the boot disk at the start of the data area, following
  1327                                  ;	the directory. The loader occupies several clusters that are mapped in the file allocation tables above.
  1328                                  ;	The loader executes 16-bit instructions in real mode. It performs several initialization functions such as
  1329                                  ;	determining whether the CPU and other resources are sufficient to run the operating system. If all minimum
  1330                                  ;	resources are present, the loader initializes protected mode tables, places the CPU into protected mode and
  1331                                  ;	starts the console task. Since the loader was called either from the bootstrap or as a .com file on the boot
  1332                                  ;	disk, we can assume that the initial ip is 0x100 and not perform any absolute address fix-ups on our segment
  1333                                  ;	registers.
  1334                                  ;
  1335                                  ;-----------------------------------------------------------------------------------------------------------------------
  1336                                  			cpu	8086						;assume minimal CPU
  1337                                  section			loader	vstart=0100h					;use .COM compatible addressing
  1338                                  			bits	16						;this is 16-bit code
  1339 00000000 0E                      Loader			push	cs						;use the code segment
  1340 00000001 1F                      			pop	ds						;...as our data segment
  1341 00000002 0E                      			push	cs						;use the code segment
  1342 00000003 07                      			pop	es						;...as our extra segment
  1343                                  ;
  1344                                  ;	Write a message to the console so we know we have our addressability established.
  1345                                  ;
  1346 00000004 BE[7D01]                			mov	si,czStartingMsg				;starting message
  1347 00000007 E8C900                  			call	PutTTYString					;display loader message
  1348                                  ;
  1349                                  ;	Determine the CPU type, generally. Exit if the CPU is not at least an 80386.
  1350                                  ;
  1351 0000000A E8A600                  			call	GetCPUType					;AL = cpu type
  1352 0000000D BE[EA00]                			mov	si,czCPUErrorMsg				;loader error message
  1353 00000010 3C03                    			cmp	al,3						;80386+?
  1354 00000012 7303E98700              			jb	LoaderExit					;no, exit with error message
  1355                                  			cpu	386						;allow 80386 instructions
  1356 00000017 BE[5501]                			mov	si,czCPUOKMsg					;cpu ok message
  1357 0000001A E8B600                  			call	PutTTYString					;display message
  1358                                  ;
  1359                                  ;	Initialize kernel data areas. The task queue is initialized here because as soon as we enter protected mode,
  1360                                  ;	the timer interrupt code will begin inspecting the task queue to determine if a task switch must be made. To
  1361                                  ;	start with, we set every 16th queue element to reference the background task selector. This will ensure that
  1362                                  ;	the background task, which updates the visible clock on the console, will be called at least once per second.
  1363                                  ;
  1364 0000001D 6A00                    			push	EKRNDATASEG					;load kernel data segment address ...
  1365 0000001F 07                      			pop	es						;... into extra segment reg
  1366 00000020 BF0008                  			mov	di,wwTaskQueue					;task queue address
  1367 00000023 B94000                  			mov	cx,64						;outer loop
  1368 00000026 51                      .10			push	cx						;save remaining outer iterations
  1369 00000027 B90300                  			mov	cx,3						;inner loop
  1370 0000002A B86800                  			mov	ax,ESELCONSOLETSS				;console task state segment selector
  1371 0000002D FC                      			cld							;forward strings
  1372 0000002E F3AB                    			rep	stosw						;store selectors in task queue
  1373 00000030 B87800                  			mov	ax,ESELBACKGROUNDTSS				;background task state segment selector
  1374 00000033 AB                      			stosw							;store selector in task queue
  1375 00000034 59                      			pop	cx						;restore remaining outer iterations
  1376 00000035 E2EF                    			loop	.10						;next
  1377 00000037 31C0                    			xor	ax,ax						;zero register
  1378 00000039 B104                    			mov	cl,4						;remaining words to reset
  1379 0000003B F3AB                    			rep	stosw						;reset remaining kernel data
  1380                                  ;
  1381                                  ;	Fixup the GDT descriptor for the current (loader) code segment.
  1382                                  ;
  1383 0000003D BE0003                  			mov	si,0300h					;GDT offset
  1384 00000040 8CC8                    			mov	ax,cs						;AX:SI = gdt source
  1385 00000042 C1C004                  			rol	ax,4						;AX = phys addr bits 11-0,15-12
  1386 00000045 88C1                    			mov	cl,al						;CL = phys addr bits 3-0,15-12
  1387 00000047 24F0                    			and	al,0F0h						;AL = phys addr bits 11-0
  1388 00000049 80E10F                  			and	cl,00Fh						;CL = phys addr bits 15-12
  1389 0000004C 894432                  			mov	word [si+030h+2],ax				;lo-order loader code (0-15)
  1390 0000004F 884C34                  			mov	byte [si+030h+4],cl				;lo-order loader code (16-23)
  1391 00000052 BE[5E01]                			mov	si,czGDTOKMsg					;GDT prepared message
  1392 00000055 E87B00                  			call	PutTTYString					;display message
  1393                                  ;
  1394                                  ;	Move the 32-bit kernel to its appropriate memory location.
  1395                                  ;
  1396 00000058 680001                  			push	EKRNCODESEG					;use kernel code segment ...
  1397 0000005B 07                      			pop	es						;... as target segment
  1398 0000005C 31FF                    			xor	di,di						;ES:DI = target address
  1399 0000005E BE0003                  			mov	si,0300h					;DS:SI = source address
  1400 00000061 B90070                  			mov	cx,07000h					;CX = kernel size
  1401 00000064 FC                      			cld							;forward strings
  1402 00000065 F3A4                    			rep	movsb						;copy kernel image
  1403 00000067 BE[6D01]                			mov	si,czKernelLoadedMsg				;kernel moved message
  1404 0000006A E86600                  			call	PutTTYString					;display message
  1405                                  ;
  1406                                  ;	Switch to protected mode.
  1407                                  ;
  1408 0000006D 31F6                    			xor	si,si						;ES:SI = gdt addr
  1409 0000006F 8ED6                    			mov	ss,si						;protected mode ss
  1410 00000071 BC0010                  			mov	sp,EKRNCODEADR					;initial stack immediate before code
  1411 00000074 B489                    			mov	ah,EBIOSFNINITPROTMODE				;initialize protected mode fn.
  1412 00000076 BB2820                  			mov	bx,02028h					;BH,BL = IRQ int bases
  1413 00000079 BA1F00                  			mov	dx,001Fh					;outer delay loop count
  1414 0000007C B9FFFF                  .20			mov	cx,0FFFFh					;inner delay loop count
  1415 0000007F E2FE                    			loop	$						;wait out pending interrupts
  1416 00000081 4A                      			dec	dx						;restore outer loop count
  1417 00000082 75F8                    			jnz	.20						;continue outer loop
  1418 00000084 CD15                    			int	EBIOSINTMISC					;call BIOS to set protected mode
  1419                                  ;
  1420                                  ;	Enable hardware and maskable interrupts
  1421                                  ;
  1422 00000086 30C0                    			xor	al,al						;enable all registers code
  1423 00000088 E621                    			out	EPICPORTPRI1,al					;enable all primary 8259A ints
  1424 0000008A E6A1                    			out	EPICPORTSEC1,al					;enable all secondary 8259A ints
  1425 0000008C FB                      			sti							;enable maskable interrupts
  1426                                  ;
  1427                                  ;	Load the Task State Segment (TSS) and Local Descriptor Table (LDT) registers and jump to the initial task.
  1428                                  ;
  1429 0000008D 2E0F001E[E200]          			ltr	[cs:cwLoaderTSS]				;load task register
  1430 00000093 2E0F0016[E000]          			lldt	[cs:cwLoaderLDT]				;load local descriptor table register
  1431 00000099 EA00006800              			jmp	ESELCONSOLETSS:0				;jump to task state segment selector
  1432                                  ;-----------------------------------------------------------------------------------------------------------------------
  1433                                  ;
  1434                                  ;	Routine:	LoaderExit
  1435                                  ;
  1436                                  ;	Description:	This routine displays the message at DS:SI, waits for a keypress and resets the system.
  1437                                  ;
  1438                                  ;	In:		DS:SI	string address
  1439                                  ;
  1440                                  ;-----------------------------------------------------------------------------------------------------------------------
  1441 0000009E E83200                  LoaderExit		call	PutTTYString					;display error message
  1442                                  ;
  1443                                  ;	Now we want to wait for a keypress. We can use a keyboard interrupt function for this (INT 16h, AH=0).
  1444                                  ;	However, some hypervisor BIOS implementations have been seen to implement the "wait" as simply a fast
  1445                                  ;	iteration of the keyboard status function call (INT 16h, AH=1), causing a CPU race condition. So, instead
  1446                                  ;	we will use the keyboard status call and iterate over a halt (HLT) instruction until a key is pressed.
  1447                                  ;	By convention, we enable maskable interrupts with STI before issuing HLT, so as not to catch fire.
  1448                                  ;
  1449 000000A1 B401                    .30			mov	ah,EBIOSFNKEYSTATUS				;keyboard status function
  1450 000000A3 CD16                    			int	EBIOSINTKEYBOARD				;call BIOS keyboard interrupt
  1451 000000A5 7504                    			jnz	.40						;exit if key pressed
  1452 000000A7 FB                      			sti							;enable maskable interrupts
  1453 000000A8 F4                      			hlt							;wait for interrupt
  1454 000000A9 EBF6                    			jmp	.30						;repeat until keypress
  1455                                  ;
  1456                                  ;	Now that a key has been pressed, we signal the system to restart by driving the B0 line on the 8042
  1457                                  ;	keyboard controller low (OUT 64h,0feh). The restart may take some microseconds to kick in, so we issue
  1458                                  ;	HLT until the system resets.
  1459                                  ;
  1460 000000AB B0FE                    .40			mov	al,EKEYBCMDRESET				;8042 pulse output port pin
  1461 000000AD E664                    			out	EKEYBPORTSTAT,al				;drive B0 low to restart
  1462 000000AF FB                      .50			sti							;enable maskable interrupts
  1463 000000B0 F4                      			hlt							;stop until reset, int, nmi
  1464 000000B1 EBFC                    			jmp	.50						;loop until restart kicks in
  1465                                  ;-----------------------------------------------------------------------------------------------------------------------
  1466                                  ;
  1467                                  ;	Routine:	GetCPUType
  1468                                  ;
  1469                                  ;	Description:	The loader needs only to determine that the cpu is at least an 80386 or an equivalent. Note that
  1470                                  ;			the CPUID instruction was not introduced until the SL-enhanced 80486 and Pentium processors, so
  1471                                  ;			to distinguish whether we have at least an 80386, other means must be used.
  1472                                  ;
  1473                                  ;	Out:		AX	0 = 808x, v20, etc.
  1474                                  ;				1 = 80186
  1475                                  ;				2 = 80286
  1476                                  ;				3 = 80386
  1477                                  ;
  1478                                  ;-----------------------------------------------------------------------------------------------------------------------
  1479 000000B3 B001                    GetCPUType		mov	al,1						;AL = 1
  1480 000000B5 B120                    			mov	cl,32						;shift count
  1481 000000B7 D2E8                    			shr	al,cl						;try a 32-bit shift
  1482 000000B9 08C0                    			or	al,al						;did the shift happen?
  1483 000000BB 7415                    			jz	.10						;yes, cpu is 808x, v20, etc.
  1484                                  			cpu	186
  1485 000000BD 54                      			push	sp						;save stack pointer
  1486 000000BE 59                      			pop	cx						;...into cx
  1487 000000BF 39E1                    			cmp	cx,sp						;did sp decrement before push?
  1488 000000C1 750F                    			jne	.10						;yes, cpu is 80186
  1489                                  			cpu	286
  1490 000000C3 40                      			inc	ax						;AX = 2
  1491 000000C4 0F0106[E400]            			sgdt	[cbLoaderGDT]					;store gdt reg in work area
  1492 000000C9 8A0E[E900]              			mov	cl,[cbLoaderGDTHiByte]				;CL = hi-order byte
  1493 000000CD FEC1                    			inc	cl						;was hi-byte of GDTR 0xff?
  1494 000000CF 7401                    			jz	.10						;yes, cpu is 80286
  1495 000000D1 40                      			inc	ax						;AX = 3
  1496 000000D2 C3                      .10			ret							;return
  1497                                  ;-----------------------------------------------------------------------------------------------------------------------
  1498                                  ;
  1499                                  ;	Routine:	PutTTYString
  1500                                  ;
  1501                                  ;	Description:	This routine sends a NUL-terminated string of characters to the TTY output device. We use the
  1502                                  ;			TTY output function of the BIOS video interrupt, passing the address of the string in DS:SI
  1503                                  ;			and the BIOS teletype function code in AH. After a return from the BIOS interrupt, we repeat
  1504                                  ;			for the next string character until a NUL is found. Note that we clear the direction flag (DF)
  1505                                  ;			with CLD before each LODSB. This is just in case the direction flag is ever returned as set
  1506                                  ;			by the video interrupt. This is a precaution since a well-written BIOS should preserve all
  1507                                  ;			registers and flags unless used to indicate return status.
  1508                                  ;
  1509                                  ;	In:		DS:SI	address of string
  1510                                  ;
  1511                                  ;-----------------------------------------------------------------------------------------------------------------------
  1512 000000D3 FC                      PutTTYString		cld							;forward strings
  1513 000000D4 AC                      			lodsb							;load next byte at DS:SI in AL
  1514 000000D5 84C0                    			test	al,al						;end of string?
  1515 000000D7 7406                    			jz	.10						;... yes, exit our loop
  1516 000000D9 B40E                    			mov	ah,EBIOSFNTTYOUTPUT				;BIOS teletype function
  1517 000000DB CD10                    			int	EBIOSINTVIDEO					;call BIOS display interrupt
  1518 000000DD EBF4                    			jmp	PutTTYString					;repeat until done
  1519 000000DF C3                      .10			ret							;return
  1520                                  ;-----------------------------------------------------------------------------------------------------------------------
  1521                                  ;
  1522                                  ;	Loader Data
  1523                                  ;
  1524                                  ;	The loader data is updated to include constants defining the initial (Loader) TSS and LDT selectors in the
  1525                                  ;	GDT, a work area to build the GDTR, and additional text messages.
  1526                                  ;
  1527                                  ;-----------------------------------------------------------------------------------------------------------------------
  1528                                  			align	2
  1529 000000E0 5000                    cwLoaderLDT		dw	ESELLOADERLDT					;loader local descriptor table selector
  1530 000000E2 5800                    cwLoaderTSS		dw	ESELLOADERTSS					;loader task state segment selector
  1531 000000E4 00<rept>                cbLoaderGDT		times	5 db 0						;6-byte GDTR work area
  1532 000000E9 00                      cbLoaderGDTHiByte	db	0						;hi-order byte
  1533 000000EA 546865206F70657261-     czCPUErrorMsg		db	"The operating system requires an i386 or later processor.",13,10
  1533 000000F3 74696E672073797374-
  1533 000000FC 656D20726571756972-
  1533 00000105 657320616E20693338-
  1533 0000010E 36206F72206C617465-
  1533 00000117 722070726F63657373-
  1533 00000120 6F722E0D0A         
  1534 00000125 506C65617365207072-     			db	"Please press any key to restart the computer.",13,10,0
  1534 0000012E 65737320616E79206B-
  1534 00000137 657920746F20726573-
  1534 00000140 746172742074686520-
  1534 00000149 636F6D70757465722E-
  1534 00000152 0D0A00             
  1535 00000155 435055204F4B0D0A00      czCPUOKMsg		db	"CPU OK",13,10,0
  1536 0000015E 474454207072657061-     czGDTOKMsg		db	"GDT prepared",13,10,0
  1536 00000167 7265640D0A00       
  1537 0000016D 4B65726E656C206C6F-     czKernelLoadedMsg	db	"Kernel loaded",13,10,0
  1537 00000176 616465640D0A00     
  1538 0000017D 5374617274696E6720-     czStartingMsg		db	"Starting OS",13,10,0				;starting message
  1538 00000186 4F530D0A00         
  1539 0000018B 00<rept>                			times	510-($-$$) db 0h				;zero fill to end of sector
  1540 000001FE 55AA                    			db	055h,0AAh					;end of sector signature
  1541                                  ;=======================================================================================================================
  1542                                  ;
  1543                                  ;	OS Kernel								@disk: 004400	@mem: 001000
  1544                                  ;
  1545                                  ;	This code is the operating system kernel. It resides on the boot disk image as part of the OS.COM file,
  1546                                  ;	following the 16-bit loader code above. The Kernel executes only 32-bit code in protected mode and contains one
  1547                                  ;	task, the Console, which performs a loop accepting user input from external devices (keyboard, etc.), processes
  1548                                  ;	commands and displays ouput to video memory. The Kernel also includes a library of system functions accessible
  1549                                  ;	through software interrupt 58 (30h). Finally, the Kernel provides CPU and hardware interrupt handlers.
  1550                                  ;
  1551                                  ;=======================================================================================================================
  1552                                  ;=======================================================================================================================
  1553                                  ;
  1554                                  ;	Kernel Tables
  1555                                  ;
  1556                                  ;=======================================================================================================================
  1557                                  ;-----------------------------------------------------------------------------------------------------------------------
  1558                                  ;
  1559                                  ;	Global Descriptor Table							@disk: 004400	@mem: 001000
  1560                                  ;
  1561                                  ;	The Global Descriptor Table (GDT) consists of eight-byte descriptors that define reserved memory areas. The
  1562                                  ;	first descriptor must be all nulls.
  1563                                  ;
  1564                                  ;	6   5         4         3         2         1         0
  1565                                  ;	3210987654321098765432109876543210987654321098765432109876543210
  1566                                  ;	----------------------------------------------------------------
  1567                                  ;	h......hffffmmmma......ab......................bn..............n
  1568                                  ;	00000000			all areas have base addresses below 2^24
  1569                                  ;	        0100     		(0x4) 32-bit single-byte granularity
  1570                                  ;		1100    		(0xC) 32-bit 4KB granularity
  1571                                  ;	            1001		present, ring-0, selector
  1572                                  ;
  1573                                  ;	h...h	hi-order base address (bits 24-31)
  1574                                  ;	ffff	flags
  1575                                  ;	mmmm	hi-order limit (bits 16-19)
  1576                                  ;	a...a	access
  1577                                  ;	b...b	lo-order base address (bits 0-23)
  1578                                  ;	n...n	lo-order limit (bits 0-15)
  1579                                  ;
  1580                                  ;-----------------------------------------------------------------------------------------------------------------------
  1581                                  section			gdt							;global descriptor table
  1582 00000000 0000000000000000        			dq	0000000000000000h				;00 required null selector
  1583 00000008 FF07001000934000        			dq	00409300100007FFh				;08 2KB  writable data  (GDT alias)
  1584 00000010 FF07001800934000        			dq	00409300180007FFh				;10 2KB  writable data  (IDT alias)
  1585 00000018 FFFF00000093CF00        			dq	00CF93000000FFFFh				;18 4GB  writable data  (kernel)     DS:
  1586 00000020 FF0F00800B934000        			dq	0040930B80000FFFh				;20 4KB  writable data  (CGA)        ES:
  1587 00000028 FF0F000000934000        			dq	0040930000000FFFh				;28 4KB  writable stack (Loader)     SS:
  1588 00000030 FFFF0000009B0000        			dq	00009B000000FFFFh				;30 64KB readable code  (loader)     CS:
  1589 00000038 FFFF0000FF9B0000        			dq	00009BFF0000FFFFh				;38 64KB readable code  (BIOS)
  1590 00000040 FFFF000400934000        			dq	004093000400FFFFh				;40 64KB writable data  (BIOS)
  1591 00000048 FF1F0020009B4000        			dq	00409B0020001FFFh				;48 8KB  readable code  (kernel)
  1592 00000050 7F00000F00824000        			dq	004082000F00007Fh				;50 80B  writable LDT   (loader)
  1593 00000058 7F00800F00894000        			dq	004089000F80007Fh				;58 80B  writable TSS   (loader)
  1594 00000060 7F00004700824000        			dq	004082004700007Fh				;60 80B  writable LDT   (console)
  1595 00000068 7F00804700894000        			dq	004089004780007Fh				;88 80B  writable TSS   (console)
  1596 00000070 7F00006700824000        			dq	004082006700007Fh				;70 80B  writable LDT   (background)
  1597 00000078 7F00806700894000        			dq	004089006780007Fh				;78 80B  writable TSS   (background)
  1598 00000080 FF07004800934000        			dq	00409300480007FFh				;80 2KB  foreground task message queue
  1599 00000088 00<rept>                			times	2048-($-$$) db 0h				;zero fill to end of section
  1600                                  ;-----------------------------------------------------------------------------------------------------------------------
  1601                                  ;
  1602                                  ;	Interrupt Descriptor Table						@disk: 004c00	@mem: 001800
  1603                                  ;
  1604                                  ;	The Interrupt Descriptor Table (IDT) consists of one eight-byte entry (descriptor) for each interrupt. The
  1605                                  ;	descriptors here are of two kinds, interrupt gates and trap gates. The "mint" and "mtrap" macros define the
  1606                                  ;	descriptors, taking only the name of the entry point for the code handling the interrupt.
  1607                                  ;
  1608                                  ;	6   5         4         3         2         1         0
  1609                                  ;	3210987654321098765432109876543210987654321098765432109876543210
  1610                                  ;	----------------------------------------------------------------
  1611                                  ;	h..............hPzzStttt00000000S..............Sl..............l
  1612                                  ;
  1613                                  ;	h...h	high-order offset (bits 16-31)
  1614                                  ;	P	present (0=unused interrupt)
  1615                                  ;	zz	descriptor privilege level
  1616                                  ;	S	storage segment (must be zero for IDT)
  1617                                  ;	tttt	type: 0101=task, 1110=int, 1111=trap
  1618                                  ;	S...S	handling code selector in GDT
  1619                                  ;	l...l	lo-order offset (bits 0-15)
  1620                                  ;
  1621                                  ;-----------------------------------------------------------------------------------------------------------------------
  1622                                  section			idt							;interrupt descriptor table
  1623                                  			mint	dividebyzero					;00 divide by zero
  1623                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1623 00000000 00004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1624                                  			mint	singlestep					;01 single step
  1624                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1624 00000008 0C004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1625                                  			mint	nmi						;02 non-maskable
  1625                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1625 00000010 18004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1626                                  			mint	break						;03 break
  1626                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1626 00000018 24004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1627                                  			mint	into						;04 into
  1627                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1627 00000020 30004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1628                                  			mint	bounds						;05 bounds
  1628                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1628 00000028 3C004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1629                                  			mint	badopcode					;06 bad op code
  1629                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1629 00000030 48004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1630                                  			mint	nocoproc					;07 no coprocessor
  1630                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1630 00000038 54004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1631                                  			mint	doublefault					;08 double-fault
  1631                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1631 00000040 60004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1632                                  			mint	operand						;09 operand
  1632                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1632 00000048 6C004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1633                                  			mint	badtss						;0a bad TSS
  1633                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1633 00000050 78004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1634                                  			mint	notpresent					;0b not-present
  1634                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1634 00000058 84004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1635                                  			mint	stacklimit					;0c stack limit
  1635                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1635 00000060 90004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1636                                  			mint	protection					;0d general protection fault
  1636                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1636 00000068 9C004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1637                                  			mint	int14						;0e (reserved)
  1637                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1637 00000070 A8004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1638                                  			mint	int15						;0f (reserved)
  1638                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1638 00000078 B4004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1639                                  			mint	coproccalc					;10 (reserved)
  1639                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1639 00000080 C0004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1640                                  			mint	int17						;11 (reserved)
  1640                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1640 00000088 CC004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1641                                  			mint	int18						;12 (reserved)
  1641                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1641 00000090 D5004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1642                                  			mint	int19						;13 (reserved)
  1642                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1642 00000098 DE004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1643                                  			mint	int20						;14 (reserved)
  1643                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1643 000000A0 E7004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1644                                  			mint	int21						;15 (reserved)
  1644                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1644 000000A8 F0004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1645                                  			mint	int22						;16 (reserved)
  1645                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1645 000000B0 F9004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1646                                  			mint	int23						;17 (reserved)
  1646                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1646 000000B8 02014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1647                                  			mint	int24						;18 (reserved)
  1647                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1647 000000C0 0B014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1648                                  			mint	int25						;19 (reserved)
  1648                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1648 000000C8 14014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1649                                  			mint	int26						;1a (reserved)
  1649                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1649 000000D0 1D014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1650                                  			mint	int27						;1b (reserved)
  1650                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1650 000000D8 26014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1651                                  			mint	int28						;1c (reserved)
  1651                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1651 000000E0 2F014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1652                                  			mint	int29						;1d (reserved)
  1652                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1652 000000E8 38014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1653                                  			mint	int30						;1e (reserved)
  1653                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1653 000000F0 41014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1654                                  			mint	int31						;1f (reserved)
  1654                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1654 000000F8 4A014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EACCINT << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1655                                  			mtrap	clocktick					;20 IRQ0 clock tick
  1655                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1655 00000100 31054800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1656                                  			mtrap	keyboard					;21 IRQ1 keyboard
  1656                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1656 00000108 BF054800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1657                                  			mtrap	iochannel					;22 IRQ2 second 8259A cascade
  1657                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1657 00000110 2B094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1658                                  			mtrap	com2						;23 IRQ3 com2
  1658                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1658 00000118 2E094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1659                                  			mtrap	com1						;24 IRQ4 com1
  1659                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1659 00000120 31094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1660                                  			mtrap	lpt2						;25 IRQ5 lpt2
  1660                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1660 00000128 34094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1661                                  			mtrap	diskette					;26 IRQ6 diskette
  1661                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1661 00000130 37094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1662                                  			mtrap	lpt1						;27 IRQ7 lpt1
  1662                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1662 00000138 4B094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1663                                  			mtrap	rtclock						;28 IRQ8 real-time clock
  1663                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1663 00000140 4E094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1664                                  			mtrap	retrace						;29 IRQ9 CGA vertical retrace
  1664                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1664 00000148 51094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1665                                  			mtrap	irq10						;2a IRQA (reserved)
  1665                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1665 00000150 54094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1666                                  			mtrap	irq11						;2b IRQB (reserved)
  1666                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1666 00000158 57094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1667                                  			mtrap	ps2mouse					;2c IRQC ps/2 mouse
  1667                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1667 00000160 5A094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1668                                  			mtrap	coprocessor					;2d IRQD coprocessor
  1668                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1668 00000168 5D094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1669                                  			mtrap	fixeddisk					;2e IRQE fixed disk
  1669                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1669 00000170 60094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1670                                  			mtrap	irq15						;2f IRQF (reserved)
  1670                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1670 00000178 63094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1671                                  			mtrap	svc						;30 OS services
  1671                              <1> _%1 equ ($-$$) / EKRNDESLEN
  1671 00000180 74094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EACCTRAP << 40) | ((ESELOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1672 00000188 00<rept>                			times	2048-($-$$) db 0h				;zero fill to end of section
  1673                                  ;=======================================================================================================================
  1674                                  ;
  1675                                  ;	Interrupt Handlers							@disk: 005400	@mem:  002000
  1676                                  ;
  1677                                  ;	Interrupt handlers are 32-bit routines that receive control either in response to events or by direct
  1678                                  ;	invocation from other kernel code. The interrupt handlers are of three basic types. CPU interrupts occur when a
  1679                                  ;	CPU exception is detected. Hardware interrupts occur when an external device (timer, keyboard, disk, etc.)
  1680                                  ;	signals the CPU on an interrupt request line (IRQ). Software interrupts occur when directly called by other code
  1681                                  ;	using the INT instruction. Each interrupt handler routine is defined by using our "menter" macro, which simply
  1682                                  ;	establishes a label defining the offset address of the entry point from the start of the kernel section. This
  1683                                  ;	label is referenced in the "mint" and "mtrap" macros found in the IDT to specify the address of the handlers.
  1684                                  ;
  1685                                  ;=======================================================================================================================
  1686                                  section			kernel	vstart=0h					;data offsets relative to 0
  1687                                  			cpu	386						;allow 80386 instructions
  1688                                  			bits	32						;this is 32-bit code
  1689                                  ;=======================================================================================================================
  1690                                  ;
  1691                                  ;	CPU Interrupt Handlers
  1692                                  ;
  1693                                  ;	The first 32 entries in the Interrupt Descriptor Table are reserved for use by CPU interrupts. The handling
  1694                                  ;	of these interrupts is expanded here to display the contents of registers at the time of the interrupt.
  1695                                  ;
  1696                                  ;=======================================================================================================================
  1697                                  ;-----------------------------------------------------------------------------------------------------------------------
  1698                                  ;
  1699                                  ;	INT0	Divide By Zero
  1700                                  ;
  1701                                  ;-----------------------------------------------------------------------------------------------------------------------
  1702                                  			menter	dividebyzero					;divide by zero
  1702                              <1> ?%1 equ ($-$$)
  1703 00000000 6A00                    			push	0						;store interrupt nbr
  1704 00000002 68[29030000]            			push	czIntDivideByZero				;store message offset
  1705 00000007 E947010000              			jmp	ReportInterrupt					;report interrupt
  1706                                  ;-----------------------------------------------------------------------------------------------------------------------
  1707                                  ;
  1708                                  ;	INT1	Single Step
  1709                                  ;
  1710                                  ;-----------------------------------------------------------------------------------------------------------------------
  1711                                  			menter	singlestep					;single step
  1711                              <1> ?%1 equ ($-$$)
  1712 0000000C 6A01                    			push	1						;store interrupt nbr
  1713 0000000E 68[3A030000]            			push	czIntSingleStep					;store message offset
  1714 00000013 E93B010000              			jmp	ReportInterrupt					;report interrupt
  1715                                  ;-----------------------------------------------------------------------------------------------------------------------
  1716                                  ;
  1717                                  ;	INT2	Non-Maskable Interrupt
  1718                                  ;
  1719                                  ;-----------------------------------------------------------------------------------------------------------------------
  1720                                  			menter	nmi						;non-maskable
  1720                              <1> ?%1 equ ($-$$)
  1721 00000018 6A02                    			push	2						;store interrupt nbr
  1722 0000001A 68[46030000]            			push	czIntNonMaskable				;store message offset
  1723 0000001F E92F010000              			jmp	ReportInterrupt					;report interrupt
  1724                                  ;-----------------------------------------------------------------------------------------------------------------------
  1725                                  ;
  1726                                  ;	INT3	Break
  1727                                  ;
  1728                                  ;-----------------------------------------------------------------------------------------------------------------------
  1729                                  			menter	break						;break
  1729                              <1> ?%1 equ ($-$$)
  1730 00000024 6A03                    			push	3						;store interrupt nbr
  1731 00000026 68[5D030000]            			push	czIntBreak					;store message offset
  1732 0000002B E923010000              			jmp	ReportInterrupt					;report interrupt
  1733                                  ;-----------------------------------------------------------------------------------------------------------------------
  1734                                  ;
  1735                                  ;	INT4	Into
  1736                                  ;
  1737                                  ;-----------------------------------------------------------------------------------------------------------------------
  1738                                  			menter	into						;into
  1738                              <1> ?%1 equ ($-$$)
  1739 00000030 6A04                    			push	4						;store interrupt nbr
  1740 00000032 68[63030000]            			push	czIntInto					;store message offset
  1741 00000037 E917010000              			jmp	ReportInterrupt					;report interrupt
  1742                                  ;-----------------------------------------------------------------------------------------------------------------------
  1743                                  ;
  1744                                  ;	INT5	Bounds
  1745                                  ;
  1746                                  ;-----------------------------------------------------------------------------------------------------------------------
  1747                                  			menter	bounds						;bounds
  1747                              <1> ?%1 equ ($-$$)
  1748 0000003C 6A05                    			push	5						;store interrupt nbr
  1749 0000003E 68[68030000]            			push	czIntBounds					;store message offset
  1750 00000043 E90B010000              			jmp	ReportInterrupt					;report interrupt
  1751                                  ;-----------------------------------------------------------------------------------------------------------------------
  1752                                  ;
  1753                                  ;	INT6	Bad Operation Code
  1754                                  ;
  1755                                  ;-----------------------------------------------------------------------------------------------------------------------
  1756                                  			menter	badopcode					;bad opcode interrupt
  1756                              <1> ?%1 equ ($-$$)
  1757 00000048 6A06                    			push	6						;store interrupt nbr
  1758 0000004A 68[6F030000]            			push	czIntBadOpCode					;store message offset
  1759 0000004F E9FF000000              			jmp	ReportInterrupt					;report interrupt
  1760                                  ;-----------------------------------------------------------------------------------------------------------------------
  1761                                  ;
  1762                                  ;	INT7	No Coprocessor
  1763                                  ;
  1764                                  ;-----------------------------------------------------------------------------------------------------------------------
  1765                                  			menter	nocoproc					;no coprocessor interrupt
  1765                              <1> ?%1 equ ($-$$)
  1766 00000054 6A07                    			push	7						;store interrupt nbr
  1767 00000056 68[82030000]            			push	czIntNoCoprocessor				;store message offset
  1768 0000005B E9F3000000              			jmp	ReportInterrupt					;report interrupt
  1769                                  ;-----------------------------------------------------------------------------------------------------------------------
  1770                                  ;
  1771                                  ;	INT8	Double Fault
  1772                                  ;
  1773                                  ;-----------------------------------------------------------------------------------------------------------------------
  1774                                  			menter	doublefault					;doublefault interrupt
  1774                              <1> ?%1 equ ($-$$)
  1775 00000060 6A08                    			push	8						;store interrupt nbr
  1776 00000062 68[91030000]            			push	czIntDoubleFault				;store message offset
  1777 00000067 E9E7000000              			jmp	ReportInterrupt					;report interrupt
  1778                                  ;-----------------------------------------------------------------------------------------------------------------------
  1779                                  ;
  1780                                  ;	INT9	Operand
  1781                                  ;
  1782                                  ;-----------------------------------------------------------------------------------------------------------------------
  1783                                  			menter	operand						;operand interrupt
  1783                              <1> ?%1 equ ($-$$)
  1784 0000006C 6A09                    			push	9						;store interrupt nbr
  1785 0000006E 68[9E030000]            			push	czIntOperand					;store message offset
  1786 00000073 E9DB000000              			jmp	ReportInterrupt					;report interrupt
  1787                                  ;-----------------------------------------------------------------------------------------------------------------------
  1788                                  ;
  1789                                  ;	INT10	Bad Task State Segment
  1790                                  ;
  1791                                  ;-----------------------------------------------------------------------------------------------------------------------
  1792                                  			menter	badtss						;bad tss interrupt
  1792                              <1> ?%1 equ ($-$$)
  1793 00000078 6A0A                    			push	10						;store interrupt nbr
  1794 0000007A 68[A6030000]            			push	czIntBadTSS					;store message offset
  1795 0000007F E9CF000000              			jmp	ReportInterrupt					;report interrupt
  1796                                  ;-----------------------------------------------------------------------------------------------------------------------
  1797                                  ;
  1798                                  ;	INT11	Not Present
  1799                                  ;
  1800                                  ;-----------------------------------------------------------------------------------------------------------------------
  1801                                  			menter	notpresent					;not present interrupt
  1801                              <1> ?%1 equ ($-$$)
  1802 00000084 6A0B                    			push	11						;store interrupt nbr
  1803 00000086 68[BD030000]            			push	czIntNotPresent					;store message offset
  1804 0000008B E9C3000000              			jmp	ReportInterrupt					;report interrupt
  1805                                  ;-----------------------------------------------------------------------------------------------------------------------
  1806                                  ;
  1807                                  ;	INT12	Stack Limit
  1808                                  ;
  1809                                  ;-----------------------------------------------------------------------------------------------------------------------
  1810                                  			menter	stacklimit					;stack limit interrupt
  1810                              <1> ?%1 equ ($-$$)
  1811 00000090 6A0C                    			push	12						;store interrupt nbr
  1812 00000092 68[C9030000]            			push	czIntStackLimit					;store message offset
  1813 00000097 E9B7000000              			jmp	ReportInterrupt					;report interrupt
  1814                                  ;-----------------------------------------------------------------------------------------------------------------------
  1815                                  ;
  1816                                  ;	INT13	General Protection Fault
  1817                                  ;
  1818                                  ;-----------------------------------------------------------------------------------------------------------------------
  1819                                  			menter	protection					;protection fault interrupt
  1819                              <1> ?%1 equ ($-$$)
  1820 0000009C 6A0D                    			push	13						;store interrupt nbr
  1821 0000009E 68[D5030000]            			push	czIntProtection					;store message offset
  1822 000000A3 E9AB000000              			jmp	ReportInterrupt					;report interrupt
  1823                                  ;-----------------------------------------------------------------------------------------------------------------------
  1824                                  ;
  1825                                  ;	INT14	Reserved
  1826                                  ;
  1827                                  ;-----------------------------------------------------------------------------------------------------------------------
  1828                                  			menter	int14						;(reserved)
  1828                              <1> ?%1 equ ($-$$)
  1829 000000A8 6A0E                    			push	14						;store interrupt nbr
  1830 000000AA 68[06040000]            			push	czIntReserved					;store message offset
  1831 000000AF E99F000000              			jmp	ReportInterrupt					;report interrupt
  1832                                  ;-----------------------------------------------------------------------------------------------------------------------
  1833                                  ;
  1834                                  ;	INT15	Reserved
  1835                                  ;
  1836                                  ;-----------------------------------------------------------------------------------------------------------------------
  1837                                  			menter	int15						;(reserved)
  1837                              <1> ?%1 equ ($-$$)
  1838 000000B4 6A0F                    			push	15						;store interrupt nbr
  1839 000000B6 68[06040000]            			push	czIntReserved					;store message offset
  1840 000000BB E993000000              			jmp	ReportInterrupt					;report interrupt
  1841                                  ;-----------------------------------------------------------------------------------------------------------------------
  1842                                  ;
  1843                                  ;	INT16	Coprocessor Calculation
  1844                                  ;
  1845                                  ;-----------------------------------------------------------------------------------------------------------------------
  1846                                  			menter	coproccalc					;coprocessor calculation
  1846                              <1> ?%1 equ ($-$$)
  1847 000000C0 6A10                    			push	16						;store interrupt nbr
  1848 000000C2 68[EE030000]            			push	czIntCoprocessorCalc				;store message offset
  1849 000000C7 E987000000              			jmp	ReportInterrupt					;report interrupt
  1850                                  ;-----------------------------------------------------------------------------------------------------------------------
  1851                                  ;
  1852                                  ;	INT17	Reserved
  1853                                  ;
  1854                                  ;-----------------------------------------------------------------------------------------------------------------------
  1855                                  			menter	int17						;(reserved)
  1855                              <1> ?%1 equ ($-$$)
  1856 000000CC 6A11                    			push	17						;store interrupt nbr
  1857 000000CE 68[06040000]            			push	czIntReserved					;store message offset
  1858 000000D3 EB7E                    			jmp	ReportInterrupt					;report interrupt
  1859                                  ;-----------------------------------------------------------------------------------------------------------------------
  1860                                  ;
  1861                                  ;	INT18	Reserved
  1862                                  ;
  1863                                  ;-----------------------------------------------------------------------------------------------------------------------
  1864                                  			menter	int18						;(reserved)
  1864                              <1> ?%1 equ ($-$$)
  1865 000000D5 6A12                    			push	18						;store interrupt nbr
  1866 000000D7 68[06040000]            			push	czIntReserved					;store message offset
  1867 000000DC EB75                    			jmp	ReportInterrupt					;report interrupt
  1868                                  ;-----------------------------------------------------------------------------------------------------------------------
  1869                                  ;
  1870                                  ;	INT19	Reserved
  1871                                  ;
  1872                                  ;-----------------------------------------------------------------------------------------------------------------------
  1873                                  			menter	int19						;(reserved)
  1873                              <1> ?%1 equ ($-$$)
  1874 000000DE 6A13                    			push	19						;store interrupt nbr
  1875 000000E0 68[06040000]            			push	czIntReserved					;store message offset
  1876 000000E5 EB6C                    			jmp	ReportInterrupt					;report interrupt
  1877                                  ;-----------------------------------------------------------------------------------------------------------------------
  1878                                  ;
  1879                                  ;	INT20	Reserved
  1880                                  ;
  1881                                  ;-----------------------------------------------------------------------------------------------------------------------
  1882                                  			menter	int20						;(reserved)
  1882                              <1> ?%1 equ ($-$$)
  1883 000000E7 6A14                    			push	20						;store interrupt nbr
  1884 000000E9 68[06040000]            			push	czIntReserved					;store message offset
  1885 000000EE EB63                    			jmp	ReportInterrupt					;report interrupt
  1886                                  ;-----------------------------------------------------------------------------------------------------------------------
  1887                                  ;
  1888                                  ;	INT21	Reserved
  1889                                  ;
  1890                                  ;-----------------------------------------------------------------------------------------------------------------------
  1891                                  			menter	int21						;(reserved)
  1891                              <1> ?%1 equ ($-$$)
  1892 000000F0 6A15                    			push	21						;store interrupt nbr
  1893 000000F2 68[06040000]            			push	czIntReserved					;store message offset
  1894 000000F7 EB5A                    			jmp	ReportInterrupt					;report interrupt
  1895                                  ;-----------------------------------------------------------------------------------------------------------------------
  1896                                  ;
  1897                                  ;	INT22	Reserved
  1898                                  ;
  1899                                  ;-----------------------------------------------------------------------------------------------------------------------
  1900                                  			menter	int22						;(reserved)
  1900                              <1> ?%1 equ ($-$$)
  1901 000000F9 6A16                    			push	22						;store interrupt nbr
  1902 000000FB 68[06040000]            			push	czIntReserved					;store message offset
  1903 00000100 EB51                    			jmp	ReportInterrupt					;report interrupt
  1904                                  ;-----------------------------------------------------------------------------------------------------------------------
  1905                                  ;
  1906                                  ;	INT23	Reserved
  1907                                  ;
  1908                                  ;-----------------------------------------------------------------------------------------------------------------------
  1909                                  			menter	int23						;(reserved)
  1909                              <1> ?%1 equ ($-$$)
  1910 00000102 6A17                    			push	23						;store interrupt nbr
  1911 00000104 68[06040000]            			push	czIntReserved					;store message offset
  1912 00000109 EB48                    			jmp	ReportInterrupt					;report interrupt
  1913                                  ;-----------------------------------------------------------------------------------------------------------------------
  1914                                  ;
  1915                                  ;	INT24	Reserved
  1916                                  ;
  1917                                  ;-----------------------------------------------------------------------------------------------------------------------
  1918                                  			menter	int24						;(reserved)
  1918                              <1> ?%1 equ ($-$$)
  1919 0000010B 6A18                    			push	24						;store interrupt nbr
  1920 0000010D 68[06040000]            			push	czIntReserved					;store message offset
  1921 00000112 EB3F                    			jmp	ReportInterrupt					;report interrupt
  1922                                  ;-----------------------------------------------------------------------------------------------------------------------
  1923                                  ;
  1924                                  ;	INT25	Reserved
  1925                                  ;
  1926                                  ;-----------------------------------------------------------------------------------------------------------------------
  1927                                  			menter	int25						;(reserved)
  1927                              <1> ?%1 equ ($-$$)
  1928 00000114 6A19                    			push	25						;store interrupt nbr
  1929 00000116 68[06040000]            			push	czIntReserved					;store message offset
  1930 0000011B EB36                    			jmp	ReportInterrupt					;report interrupt
  1931                                  ;-----------------------------------------------------------------------------------------------------------------------
  1932                                  ;
  1933                                  ;	INT26	Reserved
  1934                                  ;
  1935                                  ;-----------------------------------------------------------------------------------------------------------------------
  1936                                  			menter	int26						;(reserved)
  1936                              <1> ?%1 equ ($-$$)
  1937 0000011D 6A1A                    			push	26						;store interrupt nbr
  1938 0000011F 68[06040000]            			push	czIntReserved					;store message offset
  1939 00000124 EB2D                    			jmp	ReportInterrupt					;report interrupt
  1940                                  ;-----------------------------------------------------------------------------------------------------------------------
  1941                                  ;
  1942                                  ;	INT27	Reserved
  1943                                  ;
  1944                                  ;-----------------------------------------------------------------------------------------------------------------------
  1945                                  			menter	int27						;(reserved)
  1945                              <1> ?%1 equ ($-$$)
  1946 00000126 6A1B                    			push	27						;store interrupt nbr
  1947 00000128 68[06040000]            			push	czIntReserved					;store message offset
  1948 0000012D EB24                    			jmp	ReportInterrupt					;report interrupt
  1949                                  ;-----------------------------------------------------------------------------------------------------------------------
  1950                                  ;
  1951                                  ;	INT28	Reserved
  1952                                  ;
  1953                                  ;-----------------------------------------------------------------------------------------------------------------------
  1954                                  			menter	int28						;(reserved)
  1954                              <1> ?%1 equ ($-$$)
  1955 0000012F 6A1C                    			push	28						;store interrupt nbr
  1956 00000131 68[06040000]            			push	czIntReserved					;store message offset
  1957 00000136 EB1B                    			jmp	ReportInterrupt					;report interrupt
  1958                                  ;-----------------------------------------------------------------------------------------------------------------------
  1959                                  ;
  1960                                  ;	INT29	Reserved
  1961                                  ;
  1962                                  ;-----------------------------------------------------------------------------------------------------------------------
  1963                                  			menter	int29						;(reserved)
  1963                              <1> ?%1 equ ($-$$)
  1964 00000138 6A1D                    			push	29						;store interrupt nbr
  1965 0000013A 68[06040000]            			push	czIntReserved					;store message offset
  1966 0000013F EB12                    			jmp	ReportInterrupt					;report interrupt
  1967                                  ;-----------------------------------------------------------------------------------------------------------------------
  1968                                  ;
  1969                                  ;	INT30	Reserved
  1970                                  ;
  1971                                  ;-----------------------------------------------------------------------------------------------------------------------
  1972                                  			menter	int30						;(reserved)
  1972                              <1> ?%1 equ ($-$$)
  1973 00000141 6A1E                    			push	30						;store interrupt nbr
  1974 00000143 68[06040000]            			push	czIntReserved					;store message offset
  1975 00000148 EB09                    			jmp	ReportInterrupt					;report interrupt
  1976                                  ;-----------------------------------------------------------------------------------------------------------------------
  1977                                  ;
  1978                                  ;	INT31	Reserved
  1979                                  ;
  1980                                  ;-----------------------------------------------------------------------------------------------------------------------
  1981                                  			menter	int31						;(reserved)
  1981                              <1> ?%1 equ ($-$$)
  1982 0000014A 6A1F                    			push	31						;store interrupt nbr
  1983 0000014C 68[06040000]            			push	czIntReserved					;store message offset
  1984 00000151 EB00                    			jmp	ReportInterrupt					;report interrupt
  1985                                  ;-----------------------------------------------------------------------------------------------------------------------
  1986                                  ;
  1987                                  ;	Routine:	ReportInterrupt
  1988                                  ;
  1989                                  ;	Description:	This routine will be used to respond to processor interrupts that are not otherwise handled.
  1990                                  ;			At this stage, we simply restore the stack and return from the interrupt.
  1991                                  ;
  1992                                  ;	In:		[esp+16]	eflags					stored by interrupt call
  1993                                  ;			[esp+12]	cs					stored by interrupt call
  1994                                  ;			[esp+8]		eip					stored by interrupt call
  1995                                  ;			[esp+4]		interrupt number (0-31)			stored by push instruction
  1996                                  ;			[esp+0]		error message address			stored by push instructions
  1997                                  ;
  1998                                  ;	Out:		N/A		This routine does not exit.
  1999                                  ;
  2000                                  ;-----------------------------------------------------------------------------------------------------------------------
  2001 00000153 1E                      ReportInterrupt		push	ds						;save DS at time of interrupt
  2002 00000154 06                      			push	es						;save ES at time of interrupt
  2003 00000155 60                      			pushad							;save EAX,ECX,EDX,EBX,EBP,ESP,ESI,EDI
  2004 00000156 89E5                    			mov	ebp,esp						;ebp --> [EDI]
  2005                                  ;
  2006                                  ;	Addressability to registers at the time of the interrupt is now established as:
  2007                                  ;
  2008                                  ;			[ebp+56]	eflags
  2009                                  ;			[ebp+52]	cs
  2010                                  ;			[ebp+48]	eip
  2011                                  ;			[ebp+44]	interrupt number (0-31)
  2012                                  ;			[ebp+40]	error message address
  2013                                  ;			[ebp+36]	ds
  2014                                  ;			[ebp+32]	es
  2015                                  ;			[ebp+28]	eax
  2016                                  ;			[ebp+24]	ecx
  2017                                  ;			[ebp+20]	edx
  2018                                  ;			[ebp+16]	ebx
  2019                                  ;			[ebp+12]	esp
  2020                                  ;			[ebp+8]		ebp
  2021                                  ;			[ebp+4]		esi
  2022                                  ;			[ebp+0]		edi
  2023                                  ;
  2024 00000158 0E                      			push	cs						;load code selector ...
  2025 00000159 1F                      			pop	ds						;... into DS
  2026 0000015A 6A20                    			push	ESELCGA						;load CGA memory selector ...
  2027 0000015C 07                      			pop	es						;... into ES
  2028                                  ;
  2029                                  ;	Display the interrupt report boundary box
  2030                                  ;
  2031 0000015D B10D                    			mov	cl,13						;column
  2032 0000015F B506                    			mov	ch,6						;row
  2033 00000161 B232                    			mov	dl,50						;width
  2034 00000163 B608                    			mov	dh,8						;height
  2035 00000165 B707                    			mov	bh,07h						;attribute
  2036 00000167 E84C030000              			call	DrawTextDialogBox				;draw text dialog box
  2037                                  ;
  2038                                  ;	Display the report header
  2039                                  ;
  2040 0000016C B10F                    			mov	cl,15						;column
  2041 0000016E B507                    			mov	ch,7						;row
  2042 00000170 BE[0F040000]            			mov	esi,czIntHeader					;interrupt message header
  2043 00000175 E8E9110000              			call	SetConsoleString				;draw text string
  2044                                  ;
  2045                                  ;	Display the interrupt description label
  2046                                  ;
  2047 0000017A B10F                    			mov	cl,15						;column
  2048 0000017C B508                    			mov	ch,8						;row
  2049 0000017E BE[3E040000]            			mov	esi,czIntLabel					;interrupt message description lead
  2050 00000183 E8DB110000              			call	SetConsoleString				;draw text string
  2051                                  ;
  2052                                  ;	Display the interrupt number
  2053                                  ;
  2054 00000188 8B452C                  			mov	eax,[ebp+44]					;interrupt number
  2055 0000018B B11A                    			mov	cl,26						;column
  2056 0000018D B508                    			mov	ch,8						;row
  2057 0000018F E8830F0000              			call	PutConsoleHexByte				;draw ASCII hex byte
  2058                                  ;
  2059                                  ;	Display the interrupt name
  2060                                  ;
  2061 00000194 B11D                    			mov	cl,29						;column
  2062 00000196 B508                    			mov	ch,8						;row
  2063 00000198 8B7528                  			mov	esi,[ebp+40]					;interrupt-specific message
  2064 0000019B E8C3110000              			call	SetConsoleString				;display interrupt description
  2065                                  ;
  2066                                  ;	Display the register values header
  2067                                  ;
  2068 000001A0 B10F                    			mov	cl,15						;column
  2069 000001A2 B50A                    			mov	ch,10						;row
  2070 000001A4 BE[4A040000]            			mov	esi,czIntRegsHeader				;interrupt registers header
  2071 000001A9 E8B5110000              			call	SetConsoleString				;draw text string
  2072                                  ;
  2073                                  ;	Display the EAX register label and value
  2074                                  ;
  2075 000001AE B10F                    			mov	cl,15						;column
  2076 000001B0 B50B                    			mov	ch,11						;row
  2077 000001B2 BE[72040000]            			mov	esi,czIntEAX					;register EAX label
  2078 000001B7 E8A7110000              			call	SetConsoleString				;draw label
  2079 000001BC 8B451C                  			mov	eax,[ebp+28]					;EAX value at interrupt
  2080 000001BF B113                    			mov	cl,19						;column
  2081 000001C1 B50B                    			mov	ch,11						;row
  2082 000001C3 E82F0F0000              			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2083                                  ;
  2084                                  ;	Display the ECX register label and value
  2085                                  ;
  2086 000001C8 B10F                    			mov	cl,15						;column
  2087 000001CA B50C                    			mov	ch,12						;row
  2088 000001CC BE[77040000]            			mov	esi,czIntECX					;label
  2089 000001D1 E88D110000              			call	SetConsoleString				;draw label
  2090 000001D6 8B4518                  			mov	eax,[ebp+24]					;ECX value at interrupt
  2091 000001D9 B113                    			mov	cl,19						;column
  2092 000001DB B50C                    			mov	ch,12						;row
  2093 000001DD E8150F0000              			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2094                                  ;
  2095                                  ;	Display the EDX register label and value
  2096                                  ;
  2097 000001E2 B10F                    			mov	cl,15						;column
  2098 000001E4 B50D                    			mov	ch,13						;row
  2099 000001E6 BE[7C040000]            			mov	esi,czIntEDX					;label
  2100 000001EB E873110000              			call	SetConsoleString				;draw label
  2101 000001F0 8B4514                  			mov	eax,[ebp+20]					;EDX value at interrupt
  2102 000001F3 B113                    			mov	cl,19						;column
  2103 000001F5 B50D                    			mov	ch,13						;row
  2104 000001F7 E8FB0E0000              			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2105                                  ;
  2106                                  ;	Display the EBX register label and value
  2107                                  ;
  2108 000001FC B10F                    			mov	cl,15						;column
  2109 000001FE B50E                    			mov	ch,14						;row
  2110 00000200 BE[81040000]            			mov	esi,czIntEBX					;label
  2111 00000205 E859110000              			call	SetConsoleString				;draw label
  2112 0000020A 8B4510                  			mov	eax,[ebp+16]					;EBX value at interrupt
  2113 0000020D B113                    			mov	cl,19						;column
  2114 0000020F B50E                    			mov	ch,14						;row
  2115 00000211 E8E10E0000              			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2116                                  ;
  2117                                  ;	Display the ESI register label and value
  2118                                  ;
  2119 00000216 B11D                    			mov	cl,29						;column
  2120 00000218 B50B                    			mov	ch,11						;row
  2121 0000021A BE[86040000]            			mov	esi,czIntESI					;label
  2122 0000021F E83F110000              			call	SetConsoleString				;draw label
  2123 00000224 8B4504                  			mov	eax,[ebp+4]					;ESI
  2124 00000227 B121                    			mov	cl,33						;column
  2125 00000229 B50B                    			mov	ch,11						;row
  2126 0000022B E8C70E0000              			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2127                                  ;
  2128                                  ;	Display the EDI register label and value
  2129                                  ;
  2130 00000230 B11D                    			mov	cl,29						;column
  2131 00000232 B50C                    			mov	ch,12						;row
  2132 00000234 BE[8B040000]            			mov	esi,czIntEDI					;label
  2133 00000239 E825110000              			call	SetConsoleString				;draw label
  2134 0000023E 8B4500                  			mov	eax,[ebp+0]					;EDI
  2135 00000241 B121                    			mov	cl,33						;column
  2136 00000243 B50C                    			mov	ch,12						;row
  2137 00000245 E8AD0E0000              			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2138                                  ;
  2139                                  ;	Display the EBP register label and value
  2140                                  ;
  2141 0000024A B11D                    			mov	cl,29						;column
  2142 0000024C B50D                    			mov	ch,13						;row
  2143 0000024E BE[90040000]            			mov	esi,czIntEBP					;label
  2144 00000253 E80B110000              			call	SetConsoleString				;draw label
  2145 00000258 8B4508                  			mov	eax,[ebp+8]					;EBP
  2146 0000025B B121                    			mov	cl,33						;column
  2147 0000025D B50D                    			mov	ch,13						;row
  2148 0000025F E8930E0000              			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2149                                  ;
  2150                                  ;	Display the DS register label and value
  2151                                  ;
  2152 00000264 B12A                    			mov	cl,42						;column
  2153 00000266 B50B                    			mov	ch,11						;row
  2154 00000268 BE[9A040000]            			mov	esi,czIntDS					;label
  2155 0000026D E8F1100000              			call	SetConsoleString				;draw label
  2156 00000272 31C0                    			xor	eax,eax						;zero register
  2157 00000274 668B4524                			mov	ax,[ebp+36]					;DS
  2158 00000278 B12E                    			mov	cl,46						;column
  2159 0000027A B50B                    			mov	ch,11						;row
  2160 0000027C E8860E0000              			call	PutConsoleHexWord				;draw ASCII hex word
  2161                                  ;
  2162                                  ;	Display the ES register label and value
  2163                                  ;
  2164 00000281 B12A                    			mov	cl,42						;column
  2165 00000283 B50C                    			mov	ch,12						;row
  2166 00000285 BE[9F040000]            			mov	esi,czIntES					;label
  2167 0000028A E8D4100000              			call	SetConsoleString				;draw label
  2168 0000028F 31C0                    			xor	eax,eax						;zero register
  2169 00000291 668B4520                			mov	ax,[ebp+32]					;ES
  2170 00000295 B12E                    			mov	cl,46						;column
  2171 00000297 B50C                    			mov	ch,12						;row
  2172 00000299 E8690E0000              			call	PutConsoleHexWord				;draw ASCII hex word
  2173                                  ;
  2174                                  ;	Display the SS register label and value
  2175                                  ;
  2176 0000029E B12A                    			mov	cl,42						;column
  2177 000002A0 B50D                    			mov	ch,13						;row
  2178 000002A2 BE[A4040000]            			mov	esi,czIntSS					;label
  2179 000002A7 E8B7100000              			call	SetConsoleString				;draw label
  2180 000002AC 31C0                    			xor	eax,eax						;zero register
  2181 000002AE 668CD0                  			mov	ax,ss						;SS
  2182 000002B1 B12E                    			mov	cl,46						;column
  2183 000002B3 B50D                    			mov	ch,13						;row
  2184 000002B5 E84D0E0000              			call	PutConsoleHexWord				;draw ASCII hex word
  2185                                  ;
  2186                                  ;	Display the CS register lable and value
  2187                                  ;
  2188 000002BA B12A                    			mov	cl,42						;column
  2189 000002BC B50E                    			mov	ch,14						;row
  2190 000002BE BE[A9040000]            			mov	esi,czIntCS					;label
  2191 000002C3 E89B100000              			call	SetConsoleString				;draw label
  2192 000002C8 31C0                    			xor	eax,eax						;zero register
  2193 000002CA 668B4534                			mov	ax,[ebp+52]					;CS
  2194 000002CE B12E                    			mov	cl,46						;column
  2195 000002D0 B50E                    			mov	ch,14						;row
  2196 000002D2 E8300E0000              			call	PutConsoleHexWord				;draw ASCII hex word
  2197                                  ;
  2198                                  ;	Display the EFLAGS register label and value
  2199                                  ;
  2200 000002D7 B133                    			mov	cl,51						;column
  2201 000002D9 B50B                    			mov	ch,11						;row
  2202 000002DB BE[AE040000]            			mov	esi,czIntEFLAGS					;label
  2203 000002E0 E87E100000              			call	SetConsoleString				;draw label
  2204 000002E5 8B4538                  			mov	eax,[ebp+56]					;EFLAGS
  2205 000002E8 B137                    			mov	cl,55						;column
  2206 000002EA B50B                    			mov	ch,11						;row
  2207 000002EC E8060E0000              			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2208                                  ;
  2209                                  ;	Display the ESP register label and value
  2210                                  ;
  2211 000002F1 B133                    			mov	cl,51						;column
  2212 000002F3 B50D                    			mov	ch,13						;row
  2213 000002F5 BE[95040000]            			mov	esi,czIntESP					;label
  2214 000002FA E864100000              			call	SetConsoleString				;draw label
  2215 000002FF 8B450C                  			mov	eax,[ebp+12]					;ESP
  2216 00000302 B137                    			mov	cl,55						;column
  2217 00000304 B50D                    			mov	ch,13						;row
  2218 00000306 E8EC0D0000              			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2219                                  ;
  2220                                  ;	Display the EIP register label and value
  2221                                  ;
  2222 0000030B B133                    			mov	cl,51						;column
  2223 0000030D B50E                    			mov	ch,14						;row
  2224 0000030F BE[B3040000]            			mov	esi,czIntEIP					;label
  2225 00000314 E84A100000              			call	SetConsoleString				;draw label
  2226 00000319 8B4530                  			mov	eax,[ebp+48]					;EIP
  2227 0000031C B137                    			mov	cl,55						;column
  2228 0000031E B50E                    			mov	ch,14						;row
  2229 00000320 E8D20D0000              			call	PutConsoleHexDword				;draw ASCII hex doubleword
  2230                                  ;
  2231                                  ;	Halt and loop until reset
  2232                                  ;
  2233 00000325 FB                      .10			sti							;enable maskable interrupts
  2234 00000326 F4                      			hlt							;halt processor
  2235 00000327 EBFC                    			jmp	.10						;resume on interrupt
  2236                                  ;-----------------------------------------------------------------------------------------------------------------------
  2237                                  ;
  2238                                  ;	Processor Interrupt Name Strings
  2239                                  ;
  2240                                  ;-----------------------------------------------------------------------------------------------------------------------
  2241 00000329 4469766973696F6E20-     czIntDivideByZero	db	"Division by zero",0
  2241 00000332 6279207A65726F00   
  2242 0000033A 53696E676C65207374-     czIntSingleStep		db	"Single step",0
  2242 00000343 657000             
  2243 00000346 4E6F6E2D6D61736B61-     czIntNonMaskable	db	"Non-maskable interrupt",0
  2243 0000034F 626C6520696E746572-
  2243 00000358 7275707400         
  2244 0000035D 427265616B00            czIntBreak		db	"Break",0
  2245 00000363 496E746F00              czIntInto		db	"Into",0
  2246 00000368 426F756E647300          czIntBounds		db	"Bounds",0
  2247 0000036F 426164204F70657261-     czIntBadOpCode		db	"Bad Operation Code",0
  2247 00000378 74696F6E20436F6465-
  2247 00000381 00                 
  2248 00000382 4E6F20436F70726F63-     czIntNoCoprocessor	db	"No Coprocessor",0
  2248 0000038B 6573736F7200       
  2249 00000391 446F75626C65204661-     czIntDoubleFault	db	"Double Fault",0
  2249 0000039A 756C7400           
  2250 0000039E 4F706572616E6400        czIntOperand		db	"Operand",0
  2251 000003A6 426164205461736B20-     czIntBadTSS		db	"Bad Task State Segment",0
  2251 000003AF 537461746520536567-
  2251 000003B8 6D656E7400         
  2252 000003BD 4E6F74205072657365-     czIntNotPresent		db	"Not Present",0
  2252 000003C6 6E7400             
  2253 000003C9 537461636B204C696D-     czIntStackLimit		db	"Stack Limit",0
  2253 000003D2 697400             
  2254 000003D5 47656E6572616C2050-     czIntProtection		db	"General Protection Fault",0
  2254 000003DE 726F74656374696F6E-
  2254 000003E7 204661756C7400     
  2255 000003EE 436F70726F63657373-     czIntCoprocessorCalc	db	"Coprocessor Calculation",0
  2255 000003F7 6F722043616C63756C-
  2255 00000400 6174696F6E00       
  2256 00000406 526573657276656400      czIntReserved		db	"Reserved",0
  2257                                  ;-----------------------------------------------------------------------------------------------------------------------
  2258                                  ;
  2259                                  ;	Processor Interrupt Handling Strings
  2260                                  ;
  2261                                  ;-----------------------------------------------------------------------------------------------------------------------
  2262 0000040F 416E20756E68616E64-     czIntHeader		db	"An unhandled processor interrupt has occurred:",0
  2262 00000418 6C65642070726F6365-
  2262 00000421 73736F7220696E7465-
  2262 0000042A 727275707420686173-
  2262 00000433 206F63637572726564-
  2262 0000043C 3A00               
  2263 0000043E 496E74657272757074-     czIntLabel		db	"Interrupt #",0
  2263 00000447 202300             
  2264 0000044A 526567697374657273-     czIntRegsHeader		db	"Registers at the time of the interrupt:",0
  2264 00000453 206174207468652074-
  2264 0000045C 696D65206F66207468-
  2264 00000465 6520696E7465727275-
  2264 0000046E 70743A00           
  2265 00000472 4541583A00              czIntEAX		db	"EAX:",0
  2266 00000477 4543583A00              czIntECX		db	"ECX:",0
  2267 0000047C 4544583A00              czIntEDX		db	"EDX:",0
  2268 00000481 4542583A00              czIntEBX		db	"EBX:",0
  2269 00000486 4553493A00              czIntESI		db	"ESI:",0
  2270 0000048B 4544493A00              czIntEDI		db	"EDI:",0
  2271 00000490 4542503A00              czIntEBP		db	"EBP:",0
  2272 00000495 4553503A00              czIntESP		db	"ESP:",0
  2273 0000049A 2044533A00              czIntDS			db	" DS:",0
  2274 0000049F 2045533A00              czIntES			db	" ES:",0
  2275 000004A4 2053533A00              czIntSS			db	" SS:",0
  2276 000004A9 2043533A00              czIntCS			db	" CS:",0
  2277 000004AE 464C473A00              czIntEFLAGS		db	"FLG:",0
  2278 000004B3 4549503A00              czIntEIP		db	"EIP:",0
  2279                                  ;-----------------------------------------------------------------------------------------------------------------------
  2280                                  ;
  2281                                  ;	Routine:	DrawTextDialogBox
  2282                                  ;
  2283                                  ;	Description:	This routine opens a text-mode dialog box with an ASCII border.
  2284                                  ;
  2285                                  ;	In:		CL	upper left column (0-79)
  2286                                  ;			CH	upper left row (0-24)
  2287                                  ;			DL	column width, excluding border
  2288                                  ;			DH	row height, excluding border
  2289                                  ;			BH	color attribute
  2290                                  ;
  2291                                  ;-----------------------------------------------------------------------------------------------------------------------
  2292 000004B8 51                      DrawTextDialogBox	push	ecx						;save non-volatile regs
  2293 000004B9 56                      			push	esi						;
  2294 000004BA 57                      			push	edi						;
  2295 000004BB 06                      			push	es						;
  2296 000004BC 6A20                    			push	ESELCGA						;load CGA selector ...
  2297 000004BE 07                      			pop	es						;... into ES
  2298                                  ;
  2299                                  ;	Compute target display offset
  2300                                  ;
  2301 000004BF 31C0                    			xor	eax,eax						;zero register
  2302 000004C1 88E8                    			mov	al,ch						;row
  2303 000004C3 B4A0                    			mov	ah,ECONROWBYTES					;mulitplicand
  2304 000004C5 F6E4                    			mul	ah						;row offset
  2305 000004C7 00C8                    			add	al,cl						;add column
  2306 000004C9 80D400                  			adc	ah,0						;add overflow
  2307 000004CC 00C8                    			add	al,cl						;add column
  2308 000004CE 80D400                  			adc	ah,0						;add overflow
  2309 000004D1 89C7                    			mov	edi,eax						;target row offset
  2310                                  ;
  2311                                  ;	Display top border row
  2312                                  ;
  2313 000004D3 57                      			push	edi						;save target row offset
  2314 000004D4 88FC                    			mov	ah,bh						;attribute
  2315 000004D6 B0DA                    			mov	al,EASCIIBORDSGLUPRLFT				;upper-left single border
  2316 000004D8 66AB                    			stosw							;display character and attribute
  2317 000004DA B0C4                    			mov	al,EASCIIBORDSGLHORZ				;horizontal single border
  2318 000004DC 31C9                    			xor	ecx,ecx						;zero register
  2319 000004DE 88D1                    			mov	cl,dl						;width, excluding border
  2320 000004E0 F366AB                  			rep	stosw						;display horizontal border
  2321 000004E3 B0BF                    			mov	al,EASCIIBORDSGLUPRRGT				;upper-right single border
  2322 000004E5 66AB                    			stosw							;display character and attribute
  2323 000004E7 5F                      			pop	edi						;restore target row offset
  2324 000004E8 81C7A0000000            			add	edi,ECONROWBYTES				;next row
  2325                                  ;
  2326                                  ;	Display dialog box body rows
  2327                                  ;
  2328 000004EE 31C9                    			xor	ecx,ecx						;zero register
  2329 000004F0 88F1                    			mov	cl,dh						;height, excluding border
  2330 000004F2 51                      .10			push	ecx						;save remaining rows
  2331 000004F3 57                      			push	edi						;save target row offset
  2332 000004F4 88FC                    			mov	ah,bh						;attribute
  2333 000004F6 B0B3                    			mov	al,EASCIIBORDSGLVERT				;vertical single border
  2334 000004F8 66AB                    			stosw							;display character and attribute
  2335 000004FA B020                    			mov	al,EASCIISPACE					;space
  2336 000004FC 31C9                    			xor	ecx,ecx						;zero register
  2337 000004FE 88D1                    			mov	cl,dl						;width, excluding border
  2338 00000500 F366AB                  			rep	stosw						;display row
  2339 00000503 B0B3                    			mov	al,EASCIIBORDSGLVERT				;vertical single border
  2340 00000505 66AB                    			stosw							;display character and attribute
  2341 00000507 5F                      			pop	edi						;restore target row offset
  2342 00000508 81C7A0000000            			add	edi,ECONROWBYTES				;next row
  2343 0000050E 59                      			pop	ecx						;remaining rows
  2344 0000050F E2E1                    			loop	.10						;next row
  2345                                  ;
  2346                                  ;	Display bottom border row
  2347                                  ;
  2348 00000511 57                      			push	edi						;save target row offset
  2349 00000512 88FC                    			mov	ah,bh						;attribute
  2350 00000514 B0C0                    			mov	al,EASCIIBORDSGLLWRLFT				;lower-left single border
  2351 00000516 66AB                    			stosw							;display character and attribute
  2352 00000518 B0C4                    			mov	al,EASCIIBORDSGLHORZ				;horizontal single border
  2353 0000051A 31C9                    			xor	ecx,ecx						;zero register
  2354 0000051C 88D1                    			mov	cl,dl						;width, excluding border
  2355 0000051E F366AB                  			rep	stosw						;display horizontal border
  2356 00000521 B0D9                    			mov	al,EASCIIBORDSGLLWRRGT				;lower-right single border
  2357 00000523 66AB                    			stosw							;display character and attribute
  2358 00000525 5F                      			pop	edi						;restore target row offset
  2359 00000526 81C7A0000000            			add	edi,ECONROWBYTES				;next row
  2360                                  ;
  2361                                  ;	Restore and return
  2362                                  ;
  2363 0000052C 07                      			pop	es						;restore non-volatile regs
  2364 0000052D 5F                      			pop	edi						;
  2365 0000052E 5E                      			pop	esi						;
  2366 0000052F 59                      			pop	ecx						;
  2367 00000530 C3                      			ret							;return
  2368                                  ;=======================================================================================================================
  2369                                  ;
  2370                                  ;	Hardware Device Interupts
  2371                                  ;
  2372                                  ;	The next 16 interrupts are defined as our hardware interrupts. These interrupts vectors (20h-2Fh) are mapped to
  2373                                  ;	the hardware interrupts IRQ0-IRQF by the BIOS when the call to the BIOS is made invoking BIOS function 89h
  2374                                  ;	(BX=2028h).
  2375                                  ;
  2376                                  ;=======================================================================================================================
  2377                                  ;-----------------------------------------------------------------------------------------------------------------------
  2378                                  ;
  2379                                  ;	IRQ0	Clock Tick Interrupt
  2380                                  ;
  2381                                  ;	PC compatible systems contain or emulate the function of the Intel 8253 Programmable Interval Timer (PIT).
  2382                                  ;	Channel 0 of this chip decrements an internal counter to zero and then issues a hardware interrupt. The default
  2383                                  ;	rate at which IRQ0 occurs is approximately 18.2 times per second or, more accurately, 1,573,040 times per day.
  2384                                  ;
  2385                                  ;	Every time IRQ0 occurs, a counter at 40:6c is incremented. When the number of ticks reaches the maximum for one
  2386                                  ;	day, the counter is set to zero and the number of days counter at 40:70 is incremented.
  2387                                  ;
  2388                                  ;	This handler also decrements the floppy drive motor count at 40:40 if it is not zero. When this count reaches
  2389                                  ;	zero, the floppy disk motors are turned off.
  2390                                  ;
  2391                                  ;-----------------------------------------------------------------------------------------------------------------------
  2392                                  			menter	clocktick					;clock tick interrupt
  2392                              <1> ?%1 equ ($-$$)
  2393 00000531 50                      			push	eax						;save modified regs
  2394 00000532 52                      			push	edx						;
  2395 00000533 1E                      			push	ds						;
  2396                                  ;
  2397                                  ;	Update the clock tick count and the elapsed days as needed
  2398                                  ;
  2399 00000534 6A18                    			push	ESELDAT						;load OS data selector ...
  2400 00000536 1F                      			pop	ds						;... into data segment register
  2401 00000537 A16C040000              			mov	eax,[wdClockTicks]				;eax = clock ticks
  2402 0000053C 40                      			inc	eax						;increment clock ticks
  2403 0000053D 3DB0001800              			cmp	eax,EPITDAYTICKS				;clock ticks per day?
  2404 00000542 7208                    			jb	irq0.10						;no, skip ahead
  2405 00000544 FE0570040000            			inc	byte [wbClockDays]				;increment clock days
  2406 0000054A 31C0                    			xor	eax,eax						;reset clock ticks
  2407 0000054C A36C040000              irq0.10			mov	dword [wdClockTicks],eax			;save clock ticks
  2408                                  ;
  2409                                  ;	Decrement floppy disk motor timeout
  2410                                  ;
  2411 00000551 803D4004000000          			cmp	byte [wbFDCMotor],0				;floppy motor timeout?
  2412 00000558 741E                    			je	irq0.20						;yes, skip ahead
  2413 0000055A FE0D40040000            			dec	byte [wbFDCMotor]				;decrement motor timeout
  2414 00000560 7516                    			jnz	irq0.20						;skip ahead if non-zero
  2415                                  ;
  2416                                  ;	Turn off the floppy disk motor if appropriate
  2417                                  ;
  2418 00000562 FB                      			sti							;enable maskable interrupts
  2419 00000563 B603                    irq0.15 		mov	dh,EFDCPORTHI					;FDC controller port hi
  2420 00000565 B2F4                    			mov	dl,EFDCPORTLOSTAT				;FDC main status register
  2421 00000567 EC                      			in	al,dx						;FDC main status byte
  2422 00000568 A810                    			test	al,EFDCSTATBUSY					;test FDC main status for busy
  2423 0000056A 75F7                    			jnz	irq0.15						;wait while busy
  2424 0000056C B00C                    			mov	al,EFDCMOTOROFF					;motor-off / enable/ DMA setting
  2425 0000056E A23F040000              			mov	byte [wbFDCControl],al				;save motor-off setting
  2426 00000573 B603                    			mov	dh,EFDCPORTHI					;fdc port hi
  2427 00000575 B2F2                    			mov	dl,EFDCPORTLOOUT				;fdc digital output register
  2428 00000577 EE                      			out	dx,al						;turn motor off
  2429                                  ;
  2430                                  ;	Signal the end of the hardware interrupt
  2431                                  ;
  2432 00000578 E8360E0000              irq0.20			call	PutPrimaryEndOfInt				;send end-of-interrupt to PIC
  2433                                  ;
  2434                                  ;	Determine if a task switch is appropriate
  2435                                  ;
  2436 0000057D 803D070A000000          			cmp	byte [wbInCriticalSection],0			;any task holding a critical section?
  2437 00000584 7535                    			jne	irq0.30						;yes, do not switch tasks
  2438 00000586 FE05060A0000            			inc	byte [wbTaskIndex]				;increment task queue index (0-255)
  2439 0000058C 0FB605060A0000          			movzx	eax,byte [wbTaskIndex]				;load task queue index
  2440 00000593 668B940000080000        			mov	dx,[wwTaskQueue+eax*2]				;next task selector
  2441 0000059B 660F00C8                			str	ax						;current task selector
  2442 0000059F 6639C2                  			cmp	dx,ax						;next task same is current task?
  2443 000005A2 7417                    			je	irq0.30						;yes, skip task switch
  2444                                  ;
  2445                                  ;	Switch task
  2446                                  ;
  2447 000005A4 06                      			push	es						;save extra segment register
  2448 000005A5 6A08                    			push	ESELGDT						;load GDT alias selector ...
  2449 000005A7 07                      			pop	es						;... into extra segment reg
  2450 000005A8 26806005FD              			and	byte [es:eax+5],0FDh				;reset task-busy bit of current task
  2451 000005AD 07                      			pop	es						;restore extra segment register
  2452 000005AE 668915040A0000          			mov	word [wwFarJumpSelector],dx			;set next task selector in jmp instr
  2453 000005B5 FF2D000A0000            			jmp	far [wdFarJumpEIP]				;jump to next task
  2454                                  ;
  2455                                  ;	Restore and return
  2456                                  ;
  2457 000005BB 1F                      irq0.30			pop	ds						;restore modified regs
  2458 000005BC 5A                      			pop	edx						;
  2459 000005BD 58                      			pop	eax						;
  2460 000005BE CF                      			iretd							;return
  2461                                  ;-----------------------------------------------------------------------------------------------------------------------
  2462                                  ;
  2463                                  ;	IRQ1	Keyboard Interrupt
  2464                                  ;
  2465                                  ;	This handler is called when an IRQ1 hardware interrupt occurs, caused by a keyboard event. The scan-code(s)
  2466                                  ;	corresponding to the keyboard event are read and message events are appended to the message queue. Since this
  2467                                  ;	code is called in response to a hardware interrupt, no task switch occurs. We need to preseve the state of
  2468                                  ;	ALL modified registers upon return. Note that keyboard messages are added to the keyboard focus message queue.
  2469                                  ;	This is a queue referenced in the global descriptor table and must always reference the message queue for the
  2470                                  ;	task that has the keyboard focus. To direct keyboard messages to another task, update the GDT descriptor to
  2471                                  ;	point to the message queue for that task.
  2472                                  ;
  2473                                  ;-----------------------------------------------------------------------------------------------------------------------
  2474                                  			menter	keyboard					;keyboard interrrupt
  2474                              <1> ?%1 equ ($-$$)
  2475 000005BF 50                      			push	eax						;save non-volatile regs
  2476 000005C0 53                      			push	ebx						;
  2477 000005C1 51                      			push	ecx						;
  2478 000005C2 56                      			push	esi						;
  2479 000005C3 1E                      			push	ds						;
  2480 000005C4 6A18                    			push	ESELDAT						;load OS data selector ...
  2481 000005C6 1F                      			pop	ds						;... into data segment register
  2482 000005C7 30C0                    			xor	al,al						;zero
  2483 000005C9 A24D0A0000              			mov	[wbConsoleScan0],al				;clear scan code 0
  2484 000005CE A24E0A0000              			mov	[wbConsoleScan1],al				;clear scan code 1
  2485 000005D3 A24F0A0000              			mov	[wbConsoleScan2],al				;clear scan code 2
  2486 000005D8 A2500A0000              			mov	[wbConsoleScan3],al				;clear scan code 3
  2487 000005DD A2510A0000              			mov	[wbConsoleScan4],al				;clear scan code 4
  2488 000005E2 A2520A0000              			mov	[wbConsoleScan5],al				;clear scan code 5
  2489 000005E7 B020                    			mov	al,' '						;space
  2490 000005E9 A2530A0000              			mov	[wbConsoleChar],al				;set character to space
  2491 000005EE B080                    			mov	al,EKEYFTIMEOUT					;controller timeout flag
  2492 000005F0 F6D0                    			not	al						;controller timeout mask
  2493 000005F2 20054C0A0000            			and	[wbConsoleStatus],al				;clear controller timeout flag
  2494 000005F8 8A1D4A0A0000            			mov	bl,[wbConsoleShift]				;shift flags
  2495 000005FE 8A3D4B0A0000            			mov	bh,[wbConsoleLock]				;lock flags
  2496 00000604 E85F0E0000              			call	WaitForKeyOutBuffer				;controller timeout?
  2497 00000609 0F8404020000            			jz	irq1.140					;yes, skip ahead
  2498 0000060F E460                    			in	al,EKEYBPORTDATA				;read scan code 0
  2499 00000611 A24D0A0000              			mov	[wbConsoleScan0],al				;save scan code 0
  2500 00000616 88C4                    			mov	ah,al						;copy scan code 0
  2501 00000618 B002                    			mov	al,EKEYFSHIFTLEFT				;left shift flag
  2502 0000061A 80FC2A                  			cmp	ah,EKEYBSHIFTLDOWN				;left shift key down code?
  2503 0000061D 0F84E0000000            			je	irq1.30						;yes, set flag
  2504 00000623 80FCAA                  			cmp	ah,EKEYBSHIFTLUP				;left shift key up code?
  2505 00000626 0F84DB000000            			je	irq1.40						;yes, reset flag
  2506 0000062C B010                    			mov	al,EKEYFSHIFTRIGHT				;right shift flag
  2507 0000062E 80FC36                  			cmp	ah,EKEYBSHIFTRDOWN				;right shift key down code?
  2508 00000631 0F84CC000000            			je	irq1.30						;yes, set flag
  2509 00000637 80FCB6                  			cmp	ah,EKEYBSHIFTRUP				;right shift key up code?
  2510 0000063A 0F84C7000000            			je	irq1.40						;yes, reset flag
  2511 00000640 B001                    			mov	al,EKEYFCTRLLEFT				;left control flag
  2512 00000642 80FC1D                  			cmp	ah,EKEYBCTRLDOWN				;control key down code?
  2513 00000645 0F84B8000000            			je	irq1.30						;yes, set flag
  2514 0000064B 80FC9D                  			cmp	ah,EKEYBCTRLUP					;control key up code?
  2515 0000064E 0F84B3000000            			je	irq1.40						;yes, reset flag
  2516 00000654 B004                    			mov	al,EKEYFALTLEFT					;left alt flag
  2517 00000656 80FC38                  			cmp	ah,EKEYBALTDOWN					;alt key down code?
  2518 00000659 0F84A4000000            			je	irq1.30						;yes, set flag
  2519 0000065F 80FCB8                  			cmp	ah,EKEYBALTUP					;alt key up code?
  2520 00000662 0F849F000000            			je	irq1.40						;yes, reset flag
  2521 00000668 B004                    			mov	al,EKEYFLOCKCAPS				;caps-lock flag
  2522 0000066A 80FC3A                  			cmp	ah,EKEYBCAPSDOWN				;caps-lock key down code?
  2523 0000066D 0F849A000000            			je	irq1.50						;yes, toggle lamps and flags
  2524 00000673 B002                    			mov	al,EKEYFLOCKNUM					;num-lock flag
  2525 00000675 80FC45                  			cmp	ah,EKEYBNUMDOWN					;num-lock key down code?
  2526 00000678 0F848F000000            			je	irq1.50						;yes, toggle lamps and flags
  2527 0000067E B001                    			mov	al,EKEYFLOCKSCROLL				;scroll-lock flag
  2528 00000680 80FC46                  			cmp	ah,EKEYBSCROLLDOWN				;scroll-lock key down code?
  2529 00000683 0F8484000000            			je	irq1.50						;yes, toggle lamps and flags
  2530 00000689 80FCE0                  			cmp	ah,EKEYBCODEEXT0				;extended scan code 0?
  2531 0000068C 0F8598000000            			jne	irq1.70 					;no, skip ahead
  2532 00000692 E8D10D0000              			call	WaitForKeyOutBuffer				;controller timeout?
  2533 00000697 0F8476010000            			jz	irq1.140					;yes, skip ahead
  2534 0000069D E460                    			in	al,EKEYBPORTDATA				;read scan code 1
  2535 0000069F A24E0A0000              			mov	[wbConsoleScan1],al				;save scan code 1
  2536 000006A4 88C4                    			mov	ah,al						;copy scan code 1
  2537 000006A6 B008                    			mov	al,EKEYFCTRLRIGHT				;right control flag
  2538 000006A8 80FC1D                  			cmp	ah,EKEYBCTRLDOWN				;control key down code?
  2539 000006AB 7456                    			je	irq1.30						;yes, set flag
  2540 000006AD 80FC9D                  			cmp	ah,EKEYBCTRLUP					;control key up code?
  2541 000006B0 7455                    			je	irq1.40						;yes, reset flag
  2542 000006B2 B020                    			mov	al,EKEYFALTRIGHT				;right alt flag
  2543 000006B4 80FC38                  			cmp	ah,EKEYBALTDOWN					;alt key down code?
  2544 000006B7 744A                    			je	irq1.30						;yes, set flag
  2545 000006B9 80FCB8                  			cmp	ah,EKEYBALTUP					;alt key up code?
  2546 000006BC 7449                    			je	irq1.40						;yes, reset flag
  2547 000006BE 80FC35                  			cmp	ah,EKEYBSLASH					;slash down code?
  2548 000006C1 0F84D2000000            			je	irq1.80						;yes, skip ahead
  2549 000006C7 80FCB5                  			cmp	ah,EKEYBSLASHUP					;slash up code?
  2550 000006CA 0F84C9000000            			je	irq1.80						;yes, skip ahead
  2551 000006D0 80FC2A                  			cmp	ah,EKEYBPRTSCRDOWN				;print screen down code?
  2552 000006D3 7405                    			je	irq1.10						;yes, continue
  2553 000006D5 80FCB7                  			cmp	ah,EKEYBPRTSCRUP				;print screen up code?
  2554 000006D8 7524                    			jne	irq1.20						;no, skip ahead
  2555 000006DA E8890D0000              irq1.10			call	WaitForKeyOutBuffer				;controller timeout?
  2556 000006DF 0F842E010000            			jz	irq1.140					;yes, skip ahead
  2557 000006E5 E460                    			in	al,EKEYBPORTDATA				;read scan code 2
  2558 000006E7 A24F0A0000              			mov	[wbConsoleScan2],al				;save scan code 2
  2559 000006EC E8770D0000              			call	WaitForKeyOutBuffer				;controller timeout?
  2560 000006F1 0F841C010000            			jz	irq1.140					;yes, skip ahead
  2561 000006F7 E460                    			in	al,EKEYBPORTDATA				;read scan code 3
  2562 000006F9 A2500A0000              			mov	[wbConsoleScan3],al				;read scan code 3
  2563 000006FE E918010000              irq1.20			jmp	irq1.150					;finish keyboard handling
  2564 00000703 08C3                    irq1.30			or	bl,al						;set shift flag
  2565 00000705 EB0D                    			jmp	irq1.60						;skip ahead
  2566 00000707 F6D0                    irq1.40			not	al						;convert flag to mask
  2567 00000709 20C3                    			and	bl,al						;reset shift flag
  2568 0000070B EB07                    			jmp	irq1.60						;skip ahead
  2569 0000070D 30C7                    irq1.50			xor	bh,al						;toggle lock flag
  2570 0000070F E8250D0000              			call	SetKeyboardLamps				;update keyboard lamps
  2571 00000714 881D4A0A0000            irq1.60			mov	[wbConsoleShift],bl				;save shift flags
  2572 0000071A 883D4B0A0000            			mov	[wbConsoleLock],bh				;save lock flags
  2573 00000720 E8E0080000              			call	PutConsoleOIAShift				;update OIA indicators
  2574 00000725 E9F1000000              			jmp	irq1.150					;finish keyboard handling
  2575 0000072A 80FCE1                  irq1.70			cmp	ah,EKEYBCODEEXT1				;extended scan code 1?
  2576 0000072D 756A                    			jne	irq1.80						;no continue
  2577 0000072F E8340D0000              			call	WaitForKeyOutBuffer				;controller timeout?
  2578 00000734 0F84D9000000            			jz	irq1.140					;yes, skip ahead
  2579 0000073A E460                    			in	al,EKEYBPORTDATA				;read scan code 1
  2580 0000073C A24E0A0000              			mov	[wbConsoleScan1],al				;save scan code 1
  2581 00000741 88C4                    			mov	ah,al						;copy scan code 1
  2582 00000743 80FC1D                  			cmp	ah,EKEYBPAUSEDOWN				;pause key down code?
  2583 00000746 0F85CF000000            			jne	irq1.150					;no, finish keyboard handling
  2584 0000074C E8170D0000              			call	WaitForKeyOutBuffer				;controller timeout?
  2585 00000751 0F84BC000000            			jz	irq1.140					;yes, skip ahead
  2586 00000757 E460                    			in	al,EKEYBPORTDATA				;read scan code 2
  2587 00000759 A24F0A0000              			mov	[wbConsoleScan2],al				;save scan code 2
  2588 0000075E E8050D0000              			call	WaitForKeyOutBuffer				;controller timeout?
  2589 00000763 0F84AA000000            			jz	irq1.140					;yes, skip ahead
  2590 00000769 E460                    			in	al,EKEYBPORTDATA				;read scan code 3
  2591 0000076B A2500A0000              			mov	[wbConsoleScan3],al				;save scan code 3
  2592 00000770 E8F30C0000              			call	WaitForKeyOutBuffer				;controller timeout?
  2593 00000775 0F8498000000            			jz	irq1.140					;yes, skip ahead
  2594 0000077B E460                    			in	al,EKEYBPORTDATA				;read scan code 4
  2595 0000077D A2510A0000              			mov	[wbConsoleScan4],al				;save scan code 4
  2596 00000782 E8E10C0000              			call	WaitForKeyOutBuffer				;controller timeout?
  2597 00000787 0F8486000000            			jz	irq1.140					;yes, skip ahead
  2598 0000078D E460                    			in	al,EKEYBPORTDATA				;read scan code 5
  2599 0000078F A2520A0000              			mov	[wbConsoleScan5],al				;save scan code 5
  2600 00000794 E982000000              			jmp	irq1.150					;continue
  2601 00000799 30C0                    irq1.80			xor	al,al						;assume no ASCII translation
  2602 0000079B F6C480                  			test	ah,EKEYBUP					;release code?
  2603 0000079E 7571                    			jnz	irq1.130					;yes, skip ahead
  2604 000007A0 BE[2B080000]            			mov	esi,tscan2ascii					;scan-to-ascii table address
  2605 000007A5 F6C312                  			test	bl,EKEYFSHIFT					;either shift key down?
  2606 000007A8 7405                    			jz	irq1.90						;no, skip ahead
  2607 000007AA BE[AB080000]            			mov	esi,tscan2shift					;scan-to-shifted table address
  2608 000007AF 0FB6CC                  irq1.90			movzx	ecx,ah						;scan code offset
  2609 000007B2 2E8A0431                			mov	al,[cs:ecx+esi]					;al = ASCII code
  2610 000007B6 F6C704                  			test	bh,EKEYFLOCKCAPS				;caps-lock on?
  2611 000007B9 7411                    			jz	irq1.100					;no skip ahead
  2612 000007BB 88C1                    			mov	cl,al						;copy ASCII code
  2613 000007BD 80E1DF                  			and	cl,EASCIICASEMASK				;clear case mask of copy
  2614 000007C0 80F941                  			cmp	cl,EASCIIUPPERA					;less than 'A'?
  2615 000007C3 7207                    			jb	irq1.100					;yes, skip ahead
  2616 000007C5 80F95A                  			cmp	cl,EASCIIUPPERZ					;greater than 'Z'?
  2617 000007C8 7702                    			ja	irq1.100					;yes, skip ahead
  2618 000007CA 3420                    			xor	al,EASCIICASE					;switch case
  2619 000007CC A2530A0000              irq1.100		mov	[wbConsoleChar],al				;save ASCII code
  2620 000007D1 BA00000041              irq1.110		mov	edx,EMSGKEYDOWN					;assume key-down event
  2621 000007D6 F6C480                  			test	ah,EKEYBUP					;release scan-code?
  2622 000007D9 7405                    			jz	irq1.120					;no, skip ahead
  2623 000007DB BA00000141              			mov	edx,EMSGKEYUP					;key-up event
  2624 000007E0 25FFFF0000              irq1.120		and	eax,0FFFFh					;clear high-order word
  2625 000007E5 09C2                    			or	edx,eax						;msg id and codes
  2626 000007E7 31C9                    			xor	ecx,ecx						;null param
  2627 000007E9 50                      			push	eax						;save codes
  2628 000007EA B880000000              			mov	eax,ESELKEYBOARDMQ				;keyboard focus message queue
  2629 000007EF E8AC0A0000              			call	PutMessage					;put message to console
  2630 000007F4 58                      			pop	eax						;restore codes
  2631 000007F5 84C0                    			test	al,al						;ASCII translation?
  2632 000007F7 7418                    			jz	irq1.130					;no, skip ahead
  2633 000007F9 BA00000241              			mov	edx,EMSGKEYCHAR					;key-character event
  2634 000007FE 25FFFF0000              			and	eax,0FFFFh					;clear high-order word
  2635 00000803 09C2                    			or	edx,eax						;msg id and codes
  2636 00000805 31C9                    			xor	ecx,ecx						;null param
  2637 00000807 B880000000              			mov	eax,ESELKEYBOARDMQ				;keyboard focus message queue
  2638 0000080C E88F0A0000              			call	PutMessage					;put message to console
  2639 00000811 EB08                    irq1.130		jmp	irq1.150					;finish keyboard handling
  2640 00000813 B080                    irq1.140		mov	al,EKEYFTIMEOUT					;controller timeout flag
  2641 00000815 08054C0A0000            			or	[wbConsoleStatus],al				;set controller timeout flag
  2642 0000081B E87F080000              irq1.150		call	PutConsoleOIAChar				;update operator info area
  2643 00000820 E88E0B0000              			call	PutPrimaryEndOfInt				;send end-of-interrupt to PIC
  2644 00000825 1F                      			pop	ds						;restore non-volatile regs
  2645 00000826 5E                      			pop	esi						;
  2646 00000827 59                      			pop	ecx						;
  2647 00000828 5B                      			pop	ebx						;
  2648 00000829 58                      			pop	eax						;
  2649 0000082A CF                      			iretd							;return
  2650                                  ;-----------------------------------------------------------------------------------------------------------------------
  2651                                  ;	Scan-Code to ASCII Translation Tables
  2652                                  ;-----------------------------------------------------------------------------------------------------------------------
  2653 0000082B 001B313233343536        tscan2ascii		db	000h,01Bh,031h,032h,033h,034h,035h,036h		;00-07
  2654 00000833 373839302D3D0809        			db	037h,038h,039h,030h,02Dh,03Dh,008h,009h		;08-0F
  2655 0000083B 7177657274797569        			db	071h,077h,065h,072h,074h,079h,075h,069h		;10-17
  2656 00000843 6F705B5D0D006173        			db	06Fh,070h,05Bh,05Dh,00Dh,000h,061h,073h		;18-1F
  2657 0000084B 646667686A6B6C3B        			db	064h,066h,067h,068h,06Ah,06Bh,06Ch,03Bh		;20-27
  2658 00000853 2760005C7A786376        			db	027h,060h,000h,05Ch,07Ah,078h,063h,076h		;28-2F
  2659 0000085B 626E6D2C2E2F002A        			db	062h,06Eh,06Dh,02Ch,02Eh,02Fh,000h,02Ah		;30-37
  2660 00000863 0020000000000000        			db	000h,020h,000h,000h,000h,000h,000h,000h		;38-3F
  2661 0000086B 0000000000000037        			db	000h,000h,000h,000h,000h,000h,000h,037h		;40-47
  2662 00000873 38392D3435362B31        			db	038h,039h,02Dh,034h,035h,036h,02Bh,031h		;48-4F
  2663 0000087B 3233302E00000000        			db	032h,033h,030h,02Eh,000h,000h,000h,000h		;50-57
  2664 00000883 0000000000000000        			db	000h,000h,000h,000h,000h,000h,000h,000h		;58-5F
  2665 0000088B 0000000000000000        			db	000h,000h,000h,000h,000h,000h,000h,000h		;60-67
  2666 00000893 0000000000000000        			db	000h,000h,000h,000h,000h,000h,000h,000h		;68-6F
  2667 0000089B 0000000000000000        			db	000h,000h,000h,000h,000h,000h,000h,000h		;70-77
  2668 000008A3 0000000000000000        			db	000h,000h,000h,000h,000h,000h,000h,000h		;78-7F
  2669 000008AB 001B21402324255E        tscan2shift		db	000h,01Bh,021h,040h,023h,024h,025h,05Eh		;80-87
  2670 000008B3 262A28295F2B0800        			db	026h,02Ah,028h,029h,05Fh,02Bh,008h,000h		;88-8F
  2671 000008BB 5157455254595549        			db	051h,057h,045h,052h,054h,059h,055h,049h		;90-97
  2672 000008C3 4F507B7D0D004153        			db	04Fh,050h,07Bh,07Dh,00Dh,000h,041h,053h		;98-9F
  2673 000008CB 444647484A4B4C3A        			db	044h,046h,047h,048h,04Ah,04Bh,04Ch,03Ah		;A0-A7
  2674 000008D3 227E007C5A584356        			db	022h,07Eh,000h,07Ch,05Ah,058h,043h,056h		;A8-AF
  2675 000008DB 424E4D3C3E3F002A        			db	042h,04Eh,04Dh,03Ch,03Eh,03Fh,000h,02Ah		;B0-B7
  2676 000008E3 0020000000000000        			db	000h,020h,000h,000h,000h,000h,000h,000h		;B8-BF
  2677 000008EB 0000000000000037        			db	000h,000h,000h,000h,000h,000h,000h,037h		;C0-C7
  2678 000008F3 38392D3435362B31        			db	038h,039h,02Dh,034h,035h,036h,02Bh,031h		;C8-CF
  2679 000008FB 3233302E00000000        			db	032h,033h,030h,02Eh,000h,000h,000h,000h		;D0-D7
  2680 00000903 0000000000000000        			db	000h,000h,000h,000h,000h,000h,000h,000h		;D8-DF
  2681 0000090B 0000000000000000        			db	000h,000h,000h,000h,000h,000h,000h,000h		;E0-E7
  2682 00000913 0000000000000000        			db	000h,000h,000h,000h,000h,000h,000h,000h		;E8-EF
  2683 0000091B 0000000000000000        			db	000h,000h,000h,000h,000h,000h,000h,000h		;F0-F7
  2684 00000923 0000000000000000        			db	000h,000h,000h,000h,000h,000h,000h,000h		;F8-FF
  2685                                  ;-----------------------------------------------------------------------------------------------------------------------
  2686                                  ;
  2687                                  ;	IRQ2	Secondary 8259A Cascade Hardware Interrupt
  2688                                  ;
  2689                                  ;-----------------------------------------------------------------------------------------------------------------------
  2690                                  			menter	iochannel					;secondary 8259A cascade
  2690                              <1> ?%1 equ ($-$$)
  2691 0000092B 50                      			push	eax						;save modified regs
  2692 0000092C EB3F                    			jmp	hwint						;end interrupt and return
  2693                                  ;-----------------------------------------------------------------------------------------------------------------------
  2694                                  ;
  2695                                  ;	IRQ3	Communication Port 2 Hardware Interrupt
  2696                                  ;
  2697                                  ;-----------------------------------------------------------------------------------------------------------------------
  2698                                  			menter	com2						;serial port 2 interrupt
  2698                              <1> ?%1 equ ($-$$)
  2699 0000092E 50                      			push	eax						;save modified regs
  2700 0000092F EB3C                    			jmp	hwint						;end interrupt and return
  2701                                  ;-----------------------------------------------------------------------------------------------------------------------
  2702                                  ;
  2703                                  ;	IRQ4	Communication Port 1 Hardware Interrupt
  2704                                  ;
  2705                                  ;-----------------------------------------------------------------------------------------------------------------------
  2706                                  			menter	com1						;serial port 1 interrupt
  2706                              <1> ?%1 equ ($-$$)
  2707 00000931 50                      			push	eax						;save modified regs
  2708 00000932 EB39                    			jmp	hwint						;end interrupt and return
  2709                                  ;-----------------------------------------------------------------------------------------------------------------------
  2710                                  ;
  2711                                  ;	IRQ5	Parallel Port 2 Hardware Interrupt
  2712                                  ;
  2713                                  ;-----------------------------------------------------------------------------------------------------------------------
  2714                                  			menter	lpt2						;parallel port 2 interrupt
  2714                              <1> ?%1 equ ($-$$)
  2715 00000934 50                      			push	eax						;save modified regs
  2716 00000935 EB36                    			jmp	hwint						;end interrupt and return
  2717                                  ;-----------------------------------------------------------------------------------------------------------------------
  2718                                  ;
  2719                                  ;	IRQ6	Diskette Hardware Interrupt
  2720                                  ;
  2721                                  ;-----------------------------------------------------------------------------------------------------------------------
  2722                                  			menter	diskette					;floppy disk interrupt
  2722                              <1> ?%1 equ ($-$$)
  2723 00000937 50                      			push	eax						;save non-volatile regs
  2724 00000938 1E                      			push	ds						;
  2725 00000939 6A18                    			push	ESELDAT						;load OS data selector ...
  2726 0000093B 1F                      			pop	ds						;... into DS register
  2727 0000093C A03E040000              			mov	al,[wbFDCStatus]				;al = FDC calibration status
  2728 00000941 0C80                    			or	al,10000000b					;set IRQ flag
  2729 00000943 A23E040000              			mov	[wbFDCStatus],al				;update FDC calibration status
  2730 00000948 1F                      			pop	ds						;restore non-volatile regs
  2731 00000949 EB22                    			jmp	hwint						;end primary PIC interrupt
  2732                                  ;-----------------------------------------------------------------------------------------------------------------------
  2733                                  ;
  2734                                  ;	IRQ7	Parallel Port 1 Hardware Interrupt
  2735                                  ;
  2736                                  ;-----------------------------------------------------------------------------------------------------------------------
  2737                                  			menter	lpt1						;parallel port 1 interrupt
  2737                              <1> ?%1 equ ($-$$)
  2738 0000094B 50                      			push	eax						;save modified regs
  2739 0000094C EB1F                    			jmp	hwint						;end interrupt and return
  2740                                  ;-----------------------------------------------------------------------------------------------------------------------
  2741                                  ;
  2742                                  ;	IRQ8	Real-time Clock Hardware Interrupt
  2743                                  ;
  2744                                  ;-----------------------------------------------------------------------------------------------------------------------
  2745                                  			menter	rtclock						;real-time clock interrupt
  2745                              <1> ?%1 equ ($-$$)
  2746 0000094E 50                      			push	eax						;save modified regs
  2747 0000094F EB15                    			jmp	hwwint						;end interrupt and return
  2748                                  ;-----------------------------------------------------------------------------------------------------------------------
  2749                                  ;
  2750                                  ;	IRQ9	CGA Vertical Retrace Hardware Interrupt
  2751                                  ;
  2752                                  ;-----------------------------------------------------------------------------------------------------------------------
  2753                                  			menter	retrace						;CGA vertical retrace interrupt
  2753                              <1> ?%1 equ ($-$$)
  2754 00000951 50                      			push	eax						;save modified regs
  2755 00000952 EB12                    			jmp	hwwint						;end interrupt and return
  2756                                  ;-----------------------------------------------------------------------------------------------------------------------
  2757                                  ;
  2758                                  ;	IRQ10	Reserved Hardware Interrupt
  2759                                  ;
  2760                                  ;-----------------------------------------------------------------------------------------------------------------------
  2761                                  			menter	irq10						;reserved
  2761                              <1> ?%1 equ ($-$$)
  2762 00000954 50                      			push	eax						;save modified regs
  2763 00000955 EB0F                    			jmp	hwwint						;end interrupt and return
  2764                                  ;-----------------------------------------------------------------------------------------------------------------------
  2765                                  ;
  2766                                  ;	IRQ11	Reserved Hardware Interrupt
  2767                                  ;
  2768                                  ;-----------------------------------------------------------------------------------------------------------------------
  2769                                  			menter	irq11						;reserved
  2769                              <1> ?%1 equ ($-$$)
  2770 00000957 50                      			push	eax						;save modified regs
  2771 00000958 EB0C                    			jmp	hwwint						;end interrupt and return
  2772                                  ;-----------------------------------------------------------------------------------------------------------------------
  2773                                  ;
  2774                                  ;	IRQ12	PS/2 Mouse Hardware Interrupt
  2775                                  ;
  2776                                  ;-----------------------------------------------------------------------------------------------------------------------
  2777                                  			menter	ps2mouse					;PS/2 mouse interrupt
  2777                              <1> ?%1 equ ($-$$)
  2778 0000095A 50                      			push	eax						;save modified regs
  2779 0000095B EB09                    			jmp	hwwint						;end interrupt and return
  2780                                  ;-----------------------------------------------------------------------------------------------------------------------
  2781                                  ;
  2782                                  ;	IRQ13	Coprocessor Hardware Interrupt
  2783                                  ;
  2784                                  ;-----------------------------------------------------------------------------------------------------------------------
  2785                                  			menter	coprocessor					;coprocessor interrupt
  2785                              <1> ?%1 equ ($-$$)
  2786 0000095D 50                      			push	eax						;save modified regs
  2787 0000095E EB06                    			jmp	hwwint						;end interrupt and return
  2788                                  ;-----------------------------------------------------------------------------------------------------------------------
  2789                                  ;
  2790                                  ;	IRQ14	Fixed Disk Hardware Interrupt
  2791                                  ;
  2792                                  ;-----------------------------------------------------------------------------------------------------------------------
  2793                                  			menter	fixeddisk					;fixed disk interrupt
  2793                              <1> ?%1 equ ($-$$)
  2794 00000960 50                      			push	eax						;save modified regs
  2795 00000961 EB03                    			jmp	hwwint						;end interrupt and return
  2796                                  ;-----------------------------------------------------------------------------------------------------------------------
  2797                                  ;
  2798                                  ;	IRQ15	Reserved Hardware Interrupt
  2799                                  ;
  2800                                  ;-----------------------------------------------------------------------------------------------------------------------
  2801                                  			menter	irq15						;reserved
  2801                              <1> ?%1 equ ($-$$)
  2802 00000963 50                      			push	eax						;save modified regs
  2803 00000964 EB00                    			jmp	hwwint						;end interrupt and return
  2804                                  ;-----------------------------------------------------------------------------------------------------------------------
  2805                                  ;
  2806                                  ;	Exit from hardware interrupt
  2807                                  ;
  2808                                  ;-----------------------------------------------------------------------------------------------------------------------
  2809 00000966 E84E0A0000              hwwint			call	PutSecondaryEndOfInt				;send EOI to secondary PIC
  2810 0000096B EB05                    			jmp	hwint90						;skip ahead
  2811 0000096D E8410A0000              hwint			call	PutPrimaryEndOfInt				;send EOI to primary PIC
  2812 00000972 58                      hwint90			pop	eax						;restore modified regs
  2813 00000973 CF                      			iretd							;return from interrupt
  2814                                  ;-----------------------------------------------------------------------------------------------------------------------
  2815                                  ;
  2816                                  ;	INT 30h Operating System Software Service Interrupt
  2817                                  ;
  2818                                  ;	Interrupt 30h is used by our operating system as an entry point for many commonly-used subroutines reusable by
  2819                                  ;	any task. These routines include low-level i/o functions that shield applications from having to handle
  2820                                  ;	device-specific communications. On entry to this interrupt, AL contains a function number that is used to load
  2821                                  ;	the entry address of the specific function from a table.
  2822                                  ;
  2823                                  ;-----------------------------------------------------------------------------------------------------------------------
  2824                                  			menter	svc
  2824                              <1> ?%1 equ ($-$$)
  2825 00000974 3C1E                    			cmp	al,maxtsvc					;is our function out of range?
  2826 00000976 730D                    			jae	svc90						;yes, skip ahead
  2827 00000978 0FB6C0                  			movzx	eax,al						;function
  2828 0000097B C1E002                  			shl	eax,2						;offset into table
  2829 0000097E 2EFF90[86090000]        			call	dword [cs:tsvc+eax]				;far call to indirect address
  2830 00000985 CF                      svc90			iretd							;return from interrupt
  2831                                  ;-----------------------------------------------------------------------------------------------------------------------
  2832                                  ;
  2833                                  ;	Service Request Table
  2834                                  ;
  2835                                  ;
  2836                                  ;	These tsvce macros expand to define an address vector table for the service request interrupt (int 30h).
  2837                                  ;
  2838                                  ;-----------------------------------------------------------------------------------------------------------------------
  2839                                  tsvc			tsvce	AllocateMemory					;allocate memory block
  2839                              <1> tsvc :
  2839                              <1> e%1 equ ($-tsvc)/4
  2839 00000986 [FE090000]          <1>  dd %1
  2840                                  			tsvce	ByteToDecimalString				;convert byte to decimal string
  2840                              <1> e%1 equ ($-tsvc)/4
  2840 0000098A [E1110000]          <1>  dd %1
  2841                                  			tsvce	ClearConsoleScreen				;clear console screen
  2841                              <1> e%1 equ ($-tsvc)/4
  2841 0000098E [FC120000]          <1>  dd %1
  2842                                  			tsvce	CompareMemory					;compare memory
  2842                              <1> e%1 equ ($-tsvc)/4
  2842 00000992 [960E0000]          <1>  dd %1
  2843                                  			tsvce	CopyMemory					;copy memory
  2843                              <1> e%1 equ ($-tsvc)/4
  2843 00000996 [B30E0000]          <1>  dd %1
  2844                                  			tsvce	DecimalToUnsigned				;convert decimal string to unsigned integer
  2844                              <1> e%1 equ ($-tsvc)/4
  2844 0000099A [4F120000]          <1>  dd %1
  2845                                  			tsvce	FreeMemory					;free memory block
  2845                              <1> e%1 equ ($-tsvc)/4
  2845 0000099E [1C0B0000]          <1>  dd %1
  2846                                  			tsvce	GetConsoleString				;get string input
  2846                              <1> e%1 equ ($-tsvc)/4
  2846 000009A2 [F20E0000]          <1>  dd %1
  2847                                  			tsvce	HexadecimalToUnsigned				;convert hexadecimal string to unsigned integer
  2847                              <1> e%1 equ ($-tsvc)/4
  2847 000009A6 [82120000]          <1>  dd %1
  2848                                  			tsvce	IsLeapYear					;return ecx=1 if leap year
  2848                              <1> e%1 equ ($-tsvc)/4
  2848 000009AA [670C0000]          <1>  dd %1
  2849                                  			tsvce	PlaceCursor					;place the cursor at the current loc
  2849                              <1> e%1 equ ($-tsvc)/4
  2849 000009AE [89130000]          <1>  dd %1
  2850                                  			tsvce	PutConsoleString				;tty output asciiz string
  2850                              <1> e%1 equ ($-tsvc)/4
  2850 000009B2 [C50E0000]          <1>  dd %1
  2851                                  			tsvce	PutDateString					;put MM/DD/YYYY string
  2851                              <1> e%1 equ ($-tsvc)/4
  2851 000009B6 [820C0000]          <1>  dd %1
  2852                                  			tsvce	PutDayString					;put DD string
  2852                              <1> e%1 equ ($-tsvc)/4
  2852 000009BA [C30C0000]          <1>  dd %1
  2853                                  			tsvce	PutHourString					;put hh string
  2853                              <1> e%1 equ ($-tsvc)/4
  2853 000009BE [D10C0000]          <1>  dd %1
  2854                                  			tsvce	PutMinuteString					;put mm string
  2854                              <1> e%1 equ ($-tsvc)/4
  2854 000009C2 [DF0C0000]          <1>  dd %1
  2855                                  			tsvce	PutMonthString					;put MM string
  2855                              <1> e%1 equ ($-tsvc)/4
  2855 000009C6 [ED0C0000]          <1>  dd %1
  2856                                  			tsvce	PutMonthNameString				;put name(MM) string
  2856                              <1> e%1 equ ($-tsvc)/4
  2856 000009CA [FB0C0000]          <1>  dd %1
  2857                                  			tsvce	PutSecondString					;put ss string
  2857                              <1> e%1 equ ($-tsvc)/4
  2857 000009CE [1F0D0000]          <1>  dd %1
  2858                                  			tsvce	PutTimeString					;put HH:MM:SS string
  2858                              <1> e%1 equ ($-tsvc)/4
  2858 000009D2 [2C0D0000]          <1>  dd %1
  2859                                  			tsvce	PutWeekdayString				;put weekday string
  2859                              <1> e%1 equ ($-tsvc)/4
  2859 000009D6 [610D0000]          <1>  dd %1
  2860                                  			tsvce	PutWeekdayNameString				;put name(weekday) string
  2860                              <1> e%1 equ ($-tsvc)/4
  2860 000009DA [6F0D0000]          <1>  dd %1
  2861                                  			tsvce	PutYearString					;put YYYY string
  2861                              <1> e%1 equ ($-tsvc)/4
  2861 000009DE [920D0000]          <1>  dd %1
  2862                                  			tsvce	ReadRealTimeClock				;get real-time clock date and time
  2862                              <1> e%1 equ ($-tsvc)/4
  2862 000009E2 [BF130000]          <1>  dd %1
  2863                                  			tsvce	ResetSystem					;reset system using 8042 chip
  2863                              <1> e%1 equ ($-tsvc)/4
  2863 000009E6 [2A140000]          <1>  dd %1
  2864                                  			tsvce	SetConsoleString				;set console string
  2864                              <1> e%1 equ ($-tsvc)/4
  2864 000009EA [63130000]          <1>  dd %1
  2865                                  			tsvce	UnsignedToDecimalString 			;convert unsigned integer to decimal string
  2865                              <1> e%1 equ ($-tsvc)/4
  2865 000009EE [3D110000]          <1>  dd %1
  2866                                  			tsvce	UnsignedToHexadecimal				;convert unsigned integer to hexadecimal string
  2866                              <1> e%1 equ ($-tsvc)/4
  2866 000009F2 [2F120000]          <1>  dd %1
  2867                                  			tsvce	UpperCaseString					;upper-case string
  2867                              <1> e%1 equ ($-tsvc)/4
  2867 000009F6 [7C0E0000]          <1>  dd %1
  2868                                  			tsvce	Yield						;halt until interrupt
  2868                              <1> e%1 equ ($-tsvc)/4
  2868 000009FA [7F0F0000]          <1>  dd %1
  2869                                  maxtsvc			equ	($-tsvc)/4					;function out of range
  2870                                  ;-----------------------------------------------------------------------------------------------------------------------
  2871                                  ;
  2872                                  ;	Service Request Macros
  2873                                  ;
  2874                                  ;	These macros provide positional parameterization of service request calls.
  2875                                  ;
  2876                                  ;-----------------------------------------------------------------------------------------------------------------------
  2877                                  %macro			allocateMemory 1
  2878                                  			mov	ecx,%1						;bytes to allocate
  2879                                  			mov	al,eAllocateMemory				;allocate memory fn.
  2880                                  			int	_svc						;invoke OS service
  2881                                  %endmacro
  2882                                  %macro			byteToDecimalString 0
  2883                                  			mov	al,eByteToDecimalString				;function code
  2884                                  			int	_svc						;invoke OS service
  2885                                  %endmacro
  2886                                  %macro			clearConsoleScreen 0
  2887                                  			mov	al,eClearConsoleScreen				;function code
  2888                                  			int	_svc						;invoke OS service
  2889                                  %endmacro
  2890                                  %macro			compareMemory 0
  2891                                  			mov	al,eCompareMemory				;function code
  2892                                  			int	_svc						;invoke OS service
  2893                                  %endmacro
  2894                                  %macro			compareMemory 3
  2895                                  			mov	edx,%1						;first memory address
  2896                                  			mov	ebx,%2						;second memory address
  2897                                  			mov	ecx,%3						;length
  2898                                  			mov	al,eCompareMemory				;function code
  2899                                  			int	_svc						;invoke OS service
  2900                                  %endmacro
  2901                                  %macro			copyMemory 3
  2902                                  			mov	edx,%1						;first memory address
  2903                                  			mov	ebx,%2						;second memory address
  2904                                  			mov	ecx,%3						;length
  2905                                  			mov	al,eCopyMemory					;function code
  2906                                  			int	_svc						;invoke OS service
  2907                                  %endmacro
  2908                                  %macro			decimalToUnsigned 0
  2909                                  			mov	al,eDecimalToUnsigned				;function code
  2910                                  			int	_svc						;invoke OS servie
  2911                                  %endmacro
  2912                                  %macro			freeMemory 1
  2913                                  			mov	edx,%1						;address of memory block
  2914                                  			mov	al,eFreeMemory					;function code
  2915                                  			int	_svc						;invoke OS service
  2916                                  %endmacro
  2917                                  %macro			getConsoleString 4
  2918                                  			mov	edx,%1						;buffer address
  2919                                  			mov	ecx,%2						;max characters
  2920                                  			mov	bh,%3						;echo indicator
  2921                                  			mov	bl,%4						;terminator
  2922                                  			mov	al,eGetConsoleString				;function code
  2923                                  			int	_svc						;invoke OS service
  2924                                  %endmacro
  2925                                  %macro			hexadecimalToUnsigned 0
  2926                                  			mov	al,eHexadecimalToUnsigned			;function code
  2927                                  			int	_svc						;invoke OS service
  2928                                  %endmacro
  2929                                  %macro			isLeapYear 1
  2930                                  			mov	ebx,%1						;DATETIME addr
  2931                                  			mov	al,eIsLeapYear					;function code
  2932                                  			int	_svc						;invoke OS service
  2933                                  %endmacro
  2934                                  %macro			placeCursor 0
  2935                                  			mov	al,ePlaceCursor					;function code
  2936                                  			int	_svc						;invoke OS service
  2937                                  %endmacro
  2938                                  %macro			putConsoleString 1
  2939                                  			mov	edx,%1						;string address
  2940                                  			mov	al,ePutConsoleString				;function code
  2941                                  			int	_svc						;invoke OS service
  2942                                  %endmacro
  2943                                  %macro			putDateString 0
  2944                                  			mov	al,ePutDateString				;function code
  2945                                  			int	_svc						;invoke OS service
  2946                                  %endmacro
  2947                                  %macro			putDateString 2
  2948                                  			mov	ebx,%1						;DATETIME addr
  2949                                  			mov	edx,%2						;output buffer addr
  2950                                  			mov	al,ePutDateString				;function code
  2951                                  			int	_svc						;invoke OS service
  2952                                  %endmacro
  2953                                  %macro			putDayString 2
  2954                                  			mov	ebx,%1						;DATETIME addr
  2955                                  			mov	edx,%2						;output buffer addr
  2956                                  			mov	al,ePutDayString				;function code
  2957                                  			int	_svc						;invoke OS service
  2958                                  %endmacro
  2959                                  %macro			putHourString 2
  2960                                  			mov	ebx,%1						;DATETIME addr
  2961                                  			mov	edx,%2						;output buffer addr
  2962                                  			mov	al,ePutHourString				;function code
  2963                                  			int	_svc						;invoke OS service
  2964                                  %endmacro
  2965                                  %macro			putMinuteString 2
  2966                                  			mov	ebx,%1						;DATETIME addr
  2967                                  			mov	edx,%2						;output buffer addr
  2968                                  			mov	al,ePutMinuteString				;function code
  2969                                  			int	_svc						;invoke OS service
  2970                                  %endmacro
  2971                                  %macro			putMonthString 2
  2972                                  			mov	ebx,%1						;DATETIME addr
  2973                                  			mov	edx,%2						;output buffer addr
  2974                                  			mov	al,ePutMonthString				;function code
  2975                                  			int	_svc						;invoke OS service
  2976                                  %endmacro
  2977                                  %macro			putMonthNameString 2
  2978                                  			mov	ebx,%1						;DATETIME addr
  2979                                  			mov	edx,%2						;output buffer addr
  2980                                  			mov	al,ePutMonthNameString				;function code
  2981                                  			int	_svc						;invoke OS service
  2982                                  %endmacro
  2983                                  %macro			putSecondString 2
  2984                                  			mov	ebx,%1						;DATETIME addr
  2985                                  			mov	edx,%2						;output buffer addr
  2986                                  			mov	al,ePutSecondString				;function code
  2987                                  			int	_svc						;invoke OS service
  2988                                  %endmacro
  2989                                  %macro			putTimeString 0
  2990                                  			mov	al,ePutTimeString				;function code
  2991                                  			int	_svc						;invoke OS service
  2992                                  %endmacro
  2993                                  %macro			putTimeString 2
  2994                                  			mov	ebx,%1						;DATETIME addr
  2995                                  			mov	edx,%2						;output buffer addr
  2996                                  			mov	al,ePutTimeString				;function code
  2997                                  			int	_svc						;invoke OS service
  2998                                  %endmacro
  2999                                  %macro			putWeekdayString 2
  3000                                  			mov	ebx,%1						;DATETIME addr
  3001                                  			mov	edx,%2						;output buffer addr
  3002                                  			mov	al,ePutWeekdayString				;function code
  3003                                  			int	_svc						;invoke OS service
  3004                                  %endmacro
  3005                                  %macro			putWeekdayNameString 2
  3006                                  			mov	ebx,%1						;DATETIME addr
  3007                                  			mov	edx,%2						;output buffer addr
  3008                                  			mov	al,ePutWeekdayNameString			;function code
  3009                                  			int	_svc						;invoke OS service
  3010                                  %endmacro
  3011                                  %macro			putYearString 2
  3012                                  			mov	ebx,%1						;DATETIME addr
  3013                                  			mov	edx,%2						;output buffer addr
  3014                                  			mov	al,ePutYearString				;function code
  3015                                  			int	_svc						;invoke OS service
  3016                                  %endmacro
  3017                                  %macro			readRealTimeClock 0
  3018                                  			mov	al,eReadRealTimeClock				;function code
  3019                                  			int	_svc						;invoke OS service
  3020                                  %endmacro
  3021                                  %macro			readRealTimeClock 1
  3022                                  			mov	ebx,%1						;DATETIME addr
  3023                                  			mov	al,eReadRealTimeClock				;function code
  3024                                  			int	_svc						;invoke OS service
  3025                                  %endmacro
  3026                                  %macro			resetSystem 0
  3027                                  			mov	al,eResetSystem					;function code
  3028                                  			int	_svc						;invoke OS service
  3029                                  %endmacro
  3030                                  %macro			setConsoleString 0
  3031                                  			mov	al,eSetConsoleString				;function code
  3032                                  			int	_svc						;invoke OS service
  3033                                  %endmacro
  3034                                  %macro			unsignedToDecimalString 0
  3035                                  			mov	al,eUnsignedToDecimalString			;function code
  3036                                  			int	_svc						;invoke OS service
  3037                                  %endmacro
  3038                                  %macro			unsignedToHexadecimal 0
  3039                                  			mov	al,eUnsignedToHexadecimal			;function code
  3040                                  			int	_svc						;invoke OS service
  3041                                  %endmacro
  3042                                  %macro			upperCaseString 0
  3043                                  			mov	al,eUpperCaseString				;function code
  3044                                  			int	_svc						;invoke OS service
  3045                                  %endmacro
  3046                                  %macro			yield 0
  3047                                  			mov	al,eYield					;function code
  3048                                  			int	_svc						;invoke OS service
  3049                                  %endmacro
  3050                                  ;=======================================================================================================================
  3051                                  ;
  3052                                  ;	Kernel Function Library
  3053                                  ;
  3054                                  ;=======================================================================================================================
  3055                                  ;=======================================================================================================================
  3056                                  ;
  3057                                  ;	Memory Helper Routines
  3058                                  ;
  3059                                  ;	AllocateMemory
  3060                                  ;	FreeMemory
  3061                                  ;
  3062                                  ;=======================================================================================================================
  3063                                  ;-----------------------------------------------------------------------------------------------------------------------
  3064                                  ;
  3065                                  ;	Routine:	AllocateMemory
  3066                                  ;
  3067                                  ;	Description:	This routine allocates a memory block for the given task.
  3068                                  ;
  3069                                  ;	In:		ECX	bytes of memory to allocate
  3070                                  ;
  3071                                  ;	Out:		EAX	!0	address of user portion of newly allocated memory block
  3072                                  ;				0	unable to allocate memory
  3073                                  ;
  3074                                  ;-----------------------------------------------------------------------------------------------------------------------
  3075 000009FE 53                      AllocateMemory		push	ebx						;save non-volatile regs
  3076 000009FF 51                      			push	ecx						;
  3077 00000A00 56                      			push	esi						;
  3078 00000A01 1E                      			push	ds						;
  3079                                  ;
  3080                                  ;	Address kernel memory structures
  3081                                  ;
  3082 00000A02 6A18                    			push	ESELDAT						;load OS data GDT selector ...
  3083 00000A04 1F                      			pop	ds						;... into data segment reg
  3084 00000A05 BE0C0A0000              			mov	esi,wsMemRoot					;memory root structure address
  3085                                  ;
  3086                                  ;	Set requested size to minimum block size if requested size is too small.
  3087                                  ;
  3088 00000A0A 81F900010000            			cmp	ecx,EMEMMINSIZE					;is requested size too small?
  3089 00000A10 7305                    			jae	.10						;no, branch
  3090 00000A12 B900010000              			mov	ecx,EMEMMINSIZE					;set requested size to minimum
  3091 00000A17 83C120                  .10			add	ecx,EMEMBLOCKLEN				;add header block length
  3092                                  ;
  3093                                  ;	Find the first free memory block large enough to satisfy the request.
  3094                                  ;
  3095 00000A1A 8B4608                  			mov	eax,[esi+MEMROOT.firstfree]			;first free block ptr
  3096 00000A1D 85C0                    .20			test	eax,eax						;end of free block chain?
  3097 00000A1F 0F84F2000000            			jz	.220						;yes, branch
  3098 00000A25 3B4804                  			cmp	ecx,[eax+MEMBLOCK.bytes]			;free block big enough?
  3099 00000A28 7605                    			jbe	.30						;yes, branch
  3100 00000A2A 8B4018                  			mov	eax,[eax+MEMBLOCK.nextblock]			;next free block addr
  3101 00000A2D EBEE                    			jmp	.20						;continue
  3102                                  ;-----------------------------------------------------------------------------------------------------------------------
  3103                                  ;
  3104                                  ;	Address the previous and next free memory blocks.
  3105                                  ;
  3106 00000A2F 8B581C                  .30			mov	ebx,[eax+MEMBLOCK.previousblock]		;previous free block addr
  3107 00000A32 8B5018                  			mov	edx,[eax+MEMBLOCK.nextblock]			;next free block addr
  3108                                  ;
  3109                                  ;	Remove the free memory block from the forward free memory block chain.
  3110                                  ;
  3111 00000A35 85DB                    			test	ebx,ebx						;any previous free memory block?
  3112 00000A37 7405                    			jz	.40						;no, branch
  3113 00000A39 895318                  			mov	[ebx+MEMBLOCK.nextblock],edx			;remove free block from forwrad chain
  3114 00000A3C EB03                    			jmp	.50						;continue
  3115 00000A3E 895608                  .40			mov	[esi+MEMROOT.firstfree],edx			;next free is now also the first free
  3116                                  ;
  3117                                  ;	Remove the free memory block from the reverse free memory block chain.
  3118                                  ;
  3119 00000A41 85D2                    .50			test	edx,edx						;any next free memory block?
  3120 00000A43 7405                    			jz	.60						;no, branch
  3121 00000A45 895A1C                  			mov	[edx+MEMBLOCK.previousblock],ebx		;remove free block from reverse chain
  3122 00000A48 EB03                    			jmp	.70						;continue
  3123 00000A4A 895E0C                  .60			mov	[esi+MEMROOT.lastfree],ebx			;previous free is now also the last free
  3124                                  ;-----------------------------------------------------------------------------------------------------------------------
  3125                                  ;
  3126                                  ;	Determine if the free memory block can be split.
  3127                                  ;
  3128 00000A4D 8B5804                  .70			mov	ebx,[eax+MEMBLOCK.bytes]			;size of free memory block
  3129 00000A50 29CB                    			sub	ebx,ecx						;subtract requested memory size
  3130 00000A52 81FB00010000            			cmp	ebx,EMEMMINSIZE					;remaining block can stand alone?
  3131 00000A58 7263                    			jb	.150						;no, branch
  3132                                  ;
  3133                                  ;	We know that our block can be split to create a new free memory block. We update the size of our free memory
  3134                                  ;	block to the requested memory size. We update the next contiguous block pointer to point just past the end
  3135                                  ;	of the requested memory size.
  3136                                  ;
  3137 00000A5A 894804                  			mov	[eax+MEMBLOCK.bytes],ecx			;shorten memory block size
  3138 00000A5D 89C2                    			mov	edx,eax						;memory block address
  3139 00000A5F 01CA                    			add	edx,ecx						;address new new next contig block
  3140 00000A61 8B4810                  			mov	ecx,[eax+MEMBLOCK.nextcontig]			;next contig block address
  3141 00000A64 895010                  			mov	[eax+MEMBLOCK.nextcontig],edx			;update next contig block address
  3142                                  ;
  3143                                  ;	If there is a next contiguous block, we update that memory block's previous contig pointer to point to the new
  3144                                  ;	free block we are splitting off. If there is no next contiguous block, we update the last contig block pointer.
  3145                                  ;
  3146 00000A67 E305                    			jecxz	.80						;no next contig, branch
  3147 00000A69 895114                  			mov	[ecx+MEMBLOCK.previouscontig],edx		;update previous contig pointer
  3148 00000A6C EB03                    			jmp	.90						;continue
  3149 00000A6E 895604                  .80			mov	[esi+MEMROOT.lastcontig],edx			;update last contig pointer
  3150                                  ;
  3151                                  ;	Now that the contig block pointers have been updated, we initialize the new free block members.
  3152                                  ;
  3153 00000A71 895A04                  .90			mov	[edx+MEMBLOCK.bytes],ebx			;set the block size
  3154 00000A74 894A10                  			mov	[edx+MEMBLOCK.nextcontig],ecx			;set the next contig block addr
  3155 00000A77 894214                  			mov	[edx+MEMBLOCK.previouscontig],eax		;set the previous contig block addr
  3156 00000A7A BB46524545              			mov	ebx,EMEMFREECODE				;free memory signature
  3157 00000A7F 891A                    			mov	[edx+MEMBLOCK.signature],ebx			;set the block signature
  3158 00000A81 31DB                    			xor	ebx,ebx						;zero register
  3159 00000A83 895A0C                  			mov	[edx+MEMBLOCK.reserved],ebx			;set reserved
  3160 00000A86 895A08                  			mov	[edx+MEMBLOCK.owner],ebx			;set the owner
  3161                                  ;
  3162                                  ;	Find the proper location in the free block chain for the new free block
  3163                                  ;
  3164 00000A89 8B5A04                  			mov	ebx,[edx+MEMBLOCK.bytes]			;free block size
  3165 00000A8C 8B4E08                  			mov	ecx,[esi+MEMROOT.firstfree]			;first free block addr
  3166 00000A8F E30A                    .100			jecxz	.110						;branch if at end of chain
  3167 00000A91 3B5904                  			cmp	ebx,[ecx+MEMBLOCK.bytes]			;new block smaller or equal?
  3168 00000A94 7605                    			jbe	.110						;yes, branch
  3169 00000A96 8B4918                  			mov	ecx,[ecx+MEMBLOCK.nextblock]			;next free block addr
  3170 00000A99 EBF4                    			jmp	.100						;continue
  3171                                  ;
  3172                                  ;	Having found the proper location for our new free block, we store the address of the following free block, or
  3173                                  ;	zero if our new free block is larger than any other, as our next free block. Then, we take the address of our
  3174                                  ;	next block's previous block or the global last-free block as our new previous block and update the previous
  3175                                  ;	block of hte next block, if there is one.
  3176                                  ;
  3177 00000A9B 894A18                  .110			mov	[edx+MEMBLOCK.nextblock],ecx			;set the new free block's next ptr
  3178 00000A9E 8B5E0C                  			mov	ebx,[esi+MEMROOT.lastfree]			;last free block addr
  3179 00000AA1 E308                    			jecxz	.120						;branch if no next block
  3180 00000AA3 8B591C                  			mov	ebx,[ecx+MEMBLOCK.previousblock]		;next block's previous block
  3181 00000AA6 89511C                  			mov	[ecx+MEMBLOCK.previousblock],edx		;set the next block's previous block
  3182 00000AA9 EB03                    			jmp	.130						;continue
  3183 00000AAB 89560C                  .120			mov	[esi+MEMROOT.lastfree],edx			;set the new last free block
  3184                                  ;
  3185                                  ;	Store our previous block pointer. If we have a previous free block, update that block's next block pointer to
  3186                                  ;	point to the new block. Since the new block may now be the first or last user block, we update the first and/or
  3187                                  ;	last user block pointers if necessary.
  3188                                  ;
  3189 00000AAE 895A1C                  .130			mov	[edx+MEMBLOCK.previousblock],ebx		;set the previous block pointer
  3190 00000AB1 85DB                    			test	ebx,ebx						;is there a previous block?
  3191 00000AB3 7405                    			jz	.140						;no, branch
  3192 00000AB5 895318                  			mov	[ebx+MEMBLOCK.nextblock],edx			;set the previous block's next ptr
  3193 00000AB8 EB03                    			jmp	.150						;continue
  3194 00000ABA 895608                  .140			mov	[esi+MEMROOT.firstfree],edx			;set the new first free ptr
  3195                                  ;
  3196                                  ;	Update the newly allocated block's owner and signature.
  3197                                  ;
  3198 00000ABD BA55534552              .150			mov	edx,EMEMUSERCODE				;user memory signature
  3199 00000AC2 8910                    			mov	[eax+MEMBLOCK.signature],edx			;set the block signature
  3200 00000AC4 31D2                    			xor	edx,edx						;zero register
  3201 00000AC6 660F00CA                			str	dx						;load the task state register
  3202 00000ACA 895008                  			mov	[eax+MEMBLOCK.owner],edx			;set the block owner
  3203                                  ;
  3204                                  ;	Remove the allocated block from the free block chain and insert it into the user block chain.
  3205                                  ;
  3206 00000ACD 8B4E10                  			mov	ecx,[esi+MEMROOT.firsttask]			;first task block
  3207 00000AD0 E323                    .160			jecxz	.180						;branch if at end of chain
  3208 00000AD2 3B5108                  			cmp	edx,[ecx+MEMBLOCK.owner]			;does this block belong to the task?
  3209 00000AD5 721E                    			jb	.180						;branch if block belongs to next task
  3210 00000AD7 7405                    			je	.170						;branch if block belongs to this task
  3211 00000AD9 8B4918                  			mov	ecx,[ecx+MEMBLOCK.nextblock]			;next task block
  3212 00000ADC EBF2                    			jmp	.160						;continue
  3213                                  ;
  3214                                  ;	We have found the start of our task's user block chain or the start of the next task's user block chain. If we
  3215                                  ;	have found the next task's chain, then we have no other user memory for this task and we can simply add the
  3216                                  ;	block here. If we are at the start of our task's user block chain, then we need to further seek for the proper
  3217                                  ;	place to insert the block.
  3218                                  ;
  3219 00000ADE 8B5004                  .170			mov	edx,[eax+MEMBLOCK.bytes]			;size of block in bytes
  3220 00000AE1 3B5104                  			cmp	edx,[ecx+MEMBLOCK.bytes]			;less or equal to chain block?
  3221 00000AE4 760F                    			jbe	.180						;yes, branch
  3222 00000AE6 8B4918                  			mov	ecx,[ecx+MEMBLOCK.nextblock]			;next chain block address
  3223 00000AE9 85C9                    			test	ecx,ecx						;end of chain?
  3224 00000AEB 7408                    			jz	.180						;yes, branch
  3225 00000AED 8B5008                  			mov	edx,[eax+MEMBLOCK.owner]			;owning task
  3226 00000AF0 3B5108                  			cmp	edx,[ecx+MEMBLOCK.owner]			;same task?
  3227 00000AF3 74E9                    			je	.170						;yes, continue search
  3228                                  ;
  3229                                  ;	We have found the proper place in our task's user-block chain to insert our new user block. It may also be the
  3230                                  ;	end of the user-block chain. To insert our new user block, first we update the next-block pointer. Then, we load
  3231                                  ;	the next-block's previous-block pointer or the global last-user block pointer if we have no next-block. If we
  3232                                  ;	do have a previous-block, we update that block's next-block pointer.
  3233                                  ;
  3234 00000AF5 894818                  .180			mov	[eax+MEMBLOCK.nextblock],ecx			;set the next task block
  3235 00000AF8 8B5E14                  			mov	ebx,[esi+MEMROOT.lasttask]			;last task block
  3236 00000AFB E308                    			jecxz	.190						;branch if no next-task block
  3237 00000AFD 8B591C                  			mov	ebx,[ecx+MEMBLOCK.previousblock]		;next-task's previous-task block
  3238 00000B00 89411C                  			mov	[ecx+MEMBLOCK.previousblock],eax		;update next-task block's previous-task
  3239 00000B03 EB03                    			jmp	.200						;continue
  3240 00000B05 894614                  .190			mov	[esi+MEMROOT.lasttask],eax			;new block is the last user-block
  3241                                  ;
  3242                                  ;	Now wes tore our previous-block pointer and, if we have a previous-free block, we update that block's next-
  3243                                  ;	block pointer to point to our block. Since our block may now be the first or last user-block, we update the
  3244                                  ;	global first and/or last user-block pointers if necessary.
  3245                                  ;
  3246 00000B08 89581C                  .200			mov	[eax+MEMBLOCK.previousblock],ebx		;set the previous task block
  3247 00000B0B 85DB                    			test	ebx,ebx						;do we have a previous task block?
  3248 00000B0D 7405                    			jz	.210						;no, branch
  3249 00000B0F 894318                  			mov	[ebx+MEMBLOCK.nextblock],eax			;set previous-block's next-task block
  3250 00000B12 EB03                    			jmp	.220						;continue
  3251 00000B14 894610                  .210			mov	[esi+MEMROOT.firsttask],eax			;new block is the first user-block
  3252                                  ;
  3253                                  ;	Restore registers and return to caller.
  3254                                  ;
  3255 00000B17 1F                      .220			pop	ds						;restore non-volatie regs
  3256 00000B18 5E                      			pop	esi						;
  3257 00000B19 59                      			pop	ecx						;
  3258 00000B1A 5B                      			pop	ebx						;
  3259 00000B1B C3                      			ret							;return
  3260                                  ;-----------------------------------------------------------------------------------------------------------------------
  3261                                  ;
  3262                                  ;	Routine:	FreeMemory
  3263                                  ;
  3264                                  ;	Description:	This routine frees a memory block for the given task. The address provided in EDX points to the
  3265                                  ;			memory block header. The memory block must be USER memory, not a FREE memory block. If the block
  3266                                  ;			is adjacent to a contiguous FREE memory block, then the blocks are merged. The residual FREE
  3267                                  ;			memory is repositioned in the FREE memory block chain according to size. The user portion of the
  3268                                  ;			block, following the block header, is reset (wiped) with the memory wipe value.
  3269                                  ;
  3270                                  ;	In:		EDX	memory block to free, relative to ESELDAT
  3271                                  ;
  3272                                  ;	Out:		EAX	-1	invalid memory block
  3273                                  ;				0	memory block freed
  3274                                  ;
  3275                                  ;-----------------------------------------------------------------------------------------------------------------------
  3276 00000B1C 53                      FreeMemory		push	ebx						;save non-volatile regs
  3277 00000B1D 51                      			push	ecx						;
  3278 00000B1E 56                      			push	esi						;
  3279 00000B1F 57                      			push	edi						;
  3280 00000B20 1E                      			push	ds						;
  3281 00000B21 06                      			push	es						;
  3282                                  ;
  3283                                  ;	Address the root memory structure
  3284                                  ;
  3285 00000B22 6A18                    			push	ESELDAT						;load OS data selector ...
  3286 00000B24 07                      			pop	es						;... into extra segment reg
  3287 00000B25 6A18                    			push	ESELDAT						;load OS data selector ...
  3288 00000B27 1F                      			pop	ds						;... into data segment reg
  3289 00000B28 BE0C0A0000              			mov	esi,wsMemRoot					;memory root structure
  3290 00000B2D 89D7                    			mov	edi,edx						;memory block address
  3291                                  ;
  3292                                  ;	If the block is FREE, return success. Otherwise, if it is not USER, return with error.
  3293                                  ;
  3294 00000B2F 31C0                    			xor	eax,eax						;indicate success
  3295 00000B31 813F46524545            			cmp	dword [edi+MEMBLOCK.signature],EMEMFREECODE	;is the block FREE?
  3296 00000B37 0F8415010000            			je	.240						;yes, branch
  3297 00000B3D 48                      			dec	eax						;indicate failure
  3298 00000B3E 813F55534552            			cmp	dword [edi+MEMBLOCK.signature],EMEMUSERCODE	;is the block USER?
  3299 00000B44 0F8508010000            			jne	.240						;no, branch
  3300                                  ;-----------------------------------------------------------------------------------------------------------------------
  3301                                  ;
  3302                                  ;	Unlink the USER memory block.
  3303                                  ;
  3304                                  ;-----------------------------------------------------------------------------------------------------------------------
  3305                                  ;
  3306                                  ;	Set the block signature. Reset owner.
  3307                                  ;
  3308 00000B4A C70746524545            			mov	dword [edi+MEMBLOCK.signature],EMEMFREECODE	;set FREE block signature
  3309 00000B50 31C0                    			xor	eax,eax						;zero register
  3310 00000B52 894708                  			mov	[edi+MEMBLOCK.owner],eax			;zero block owner
  3311                                  ;
  3312                                  ;	Wipe user area.
  3313                                  ;
  3314 00000B55 57                      			push	edi						;save block address
  3315 00000B56 8B4F04                  			mov	ecx,[edi+MEMBLOCK.bytes]			;block size
  3316 00000B59 83E920                  			sub	ecx,EMEMBLOCKLEN				;subtract header size
  3317 00000B5C 83C720                  			add	edi,EMEMBLOCKLEN				;point to user area
  3318 00000B5F B000                    			mov	al,EMEMWIPEBYTE					;memory wipe byte
  3319 00000B61 F3AA                    			rep	stosb						;clear memory
  3320 00000B63 5F                      			pop	edi						;restore block address
  3321                                  ;
  3322                                  ;	Address the preceding and following USER memory blocks
  3323                                  ;
  3324 00000B64 8B5F1C                  			mov	ebx,[edi+MEMBLOCK.previousblock]		;previous block pointer
  3325 00000B67 8B4F18                  			mov	ecx,[edi+MEMBLOCK.nextblock]			;next block pointer
  3326                                  ;
  3327                                  ;	If a USER block precedes this block, update that block's next pointer. Otherwise, update the first task
  3328                                  ;	pointer to point to the USER block following this block.
  3329                                  ;
  3330 00000B6A 85DB                    			test	ebx,ebx						;is there a previous block?
  3331 00000B6C 7405                    			jz	.10						;no, branch
  3332 00000B6E 894B18                  			mov	[ebx+MEMBLOCK.nextblock],ecx			;update previous block's next pointer
  3333 00000B71 EB03                    			jmp	.20						;continue
  3334 00000B73 894E10                  .10			mov	[esi+MEMROOT.firsttask],ecx			;update first USER pointer
  3335                                  ;
  3336                                  ;	If a USER block follows this block, update that block's previous pointer. Otherwise, update the last task
  3337                                  ;	pointer to point to the USER block preceding this block.
  3338                                  ;
  3339 00000B76 E305                    .20			jecxz	.30						;branch if no next block
  3340 00000B78 89591C                  			mov	[ecx+MEMBLOCK.previousblock],ebx		;update next block's previous pointer
  3341 00000B7B EB03                    			jmp	.40						;continue
  3342 00000B7D 895E14                  .30			mov	[esi+MEMROOT.lasttask],ebx			;update last USER pointer
  3343                                  ;-----------------------------------------------------------------------------------------------------------------------
  3344                                  ;
  3345                                  ;	Merge with a previous contiguous FREE memory block.
  3346                                  ;
  3347                                  ;-----------------------------------------------------------------------------------------------------------------------
  3348                                  ;
  3349                                  ;	Address the preceding and following contiguous memory blocks.
  3350                                  ;
  3351 00000B80 8B5F14                  .40			mov	ebx,[edi+MEMBLOCK.previouscontig]		;previous contiguous block ptr
  3352 00000B83 8B4F10                  			mov	ecx,[edi+MEMBLOCK.nextcontig]			;next contiguous block ptr
  3353                                  ;
  3354                                  ;	Verify we have a previous contiguous FREE block.
  3355                                  ;
  3356 00000B86 85DB                    			test	ebx,ebx						;is there a previous block?
  3357 00000B88 7442                    			jz	.100						;no, branch
  3358 00000B8A 813B46524545            			cmp	dword [ebx+MEMBLOCK.signature],EMEMFREECODE	;is the previous block FREE?
  3359 00000B90 753A                    			jne	.100						;no, branch
  3360                                  ;
  3361                                  ;	Update adjacent block's contiguous pointers.
  3362                                  ;
  3363 00000B92 894B10                  			mov	[ebx+MEMBLOCK.nextcontig],ecx			;update previous contig's next contig
  3364 00000B95 E305                    			jecxz	.50						;branch if no next contiguous block
  3365 00000B97 895914                  			mov	[ecx+MEMBLOCK.previouscontig],ebx		;update next congit's previous contig
  3366 00000B9A EB03                    			jmp	.60						;continue
  3367 00000B9C 895E04                  .50			mov	[esi+MEMROOT.lastcontig],ebx			;update last contig pointer
  3368                                  ;
  3369                                  ;	Update the size of the merged FREE block.
  3370                                  ;
  3371 00000B9F 8B4704                  .60			mov	eax,[edi+MEMBLOCK.bytes]			;current block size
  3372 00000BA2 014304                  			add	[ebx+MEMBLOCK.bytes],eax			;update previous block's size
  3373                                  ;
  3374                                  ;	Having merged our new free block into the previous free block, make the previous free block the current block
  3375                                  ;
  3376 00000BA5 B920000000              			mov	ecx,EMEMBLOCKLEN				;block header length
  3377 00000BAA B000                    			mov	al,EMEMWIPEBYTE					;memory wipe byte
  3378 00000BAC F3AA                    			rep	stosb						;clear memory header
  3379 00000BAE 89DF                    			mov	edi,ebx						;current block is now previous block
  3380                                  ;-----------------------------------------------------------------------------------------------------------------------
  3381                                  ;
  3382                                  ;	Unlink the previous contiguous FREE memory block
  3383                                  ;
  3384                                  ;-----------------------------------------------------------------------------------------------------------------------
  3385                                  ;
  3386                                  ;	Address the preceding and following USER memory blocks
  3387                                  ;
  3388 00000BB0 8B5F1C                  			mov	ebx,[edi+MEMBLOCK.previousblock]		;previous block pointer
  3389 00000BB3 8B4F18                  			mov	ecx,[edi+MEMBLOCK.nextblock]			;next block pointer
  3390                                  ;
  3391                                  ;	Update the previous block's next-block pointer if there is a previous block. Otherwise, update the first free
  3392                                  ;	block pointer.
  3393                                  ;
  3394 00000BB6 85DB                    			test	ebx,ebx						;is there a previous block?
  3395 00000BB8 7405                    			jz	.70						;no, branch
  3396 00000BBA 894B18                  			mov	[ebx+MEMBLOCK.nextblock],ecx			;update previous block's next pointer
  3397 00000BBD EB03                    			jmp	.80						;branch
  3398 00000BBF 894E08                  .70			mov	[esi+MEMROOT.firstfree],ecx			;update first FREE block pointer
  3399                                  ;
  3400                                  ;	Update the next block's previous-block pointer if there is a next block. Otherwise, update the last free block
  3401                                  ;	pointer.
  3402                                  ;
  3403 00000BC2 E305                    .80			jecxz	.90						;branch if no next block
  3404 00000BC4 89591C                  			mov	[ecx+MEMBLOCK.previousblock],ebx		;update next block's previous pointer
  3405 00000BC7 EB03                    			jmp	.100						;continue
  3406 00000BC9 895E0C                  .90			mov	[esi+MEMROOT.lastfree],ebx			;update last FREE block pointer
  3407                                  ;-----------------------------------------------------------------------------------------------------------------------
  3408                                  ;
  3409                                  ;	Merge with a following contiguous FREE memory block.
  3410                                  ;
  3411                                  ;-----------------------------------------------------------------------------------------------------------------------
  3412                                  ;
  3413                                  ;	Verify we have a following contiguous FREE block.
  3414                                  ;
  3415 00000BCC 8B4F10                  .100			mov	ecx,[edi+MEMBLOCK.nextcontig]			;next contiguous block ptr
  3416 00000BCF E34B                    			jecxz	.170						;branch if no next contiguous block
  3417 00000BD1 813946524545            			cmp	dword [ecx+MEMBLOCK.signature],EMEMFREECODE	;is the next-contiguous block free?
  3418 00000BD7 7543                    			jne	.170						;no, branch
  3419                                  ;
  3420                                  ;	Add the size of the following adjacent FREE block to this block's size.
  3421                                  ;
  3422 00000BD9 8B4104                  			mov	eax,[ecx+MEMBLOCK.bytes]			;next contiguous (free) block size
  3423 00000BDC 014704                  			add	[edi+MEMBLOCK.bytes],eax			;add size to this block's size
  3424                                  ;
  3425                                  ;	Unlink the following contiguous FREE block from the contiguous block chain.
  3426                                  ;
  3427 00000BDF 8B4110                  			mov	eax,[ecx+MEMBLOCK.nextcontig]			;following block's next-contig ptr
  3428 00000BE2 894710                  			mov	[edi+MEMBLOCK.nextcontig],eax			;update this block's next-contig ptr
  3429 00000BE5 85C0                    			test	eax,eax						;does a block follow the next contig blk
  3430 00000BE7 7405                    			jz	.110						;no, branch
  3431 00000BE9 897814                  			mov	[eax+MEMBLOCK.previouscontig],edi		;update following block's prev contig
  3432 00000BEC EB03                    			jmp	.120						;continue
  3433 00000BEE 897E04                  .110			mov	[esi+MEMROOT.lastcontig],edi			;update last contig block ptr
  3434                                  ;-----------------------------------------------------------------------------------------------------------------------
  3435                                  ;
  3436                                  ;	Unlink the following contiguous FREE memory block
  3437                                  ;
  3438                                  ;-----------------------------------------------------------------------------------------------------------------------
  3439                                  ;
  3440                                  ;	Unlink the following adjacent FREE block from the FREE block chain.
  3441                                  ;
  3442 00000BF1 57                      .120			push	edi						;save this block
  3443 00000BF2 89CF                    			mov	edi,ecx						;next contiguous block
  3444 00000BF4 51                      			push	ecx						;save next contiguous block
  3445                                  ;
  3446                                  ;	Address the preceding and following USER memory blocks
  3447                                  ;
  3448 00000BF5 8B5F1C                  			mov	ebx,[edi+MEMBLOCK.previousblock]		;next contig's previous block pointer
  3449 00000BF8 8B4F18                  			mov	ecx,[edi+MEMBLOCK.nextblock]			;next contig's next block pointer
  3450                                  ;
  3451                                  ;	Update the previous block's next-block pointer if there is a previous block. Otherwise, update the first free
  3452                                  ;	block pointer.
  3453                                  ;
  3454 00000BFB 85DB                    			test	ebx,ebx						;is there a previous block?
  3455 00000BFD 7405                    			jz	.130						;no, branch
  3456 00000BFF 894B18                  			mov	[ebx+MEMBLOCK.nextblock],ecx			;update next contig's prev blk next-ptr
  3457 00000C02 EB03                    			jmp	.140						;branch
  3458 00000C04 894E08                  .130			mov	[esi+MEMROOT.firstfree],ecx			;update first FREE block pointer
  3459                                  ;
  3460                                  ;	Update the next block's previous-block pointer if there is a next block. Otherwise, update the last free block
  3461                                  ;	pointer.
  3462                                  ;
  3463 00000C07 E305                    .140			jecxz	.150						;branch if no next block
  3464 00000C09 89591C                  			mov	[ecx+MEMBLOCK.previousblock],ebx		;update next contig's next blk prev-ptr
  3465 00000C0C EB03                    			jmp	.160						;continue
  3466 00000C0E 895E0C                  .150			mov	[esi+MEMROOT.lastfree],ebx			;update last FREE block pointer
  3467                                  ;
  3468                                  ;	Clear next contiguous block's header
  3469                                  ;
  3470 00000C11 5F                      .160			pop	edi						;next congiguous block pointer
  3471 00000C12 B920000000              			mov	ecx,EMEMBLOCKLEN				;memory block header length
  3472 00000C17 B000                    			mov	al,EMEMWIPEBYTE					;memory wipe byte
  3473 00000C19 F3AA                    			rep	stosb						;clear memory header
  3474 00000C1B 5F                      			pop	edi						;this block's pointer
  3475                                  ;-----------------------------------------------------------------------------------------------------------------------
  3476                                  ;
  3477                                  ;	Insert the final FREE block back into the block chain.
  3478                                  ;
  3479                                  ;-----------------------------------------------------------------------------------------------------------------------
  3480                                  ;
  3481                                  ;	Walk the FREE memory chain until a block is found that is larger than or equal in size to the block being
  3482                                  ;	inserted. The block being inserted will be inserted before that block or after the last block found if none
  3483                                  ;	all are smaller in size.
  3484                                  ;
  3485 00000C1C 8B5F04                  .170			mov	ebx,[edi+MEMBLOCK.bytes]			;size of block
  3486 00000C1F 8B4E08                  			mov	ecx,[esi+MEMROOT.firstfree]			;first free block ptr
  3487 00000C22 E30A                    .180			jecxz	.190						;exit if no ptr
  3488 00000C24 3B5904                  			cmp	ebx,[ecx+MEMBLOCK.bytes]			;next block bigger?
  3489 00000C27 7205                    			jb	.190						;yes, branch
  3490 00000C29 8B4918                  			mov	ecx,[ecx+MEMBLOCK.nextblock]			;next free memory block
  3491 00000C2C EBF4                    			jmp	.180						;continue
  3492                                  ;
  3493                                  ;	Set the next-block pointer. Determine the previous-block, which may be the last FREE block if we found no
  3494                                  ;	larger free block. Update the next block's previous block pointer.
  3495                                  ;
  3496 00000C2E 894F18                  .190			mov	[edi+MEMBLOCK.nextblock],ecx			;set the next block ptr
  3497 00000C31 8B5E0C                  			mov	ebx,[esi+MEMROOT.lastfree]			;assume all blocks smaller
  3498 00000C34 E308                    			jecxz	.200						;branch if no block found
  3499 00000C36 8B591C                  			mov	ebx,[ecx+MEMBLOCK.previousblock]		;next block's previous block ptr
  3500 00000C39 89791C                  			mov	[ecx+MEMBLOCK.previousblock],edi		;update next block's previous ptr
  3501 00000C3C EB03                    			jmp	.210						;continue
  3502 00000C3E 897E0C                  .200			mov	[esi+MEMROOT.lastfree],edi			;this block is now the last free
  3503                                  ;
  3504                                  ;	Set our previous block pointer to either the previous pointer of the found block or the last free block.
  3505                                  ;	If there is no previous block pointer, then this block now the first FREE block. Otherwise update that block's
  3506                                  ;	next pointer.
  3507                                  ;
  3508 00000C41 895F1C                  .210			mov	[edi+MEMBLOCK.previousblock],ebx		;set the previous block ptr
  3509 00000C44 85DB                    			test	ebx,ebx						;do we have a previous block?
  3510 00000C46 7405                    			jz	.220						;no, branch
  3511 00000C48 897B18                  			mov	[ebx+MEMBLOCK.nextblock],edi			;update previous block's next block ptr
  3512 00000C4B EB03                    			jmp	.230						;continue
  3513 00000C4D 897E08                  .220			mov	[esi+MEMROOT.firstfree],edi			;update first free ptr
  3514                                  ;
  3515                                  ;	The memory free has completed.
  3516                                  ;
  3517 00000C50 31C0                    .230			xor	eax,eax						;indicate success
  3518                                  ;
  3519                                  ;	Restore and return.
  3520                                  ;
  3521 00000C52 07                      .240			pop	es						;restore non-volatile regs
  3522 00000C53 1F                      			pop	ds						;
  3523 00000C54 5F                      			pop	edi						;
  3524 00000C55 5E                      			pop	esi						;
  3525 00000C56 59                      			pop	ecx						;
  3526 00000C57 5B                      			pop	ebx						;
  3527 00000C58 C3                      			ret							;return
  3528                                  ;=======================================================================================================================
  3529                                  ;
  3530                                  ;	Date and Time Helper Routines
  3531                                  ;
  3532                                  ;	GetYear
  3533                                  ;	IsLeapYear
  3534                                  ;	PutDateString
  3535                                  ;	PutDayString
  3536                                  ;	PutHourString
  3537                                  ;	PutMinuteString
  3538                                  ;	PutMonthString
  3539                                  ;	PutMonthNameString
  3540                                  ;	PutSecondString
  3541                                  ;	PutTimeString
  3542                                  ;	PutWeekdayString
  3543                                  ;	PutWeekdayNameString
  3544                                  ;	PutYearString
  3545                                  ;
  3546                                  ;=======================================================================================================================
  3547                                  ;-----------------------------------------------------------------------------------------------------------------------
  3548                                  ;
  3549                                  ;	Routine:	GetYear
  3550                                  ;
  3551                                  ;	Description:	Return the four-digit year (century * 100 + year of century)
  3552                                  ;
  3553                                  ;	In:		DS:EBX	DATETIME address
  3554                                  ;
  3555                                  ;	Out:		ECX	year
  3556                                  ;
  3557                                  ;-----------------------------------------------------------------------------------------------------------------------
  3558 00000C59 0FB64B07                GetYear			movzx	ecx,byte [ebx+DATETIME.century]			;century
  3559 00000C5D 6BC964                  			imul	ecx,100						;century * 100
  3560 00000C60 0FB64306                			movzx	eax,byte [ebx+DATETIME.year]			;year of century
  3561 00000C64 01C1                    			add	ecx,eax						;year (YYYY)
  3562 00000C66 C3                      			ret							;return
  3563                                  ;-----------------------------------------------------------------------------------------------------------------------
  3564                                  ;
  3565                                  ;	Routine:	IsLeapYear
  3566                                  ;
  3567                                  ;	Description:	This routine returns an indicator if the current year is a leap year.
  3568                                  ;
  3569                                  ;	In:		DS:EBX	DATETIME ADDRESS
  3570                                  ;
  3571                                  ;	Out:		ECX	0 = not a leap year
  3572                                  ;				1 = leap year
  3573                                  ;
  3574                                  ;-----------------------------------------------------------------------------------------------------------------------
  3575 00000C67 E8EDFFFFFF              IsLeapYear		call	GetYear						;ECX = YYYY
  3576 00000C6C 89C8                    			mov	eax,ecx						;EAX = YYYY
  3577 00000C6E 31C9                    			xor	ecx,ecx						;assume not leap year
  3578 00000C70 A803                    			test	al,00000011b					;multiple of four?
  3579 00000C72 750D                    			jnz	.no						;no, branch
  3580 00000C74 B264                    			mov	dl,100						;divisor
  3581 00000C76 F6F2                    			div	dl						;divide by 100
  3582 00000C78 84E4                    			test	ah,ah						;multiple of 100?
  3583 00000C7A 7504                    			jnz	.yes						;yes, branch
  3584 00000C7C A803                    			test	al,00000011b					;multiple of 400?
  3585 00000C7E 7501                    			jnz	.no						;no, branch
  3586 00000C80 41                      .yes			inc	ecx						;indicate leap
  3587 00000C81 C3                      .no			ret							;return
  3588                                  ;-----------------------------------------------------------------------------------------------------------------------
  3589                                  ;
  3590                                  ;	Routine:	PutDateString
  3591                                  ;
  3592                                  ;	Description:	This routine returns an ASCIIZ mm/dd/yyyy string at ds:edx from the date in the DATETIME
  3593                                  ;			structure at ds:ebx.
  3594                                  ;
  3595                                  ;	In:		DS:EBX	DATETIME address
  3596                                  ;			DS:EDX	output buffer address
  3597                                  ;
  3598                                  ;-----------------------------------------------------------------------------------------------------------------------
  3599 00000C82 51                      PutDateString		push	ecx						;save non-volatile regs
  3600 00000C83 57                      			push	edi						;
  3601 00000C84 06                      			push	es						;
  3602 00000C85 1E                      			push	ds						;store data selector ...
  3603 00000C86 07                      			pop	es						;... in extra segment reg
  3604 00000C87 89D7                    			mov	edi,edx						;output buffer address
  3605 00000C89 B10A                    			mov	cl,10						;divisor
  3606 00000C8B BA30302F00              			mov	edx,0002F3030h					;ASCIIZ "00/" (reversed)
  3607 00000C90 0FB64305                			movzx	eax,byte [ebx+DATETIME.month]			;month
  3608 00000C94 F6F1                    			div	cl						;AH = rem; AL = quotient
  3609 00000C96 09D0                    			or	eax,edx						;apply ASCII zones and delimiter
  3610 00000C98 FC                      			cld							;forward strings
  3611 00000C99 AB                      			stosd							;store "mm/"nul
  3612 00000C9A 4F                      			dec	edi						;address of terminator
  3613 00000C9B 0FB64304                			movzx	eax,byte [ebx+DATETIME.day]			;day
  3614 00000C9F F6F1                    			div	cl						;AH = rem; AL = quotient
  3615 00000CA1 09D0                    			or	eax,edx						;apply ASCII zones and delimiter
  3616 00000CA3 AB                      			stosd							;store "dd/"nul
  3617 00000CA4 4F                      			dec	edi						;address of terminator
  3618 00000CA5 0FB64307                			movzx	eax,byte [ebx+DATETIME.century]			;century
  3619 00000CA9 F6F1                    			div	cl						;AH = rem; AL = quotient
  3620 00000CAB 09D0                    			or	eax,edx						;apply ASCII zones and delimiter
  3621 00000CAD AB                      			stosd							;store "cc/"null
  3622 00000CAE 4F                      			dec	edi						;address of terminator
  3623 00000CAF 4F                      			dec	edi						;address of delimiter
  3624 00000CB0 0FB64306                			movzx	eax,byte [ebx+DATETIME.year]			;year (yy)
  3625 00000CB4 F6F1                    			div	cl						;AH = rem; AL = quotient
  3626 00000CB6 09D0                    			or	eax,edx						;apply ASCII zones and delimiter
  3627 00000CB8 AA                      			stosb							;store quotient
  3628 00000CB9 88E0                    			mov	al,ah						;remainder
  3629 00000CBB AA                      			stosb							;store remainder
  3630 00000CBC 30C0                    			xor	al,al						;null terminator
  3631 00000CBE AA                      			stosb							;store terminator
  3632 00000CBF 07                      			pop	es						;restore non-volatile regs
  3633 00000CC0 5F                      			pop	edi						;
  3634 00000CC1 59                      			pop	ecx						;
  3635 00000CC2 C3                      			ret							;return
  3636                                  ;-----------------------------------------------------------------------------------------------------------------------
  3637                                  ;
  3638                                  ;	Routine:	PutDayString
  3639                                  ;
  3640                                  ;	Description:	This routine returns an ASCIIZ dd string at ds:edx from the date in the DATETIME
  3641                                  ;			structure at ds:ebx.
  3642                                  ;
  3643                                  ;	In:		DS:EBX	DATETIME address
  3644                                  ;			DS:EDX	output buffer address
  3645                                  ;
  3646                                  ;-----------------------------------------------------------------------------------------------------------------------
  3647 00000CC3 51                      PutDayString		push	ecx						;save non-volatile regs
  3648 00000CC4 0FB64B04                			movzx	ecx,byte [ebx+DATETIME.day]			;day
  3649 00000CC8 B701                    			mov	bh,1						;trim leading zeros; no commas
  3650 00000CCA E86E040000              			call	UnsignedToDecimalString				;store ASCII decimal string
  3651 00000CCF 59                      			pop	ecx						;
  3652 00000CD0 C3                      			ret							;return
  3653                                  ;-----------------------------------------------------------------------------------------------------------------------
  3654                                  ;
  3655                                  ;	Routine:	PutHourString
  3656                                  ;
  3657                                  ;	Description:	This routine returns an ASCIIZ hh string at ds:edx from the date in the DATETIME
  3658                                  ;			structure at ds:ebx.
  3659                                  ;
  3660                                  ;	In:		DS:EBX	DATETIME address
  3661                                  ;			DS:EDX	output buffer address
  3662                                  ;
  3663                                  ;-----------------------------------------------------------------------------------------------------------------------
  3664 00000CD1 51                      PutHourString		push	ecx						;save non-volatile regs
  3665 00000CD2 0FB64B02                			movzx	ecx,byte [ebx+DATETIME.hour]			;hour
  3666 00000CD6 B701                    			mov	bh,1						;trim leading zeros; no commas
  3667 00000CD8 E860040000              			call	UnsignedToDecimalString				;store ASCII decimal string
  3668 00000CDD 59                      			pop	ecx						;
  3669 00000CDE C3                      			ret							;return
  3670                                  ;-----------------------------------------------------------------------------------------------------------------------
  3671                                  ;
  3672                                  ;	Routine:	PutMinuteString
  3673                                  ;
  3674                                  ;	Description:	This routine returns an ASCIIZ mm string at ds:edx from the date in the DATETIME
  3675                                  ;			structure at ds:ebx.
  3676                                  ;
  3677                                  ;	In:		DS:EBX	DATETIME address
  3678                                  ;			DS:EDX	output buffer address
  3679                                  ;
  3680                                  ;-----------------------------------------------------------------------------------------------------------------------
  3681 00000CDF 51                      PutMinuteString		push	ecx						;save non-volatile regs
  3682 00000CE0 0FB64B01                			movzx	ecx,byte [ebx+DATETIME.minute]			;minute
  3683 00000CE4 B701                    			mov	bh,1						;trim leading zeros; no commas
  3684 00000CE6 E852040000              			call	UnsignedToDecimalString				;store ASCII decimal string
  3685 00000CEB 59                      			pop	ecx						;
  3686 00000CEC C3                      			ret							;return
  3687                                  ;-----------------------------------------------------------------------------------------------------------------------
  3688                                  ;
  3689                                  ;	Routine:	PutMonthString
  3690                                  ;
  3691                                  ;	Description:	This routine returns an ASCIIZ mm string at ds:edx from the date in the DATETIME
  3692                                  ;			structure at ds:ebx.
  3693                                  ;
  3694                                  ;	In:		DS:EBX	DATETIME address
  3695                                  ;			DS:EDX	output buffer address
  3696                                  ;
  3697                                  ;-----------------------------------------------------------------------------------------------------------------------
  3698 00000CED 51                      PutMonthString		push	ecx						;save non-volatile regs
  3699 00000CEE 0FB64B05                			movzx	ecx,byte [ebx+DATETIME.month]			;month
  3700 00000CF2 B701                    			mov	bh,1						;trim leading zeros; no commas
  3701 00000CF4 E844040000              			call	UnsignedToDecimalString				;store ASCII decimal string
  3702 00000CF9 59                      			pop	ecx						;
  3703 00000CFA C3                      			ret							;return
  3704                                  ;-----------------------------------------------------------------------------------------------------------------------
  3705                                  ;
  3706                                  ;	Routine:	PutMonthNameString
  3707                                  ;
  3708                                  ;	Description:	This routine returns an ASCIIZ name(mm) string at ds:edx from the date in the DATETIME
  3709                                  ;			structure at ds:ebx.
  3710                                  ;
  3711                                  ;	In:		DS:EBX	DATETIME address
  3712                                  ;			DS:EDX	output buffer address
  3713                                  ;
  3714                                  ;-----------------------------------------------------------------------------------------------------------------------
  3715 00000CFB 56                      PutMonthNameString	push	esi						;save non-volatile regs
  3716 00000CFC 57                      			push	edi						;
  3717 00000CFD 1E                      			push	ds						;
  3718 00000CFE 06                      			push	es						;
  3719 00000CFF 1E                      			push	ds						;load data selector ...
  3720 00000D00 07                      			pop	es						;... into extra segment
  3721 00000D01 89D7                    			mov	edi,edx						;output buffer address
  3722 00000D03 0FB64305                			movzx	eax,byte [ebx+DATETIME.month]			;month (1-12)
  3723 00000D07 48                      			dec	eax						;month (0-11)
  3724 00000D08 C1E002                  			shl	eax,2						;offset into month name lookup table
  3725 00000D0B 0E                      			push	cs						;load code selector ...
  3726 00000D0C 1F                      			pop	ds						;... into data segment
  3727 00000D0D 8BB0[4C0E0000]          			mov	esi,[tMonthNames+eax]				;month name address
  3728 00000D13 FC                      			cld							;forward strings
  3729 00000D14 AC                      .10			lodsb							;name character
  3730 00000D15 AA                      			stosb							;store in output buffer
  3731 00000D16 84C0                    			test	al,al						;end of string?
  3732 00000D18 75FA                    			jnz	.10						;no, continue
  3733 00000D1A 07                      			pop	es						;restore non-volatile regs
  3734 00000D1B 1F                      			pop	ds						;
  3735 00000D1C 5F                      			pop	edi						;
  3736 00000D1D 5E                      			pop	esi						;
  3737 00000D1E C3                      			ret							;return
  3738                                  ;-----------------------------------------------------------------------------------------------------------------------
  3739                                  ;
  3740                                  ;	Routine:	PutSecondString
  3741                                  ;
  3742                                  ;	Description:	This routine returns an ASCIIZ ss string at ds:edx from the date in the DATETIME
  3743                                  ;			structure at ds:ebx.
  3744                                  ;
  3745                                  ;	In:		DS:EBX	DATETIME address
  3746                                  ;			DS:EDX	output buffer address
  3747                                  ;
  3748                                  ;-----------------------------------------------------------------------------------------------------------------------
  3749 00000D1F 51                      PutSecondString		push	ecx						;save non-volatile regs
  3750 00000D20 0FB60B                  			movzx	ecx,byte [ebx+DATETIME.second]			;second
  3751 00000D23 B701                    			mov	bh,1						;trim leading zeros; no commas
  3752 00000D25 E813040000              			call	UnsignedToDecimalString				;store ASCII decimal string
  3753 00000D2A 59                      			pop	ecx						;
  3754 00000D2B C3                      			ret							;return
  3755                                  ;-----------------------------------------------------------------------------------------------------------------------
  3756                                  ;
  3757                                  ;	Routine:	PutTimeString
  3758                                  ;
  3759                                  ;	Description:	This routine returns an ASCIIZ hh:mm:ss string at ds:edx from the date in the DATETIME
  3760                                  ;			structure at ds:ebx.
  3761                                  ;
  3762                                  ;	In:		DS:EBX	DATETIME address
  3763                                  ;			DS:EDX	output buffer address
  3764                                  ;
  3765                                  ;-----------------------------------------------------------------------------------------------------------------------
  3766 00000D2C 51                      PutTimeString		push	ecx						;save non-volatile regs
  3767 00000D2D 57                      			push	edi						;
  3768 00000D2E 06                      			push	es						;
  3769 00000D2F 1E                      			push	ds						;store data selector ...
  3770 00000D30 07                      			pop	es						;... in extra segment reg
  3771 00000D31 89D7                    			mov	edi,edx						;output buffer address
  3772 00000D33 B10A                    			mov	cl,10						;divisor
  3773 00000D35 BA30303A00              			mov	edx,003a3030h					;ASCIIZ "00:" (reversed)
  3774 00000D3A 0FB64302                			movzx	eax,byte [ebx+DATETIME.hour]			;hour
  3775 00000D3E F6F1                    			div	cl						;ah = rem; al = quotient
  3776 00000D40 09D0                    			or	eax,edx						;apply ASCII zones and delimiter
  3777 00000D42 FC                      			cld							;forward strings
  3778 00000D43 AB                      			stosd							;store "mm/"nul
  3779 00000D44 4F                      			dec	edi						;address of terminator
  3780 00000D45 0FB64301                			movzx	eax,byte [ebx+DATETIME.minute]			;minute
  3781 00000D49 F6F1                    			div	cl						;ah = rem; al = quotient
  3782 00000D4B 09D0                    			or	eax,edx						;apply ASCII zones and delimiter
  3783 00000D4D AB                      			stosd							;store "dd/"nul
  3784 00000D4E 4F                      			dec	edi						;address of terminator
  3785 00000D4F 0FB603                  			movzx	eax,byte [ebx+DATETIME.second]			;second
  3786 00000D52 F6F1                    			div	cl						;ah = rem; al = quotient
  3787 00000D54 09D0                    			or	eax,edx						;apply ASCII zones and delimiter
  3788 00000D56 AA                      			stosb							;store quotient
  3789 00000D57 88E0                    			mov	al,ah						;remainder
  3790 00000D59 AA                      			stosb							;store remainder
  3791 00000D5A 30C0                    			xor	al,al						;null terminator
  3792 00000D5C AA                      			stosb							;store terminator
  3793 00000D5D 07                      			pop	es						;restore non-volatile regs
  3794 00000D5E 5F                      			pop	edi						;
  3795 00000D5F 59                      			pop	ecx						;
  3796 00000D60 C3                      			ret							;return
  3797                                  ;-----------------------------------------------------------------------------------------------------------------------
  3798                                  ;
  3799                                  ;	Routine:	PutWeekdayString
  3800                                  ;
  3801                                  ;	Description:	This routine returns an ASCIIZ weekday string at ds:edx from the date in the DATETIME
  3802                                  ;			structure at ds:ebx.
  3803                                  ;
  3804                                  ;	In:		DS:EBX	DATETIME address
  3805                                  ;			DS:EDX	output buffer address
  3806                                  ;
  3807                                  ;-----------------------------------------------------------------------------------------------------------------------
  3808 00000D61 51                      PutWeekdayString	push	ecx						;save non-volatile regs
  3809 00000D62 0FB64B03                			movzx	ecx,byte [ebx+DATETIME.weekday]			;weekday
  3810 00000D66 B701                    			mov	bh,1						;trim leading zeros; no commas
  3811 00000D68 E8D0030000              			call	UnsignedToDecimalString				;store ASCII decimal string
  3812 00000D6D 59                      			pop	ecx						;
  3813 00000D6E C3                      			ret							;return
  3814                                  ;-----------------------------------------------------------------------------------------------------------------------
  3815                                  ;
  3816                                  ;	Routine:	PutWeekdayNameString
  3817                                  ;
  3818                                  ;	Description:	This routine returns an ASCIIZ name(weekday) string at ds:edx from the date in the DATETIME
  3819                                  ;			structure at ds:ebx.
  3820                                  ;
  3821                                  ;	In:		DS:EBX	DATETIME address
  3822                                  ;			DS:EDX	output buffer address
  3823                                  ;
  3824                                  ;-----------------------------------------------------------------------------------------------------------------------
  3825 00000D6F 56                      PutWeekdayNameString	push	esi						;save non-volatile regs
  3826 00000D70 57                      			push	edi						;
  3827 00000D71 1E                      			push	ds						;
  3828 00000D72 06                      			push	es						;
  3829 00000D73 1E                      			push	ds						;load data selector ...
  3830 00000D74 07                      			pop	es						;... into extra segment
  3831 00000D75 89D7                    			mov	edi,edx						;output buffer address
  3832 00000D77 0FB64303                			movzx	eax,byte [ebx+DATETIME.weekday]			;weekday (0-6)
  3833 00000D7B C1E002                  			shl	eax,2						;offset into day name lookup table
  3834 00000D7E 0E                      			push	cs						;load code selector ...
  3835 00000D7F 1F                      			pop	ds						;... into data segment
  3836 00000D80 8BB0[300E0000]          			mov	esi,[tDayNames+eax]				;day name address
  3837 00000D86 FC                      			cld							;forward strings
  3838 00000D87 AC                      .10			lodsb							;name character
  3839 00000D88 AA                      			stosb							;store in output buffer
  3840 00000D89 84C0                    			test	al,al						;end of string?
  3841 00000D8B 75FA                    			jnz	.10						;no, continue
  3842 00000D8D 07                      			pop	es						;restore non-volatile regs
  3843 00000D8E 1F                      			pop	ds						;
  3844 00000D8F 5F                      			pop	edi						;
  3845 00000D90 5E                      			pop	esi						;
  3846 00000D91 C3                      			ret							;return
  3847                                  ;-----------------------------------------------------------------------------------------------------------------------
  3848                                  ;
  3849                                  ;	Routine:	PutYearString
  3850                                  ;
  3851                                  ;	Description:	This routine returns an ASCIIZ yyyy string at ds:edx from the date in the DATETIME
  3852                                  ;			structure at ds:ebx.
  3853                                  ;
  3854                                  ;	In:		DS:EBX	DATETIME address
  3855                                  ;			DS:EDX	output buffer address
  3856                                  ;
  3857                                  ;-----------------------------------------------------------------------------------------------------------------------
  3858 00000D92 51                      PutYearString		push	ecx						;save non-volatile regs
  3859 00000D93 E8C1FEFFFF              			call	GetYear						;ECX = YYYY
  3860 00000D98 B701                    			mov	bh,1						;trim leading zeros; no commas
  3861 00000D9A E89E030000              			call	UnsignedToDecimalString				;store decimal string at DS:EDX
  3862 00000D9F 59                      			pop	ecx						;restore non-volatile regs
  3863 00000DA0 C3                      			ret							;return
  3864                                  ;-----------------------------------------------------------------------------------------------------------------------
  3865                                  ;
  3866                                  ;	Day Names
  3867                                  ;
  3868                                  ;-----------------------------------------------------------------------------------------------------------------------
  3869 00000DA1 53756E64617900          czSunday		db	"Sunday",0
  3870 00000DA8 4D6F6E64617900          czMonday		db	"Monday",0
  3871 00000DAF 5475657364617900        czTuesday		db	"Tuesday",0
  3872 00000DB7 5765646E6573646179-     czWednesday		db	"Wednesday",0
  3872 00000DC0 00                 
  3873 00000DC1 546875727364617900      czThursday		db	"Thursday",0
  3874 00000DCA 46726964617900          czFriday		db	"Friday",0
  3875 00000DD1 536174757264617900      czSaturday		db	"Saturday",0
  3876                                  ;-----------------------------------------------------------------------------------------------------------------------
  3877                                  ;
  3878                                  ;	Month Names
  3879                                  ;
  3880                                  ;-----------------------------------------------------------------------------------------------------------------------
  3881 00000DDA 4A616E7561727900        czJanuary		db	"January",0
  3882 00000DE2 466562727561727900      czFebruary		db	"February",0
  3883 00000DEB 4D6172636800            czMarch			db	"March",0
  3884 00000DF1 417072696C00            czApril			db	"April",0
  3885 00000DF7 4D617900                czMay			db	"May",0
  3886 00000DFB 4A756E6500              czJune			db	"June",0
  3887 00000E00 4A756C7900              czJuly			db	"July",0
  3888 00000E05 41756775737400          czAugust		db	"August",0
  3889 00000E0C 53657074656D626572-     czSeptember		db	"September",0
  3889 00000E15 00                 
  3890 00000E16 4F63746F62657200        czOctober		db	"October",0
  3891 00000E1E 4E6F76656D62657200      czNovember		db	"November",0
  3892 00000E27 446563656D62657200      czDecember		db	"December",0
  3893                                  ;-----------------------------------------------------------------------------------------------------------------------
  3894                                  ;
  3895                                  ;	Day Names Lookup Table
  3896                                  ;
  3897                                  ;-----------------------------------------------------------------------------------------------------------------------
  3898                                  			align	4
  3899                                  tDayNames		equ	$
  3900 00000E30 [A10D0000]              			dd	czSunday
  3901 00000E34 [A80D0000]              			dd	czMonday
  3902 00000E38 [AF0D0000]              			dd	czTuesday
  3903 00000E3C [B70D0000]              			dd	czWednesday
  3904 00000E40 [C10D0000]              			dd	czThursday
  3905 00000E44 [CA0D0000]              			dd	czFriday
  3906 00000E48 [D10D0000]              			dd	czSaturday
  3907                                  EDAYNAMESTBLL		equ	($-tDayNames)
  3908                                  EDAYNAMESTBLCNT		equ	EDAYNAMESTBLL/4
  3909                                  ;-----------------------------------------------------------------------------------------------------------------------
  3910                                  ;
  3911                                  ;	Month Names Lookup Table
  3912                                  ;
  3913                                  ;-----------------------------------------------------------------------------------------------------------------------
  3914                                  			align	4
  3915                                  tMonthNames		equ	$
  3916 00000E4C [DA0D0000]              			dd	czJanuary
  3917 00000E50 [E20D0000]              			dd	czFebruary
  3918 00000E54 [EB0D0000]              			dd	czMarch
  3919 00000E58 [F10D0000]              			dd	czApril
  3920 00000E5C [F70D0000]              			dd	czMay
  3921 00000E60 [FB0D0000]              			dd	czJune
  3922 00000E64 [000E0000]              			dd	czJuly
  3923 00000E68 [050E0000]              			dd	czAugust
  3924 00000E6C [0C0E0000]              			dd	czSeptember
  3925 00000E70 [160E0000]              			dd	czOctober
  3926 00000E74 [1E0E0000]              			dd	czNovember
  3927 00000E78 [270E0000]              			dd	czDecember
  3928                                  EMONTHNAMESTBLL		equ	($-tMonthNames)
  3929                                  EMONTHNAMESTBLCNT	equ	EMONTHNAMESTBLL/4
  3930                                  ;=======================================================================================================================
  3931                                  ;
  3932                                  ;	String Helper Routines
  3933                                  ;
  3934                                  ;	UpperCaseString
  3935                                  ;	CompareMemory
  3936                                  ;	CopyMemory
  3937                                  ;
  3938                                  ;=======================================================================================================================
  3939                                  ;-----------------------------------------------------------------------------------------------------------------------
  3940                                  ;
  3941                                  ;	Routine:	UpperCaseString
  3942                                  ;
  3943                                  ;	Description:	This routine places all characters in the given string to upper case.
  3944                                  ;
  3945                                  ;	In:		DS:EDX	string address
  3946                                  ;
  3947                                  ;	Out:		EDX	string address
  3948                                  ;
  3949                                  ;-----------------------------------------------------------------------------------------------------------------------
  3950 00000E7C 56                      UpperCaseString		push	esi						;save non-volatile regs
  3951 00000E7D 89D6                    			mov	esi,edx						;string address
  3952 00000E7F FC                      			cld							;forward strings
  3953 00000E80 AC                      .10			lodsb							;string character
  3954 00000E81 84C0                    			test	al,al						;null?
  3955 00000E83 740F                    			jz	.20						;yes, skip ahead
  3956 00000E85 3C61                    			cmp	al,EASCIILOWERA					;lower-case? (lower bounds)
  3957 00000E87 72F7                    			jb	.10						;no, continue
  3958 00000E89 3C7A                    			cmp	al,EASCIILOWERZ					;lower-case? (upper bounds)
  3959 00000E8B 77F3                    			ja	.10						;no, continue
  3960 00000E8D 24DF                    			and	al,EASCIICASEMASK				;mask for upper case
  3961 00000E8F 8846FF                  			mov	[esi-1],al					;upper character
  3962 00000E92 EBEC                    			jmp	.10						;continue
  3963 00000E94 5E                      .20			pop	esi						;restore non-volatile regs
  3964 00000E95 C3                      			ret							;return
  3965                                  ;-----------------------------------------------------------------------------------------------------------------------
  3966                                  ;
  3967                                  ;	Routine:	CompareMemory
  3968                                  ;
  3969                                  ;	Description:	This routine compares two byte arrays.
  3970                                  ;
  3971                                  ;	In:		DS:EDX	first source address
  3972                                  ;			DS:EBX	second source address
  3973                                  ;			ECX	comparison length
  3974                                  ;
  3975                                  ;	Out:		EDX	first source address
  3976                                  ;			EBX	second source address
  3977                                  ;			ECX	0	array 1 = array 2
  3978                                  ;				<0	array 1 < array 2
  3979                                  ;				>0	array 1 > array 2
  3980                                  ;
  3981                                  ;-----------------------------------------------------------------------------------------------------------------------
  3982 00000E96 56                      CompareMemory		push	esi						;save non-volatile regs
  3983 00000E97 57                      			push	edi						;
  3984 00000E98 06                      			push	es						;
  3985 00000E99 1E                      			push	ds						;copy DS
  3986 00000E9A 07                      			pop	es						;... to ES
  3987 00000E9B 89D6                    			mov	esi,edx						;first source address
  3988 00000E9D 89DF                    			mov	edi,ebx						;second source address
  3989 00000E9F FC                      			cld							;forward strings
  3990 00000EA0 F3A6                    			rep	cmpsb						;compare bytes
  3991 00000EA2 B000                    			mov	al,0						;default result
  3992 00000EA4 7406                    			jz	.10						;branch if arrays equal
  3993 00000EA6 B001                    			mov	al,1						;positive result
  3994 00000EA8 7302                    			jnc	.10						;branch if target > source
  3995 00000EAA B0FF                    			mov	al,-1						;negative result
  3996 00000EAC 0FBEC8                  .10			movsx	ecx,al						;extend sign
  3997 00000EAF 07                      			pop	es						;restore non-volatile regs
  3998 00000EB0 5F                      			pop	edi						;
  3999 00000EB1 5E                      			pop	esi						;
  4000 00000EB2 C3                      			ret							;return
  4001                                  ;-----------------------------------------------------------------------------------------------------------------------
  4002                                  ;
  4003                                  ;	Routine:	CopyMemory
  4004                                  ;
  4005                                  ;	Description:	This routine copies a byte array.
  4006                                  ;
  4007                                  ;	In:		DS:EDX	first source address
  4008                                  ;			DS:EBX	second source address
  4009                                  ;			ECX	copy length
  4010                                  ;
  4011                                  ;-----------------------------------------------------------------------------------------------------------------------
  4012 00000EB3 51                      CopyMemory		push	ecx						;save non-volatile regs
  4013 00000EB4 56                      			push	esi						;
  4014 00000EB5 57                      			push	edi						;
  4015 00000EB6 06                      			push	es						;
  4016                                  ;
  4017                                  ;	Compare byte array
  4018                                  ;
  4019 00000EB7 1E                      			push	ds						;load data selector
  4020 00000EB8 07                      			pop	es						;... into ES register
  4021 00000EB9 89D6                    			mov	esi,edx						;first source address
  4022 00000EBB 89DF                    			mov	edi,ebx						;second source address
  4023 00000EBD FC                      			cld							;forward strings
  4024 00000EBE F3A4                    			rep	movsb						;copy bytes
  4025                                  ;
  4026                                  ;	Restore and return
  4027                                  ;
  4028 00000EC0 07                      			pop	es						;restore non-volatile regs
  4029 00000EC1 5F                      			pop	edi						;
  4030 00000EC2 5E                      			pop	esi						;
  4031 00000EC3 59                      			pop	ecx						;
  4032 00000EC4 C3                      			ret							;return
  4033                                  ;=======================================================================================================================
  4034                                  ;
  4035                                  ;	Console Helper Routines
  4036                                  ;
  4037                                  ;	PutConsoleString
  4038                                  ;	GetConsoleString
  4039                                  ;	GetConsoleChar
  4040                                  ;	Yield
  4041                                  ;	PreviousConsoleColumn
  4042                                  ;	NextConsoleColumn
  4043                                  ;	FirstConsoleColumn
  4044                                  ;	NextConsoleRow
  4045                                  ;	PutConsoleChar
  4046                                  ;	PutConsoleOIAShift
  4047                                  ;	PutConsoleOIAChar
  4048                                  ;	PutConsoleHexByte
  4049                                  ;
  4050                                  ;=======================================================================================================================
  4051                                  ;-----------------------------------------------------------------------------------------------------------------------
  4052                                  ;
  4053                                  ;	Routine:	PutConsoleString
  4054                                  ;
  4055                                  ;	Description:	This routine writes a sequence of ASCII characters to the console until null and updates the
  4056                                  ;			console position as needed.
  4057                                  ;
  4058                                  ;	In:		EDX	source address
  4059                                  ;			DS	OS data selector
  4060                                  ;
  4061                                  ;-----------------------------------------------------------------------------------------------------------------------
  4062 00000EC5 56                      PutConsoleString	push	esi						;save non-volatile regs
  4063 00000EC6 89D6                    			mov	esi,edx						;source address
  4064 00000EC8 FC                      			cld							;forward strings
  4065 00000EC9 AC                      .10			lodsb							;ASCII character
  4066 00000ECA 08C0                    			or	al,al						;end of string?
  4067 00000ECC 7422                    			jz	.40						;yes, skip ahead
  4068 00000ECE 3C0D                    			cmp	al,EASCIIRETURN					;carriage return?
  4069 00000ED0 7507                    			jne	.20						;no, skip ahead
  4070 00000ED2 E8EB000000              			call	FirstConsoleColumn				;move to start of row
  4071 00000ED7 EBF0                    			jmp	.10						;next character
  4072 00000ED9 3C0A                    .20			cmp	al,EASCIILINEFEED				;line feed?
  4073 00000EDB 7507                    			jne	.30						;no, skip ahead
  4074 00000EDD E8E8000000              			call	NextConsoleRow					;move to next row
  4075 00000EE2 EBE5                    			jmp	.10						;next character
  4076 00000EE4 E803010000              .30			call	PutConsoleChar					;output character to console
  4077 00000EE9 E8B9000000              			call	NextConsoleColumn				;advance to next column
  4078 00000EEE EBD9                    			jmp	.10						;next character
  4079 00000EF0 5E                      .40			pop	esi						;restore non-volatile regs
  4080 00000EF1 C3                      			ret							;return
  4081                                  ;-----------------------------------------------------------------------------------------------------------------------
  4082                                  ;
  4083                                  ;	Routine:	GetConsoleString
  4084                                  ;
  4085                                  ;	Description:	This routine accepts keyboard input into a buffer.
  4086                                  ;
  4087                                  ;	In:		DS:EDX	target buffer address
  4088                                  ;			ECX	maximum number of characters to accept
  4089                                  ;			BH	echo to terminal
  4090                                  ;			BL	terminating character
  4091                                  ;
  4092                                  ;-----------------------------------------------------------------------------------------------------------------------
  4093 00000EF2 51                      GetConsoleString	push	ecx						;save non-volatile regs
  4094 00000EF3 56                      			push	esi						;
  4095 00000EF4 57                      			push	edi						;
  4096 00000EF5 06                      			push	es						;
  4097 00000EF6 1E                      			push	ds						;load data segment selector ...
  4098 00000EF7 07                      			pop	es						;... into extra segment register
  4099 00000EF8 89D7                    			mov	edi,edx						;edi = target buffer
  4100 00000EFA 51                      			push	ecx						;save maximum characters
  4101 00000EFB 30C0                    			xor	al,al						;zero register
  4102 00000EFD FC                      			cld							;forward strings
  4103 00000EFE F3AA                    			rep	stosb						;zero fill buffer
  4104 00000F00 59                      			pop	ecx						;maximum characters
  4105 00000F01 89D7                    			mov	edi,edx						;edi = target buffer
  4106 00000F03 89D6                    			mov	esi,edx						;esi = target buffer
  4107 00000F05 E34E                    .10			jecxz	.50						;exit if max-length is zero
  4108 00000F07 E856000000              .20			call	GetConsoleChar					;al = next input char
  4109 00000F0C 38D8                    			cmp	al,bl						;is this the terminator?
  4110 00000F0E 7445                    			je	.50						;yes, exit
  4111 00000F10 3C08                    			cmp	al,EASCIIBACKSPACE				;is this a backspace?
  4112 00000F12 7521                    			jne	.30						;no, skip ahead
  4113 00000F14 39FE                    			cmp	esi,edi						;at start of buffer?
  4114 00000F16 74EF                    			je	.20						;yes, get next character
  4115 00000F18 4F                      			dec	edi						;backup target pointer
  4116 00000F19 C60700                  			mov	byte [edi],0					;zero previous character
  4117 00000F1C 41                      			inc	ecx						;increment remaining chars
  4118 00000F1D F6C701                  			test	bh,1						;echo to console?
  4119 00000F20 74E5                    			jz	.20						;no, get next character
  4120 00000F22 E85B000000              			call	PreviousConsoleColumn				;backup console position
  4121 00000F27 B020                    			mov	al,EASCIISPACE					;ASCII space
  4122 00000F29 E8BE000000              			call	PutConsoleChar					;write space to console
  4123 00000F2E E856040000              			call	PlaceCursor					;position the cursor
  4124 00000F33 EBD2                    			jmp	.20						;get next character
  4125 00000F35 3C20                    .30			cmp	al,EASCIISPACE					;printable? (lower bounds)
  4126 00000F37 72CE                    			jb	.20						;no, get another character
  4127 00000F39 3C7E                    			cmp	al,EASCIITILDE					;printable? (upper bounds)
  4128 00000F3B 77CA                    			ja	.20						;no, get another character
  4129 00000F3D AA                      			stosb							;store character in buffer
  4130 00000F3E F6C701                  			test	bh,1						;echo to console?
  4131 00000F41 740F                    			jz	.40						;no, skip ahead
  4132 00000F43 E8A4000000              			call	PutConsoleChar					;write character to console
  4133 00000F48 E85A000000              			call	NextConsoleColumn				;advance console position
  4134 00000F4D E837040000              			call	PlaceCursor					;position the cursor
  4135 00000F52 49                      .40			dec	ecx						;decrement remaining chars
  4136 00000F53 EBB0                    			jmp	.10						;next
  4137 00000F55 30C0                    .50			xor	al,al						;null
  4138 00000F57 AA                      			stosb							;terminate buffer
  4139 00000F58 07                      			pop	es						;restore non-volatile regs
  4140 00000F59 5F                      			pop	edi						;
  4141 00000F5A 5E                      			pop	esi						;
  4142 00000F5B 59                      			pop	ecx						;
  4143 00000F5C C3                      			ret							;return
  4144                                  ;-----------------------------------------------------------------------------------------------------------------------
  4145                                  ;
  4146                                  ;	Routine:	GetConsoleChar
  4147                                  ;
  4148                                  ;	Description:	This routine waits for EMSGKEYCHAR message and return character code.
  4149                                  ;
  4150                                  ;	Out:		AL	ASCII character code
  4151                                  ;			AH	keyboard scan code
  4152                                  ;
  4153                                  ;-----------------------------------------------------------------------------------------------------------------------
  4154 00000F5D E81D000000              GetConsoleChar.10	call	Yield						;pass control or halt
  4155 00000F62 E860030000              GetConsoleChar		call	GetMessage					;get the next message
  4156 00000F67 09C0                    			or	eax,eax						;do we have a message?
  4157 00000F69 74F2                    			jz	GetConsoleChar.10				;no, skip ahead
  4158 00000F6B 50                      			push	eax						;save key codes
  4159 00000F6C 250000FFFF              			and	eax,0FFFF0000h					;mask for message type
  4160 00000F71 3D00000241              			cmp	eax,EMSGKEYCHAR					;key-char message?
  4161 00000F76 58                      			pop	eax						;restore key codes
  4162 00000F77 75E9                    			jne	GetConsoleChar					;no, try again
  4163 00000F79 25FFFF0000              			and	eax,0000ffffh					;mask for key codes
  4164 00000F7E C3                      			ret							;return
  4165                                  ;-----------------------------------------------------------------------------------------------------------------------
  4166                                  ;
  4167                                  ;	Routine:	Yield
  4168                                  ;
  4169                                  ;	Description:	This routine passes control to the next ready task or enter halt.
  4170                                  ;
  4171                                  ;-----------------------------------------------------------------------------------------------------------------------
  4172 00000F7F FB                      Yield			sti							;enable maskagle interrupts
  4173 00000F80 F4                      			hlt							;halt until external interrupt
  4174 00000F81 C3                      			ret							;return
  4175                                  ;-----------------------------------------------------------------------------------------------------------------------
  4176                                  ;
  4177                                  ;	Routine:	PreviousConsoleColumn
  4178                                  ;
  4179                                  ;	Description:	This routine retreats the cursor one logical column. If the cursor was at the start of a row,
  4180                                  ;			the column is set to the last position in the row and the row is decremented.
  4181                                  ;
  4182                                  ;	In:		DS	OS data selector
  4183                                  ;
  4184                                  ;-----------------------------------------------------------------------------------------------------------------------
  4185 00000F82 A0480A0000              PreviousConsoleColumn	mov	al,[wbConsoleColumn]				;current column
  4186 00000F87 08C0                    			or	al,al						;start of row?
  4187 00000F89 7514                    			jnz	.10						;no, skip ahead
  4188 00000F8B 8A25490A0000            			mov	ah,[wbConsoleRow]				;current row
  4189 00000F91 08E4                    			or	ah,ah						;top of screen?
  4190 00000F93 7411                    			jz	.20						;yes, exit with no change
  4191 00000F95 FECC                    			dec	ah						;decrement row
  4192 00000F97 8825490A0000            			mov	[wbConsoleRow],ah				;save row
  4193 00000F9D B050                    			mov	al,ECONCOLS					;set maximum column
  4194 00000F9F FEC8                    .10			dec	al						;decrement column
  4195 00000FA1 A2480A0000              			mov	[wbConsoleColumn],al				;save column
  4196 00000FA6 C3                      .20			ret							;return
  4197                                  ;-----------------------------------------------------------------------------------------------------------------------
  4198                                  ;
  4199                                  ;	Routine:	NextConsoleColumn
  4200                                  ;
  4201                                  ;	Description:	This routine advances the console position one column. The columnn is reset to zero and the row
  4202                                  ;			incremented if the end of the current row is reached.
  4203                                  ;
  4204                                  ;	In:		DS	OS data selector
  4205                                  ;
  4206                                  ;-----------------------------------------------------------------------------------------------------------------------
  4207 00000FA7 A0480A0000              NextConsoleColumn	mov	al,[wbConsoleColumn]				;current column
  4208 00000FAC FEC0                    			inc	al						;increment column
  4209 00000FAE A2480A0000              			mov	[wbConsoleColumn],al				;save column
  4210 00000FB3 3C50                    			cmp	al,ECONCOLS					;end of row?
  4211 00000FB5 720A                    			jb	.10						;no, skip ahead
  4212 00000FB7 E806000000              			call	FirstConsoleColumn				;reset column to start of row
  4213 00000FBC E809000000              			call	NextConsoleRow					;line feed to next row
  4214 00000FC1 C3                      .10			ret							;return
  4215                                  ;-----------------------------------------------------------------------------------------------------------------------
  4216                                  ;
  4217                                  ;	Routine:	FirstConsoleColumn
  4218                                  ;
  4219                                  ;	Description:	This routine resets the console column to start of the row.
  4220                                  ;
  4221                                  ;	In:		DS	OS data selector
  4222                                  ;
  4223                                  ;-----------------------------------------------------------------------------------------------------------------------
  4224 00000FC2 30C0                    FirstConsoleColumn	xor	al,al						;zero column
  4225 00000FC4 A2480A0000              			mov	[wbConsoleColumn],al				;save column
  4226 00000FC9 C3                      			ret							;return
  4227                                  ;-----------------------------------------------------------------------------------------------------------------------
  4228                                  ;
  4229                                  ;	Routine:	NextConsoleRow
  4230                                  ;
  4231                                  ;	Description:	This routine advances the console position one line. Scroll the screen one row if needed.
  4232                                  ;
  4233                                  ;	In:		DS	OS data selector
  4234                                  ;
  4235                                  ;-----------------------------------------------------------------------------------------------------------------------
  4236 00000FCA A0490A0000              NextConsoleRow		mov	al,[wbConsoleRow]				;current row
  4237 00000FCF FEC0                    			inc	al						;increment row
  4238 00000FD1 A2490A0000              			mov	[wbConsoleRow],al				;save row
  4239 00000FD6 3C18                    			cmp	al,ECONROWS					;end of screen?
  4240 00000FD8 7211                    			jb	.10						;no, skip ahead
  4241 00000FDA E858030000              			call	ScrollConsoleRow				;scroll up one row
  4242 00000FDF A0490A0000              			mov	al,[wbConsoleRow]				;row
  4243 00000FE4 FEC8                    			dec	al						;decrement row
  4244 00000FE6 A2490A0000              			mov	[wbConsoleRow],al				;save row
  4245 00000FEB C3                      .10			ret							;return
  4246                                  ;-----------------------------------------------------------------------------------------------------------------------
  4247                                  ;
  4248                                  ;	Routine:	PutConsoleChar
  4249                                  ;
  4250                                  ;	Description:	This routine writes one ASCII character to the console screen.
  4251                                  ;
  4252                                  ;	In:		AL	ASCII character
  4253                                  ;			DS	OS data selector
  4254                                  ;
  4255                                  ;-----------------------------------------------------------------------------------------------------------------------
  4256 00000FEC 51                      PutConsoleChar		push	ecx						;save non-volatile regs
  4257 00000FED 06                      			push	es						;
  4258 00000FEE 6A20                    			push	ESELCGA						;load CGA selector ...
  4259 00000FF0 07                      			pop	es						;... into extra segment reg
  4260 00000FF1 8A0D480A0000            			mov	cl,[wbConsoleColumn]				;column
  4261 00000FF7 8A2D490A0000            			mov	ch,[wbConsoleRow]				;row
  4262 00000FFD E871030000              			call	SetConsoleChar					;put character at row, column
  4263 00001002 07                      			pop	es						;restore non-volatile regs
  4264 00001003 59                      			pop	ecx						;
  4265 00001004 C3                      			ret							;return
  4266                                  ;-----------------------------------------------------------------------------------------------------------------------
  4267                                  ;
  4268                                  ;	Routine:	PutConsoleOIAShift
  4269                                  ;
  4270                                  ;	Description:	This routine updates the shift/ctrl/alt/lock indicators in the operator information area (OIA).
  4271                                  ;
  4272                                  ;	In:		BL	shift flags
  4273                                  ;			BH	lock flags
  4274                                  ;			DS	OS data selector
  4275                                  ;
  4276                                  ;-----------------------------------------------------------------------------------------------------------------------
  4277 00001005 51                      PutConsoleOIAShift	push	ecx						;save non-volatile regs
  4278 00001006 06                      			push	es						;
  4279 00001007 6A20                    			push	ESELCGA						;load CGA selector ...
  4280 00001009 07                      			pop	es						;... into ES register
  4281 0000100A B518                    			mov	ch,ECONOIAROW					;OIA row
  4282 0000100C B020                    			mov	al,EASCIISPACE					;space is default character
  4283 0000100E F6C302                  			test	bl,EKEYFSHIFTLEFT				;left-shift indicated?
  4284 00001011 7402                    			jz	.10						;no, skip ahead
  4285 00001013 B053                    			mov	al,'S'						;yes, indicate with 'S'
  4286 00001015 B10E                    .10			mov	cl,14						;indicator column
  4287 00001017 E857030000              			call	SetConsoleChar					;display ASCII character
  4288 0000101C B020                    			mov	al,EASCIISPACE					;ASCII space
  4289 0000101E F6C310                  			test	bl,EKEYFSHIFTRIGHT				;right-shift indicated?
  4290 00001021 7402                    			jz	.20						;no, skip ahead
  4291 00001023 B053                    			mov	al,'S'						;yes, indicate with 'S'
  4292 00001025 B140                    .20			mov	cl,64						;indicator column
  4293 00001027 E847030000              			call	SetConsoleChar					;display ASCII character
  4294 0000102C B020                    			mov	al,EASCIISPACE					;ASCII space
  4295 0000102E F6C301                  			test	bl,EKEYFCTRLLEFT				;left-ctrl indicated?
  4296 00001031 7402                    			jz	.30						;no, skip ahead
  4297 00001033 B043                    			mov	al,'C'						;yes, indicate with 'C'
  4298 00001035 B10F                    .30			mov	cl,15						;indicator column
  4299 00001037 E837030000              			call	SetConsoleChar					;display ASCII character
  4300 0000103C B020                    			mov	al,EASCIISPACE					;ASCII space
  4301 0000103E F6C308                  			test	bl,EKEYFCTRLRIGHT				;right-ctrl indicated?
  4302 00001041 7402                    			jz	.40						;no, skip ahead
  4303 00001043 B043                    			mov	al,'C'						;yes, indicate with 'C'
  4304 00001045 B13F                    .40			mov	cl,63						;indicator column
  4305 00001047 E827030000              			call	SetConsoleChar					;display ASCII character
  4306 0000104C B020                    			mov	al,EASCIISPACE					;ASCII space
  4307 0000104E F6C304                  			test	bl,EKEYFALTLEFT					;left-alt indicated?
  4308 00001051 7402                    			jz	.50						;no, skip ahead
  4309 00001053 B041                    			mov	al,'A'						;yes, indicate with 'A'
  4310 00001055 B110                    .50			mov	cl,16						;indicator column
  4311 00001057 E817030000              			call	SetConsoleChar					;display ASCII character
  4312 0000105C B020                    			mov	al,EASCIISPACE					;ASCII space
  4313 0000105E F6C320                  			test	bl,EKEYFALTRIGHT				;right-alt indicated?
  4314 00001061 7402                    			jz	.60						;no, skip ahead
  4315 00001063 B041                    			mov	al,'A'						;yes, indicate with 'A'
  4316 00001065 B13E                    .60			mov	cl,62						;indicator column
  4317 00001067 E807030000              			call	SetConsoleChar					;display ASCII character
  4318 0000106C B020                    			mov	al,EASCIISPACE					;ASCII space
  4319 0000106E F6C704                  			test	bh,EKEYFLOCKCAPS				;caps-lock indicated?
  4320 00001071 7402                    			jz	.70						;no, skip ahead
  4321 00001073 B043                    			mov	al,'C'						;yes, indicate with 'C'
  4322 00001075 B14E                    .70			mov	cl,78						;indicator column
  4323 00001077 E8F7020000              			call	SetConsoleChar					;display ASCII character
  4324 0000107C B020                    			mov	al,EASCIISPACE					;ASCII space
  4325 0000107E F6C702                  			test	bh,EKEYFLOCKNUM					;num-lock indicated?
  4326 00001081 7402                    			jz	.80						;no, skip ahead
  4327 00001083 B04E                    			mov	al,'N'						;yes, indicate with 'N'
  4328 00001085 B14D                    .80			mov	cl,77						;indicator column
  4329 00001087 E8E7020000              			call	SetConsoleChar					;display ASCII character
  4330 0000108C B020                    			mov	al,EASCIISPACE					;ASCII space
  4331 0000108E F6C701                  			test	bh,EKEYFLOCKSCROLL				;scroll-lock indicated?
  4332 00001091 7402                    			jz	.90						;no, skip ahead
  4333 00001093 B053                    			mov	al,'S'						;yes, indicate with 'S'
  4334 00001095 B14C                    .90			mov	cl,76						;indicator column
  4335 00001097 E8D7020000              			call	SetConsoleChar					;display ASCII character
  4336 0000109C 07                      			pop	es						;restore non-volatile regs
  4337 0000109D 59                      			pop	ecx						;
  4338 0000109E C3                      			ret							;return
  4339                                  ;-----------------------------------------------------------------------------------------------------------------------
  4340                                  ;
  4341                                  ;	Routine:	PutConsoleOIAChar
  4342                                  ;
  4343                                  ;	Description:	This routine updates the Operator Information Area (OIA).
  4344                                  ;
  4345                                  ;	In:		DS	OS data selector
  4346                                  ;
  4347                                  ;-----------------------------------------------------------------------------------------------------------------------
  4348 0000109F 53                      PutConsoleOIAChar	push	ebx						;save non-volatile regs
  4349 000010A0 51                      			push	ecx						;
  4350 000010A1 56                      			push	esi						;
  4351 000010A2 1E                      			push	ds						;
  4352 000010A3 06                      			push	es						;
  4353 000010A4 6A18                    			push	ESELDAT						;load OS data selector ...
  4354 000010A6 1F                      			pop	ds						;... into data segment register
  4355 000010A7 6A20                    			push	ESELCGA						;load CGA selector ...
  4356 000010A9 07                      			pop	es						;... into extra segment register
  4357 000010AA BE4D0A0000              			mov	esi,wbConsoleScan0				;scan codes address
  4358 000010AF B718                    			mov	bh,ECONOIAROW					;OIA row
  4359 000010B1 B300                    			mov	bl,0						;starting column
  4360 000010B3 B906000000              			mov	ecx,6						;maximum scan codes
  4361 000010B8 51                      .10			push	ecx						;save remaining count
  4362 000010B9 89D9                    			mov	ecx,ebx						;row, column
  4363 000010BB AC                      			lodsb							;read scan code
  4364 000010BC 08C0                    			or	al,al						;scan code present?
  4365 000010BE 7407                    			jz	.20						;no, skip ahead
  4366 000010C0 E852000000              			call	PutConsoleHexByte				;display scan code
  4367 000010C5 EB0E                    			jmp	.30						;continue
  4368 000010C7 B020                    .20			mov	al,' '						;ASCII space
  4369 000010C9 E8A5020000              			call	SetConsoleChar					;display space
  4370 000010CE B020                    			mov	al,' '						;ASCII space
  4371 000010D0 E89E020000              			call	SetConsoleChar					;display space
  4372 000010D5 80C302                  .30			add	bl,2						;next column (+2)
  4373 000010D8 59                      			pop	ecx						;restore remaining
  4374 000010D9 E2DD                    			loop	.10						;next code
  4375 000010DB A0530A0000              			mov	al,[wbConsoleChar]				;console ASCII character
  4376 000010E0 3C20                    			cmp	al,32						;printable? (lower-bounds)
  4377 000010E2 720D                    			jb	.40						;no, skip ahead
  4378 000010E4 3C7E                    			cmp	al,126						;printable? (upper-bounds)
  4379 000010E6 7709                    			ja	.40						;no, skip ahead
  4380 000010E8 88FD                    			mov	ch,bh						;OIA row
  4381 000010EA B128                    			mov	cl,40						;character display column
  4382 000010EC E882020000              			call	SetConsoleChar					;display ASCII character
  4383 000010F1 07                      .40			pop	es						;restore non-volatile regs
  4384 000010F2 1F                      			pop	ds						;
  4385 000010F3 5E                      			pop	esi						;
  4386 000010F4 59                      			pop	ecx						;
  4387 000010F5 5B                      			pop	ebx						;
  4388 000010F6 C3                      			ret							;return
  4389                                  ;-----------------------------------------------------------------------------------------------------------------------
  4390                                  ;
  4391                                  ;	Routine:	PutConsoleHexDword
  4392                                  ;
  4393                                  ;	Description:	This routine writes eight ASCII characters to the console representing a doubleword value.
  4394                                  ;
  4395                                  ;	In:		EAX	value
  4396                                  ;			CL	column
  4397                                  ;			CH	row
  4398                                  ;			DS	OS data selector
  4399                                  ;			ES	CGA selector
  4400                                  ;
  4401                                  ;-----------------------------------------------------------------------------------------------------------------------
  4402 000010F7 50                      PutConsoleHexDword	push	eax
  4403 000010F8 C1E810                  			shr	eax,16
  4404 000010FB E807000000              			call	PutConsoleHexWord
  4405 00001100 58                      			pop	eax
  4406 00001101 E801000000              			call	PutConsoleHexWord
  4407 00001106 C3                      			ret
  4408                                  ;-----------------------------------------------------------------------------------------------------------------------
  4409                                  ;
  4410                                  ;	Routine:	PutConsoleHexWord
  4411                                  ;
  4412                                  ;	Description:	This routine writes four ASCII characters to the console representing a word value.
  4413                                  ;
  4414                                  ;	In:		EAX	value
  4415                                  ;			CL	column
  4416                                  ;			CH	row
  4417                                  ;			DS	OS data selector
  4418                                  ;			ES	CGA selector
  4419                                  ;
  4420                                  ;-----------------------------------------------------------------------------------------------------------------------
  4421 00001107 50                      PutConsoleHexWord	push	eax
  4422 00001108 C1E808                  			shr	eax,8
  4423 0000110B E807000000              			call	PutConsoleHexByte
  4424 00001110 58                      			pop	eax
  4425 00001111 E801000000              			call	PutConsoleHexByte
  4426 00001116 C3                      			ret
  4427                                  ;-----------------------------------------------------------------------------------------------------------------------
  4428                                  ;
  4429                                  ;	Routine:	PutConsoleHexByte
  4430                                  ;
  4431                                  ;	Description:	This routine writes two ASCII characters to the console representing a byte value.
  4432                                  ;
  4433                                  ;	In:		AL	byte value
  4434                                  ;			CL	column
  4435                                  ;			CH	row
  4436                                  ;			DS	OS data selector
  4437                                  ;			ES	CGA selector
  4438                                  ;
  4439                                  ;-----------------------------------------------------------------------------------------------------------------------
  4440 00001117 53                      PutConsoleHexByte	push	ebx						;save non-volatile regs
  4441 00001118 88C3                    			mov	bl,al						;save byte value
  4442 0000111A C0E804                  			shr	al,4						;hi-order nybble
  4443 0000111D 0C30                    			or	al,030h						;apply ASCII zone
  4444 0000111F 3C3A                    			cmp	al,03ah						;numeric?
  4445 00001121 7202                    			jb	.10						;yes, skip ahead
  4446 00001123 0407                    			add	al,7						;add ASCII offset for alpha
  4447 00001125 E849020000              .10			call	SetConsoleChar					;display ASCII character
  4448 0000112A 88D8                    			mov	al,bl						;byte value
  4449 0000112C 240F                    			and	al,0fh						;lo-order nybble
  4450 0000112E 0C30                    			or	al,30h						;apply ASCII zone
  4451 00001130 3C3A                    			cmp	al,03ah						;numeric?
  4452 00001132 7202                    			jb	.20						;yes, skip ahead
  4453 00001134 0407                    			add	al,7						;add ASCII offset for alpha
  4454 00001136 E838020000              .20			call	SetConsoleChar					;display ASCII character
  4455 0000113B 5B                      			pop	ebx						;restore non-volatile regs
  4456 0000113C C3                      			ret							;return
  4457                                  ;=======================================================================================================================
  4458                                  ;
  4459                                  ;	Data-Type Conversion Helper Routines
  4460                                  ;
  4461                                  ;	UnsignedToDecimalString
  4462                                  ;	ByteToDecimalString
  4463                                  ;	UnsignedToHexadecimal
  4464                                  ;	DecimalToUnsigned
  4465                                  ;	HexadecimalToUnsigned
  4466                                  ;
  4467                                  ;=======================================================================================================================
  4468                                  ;-----------------------------------------------------------------------------------------------------------------------
  4469                                  ;
  4470                                  ;	Routine:	UnsignedToDecimalString
  4471                                  ;
  4472                                  ;	Description:	This routine creates an ASCIIZ string representing the decimal value of 32-bit binary input.
  4473                                  ;
  4474                                  ;	Input:		BH	flags		bit 0: 1 = trim leading zeros
  4475                                  ;						bit 1: 1 = include comma grouping delimiters
  4476                                  ;						bit 4: 1 = non-zero digit found (internal)
  4477                                  ;			ECX	32-bit binary
  4478                                  ;			DS:EDX	output buffer address
  4479                                  ;
  4480                                  ;-----------------------------------------------------------------------------------------------------------------------
  4481 0000113D 53                      UnsignedToDecimalString push	ebx						;save non-volatile regs
  4482 0000113E 51                      			push	ecx						;
  4483 0000113F 57                      			push	edi						;
  4484 00001140 06                      			push	es						;
  4485 00001141 1E                      			push	ds						;load data selector
  4486 00001142 07                      			pop	es						;... into extra segment reg
  4487 00001143 89D7                    			mov	edi,edx 					;output buffer address
  4488 00001145 80E70F                  			and	bh,00001111b					;zero internal flags
  4489 00001148 89CA                    			mov	edx,ecx 					;binary
  4490 0000114A B900CA9A3B              			mov	ecx,1000000000					;10^9 divisor
  4491 0000114F E871000000              			call	.30						;divide and store
  4492 00001154 B900E1F505              			mov	ecx,100000000					;10^8 divisor
  4493 00001159 E855000000              			call	.10						;divide and store
  4494 0000115E B980969800              			mov	ecx,10000000					;10^7 divisor
  4495 00001163 E85D000000              			call	.30						;divide and store
  4496 00001168 B940420F00              			mov	ecx,1000000					;10^6 divisor
  4497 0000116D E853000000              			call	.30						;divide and store
  4498 00001172 B9A0860100              			mov	ecx,100000					;10^5 divisor
  4499 00001177 E837000000              			call	.10						;divide and store
  4500 0000117C B910270000              			mov	ecx,10000					;10^4 divisor
  4501 00001181 E83F000000              			call	.30						;divide and store
  4502 00001186 B9E8030000              			mov	ecx,1000					;10^3 divisor
  4503 0000118B E835000000              			call	.30						;divide and store
  4504 00001190 B964000000              			mov	ecx,100 					;10^2 divisor
  4505 00001195 E819000000              			call	.10						;divide and store
  4506 0000119A B90A000000              			mov	ecx,10						;10^2 divisor
  4507 0000119F E821000000              			call	.30						;divide and store
  4508 000011A4 89D0                    			mov	eax,edx 					;10^1 remainder
  4509 000011A6 E827000000              			call	.40						;store
  4510 000011AB 30C0                    			xor	al,al						;null terminator
  4511 000011AD AA                      			stosb
  4512 000011AE 07                      			pop	es						;restore non-volatile regs
  4513 000011AF 5F                      			pop	edi						;
  4514 000011B0 59                      			pop	ecx						;
  4515 000011B1 5B                      			pop	ebx						;
  4516 000011B2 C3                      			ret							;return
  4517 000011B3 F6C702                  .10			test	bh,00000010b					;comma group delims?
  4518 000011B6 740D                    			jz	.30						;no, branch
  4519 000011B8 F6C701                  			test	bh,00000001b					;trim leading zeros?
  4520 000011BB 7405                    			jz	.20						;no, store delim
  4521 000011BD F6C710                  			test	bh,00010000b					;non-zero found?
  4522 000011C0 7403                    			jz	.30						;no, branch
  4523 000011C2 B02C                    .20			mov	al,','						;delimiter
  4524 000011C4 AA                      			stosb							;store delimiter
  4525 000011C5 89D0                    .30			mov	eax,edx 					;lo-orer dividend
  4526 000011C7 31D2                    			xor	edx,edx 					;zero hi-order
  4527 000011C9 F7F1                    			div	ecx						;divide by power of 10
  4528 000011CB 84C0                    			test	al,al						;zero?
  4529 000011CD 7407                    			jz	.50						;yes, branch
  4530 000011CF 80CF10                  			or	bh,00010000b					;non-zero found
  4531 000011D2 0C30                    .40			or	al,30h						;ASCII zone
  4532 000011D4 AA                      			stosb							;store digit
  4533 000011D5 C3                      			ret							;return
  4534 000011D6 F6C701                  .50			test	bh,00000001b					;trim leading zeros?
  4535 000011D9 74F7                    			jz	.40						;no, store and continue
  4536 000011DB F6C710                  			test	bh,00010000b					;non-zero found?
  4537 000011DE 75F2                    			jnz	.40						;yes, store and continue
  4538 000011E0 C3                      			ret							;return
  4539                                  ;-----------------------------------------------------------------------------------------------------------------------
  4540                                  ;
  4541                                  ;	Routine:	ByteToDecimalString
  4542                                  ;
  4543                                  ;	Description:	This routine outputs an ASCIIZ string representing the decimal value of 8-bit binary input
  4544                                  ;
  4545                                  ;	Input:		BH	flags		bit 0: 1 = trim leading zeros
  4546                                  ;						bit 1: 1 = left pad with spaces
  4547                                  ;						bit 4: 1 = non-zero digit found (internal)
  4548                                  ;			CL	8-bit binary
  4549                                  ;			DS:EDX	output buffer address
  4550                                  ;
  4551                                  ;-----------------------------------------------------------------------------------------------------------------------
  4552 000011E1 53                      ByteToDecimalString	push	ebx						;save non-volatile regs
  4553 000011E2 51                      			push	ecx						;
  4554 000011E3 57                      			push	edi						;
  4555 000011E4 06                      			push	es						;
  4556 000011E5 1E                      			push	ds						;copy data segment selector
  4557 000011E6 07                      			pop	es						;... into extra segment selector
  4558 000011E7 89D7                    			mov	edi,edx						;output buffer address
  4559 000011E9 80E70F                  			and	bh,00001111b					;zero internal flags
  4560 000011EC 88CC                    			mov	ah,cl						;8-bit binary value
  4561 000011EE B164                    			mov	cl,100						;divisor
  4562 000011F0 FC                      			cld							;forward strings
  4563 000011F1 E816000000              			call	.10						;divide and store
  4564 000011F6 B10A                    			mov	cl,10						;divisor
  4565 000011F8 E80F000000              			call	.10						;divide and store
  4566 000011FD 88E0                    			mov	al,ah						;remainder
  4567 000011FF E815000000              			call	.20						;store
  4568 00001204 30C0                    			xor	al,al						;null
  4569 00001206 AA                      			stosb							;terminate string
  4570 00001207 07                      			pop	es						;restore non-volatile regs
  4571 00001208 5F                      			pop	edi						;
  4572 00001209 59                      			pop	ecx						;
  4573 0000120A 5B                      			pop	ebx						;
  4574 0000120B C3                      			ret							;return
  4575 0000120C 88E0                    .10			mov	al,ah						;last remainder (or starting value)
  4576 0000120E 30E4                    			xor	ah,ah						;zero hi-order dividend
  4577 00001210 F6F1                    			div	cl						;divide by power or 10
  4578 00001212 84C0                    			test	al,al						;zero?
  4579 00001214 7407                    			jz	.40						;yes, branch
  4580 00001216 80CF10                  			or	bh,00010000b					;non-zero found
  4581 00001219 0C30                    .20			or	al,30h						;ASCII zone
  4582 0000121B AA                      .30			stosb							;store digit
  4583 0000121C C3                      			ret							;return
  4584 0000121D F6C701                  .40			test	bh,00000001b					;trim leading zeros?
  4585 00001220 74F7                    			jz	.20						;no, store and continue
  4586 00001222 F6C710                  			test	bh,00010000b					;non-zero found?
  4587 00001225 75F2                    			jnz	.20						;yes, store and continue
  4588 00001227 B020                    			mov	al,' '						;space
  4589 00001229 F6C702                  			test	bh,00000010b					;left pad with spaces?
  4590 0000122C 75ED                    			jnz	.30						;yes, store space and continue
  4591 0000122E C3                      			ret							;return
  4592                                  ;-----------------------------------------------------------------------------------------------------------------------
  4593                                  ;
  4594                                  ;	Routine:	UnsignedToHexadecimal
  4595                                  ;
  4596                                  ;	Description:	This routine creates an ASCIIZ string representing the hexadecimal value of binary input
  4597                                  ;
  4598                                  ;	Input:		DS:EDX	output buffer address
  4599                                  ;			ECX	32-bit binary
  4600                                  ;
  4601                                  ;-----------------------------------------------------------------------------------------------------------------------
  4602 0000122F 57                      UnsignedToHexadecimal	push	edi						;store non-volatile regs
  4603 00001230 89D7                    			mov	edi,edx						;output buffer address
  4604 00001232 89CA                    			mov	edx,ecx						;32-bit unsigned
  4605 00001234 31C9                    			xor	ecx,ecx						;zero register
  4606 00001236 B108                    			mov	cl,8						;nybble count
  4607 00001238 C1C204                  .10			rol	edx,4						;next hi-order nybble in bits 0-3
  4608 0000123B 88D0                    			mov	al,dl						;????bbbb
  4609 0000123D 240F                    			and	al,0fh						;mask out bits 4-7
  4610 0000123F 0C30                    			or	al,30h						;mask in ascii zone
  4611 00001241 3C3A                    			cmp	al,3ah						;A through F?
  4612 00001243 7202                    			jb	.20						;no, skip ahead
  4613 00001245 0407                    			add	al,7						;41h through 46h
  4614 00001247 AA                      .20			stosb							;store hexnum
  4615 00001248 E2EE                    			loop	.10						;next nybble
  4616 0000124A 30C0                    			xor	al,al						;zero reg
  4617 0000124C AA                      			stosb							;null terminate
  4618 0000124D 5F                      			pop	edi						;restore non-volatile regs
  4619 0000124E C3                      			ret							;return
  4620                                  ;-----------------------------------------------------------------------------------------------------------------------
  4621                                  ;
  4622                                  ;	Routine:	DecimalToUnsigned
  4623                                  ;
  4624                                  ;	Description:	This routine returns an unsigned integer of the value of the input ASCIIZ decimal string.
  4625                                  ;
  4626                                  ;	Input:		DS:EDX	null-terminated decimal string address
  4627                                  ;
  4628                                  ;	Output: 	EAX	unsigned integer value
  4629                                  ;
  4630                                  ;-----------------------------------------------------------------------------------------------------------------------
  4631 0000124F 56                      DecimalToUnsigned	push	esi						;save non-volatile regs
  4632 00001250 89D6                    			mov	esi,edx						;source address
  4633 00001252 31D2                    			xor	edx,edx						;zero total
  4634 00001254 AC                      .10			lodsb							;source byte
  4635 00001255 3C2C                    			cmp	al,','						;comma?
  4636 00001257 74FB                    			je	.10						;yes, ignore
  4637 00001259 84C0                    			test	al,al						;end of string?
  4638 0000125B 7421                    			jz	.30						;yes, done
  4639 0000125D 3C2E                    			cmp	al,'.'						;decimal point?
  4640 0000125F 741D                    			je	.30						;yes, done
  4641 00001261 3C30                    			cmp	al,'0'						;numeral?
  4642 00001263 7217                    			jb	.20						;no, invalid string
  4643 00001265 3C39                    			cmp	al,'9'						;numeral?
  4644 00001267 7713                    			ja	.20						;no, invalid string
  4645 00001269 240F                    			and	al,00Fh						;mask ASCII zone
  4646 0000126B 50                      			push	eax						;save numeral
  4647 0000126C D1E2                    			shl	edx,1						;total * 2
  4648 0000126E 89D0                    			mov	eax,edx						;total * 2
  4649 00001270 C1E202                  			shl	edx,2						;total * 8
  4650 00001273 01C2                    			add	edx,eax						;total * 10
  4651 00001275 58                      			pop	eax						;restore numeral
  4652 00001276 01C2                    			add	edx,eax						;accumulate decimal digit
  4653 00001278 31C0                    			xor	eax,eax						;zero register
  4654 0000127A EBD8                    			jmp	.10						;next
  4655 0000127C 31D2                    .20			xor	edx,edx						;zero result on error
  4656 0000127E 89D0                    .30			mov	eax,edx						;result
  4657 00001280 5E                      			pop	esi						;restore non-volatile regs
  4658 00001281 C3                      			ret							;return
  4659                                  ;-----------------------------------------------------------------------------------------------------------------------
  4660                                  ;
  4661                                  ;	Routine:	HexadecimalToUnsigned
  4662                                  ;
  4663                                  ;	Description:	This routine returns an unsigned integer of the value of the input ASCIIZ hexadecimal string.
  4664                                  ;
  4665                                  ;	Input:		DS:EDX	null-terminated hexadecimal string address
  4666                                  ;
  4667                                  ;	Output: 	EAX	unsigned integer value
  4668                                  ;
  4669                                  ;-----------------------------------------------------------------------------------------------------------------------
  4670 00001282 56                      HexadecimalToUnsigned	push	esi						;save non-volatile regs
  4671 00001283 89D6                    			mov	esi,edx						;source address
  4672 00001285 31D2                    			xor	edx,edx						;zero register
  4673 00001287 AC                      .10			lodsb							;source byte
  4674 00001288 84C0                    			test	al,al						;end of string?
  4675 0000128A 7410                    			jz	.30						;yes, branch
  4676 0000128C 3C39                    			cmp	al,'9'						;hexadecimal?
  4677 0000128E 7602                    			jna	.20						;no, skip ahead
  4678 00001290 2C37                    			sub	al,37h						;'A' = 41h, less 37h = 0Ah
  4679 00001292 83E00F                  .20			and	eax,0fh						;remove ascii zone
  4680 00001295 C1E204                  			shl	edx,4						;previous total x 16
  4681 00001298 01C2                    			add	edx,eax						;add prior value x 16
  4682 0000129A EBEB                    			jmp	.10						;next
  4683 0000129C 89D0                    .30			mov	eax,edx						;result
  4684 0000129E 5E                      			pop	esi						;restore non-volatile regs
  4685 0000129F C3                      			ret							;return
  4686                                  ;=======================================================================================================================
  4687                                  ;
  4688                                  ;	Message Queue Helper Routines
  4689                                  ;
  4690                                  ;	PutMessage
  4691                                  ;	GetMessage
  4692                                  ;
  4693                                  ;=======================================================================================================================
  4694                                  ;-----------------------------------------------------------------------------------------------------------------------
  4695                                  ;
  4696                                  ;	Routine:	PutMessage
  4697                                  ;
  4698                                  ;	Description:	This routine adda a message to the message queue.
  4699                                  ;
  4700                                  ;	In:		EAX	message queue selector
  4701                                  ;			ECX	hi-order data word
  4702                                  ;			EDX	lo-order data word
  4703                                  ;
  4704                                  ;	Out:		CY	0 = success
  4705                                  ;				1 = fail: queue is full
  4706                                  ;
  4707                                  ;-----------------------------------------------------------------------------------------------------------------------
  4708 000012A0 1E                      PutMessage		push	ds						;save non-volatile regs
  4709 000012A1 50                      			push	eax						;load task message queue selector ...
  4710 000012A2 1F                      			pop	ds						;... into data segment register
  4711 000012A3 A104000000              			mov	eax,[MQTail]					;tail ptr
  4712 000012A8 833800                  			cmp	dword [eax],0					;is queue full?
  4713 000012AB F9                      			stc							;assume failure
  4714 000012AC 7517                    			jne	.20						;yes, cannot store
  4715 000012AE 8910                    			mov	[eax],edx					;store lo-order data
  4716 000012B0 894804                  			mov	[eax+4],ecx					;store hi-order data
  4717 000012B3 83C008                  			add	eax,8						;next queue element adr
  4718 000012B6 25FC030000              			and	eax,03fch					;at end of queue?
  4719 000012BB 7502                    			jnz	.10						;no, skip ahead
  4720 000012BD B008                    			mov	al,8						;reset to top of queue
  4721 000012BF A304000000              .10			mov	[MQTail],eax					;save new tail ptr
  4722 000012C4 F8                      			clc							;indicate success
  4723 000012C5 1F                      .20			pop	ds						;restore non-volatile regs
  4724 000012C6 C3                      			ret							;return
  4725                                  ;-----------------------------------------------------------------------------------------------------------------------
  4726                                  ;
  4727                                  ;	Routine:	GetMessage
  4728                                  ;
  4729                                  ;	Description:	This routine reads and removes a message from the message queue.
  4730                                  ;
  4731                                  ;	Out:		EAX	lo-order message data
  4732                                  ;			EDX	hi-order message data
  4733                                  ;
  4734                                  ;			CY	0 = message read
  4735                                  ;				1 = no message to read
  4736                                  ;
  4737                                  ;-----------------------------------------------------------------------------------------------------------------------
  4738 000012C7 53                      GetMessage		push	ebx						;save non-volatile regs
  4739 000012C8 51                      			push	ecx						;
  4740 000012C9 1E                      			push	ds						;
  4741 000012CA 6A2C                    			push	ESELMQ						;load message queue selector ...
  4742 000012CC 1F                      			pop	ds						;... into data segment register
  4743 000012CD 8B1D00000000            			mov	ebx,[MQHead]					;head ptr
  4744 000012D3 8B03                    			mov	eax,[ebx]					;lo-order 32 bits
  4745 000012D5 8B5304                  			mov	edx,[ebx+4]					;hi-order 32 bits
  4746 000012D8 09D0                    			or	eax,edx						;is queue empty?
  4747 000012DA F9                      			stc							;assume queue is emtpy
  4748 000012DB 741B                    			jz	.20						;yes, skip ahead
  4749 000012DD 31C9                    			xor	ecx,ecx						;store zero
  4750 000012DF 890B                    			mov	[ebx],ecx					;... in lo-order dword
  4751 000012E1 894B04                  			mov	[ebx+4],ecx					;... in hi-order dword
  4752 000012E4 83C308                  			add	ebx,8						;next queue element
  4753 000012E7 81E3FC030000            			and	ebx,03fch					;at end of queue?
  4754 000012ED 7502                    			jnz	.10						;no, skip ahead
  4755 000012EF B308                    			mov	bl,8						;reset to 1st entry
  4756 000012F1 891D00000000            .10			mov	[MQHead],ebx					;save new head ptr
  4757 000012F7 F8                      			clc							;indicate message read
  4758 000012F8 1F                      .20			pop	ds						;restore non-volatile regs
  4759 000012F9 59                      			pop	ecx						;
  4760 000012FA 5B                      			pop	ebx						;
  4761 000012FB C3                      			ret							;return
  4762                                  ;=======================================================================================================================
  4763                                  ;
  4764                                  ;	Memory-Mapped Video Routines
  4765                                  ;
  4766                                  ;	These routines read and/or write directly to CGA video memory (B800:0)
  4767                                  ;
  4768                                  ;	ClearConsoleScreen
  4769                                  ;	ScrollConsoleRow
  4770                                  ;	SetConsoleChar
  4771                                  ;
  4772                                  ;=======================================================================================================================
  4773                                  ;-----------------------------------------------------------------------------------------------------------------------
  4774                                  ;
  4775                                  ;	Routine:	ClearConsoleScreen
  4776                                  ;
  4777                                  ;	Description:	This routine clears the console (CGA) screen.
  4778                                  ;
  4779                                  ;-----------------------------------------------------------------------------------------------------------------------
  4780 000012FC 51                      ClearConsoleScreen	push	ecx						;save non-volatile regs
  4781 000012FD 57                      			push	edi						;
  4782 000012FE 1E                      			push	ds						;
  4783 000012FF 06                      			push	es						;
  4784 00001300 6A18                    			push	ESELDAT						;load OS Data selector ...
  4785 00001302 1F                      			pop	ds						;... into DS register
  4786 00001303 6A20                    			push	ESELCGA						;load CGA selector ...
  4787 00001305 07                      			pop	es						;... into ES register
  4788 00001306 B820072007              			mov	eax,ECONCLEARDWORD				;initializtion value
  4789 0000130B B9C0030000              			mov	ecx,ECONROWDWORDS*(ECONROWS)			;double-words to clear
  4790 00001310 31FF                    			xor	edi,edi						;target offset
  4791 00001312 FC                      			cld							;forward strings
  4792 00001313 F3AB                    			rep	stosd						;reset screen body
  4793 00001315 B820702070              			mov	eax,ECONOIADWORD				;OIA attribute and space
  4794 0000131A B928000000              			mov	ecx,ECONROWDWORDS				;double-words per row
  4795 0000131F F3AB                    			rep	stosd						;reset OIA line
  4796 00001321 30C0                    			xor	al,al						;zero register
  4797 00001323 A2490A0000              			mov	[wbConsoleRow],al				;reset console row
  4798 00001328 A2480A0000              			mov	[wbConsoleColumn],al				;reset console column
  4799 0000132D E857000000              			call	PlaceCursor					;place cursor at current position
  4800 00001332 07                      			pop	es						;restore non-volatile regs
  4801 00001333 1F                      			pop	ds						;
  4802 00001334 5F                      			pop	edi						;
  4803 00001335 59                      			pop	ecx						;
  4804 00001336 C3                      			ret							;return
  4805                                  ;-----------------------------------------------------------------------------------------------------------------------
  4806                                  ;
  4807                                  ;	Routine:	ScrollConsoleRow
  4808                                  ;
  4809                                  ;	Description:	This routine scrolls the console (text) screen up one row.
  4810                                  ;
  4811                                  ;-----------------------------------------------------------------------------------------------------------------------
  4812 00001337 51                      ScrollConsoleRow	push	ecx						;save non-volatile regs
  4813 00001338 56                      			push	esi						;
  4814 00001339 57                      			push	edi						;
  4815 0000133A 1E                      			push	ds						;
  4816 0000133B 06                      			push	es						;
  4817 0000133C 6A20                    			push	ESELCGA						;load CGA video selector ...
  4818 0000133E 1F                      			pop	ds						;... into DS
  4819 0000133F 6A20                    			push	ESELCGA						;load CGA video selector ...
  4820 00001341 07                      			pop	es						;... into ES
  4821 00001342 B998030000              			mov	ecx,ECONROWDWORDS*(ECONROWS-1)			;double-words to move
  4822 00001347 BEA0000000              			mov	esi,ECONROWBYTES				;esi = source (line 2)
  4823 0000134C 31FF                    			xor	edi,edi						;edi = target (line 1)
  4824 0000134E FC                      			cld							;forward strings
  4825 0000134F F3A5                    			rep	movsd						;move 24 lines up
  4826 00001351 B820072007              			mov	eax,ECONCLEARDWORD				;attribute and ASCII space
  4827 00001356 B928000000              			mov	ecx,ECONROWDWORDS				;double-words per row
  4828 0000135B F3AB                    			rep	stosd						;clear bottom row
  4829 0000135D 07                      			pop	es						;restore non-volatile regs
  4830 0000135E 1F                      			pop	ds						;
  4831 0000135F 5F                      			pop	edi						;
  4832 00001360 5E                      			pop	esi						;
  4833 00001361 59                      			pop	ecx						;
  4834 00001362 C3                      			ret							;return
  4835                                  ;-----------------------------------------------------------------------------------------------------------------------
  4836                                  ;
  4837                                  ;	Routine:	SetConsoleString
  4838                                  ;
  4839                                  ;	Description:	This routine outputs a sequence of ASCII character at the given row and column.
  4840                                  ;
  4841                                  ;	In:		ESI	source offset (DS:)
  4842                                  ;			CL	column
  4843                                  ;			CH	row
  4844                                  ;			ES	CGA selector
  4845                                  ;
  4846                                  ;-----------------------------------------------------------------------------------------------------------------------
  4847 00001363 56                      SetConsoleString	push	esi						;save non-volatile regs
  4848 00001364 FC                      			cld							;forward strings
  4849 00001365 AC                      .10			lodsb							;next ASCII character
  4850 00001366 84C0                    			test	al,al						;end of string?
  4851 00001368 7407                    			jz	.20						;yes, branch
  4852 0000136A E804000000              			call	SetConsoleChar					;store character
  4853 0000136F EBF4                    			jmp	.10						;continue
  4854 00001371 5E                      .20			pop	esi						;restore non-volatile regs
  4855 00001372 C3                      			ret							;return
  4856                                  ;-----------------------------------------------------------------------------------------------------------------------
  4857                                  ;
  4858                                  ;	Routine:	SetConsoleChar
  4859                                  ;
  4860                                  ;	Description:	This routine outputs an ASCII character at the given row and column.
  4861                                  ;
  4862                                  ;	In:		AL	ASCII character
  4863                                  ;			CL	column
  4864                                  ;			CH	row
  4865                                  ;			ES	CGA selector
  4866                                  ;
  4867                                  ;	Out:		EAX	last target address written (ES:)
  4868                                  ;			CL	column + 1
  4869                                  ;
  4870                                  ;-----------------------------------------------------------------------------------------------------------------------
  4871 00001373 88C2                    SetConsoleChar		mov	dl,al						;ASCII character
  4872 00001375 0FB6C5                  			movzx	eax,ch						;row
  4873 00001378 B450                    			mov	ah,ECONCOLS					;cols/row
  4874 0000137A F6E4                    			mul	ah						;row * cols/row
  4875 0000137C 00C8                    			add	al,cl						;add column
  4876 0000137E 80D400                  			adc	ah,0						;handle carry
  4877 00001381 D1E0                    			shl	eax,1						;screen offset
  4878 00001383 268810                  			mov	[es:eax],dl					;store character
  4879 00001386 FEC1                    			inc	cl						;next column
  4880 00001388 C3                      			ret							;return
  4881                                  ;=======================================================================================================================
  4882                                  ;
  4883                                  ;	Input/Output Routines
  4884                                  ;
  4885                                  ;	These routines read and/or write directly to ports.
  4886                                  ;
  4887                                  ;	PlaceCursor
  4888                                  ;	PutPrimaryEndOfInt
  4889                                  ;	PutSecondaryEndOfInt
  4890                                  ;	ReadRealTimeClock
  4891                                  ;	ResetSystem
  4892                                  ;	SetKeyboardLamps
  4893                                  ;	WaitForKeyInBuffer
  4894                                  ;	WaitForKeyOutBuffer
  4895                                  ;
  4896                                  ;=======================================================================================================================
  4897                                  ;-----------------------------------------------------------------------------------------------------------------------
  4898                                  ;
  4899                                  ;	Routine:	PlaceCursor
  4900                                  ;
  4901                                  ;	Description:	This routine positions the cursor on the console.
  4902                                  ;
  4903                                  ;	In:		DS	OS data selector
  4904                                  ;
  4905                                  ;-----------------------------------------------------------------------------------------------------------------------
  4906 00001389 51                      PlaceCursor		push	ecx						;save non-volatile regs
  4907 0000138A A0490A0000              			mov	al,[wbConsoleRow]				;al = row
  4908 0000138F B450                    			mov	ah,ECONCOLS					;ah = cols/row
  4909 00001391 F6E4                    			mul	ah						;row offset
  4910 00001393 0205480A0000            			add	al,[wbConsoleColumn]				;add column
  4911 00001399 80D400                  			adc	ah,0						;add overflow
  4912 0000139C 89C1                    			mov	ecx,eax						;screen offset
  4913 0000139E B2D4                    			mov	dl,ECRTPORTLO					;crt controller port lo
  4914 000013A0 B603                    			mov	dh,ECRTPORTHI					;crt controller port hi
  4915 000013A2 B00E                    			mov	al,ECRTCURLOCHI					;crt cursor loc reg hi
  4916 000013A4 EE                      			out	dx,al						;select register
  4917 000013A5 42                      			inc	edx						;data port
  4918 000013A6 88E8                    			mov	al,ch						;hi-order cursor loc
  4919 000013A8 EE                      			out	dx,al						;store hi-order loc
  4920 000013A9 4A                      			dec	edx						;register select port
  4921 000013AA B00F                    			mov	al,ECRTCURLOCLO					;crt cursor loc reg lo
  4922 000013AC EE                      			out	dx,al						;select register
  4923 000013AD 42                      			inc	edx						;data port
  4924 000013AE 88C8                    			mov	al,cl						;lo-order cursor loc
  4925 000013B0 EE                      			out	dx,al						;store lo-order loc
  4926 000013B1 59                      			pop	ecx						;restore non-volatile regs
  4927 000013B2 C3                      			ret							;return
  4928                                  ;-----------------------------------------------------------------------------------------------------------------------
  4929                                  ;
  4930                                  ;	Routine:	PutPrimaryEndOfInt
  4931                                  ;
  4932                                  ;	Description:	This routine sends a non-specific end-of-interrupt signal to the primary PIC.
  4933                                  ;
  4934                                  ;-----------------------------------------------------------------------------------------------------------------------
  4935 000013B3 FB                      PutPrimaryEndOfInt	sti							;enable maskable interrupts
  4936 000013B4 B020                    			mov	al,EPICEOI					;non-specific end-of-interrupt
  4937 000013B6 E620                    			out	EPICPORTPRI,al					;send EOI to primary PIC
  4938 000013B8 C3                      			ret							;return
  4939                                  ;-----------------------------------------------------------------------------------------------------------------------
  4940                                  ;
  4941                                  ;	Routine:	PutSecondaryEndOfInt
  4942                                  ;
  4943                                  ;	Description:	This routine sends a non-specific end-of-interrupt signal to the secondary PIC.
  4944                                  ;
  4945                                  ;-----------------------------------------------------------------------------------------------------------------------
  4946 000013B9 FB                      PutSecondaryEndOfInt	sti							;enable maskable interrupts
  4947 000013BA B020                    			mov	al,EPICEOI					;non-specific end-of-interrupt
  4948 000013BC E6A0                    			out	EPICPORTSEC,al					;send EOI to secondary PIC
  4949 000013BE C3                      			ret							;return
  4950                                  ;-----------------------------------------------------------------------------------------------------------------------
  4951                                  ;
  4952                                  ;	Routine:	ReadRealTimeClock
  4953                                  ;
  4954                                  ;	Description:	This routine gets current date time from the real-time clock.
  4955                                  ;
  4956                                  ;	In:		DS:EBX	DATETIME structure
  4957                                  ;
  4958                                  ;-----------------------------------------------------------------------------------------------------------------------
  4959 000013BF 56                      ReadRealTimeClock	push	esi						;save non-volatile regs
  4960 000013C0 57                      			push	edi						;
  4961 000013C1 06                      			push	es						;
  4962 000013C2 1E                      			push	ds						;store data selector ...
  4963 000013C3 07                      			pop	es						;... in es register
  4964 000013C4 89DF                    			mov	edi,ebx						;date-time structure
  4965 000013C6 B000                    			mov	al,ERTCSECONDREG				;second register
  4966 000013C8 E670                    			out	ERTCREGPORT,al					;select second register
  4967 000013CA E471                    			in	al,ERTCDATAPORT					;read second register
  4968 000013CC FC                      			cld							;forward strings
  4969 000013CD AA                      			stosb							;store second value
  4970 000013CE B002                    			mov	al,ERTCMINUTEREG				;minute register
  4971 000013D0 E670                    			out	ERTCREGPORT,al					;select minute register
  4972 000013D2 E471                    			in	al,ERTCDATAPORT					;read minute register
  4973 000013D4 AA                      			stosb							;store minute value
  4974 000013D5 B004                    			mov	al,ERTCHOURREG					;hour register
  4975 000013D7 E670                    			out	ERTCREGPORT,al					;select hour register
  4976 000013D9 E471                    			in	al,ERTCDATAPORT					;read hour register
  4977 000013DB AA                      			stosb							;store hour value
  4978 000013DC B006                    			mov	al,ERTCWEEKDAYREG				;weekday register
  4979 000013DE E670                    			out	ERTCREGPORT,al					;select weekday register
  4980 000013E0 E471                    			in	al,ERTCDATAPORT					;read weekday register
  4981 000013E2 AA                      			stosb							;store weekday value
  4982 000013E3 B007                    			mov	al,ERTCDAYREG					;day register
  4983 000013E5 E670                    			out	ERTCREGPORT,al					;select day register
  4984 000013E7 E471                    			in	al,ERTCDATAPORT					;read day register
  4985 000013E9 AA                      			stosb							;store day value
  4986 000013EA B008                    			mov	al,ERTCMONTHREG					;month register
  4987 000013EC E670                    			out	ERTCREGPORT,al					;select month register
  4988 000013EE E471                    			in	al,ERTCDATAPORT					;read month register
  4989 000013F0 AA                      			stosb							;store month value
  4990 000013F1 B009                    			mov	al,ERTCYEARREG					;year register
  4991 000013F3 E670                    			out	ERTCREGPORT,al					;select year register
  4992 000013F5 E471                    			in	al,ERTCDATAPORT					;read year register
  4993 000013F7 AA                      			stosb							;store year value
  4994 000013F8 B032                    			mov	al,ERTCCENTURYREG				;century register
  4995 000013FA E670                    			out	ERTCREGPORT,al					;select century register
  4996 000013FC E471                    			in	al,ERTCDATAPORT					;read century register
  4997 000013FE AA                      			stosb							;store century value
  4998 000013FF B00B                    			mov	al,ERTCSTATUSREG				;status register
  4999 00001401 E670                    			out	ERTCREGPORT,al					;select status register
  5000 00001403 E471                    			in	al,ERTCDATAPORT					;read status register
  5001 00001405 A804                    			test	al,ERTCBINARYVALS				;test if values are binary
  5002 00001407 751D                    			jnz	.20						;skip ahead if binary values
  5003 00001409 89DE                    			mov	esi,ebx						;date-time structure address
  5004 0000140B 89DF                    			mov	edi,ebx						;date-time structure address
  5005 0000140D B908000000              			mov	ecx,8						;loop counter
  5006 00001412 AC                      .10			lodsb							;BCD value
  5007 00001413 88C4                    			mov	ah,al						;BCD value
  5008 00001415 240F                    			and	al,00001111b					;low-order decimal zone
  5009 00001417 80E4F0                  			and	ah,11110000b					;hi-order decimal zone
  5010 0000141A D0EC                    			shr	ah,1						;hi-order decimal * 8
  5011 0000141C 00E0                    			add	al,ah						;low-order + hi-order * 8
  5012 0000141E C0EC02                  			shr	ah,2						;hi-order decimal * 2
  5013 00001421 00E0                    			add	al,ah						;low-order + hi-order * 10
  5014 00001423 AA                      			stosb							;replace BCD with binary
  5015 00001424 E2EC                    			loop	.10						;next value
  5016 00001426 07                      .20			pop	es						;restore non-volatile regs
  5017 00001427 5F                      			pop	edi						;
  5018 00001428 5E                      			pop	esi						;
  5019 00001429 C3                      			ret							;return
  5020                                  ;-----------------------------------------------------------------------------------------------------------------------
  5021                                  ;
  5022                                  ;	Routine:	ResetSystem
  5023                                  ;
  5024                                  ;	Description:	This routine restarts the system using the 8042 controller.
  5025                                  ;
  5026                                  ;	Out:		N/A	This routine does not return.
  5027                                  ;
  5028                                  ;-----------------------------------------------------------------------------------------------------------------------
  5029 0000142A B9FFFF1F00              ResetSystem		mov	ecx,001fffffh					;delay to clear ints
  5030 0000142F E2FE                    			loop	$						;clear interrupts
  5031 00001431 B0FE                    			mov	al,EKEYBCMDRESET				;mask out bit zero
  5032 00001433 E664                    			out	EKEYBPORTSTAT,al				;drive bit zero low
  5033 00001435 FB                      .10			sti							;enable maskable interrupts
  5034 00001436 F4                      			hlt							;halt until interrupt
  5035 00001437 EBFC                    			jmp	.10						;repeat until reset kicks in
  5036                                  ;-----------------------------------------------------------------------------------------------------------------------
  5037                                  ;
  5038                                  ;	Routine:	SetKeyboardLamps
  5039                                  ;
  5040                                  ;	Description:	This routine sends the set/reset mode indicators command to the keyboard device.
  5041                                  ;
  5042                                  ;	In:		BH	00000CNS (C:Caps Lock,N:Num Lock,S:Scroll Lock)
  5043                                  ;
  5044                                  ;-----------------------------------------------------------------------------------------------------------------------
  5045 00001439 E81C000000              SetKeyboardLamps	call	WaitForKeyInBuffer				;wait for input buffer ready
  5046 0000143E B0ED                    			mov	al,EKEYBCMDLAMPS				;set/reset lamps command
  5047 00001440 E660                    			out	EKEYBPORTDATA,al				;send command to 8042
  5048 00001442 E821000000              			call	WaitForKeyOutBuffer				;wait for 8042 result
  5049 00001447 E460                    			in	al,EKEYBPORTDATA				;read 8042 'ACK' (0fah)
  5050 00001449 E80C000000              			call	WaitForKeyInBuffer				;wait for input buffer ready
  5051 0000144E 88F8                    			mov	al,bh						;set/reset lamps value
  5052 00001450 E660                    			out	EKEYBPORTDATA,al				;send lamps value
  5053 00001452 E811000000              			call	WaitForKeyOutBuffer				;wait for 8042 result
  5054 00001457 E460                    			in	al,EKEYBPORTDATA				;read 8042 'ACK' (0fah)
  5055 00001459 C3                      			ret							;return
  5056                                  ;-----------------------------------------------------------------------------------------------------------------------
  5057                                  ;
  5058                                  ;	Routine:	WaitForKeyInBuffer
  5059                                  ;
  5060                                  ;	Description:	This routine waits for keyboard input buffer to be ready for input.
  5061                                  ;
  5062                                  ;	Out:		ZF	1 = Input buffer ready
  5063                                  ;				0 = Input buffer not ready after timeout
  5064                                  ;
  5065                                  ;-----------------------------------------------------------------------------------------------------------------------
  5066 0000145A 51                      WaitForKeyInBuffer	push	ecx						;save non-volatile regs
  5067 0000145B B900000100              			mov	ecx,EKEYBWAITLOOP				;keyboard controller timeout
  5068 00001460 E464                    .10			in	al,EKEYBPORTSTAT				;keyboard status byte
  5069 00001462 A802                    			test	al,EKEYBBITIN					;is input buffer still full?
  5070 00001464 E0FA                    			loopnz	.10						;yes, repeat till timeout
  5071 00001466 59                      			pop	ecx						;restore non-volatile regs
  5072 00001467 C3                      			ret							;return
  5073                                  ;-----------------------------------------------------------------------------------------------------------------------
  5074                                  ;
  5075                                  ;	Routine:	WaitForKeyOutBuffer
  5076                                  ;
  5077                                  ;	Description:	This routine waits for keyboard output buffer to have data to read.
  5078                                  ;
  5079                                  ;	Out:		ZF	1 = Output buffer has data from controller
  5080                                  ;				0 = Output buffer empty after timeout
  5081                                  ;
  5082                                  ;-----------------------------------------------------------------------------------------------------------------------
  5083 00001468 51                      WaitForKeyOutBuffer	push	ecx						;save non-volatile regs
  5084 00001469 B900000100              			mov	ecx,EKEYBWAITLOOP				;keyboard controller timeout
  5085 0000146E E464                    .10			in	al,EKEYBPORTSTAT				;keyboard status byte
  5086 00001470 A801                    			test	al,EKEYBBITOUT					;output buffer status bit
  5087 00001472 E1FA                    			loopz	.10						;loop until output buffer bit
  5088 00001474 59                      			pop	ecx						;restore non-volatile regs
  5089 00001475 C3                      			ret							;return
  5090                                  ;-----------------------------------------------------------------------------------------------------------------------
  5091                                  ;
  5092                                  ;	End of the Kernel Function Library
  5093                                  ;
  5094                                  ;-----------------------------------------------------------------------------------------------------------------------
  5095 00001476 00<rept>                			times	8190-($-$$) db 0h				;zero fill to end of section
  5096 00001FFE 55AA                    			db	055h,0AAh					;end of segment
  5097                                  ;=======================================================================================================================
  5098                                  ;
  5099                                  ;	Console Task
  5100                                  ;
  5101                                  ;	The only task defined in the kernel is the console task. This task consists of code, data, stack, and task state
  5102                                  ;	segments and a local descriptor table. The console task accepts and echos user keyboard input to the console
  5103                                  ;	screen and responds to user commands.
  5104                                  ;
  5105                                  ;=======================================================================================================================
  5106                                  ;-----------------------------------------------------------------------------------------------------------------------
  5107                                  ;
  5108                                  ;	Console Stack								@disk: 007400	@mem:  004000
  5109                                  ;
  5110                                  ;	This is the stack for the console task. It supports 448 nested calls.
  5111                                  ;
  5112                                  ;-----------------------------------------------------------------------------------------------------------------------
  5113                                  section			constack						;console task stack
  5114 00000000 00<rept>                			times	1792-($-$$) db 0h				;zero fill to end of section
  5115                                  ;-----------------------------------------------------------------------------------------------------------------------
  5116                                  ;
  5117                                  ;	Console Local Descriptor Table						@disk: 007B00	@mem:  004700
  5118                                  ;
  5119                                  ;	This is the LDT for the console task. It defines the stack, code, data and queue segments as well as data
  5120                                  ;	aliases for the TSS LDT. Data aliases allow inspection and altering of the TSS and LDT. This LDT can hold up to
  5121                                  ;	16 descriptors. Six are initially defined.
  5122                                  ;
  5123                                  ;-----------------------------------------------------------------------------------------------------------------------
  5124                                  section			conldt							;console local descriptors
  5125 00000000 7F00804700934000        			dq	004093004780007Fh				;04 TSS alias
  5126 00000008 7F00004700934000        			dq	004093004700007Fh				;0C LDT alias
  5127 00000010 FF06004000934000        			dq	00409300400006FFh				;14 stack
  5128 00000018 FFFF00000093CF00        			dq	00CF93000000FFFFh				;1C data
  5129 00000020 FF0F0050009B4000        			dq	00409B0050000FFFh				;24 code
  5130 00000028 FF07004800934000        			dq	00409300480007FFh				;2C message queue
  5131 00000030 00<rept>                			times	128-($-$$) db 0h				;zero fill to end of section
  5132                                  ;-----------------------------------------------------------------------------------------------------------------------
  5133                                  ;
  5134                                  ;	Console Task State Segment						@disk: 007B80	@mem:  004780
  5135                                  ;
  5136                                  ;	This is the TSS for the console task. All rings share the same stack. DS and ES are set to the console data
  5137                                  ;	segment. CS to console code.
  5138                                  ;
  5139                                  ;-----------------------------------------------------------------------------------------------------------------------
  5140                                  section			contss							;console task state segment
  5141 00000000 00000000                			dd	0						;00 back-link tss
  5142 00000004 00070000                			dd	0700h						;04 esp ring 0
  5143 00000008 14000000                			dd	0014h						;08 ss ring 0
  5144 0000000C 00070000                			dd	0700h						;0C esp ring 1
  5145 00000010 14000000                			dd	0014h						;10 es ring 1
  5146 00000014 00070000                			dd	0700h						;14 esp ring 2
  5147 00000018 14000000                			dd	0014h						;18 ss ring 2
  5148 0000001C 00000000                			dd	0						;1C cr ring 3
  5149 00000020 00000000                			dd	0						;20 eip
  5150 00000024 00020000                			dd	0200h						;24 eflags
  5151 00000028 00000000                			dd	0						;28 eax
  5152 0000002C 00000000                			dd	0						;2C ecx
  5153 00000030 00000000                			dd	0						;30 edx
  5154 00000034 00000000                			dd	0						;34 ebx
  5155 00000038 00070000                			dd	0700h						;38 esp ring 3
  5156 0000003C 00000000                			dd	0						;3C ebp
  5157 00000040 00000000                			dd	0						;40 esi
  5158 00000044 00000000                			dd	0						;44 edi
  5159 00000048 1C000000                			dd	001Ch						;48 es
  5160 0000004C 24000000                			dd	0024h						;4C cs
  5161 00000050 14000000                			dd	0014h						;50 ss ring 3
  5162 00000054 1C000000                			dd	001Ch						;54 ds
  5163 00000058 00000000                			dd	0						;58 fs
  5164 0000005C 00000000                			dd	0						;5c gs
  5165 00000060 60000000                			dd	ESELCONSOLELDT					;60 ldt selector in gdt
  5166 00000064 00<rept>                			times	128-($-$$) db 0h				;zero fill to end of section
  5167                                  ;-----------------------------------------------------------------------------------------------------------------------
  5168                                  ;
  5169                                  ;	Console Message Queue							@disk: 007C00	@mem: 004800
  5170                                  ;
  5171                                  ;	The console message queue is 2048 bytes of memory organized as a queue of 510 double words (4 bytes each) and
  5172                                  ;	two double word values that act as indices. The queue is a FIFO that is fed by the keyboard hardware interrupt
  5173                                  ;	handler and consumed by a service routine called from a task. Each queue entry defines an input (keystroke)
  5174                                  ;	event.
  5175                                  ;
  5176                                  ;-----------------------------------------------------------------------------------------------------------------------
  5177                                  section			conmque							;console message queue
  5178 00000000 08000000                			dd	8						;head pointer
  5179 00000004 08000000                			dd	8						;tail pointer
  5180 00000008 00000000<rept>          			times	510 dd 0					;queue elements
  5181                                  ;-----------------------------------------------------------------------------------------------------------------------
  5182                                  ;
  5183                                  ;	Console Code								@disk: 008400	@mem: 005000
  5184                                  ;
  5185                                  ;	This is the code for the console task. The task is defined in the GDT in two descriptors, the Local Descriptor
  5186                                  ;	Table (LDT) at 0050h and the Task State Segment (TSS) at 0058h. Jumping to or calling a TSS selector causes a
  5187                                  ;	task switch, giving control to the code for the task at the CS:IP defined in the TSS for the current ring level.
  5188                                  ;	The initial CS:IP in the Console TSS is 24h:0, where 24h is a selector in the LDT. This selector points to the
  5189                                  ;	concode section, loaded into memory 5000h by the Loader. The console task is dedicated to accepting user key-
  5190                                  ;	board input, echoing to the console screen and responding to user commands.
  5191                                  ;
  5192                                  ;	When control reaches this section, our addressability is set up according to the following diagram.
  5193                                  ;
  5194                                  ;	DS,ES --------> 000000	+-----------------------------------------------+ DS,ES:0000
  5195                                  ;				|  Real Mode Interrupt Vectors			|
  5196                                  ;			000400	+-----------------------------------------------+ DS,ES:0400
  5197                                  ;				|  Reserved BIOS Memory Area			|
  5198                                  ;			000800	+-----------------------------------------------+ DS,ES:0800
  5199                                  ;				|  Shared Kernel Memory Area			|
  5200                                  ;			001000	+-----------------------------------------------+		<-- GDTR
  5201                                  ;				|  Global Descriptor Table (GDT)		|
  5202                                  ;			001800	+-----------------------------------------------+		<-- IDTR
  5203                                  ;				|  Interrupt Descriptor Table (IDT)		|
  5204                                  ;			002000	+-----------------------------------------------+
  5205                                  ;				|  Interrupt Handlers				|
  5206                                  ;				|  Kernel Function Library			|
  5207                                  ;	SS ----------->	004000	+===============================================+ SS:0000
  5208                                  ;				|  Console Task Stack Area			|
  5209                                  ;	SS:SP --------> 004700	+-----------------------------------------------+ SS:0700	<-- LDTR = GDT.SEL 0050h
  5210                                  ;				|  Console Task Local Descriptor Table (LDT)	|
  5211                                  ;			004780	+-----------------------------------------------+		<-- TR  = GDT.SEL 0058h
  5212                                  ;				|  Console Task Task State Segment (TSS)	|
  5213                                  ;			004800	+-----------------------------------------------+
  5214                                  ;				|  Console Task Message Queue			|
  5215                                  ;	CS,CS:IP ----->	005000	+-----------------------------------------------+ CS:0000
  5216                                  ;				|  Console Task Code				|
  5217                                  ;				|  Console Task Constants			|
  5218                                  ;			006000	+===============================================+
  5219                                  ;
  5220                                  ;-----------------------------------------------------------------------------------------------------------------------
  5221                                  section			concode	vstart=05000h					;labels relative to 5000h
  5222 00000000 E874000000              ConCode			call	ConInitializeData				;initialize console variables
  5223                                  
  5224                                  			clearConsoleScreen					;clear the console screen
  5224 00000005 B002                <1>  mov al,eClearConsoleScreen
  5224 00000007 CD30                <1>  int _svc
  5225                                  			putConsoleString czTitle				;display startup message
  5225 00000009 BA[47090000]        <1>  mov edx,%1
  5225 0000000E B00B                <1>  mov al,ePutConsoleString
  5225 00000010 CD30                <1>  int _svc
  5226                                  .10			putConsoleString czPrompt				;display input prompt
  5226                              <1> .10 :
  5226 00000012 BA[26090000]        <1>  mov edx,%1
  5226 00000017 B00B                <1>  mov al,ePutConsoleString
  5226 00000019 CD30                <1>  int _svc
  5227                                  			placeCursor						;set CRT cursor location
  5227 0000001B B00A                <1>  mov al,ePlaceCursor
  5227 0000001D CD30                <1>  int _svc
  5228                                  			getConsoleString wzConsoleInBuffer,79,1,13		;accept keyboard input
  5228 0000001F BA580A0000          <1>  mov edx,%1
  5228 00000024 B94F000000          <1>  mov ecx,%2
  5228 00000029 B701                <1>  mov bh,%3
  5228 0000002B B30D                <1>  mov bl,%4
  5228 0000002D B007                <1>  mov al,eGetConsoleString
  5228 0000002F CD30                <1>  int _svc
  5229                                  			putConsoleString czNewLine				;newline
  5229 00000031 BA[C2080000]        <1>  mov edx,%1
  5229 00000036 B00B                <1>  mov al,ePutConsoleString
  5229 00000038 CD30                <1>  int _svc
  5230                                  
  5231 0000003A C605A80A000000          			mov	byte [wzConsoleToken],0				;null-terminate token buffer
  5232 00000041 BA580A0000              			mov	edx,wzConsoleInBuffer				;console input buffer
  5233 00000046 BBA80A0000              			mov	ebx,wzConsoleToken				;token buffer
  5234 0000004B E879000000              			call	ConTakeToken					;handle console input
  5235 00000050 BAA80A0000              			mov	edx,wzConsoleToken				;token buffer
  5236 00000055 E89D000000              			call	ConDetermineCommand				;determine command number
  5237 0000005A 83F81A                  			cmp	eax,ECONJMPTBLCNT				;valid command number?
  5238 0000005D 720B                    			jb	.20						;yes, branch
  5239                                  
  5240                                  			putConsoleString czUnknownCommand			;display error message
  5240 0000005F BA[65090000]        <1>  mov edx,%1
  5240 00000064 B00B                <1>  mov al,ePutConsoleString
  5240 00000066 CD30                <1>  int _svc
  5241                                  
  5242 00000068 EBA8                    			jmp	.10						;next command
  5243 0000006A C1E002                  .20			shl	eax,2						;index into jump table
  5244 0000006D BA[57070000]            			mov	edx,tConJmpTbl					;jump table base address
  5245 00000072 8B0402                  			mov	eax,[edx+eax]					;command handler routine address
  5246 00000075 FFD0                    			call	eax						;call command handler
  5247 00000077 EB99                    			jmp	.10						;next command
  5248                                  ;-----------------------------------------------------------------------------------------------------------------------
  5249                                  ;
  5250                                  ;	Routine:	ConInitializeData
  5251                                  ;
  5252                                  ;	Description:	This routine initializes console task variables.
  5253                                  ;
  5254                                  ;-----------------------------------------------------------------------------------------------------------------------
  5255 00000079 51                      ConInitializeData	push	ecx						;save non-volatile regs
  5256 0000007A 57                      			push	edi						;
  5257 0000007B 06                      			push	es						;
  5258                                  ;
  5259                                  ;	Initialize console work areas
  5260                                  ;
  5261 0000007C 6A18                    			push	ESELDAT						;load OS data selector ...
  5262 0000007E 07                      			pop	es						;... into extra segment register
  5263 0000007F BF240A0000              			mov	edi,ECONDATA					;OS console data address
  5264 00000084 30C0                    			xor	al,al						;initialization value
  5265 00000086 B92C010000              			mov	ecx,ECONDATALEN					;size of OS console data
  5266 0000008B FC                      			cld							;forward strings
  5267 0000008C F3AA                    			rep	stosb						;initialize data
  5268                                  ;
  5269                                  ;	Initialize heap size
  5270                                  ;
  5271 0000008E B800000080              			mov	eax,EMEMHEAPSIZE				;heap size (temporary)
  5272 00000093 A3080A0000              			mov	[wfHeapSize],eax				;set heap size
  5273                                  ;
  5274                                  ;	Initialize MEMROOT structure
  5275                                  ;
  5276 00000098 BF0C0A0000              			mov	edi,wsMemRoot					;memory root structure address
  5277 0000009D B800000100              			mov	eax,EMEMBASE					;base address of heap storage
  5278 000000A2 31C9                    			xor	ecx,ecx						;zero register
  5279 000000A4 B104                    			mov	cl,4						;count
  5280 000000A6 F3AB                    			rep	stosd						;store first/last contig and free addrs
  5281 000000A8 31C0                    			xor	eax,eax						;zero register
  5282 000000AA AB                      			stosd							;zero first task block
  5283 000000AB AB                      			stosd							;zero last task block
  5284                                  ;
  5285                                  ;	Initialize MEMBLOCK structure at EMEMBASE
  5286                                  ;
  5287 000000AC BF00000100              			mov	edi,EMEMBASE					;memory block structure address
  5288 000000B1 B846524545              			mov	eax,EMEMFREECODE				;free memory signature
  5289 000000B6 AB                      			stosd							;store signature
  5290 000000B7 A1080A0000              			mov	eax,[wfHeapSize]				;heap size
  5291 000000BC AB                      			stosd							;store block size
  5292 000000BD 31C0                    			xor	eax,eax						;zero register
  5293 000000BF 31C9                    			xor	ecx,ecx						;zero register
  5294 000000C1 B106                    			mov	cl,6						;count
  5295 000000C3 F3AB                    			rep	stosd						;zero owner, reserved, pointers
  5296                                  ;
  5297                                  ;	Restore and return
  5298                                  ;
  5299 000000C5 07                      			pop	es						;restore non-volatile regs
  5300 000000C6 5F                      			pop	edi						;
  5301 000000C7 59                      			pop	ecx						;
  5302 000000C8 C3                      			ret							;return
  5303                                  ;-----------------------------------------------------------------------------------------------------------------------
  5304                                  ;
  5305                                  ;	Routine:	ConTakeToken
  5306                                  ;
  5307                                  ;	Description:	This routine extracts the next token from the given source buffer.
  5308                                  ;
  5309                                  ;	In:		DS:EDX	source buffer address
  5310                                  ;			DS:EBX	target buffer address
  5311                                  ;
  5312                                  ;	Out:		DS:EDX	source buffer address
  5313                                  ;			DS:EBX	target buffer address
  5314                                  ;
  5315                                  ;	Command Form:	Line	= *3( *SP 1*ALNUM )
  5316                                  ;
  5317                                  ;-----------------------------------------------------------------------------------------------------------------------
  5318 000000C9 56                      ConTakeToken		push	esi						;save non-volatile regs
  5319 000000CA 57                      			push	edi						;
  5320 000000CB 89D6                    			mov	esi,edx						;source buffer address
  5321 000000CD 89DF                    			mov	edi,ebx						;target buffer address
  5322 000000CF FC                      			cld							;forward strings
  5323 000000D0 AC                      .10			lodsb							;load byte
  5324 000000D1 3C20                    			cmp	al,EASCIISPACE					;space?
  5325 000000D3 74FB                    			je	.10						;yes, continue
  5326 000000D5 84C0                    			test	al,al						;end of line?
  5327 000000D7 7410                    			jz	.40						;yes, branch
  5328 000000D9 AA                      .20			stosb							;store byte
  5329 000000DA AC                      			lodsb							;load byte
  5330 000000DB 84C0                    			test	al,al						;end of line?
  5331 000000DD 740A                    			jz	.40						;no, continue
  5332 000000DF 3C20                    			cmp	al,EASCIISPACE					;space?
  5333 000000E1 75F6                    			jne	.20						;no, continue
  5334 000000E3 AC                      .30			lodsb							;load byte
  5335 000000E4 3C20                    			cmp	al,EASCIISPACE					;space?
  5336 000000E6 74FB                    			je	.30						;yes, continue
  5337 000000E8 4E                      			dec	esi						;pre-position
  5338 000000E9 C60700                  .40			mov	byte [edi],0					;terminate buffer
  5339 000000EC 89D7                    			mov	edi,edx						;source buffer address
  5340 000000EE AC                      .50			lodsb							;remaining byte
  5341 000000EF AA                      			stosb							;move to front of buffer
  5342 000000F0 84C0                    			test	al,al						;end of line?
  5343 000000F2 75FA                    			jnz	.50						;no, continue
  5344 000000F4 5F                      			pop	edi						;restore non-volatile regs
  5345 000000F5 5E                      			pop	esi						;
  5346 000000F6 C3                      			ret							;return
  5347                                  ;-----------------------------------------------------------------------------------------------------------------------
  5348                                  ;
  5349                                  ;	Routine:	ConDetermineCommand
  5350                                  ;
  5351                                  ;	Description:	This routine determines the command number for the command at DS:EDX.
  5352                                  ;
  5353                                  ;	input:		DS:EDX	command address
  5354                                  ;
  5355                                  ;	output:		EAX	>=0	= command nbr
  5356                                  ;				0	= unknown command
  5357                                  ;
  5358                                  ;-----------------------------------------------------------------------------------------------------------------------
  5359 000000F7 53                      ConDetermineCommand	push	ebx						;save non-volatile regs
  5360 000000F8 51                      			push	ecx						;
  5361 000000F9 56                      			push	esi						;
  5362 000000FA 57                      			push	edi						;
  5363                                  
  5364                                  			upperCaseString						;upper-case string at EDX
  5364 000000FB B01C                <1>  mov al,eUpperCaseString
  5364 000000FD CD30                <1>  int _svc
  5365                                  
  5366 000000FF BE[BF070000]            			mov	esi,tConCmdTbl					;commands table
  5367 00000104 31FF                    			xor	edi,edi						;intialize command number
  5368 00000106 FC                      			cld							;forward strings
  5369 00000107 AC                      .10			lodsb							;command length
  5370 00000108 0FB6C8                  			movzx	ecx,al						;command length
  5371 0000010B E30D                    			jecxz	.20						;branch if end of table
  5372 0000010D 89F3                    			mov	ebx,esi						;table entry address
  5373 0000010F 01CE                    			add	esi,ecx						;next table entry address
  5374                                  
  5375                                  			compareMemory						;compare byte arrays at EDX, EBX
  5375 00000111 B003                <1>  mov al,eCompareMemory
  5375 00000113 CD30                <1>  int _svc
  5376                                  
  5377 00000115 E303                    			jecxz	.20						;branch if equal
  5378 00000117 47                      			inc	edi						;increment command nbr
  5379 00000118 EBED                    			jmp	.10						;repeat
  5380 0000011A 89F8                    .20			mov	eax,edi						;command number
  5381 0000011C 5F                      			pop	edi						;restore non-volatile regs
  5382 0000011D 5E                      			pop	esi						;
  5383 0000011E 59                      			pop	ecx						;
  5384 0000011F 5B                      			pop	ebx						;
  5385 00000120 C3                      			ret							;return
  5386                                  ;-----------------------------------------------------------------------------------------------------------------------
  5387                                  ;
  5388                                  ;	Routine:	ConClear
  5389                                  ;
  5390                                  ;	Description:	This routine handles the CLEAR command and its CLS alias.
  5391                                  ;
  5392                                  ;-----------------------------------------------------------------------------------------------------------------------
  5393                                  ConClear		clearConsoleScreen					;clear console screen
  5393                              <1> ConClear :
  5393 00000121 B002                <1>  mov al,eClearConsoleScreen
  5393 00000123 CD30                <1>  int _svc
  5394 00000125 C3                      			ret							;return
  5395                                  ;-----------------------------------------------------------------------------------------------------------------------
  5396                                  ;
  5397                                  ;	Routine:	ConDate
  5398                                  ;
  5399                                  ;	Description:	This routine handles the DATE command.
  5400                                  ;
  5401                                  ;-----------------------------------------------------------------------------------------------------------------------
  5402                                  ConDate			readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5402                              <1> ConDate :
  5402 00000126 BB480B0000          <1>  mov ebx,%1
  5402 0000012B B017                <1>  mov al,eReadRealTimeClock
  5402 0000012D CD30                <1>  int _svc
  5403                                  			putDateString	  wsConsoleDateTime,wzConsoleOutBuffer	;format date string
  5403 0000012F BB480B0000          <1>  mov ebx,%1
  5403 00000134 BAF80A0000          <1>  mov edx,%2
  5403 00000139 B00C                <1>  mov al,ePutDateString
  5403 0000013B CD30                <1>  int _svc
  5404                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5404 0000013D BAF80A0000          <1>  mov edx,%1
  5404 00000142 B00B                <1>  mov al,ePutConsoleString
  5404 00000144 CD30                <1>  int _svc
  5405                                  			putConsoleString  czNewLine				;write newline to console
  5405 00000146 BA[C2080000]        <1>  mov edx,%1
  5405 0000014B B00B                <1>  mov al,ePutConsoleString
  5405 0000014D CD30                <1>  int _svc
  5406 0000014F C3                      			ret							;return
  5407                                  ;-----------------------------------------------------------------------------------------------------------------------
  5408                                  ;
  5409                                  ;	Routine:	ConDay
  5410                                  ;
  5411                                  ;	Description:	This routine handles the DAY command.
  5412                                  ;
  5413                                  ;-----------------------------------------------------------------------------------------------------------------------
  5414                                  ConDay			readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5414                              <1> ConDay :
  5414 00000150 BB480B0000          <1>  mov ebx,%1
  5414 00000155 B017                <1>  mov al,eReadRealTimeClock
  5414 00000157 CD30                <1>  int _svc
  5415                                  			putDayString      wsConsoleDateTime,wzConsoleOutBuffer	;format day string
  5415 00000159 BB480B0000          <1>  mov ebx,%1
  5415 0000015E BAF80A0000          <1>  mov edx,%2
  5415 00000163 B00D                <1>  mov al,ePutDayString
  5415 00000165 CD30                <1>  int _svc
  5416                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5416 00000167 BAF80A0000          <1>  mov edx,%1
  5416 0000016C B00B                <1>  mov al,ePutConsoleString
  5416 0000016E CD30                <1>  int _svc
  5417                                  			putConsoleString  czNewLine				;write newline to console
  5417 00000170 BA[C2080000]        <1>  mov edx,%1
  5417 00000175 B00B                <1>  mov al,ePutConsoleString
  5417 00000177 CD30                <1>  int _svc
  5418 00000179 C3                      			ret							;return
  5419                                  ;-----------------------------------------------------------------------------------------------------------------------
  5420                                  ;
  5421                                  ;	Routine:	ConExit
  5422                                  ;
  5423                                  ;	Description:	This routine handles the EXIT command and its SHUTDOWN and QUIT aliases.
  5424                                  ;
  5425                                  ;-----------------------------------------------------------------------------------------------------------------------
  5426                                  ConExit			resetSystem						;issue system reset
  5426                              <1> ConExit :
  5426 0000017A B018                <1>  mov al,eResetSystem
  5426 0000017C CD30                <1>  int _svc
  5427 0000017E C3                      			ret							;return
  5428                                  ;-----------------------------------------------------------------------------------------------------------------------
  5429                                  ;
  5430                                  ;	Routine:	ConFree
  5431                                  ;
  5432                                  ;	Description:	This routine handles the FREE command.
  5433                                  ;
  5434                                  ;	Input:		wzConsoleInBuffer contains parameter(s)
  5435                                  ;
  5436                                  ;-----------------------------------------------------------------------------------------------------------------------
  5437 0000017F 53                      ConFree			push	ebx						;save non-volatile regs
  5438 00000180 51                      			push	ecx						;
  5439 00000181 56                      			push	esi						;
  5440 00000182 57                      			push	edi						;
  5441                                  ;
  5442                                  ;	Get address parameter
  5443                                  ;
  5444 00000183 BA580A0000              			mov	edx,wzConsoleInBuffer				;console input buffer address (param)
  5445 00000188 BBA80A0000              			mov	ebx,wzConsoleToken				;console command token address
  5446 0000018D E837FFFFFF              			call	ConTakeToken					;take first param as token
  5447                                  ;
  5448                                  ;	Convert input parameter from hexadecimal string to binary
  5449                                  ;
  5450 00000192 803DA80A000000          			cmp	byte [wzConsoleToken],0				;token found?
  5451 00000199 7421                    			je	.10						;no, branch
  5452 0000019B BAA80A0000              			mov	edx,wzConsoleToken				;first param as token address
  5453                                  
  5454                                  			hexadecimalToUnsigned					;convert string token to unsigned
  5454 000001A0 B008                <1>  mov al,eHexadecimalToUnsigned
  5454 000001A2 CD30                <1>  int _svc
  5455                                  
  5456 000001A4 85C0                    			test	eax,eax						;valid parameter?
  5457 000001A6 7414                    			jz	.10						;no, branch
  5458                                  ;
  5459                                  ;	Free memory block
  5460                                  ;
  5461                                  			freeMemory eax						;free memory
  5461 000001A8 89C2                <1>  mov edx,%1
  5461 000001AA B006                <1>  mov al,eFreeMemory
  5461 000001AC CD30                <1>  int _svc
  5462                                  
  5463 000001AE 83F8FF                  			cmp	eax,-1						;memory freed?
  5464 000001B1 7409                    			je	.10						;no, branch
  5465                                  ;
  5466                                  ;	Indicate memory freed
  5467                                  ;
  5468                                  			putConsoleString czOK					;indicate success
  5468 000001B3 BA[C5080000]        <1>  mov edx,%1
  5468 000001B8 B00B                <1>  mov al,ePutConsoleString
  5468 000001BA CD30                <1>  int _svc
  5469                                  ;
  5470                                  ;	Restore and return
  5471                                  ;
  5472 000001BC 5F                      .10			pop	edi						;restore non-volatile regs
  5473 000001BD 5E                      			pop	esi						;
  5474 000001BE 59                      			pop	ecx						;
  5475 000001BF 5B                      			pop	ebx						;
  5476 000001C0 C3                      			ret							;return
  5477                                  ;-----------------------------------------------------------------------------------------------------------------------
  5478                                  ;
  5479                                  ;	Routine:	ConHour
  5480                                  ;
  5481                                  ;	Description:	This routine Handles the HOUR command.
  5482                                  ;
  5483                                  ;-----------------------------------------------------------------------------------------------------------------------
  5484                                  ConHour			readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5484                              <1> ConHour :
  5484 000001C1 BB480B0000          <1>  mov ebx,%1
  5484 000001C6 B017                <1>  mov al,eReadRealTimeClock
  5484 000001C8 CD30                <1>  int _svc
  5485                                  			putHourString     wsConsoleDateTime,wzConsoleOutBuffer	;format hour string
  5485 000001CA BB480B0000          <1>  mov ebx,%1
  5485 000001CF BAF80A0000          <1>  mov edx,%2
  5485 000001D4 B00E                <1>  mov al,ePutHourString
  5485 000001D6 CD30                <1>  int _svc
  5486                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5486 000001D8 BAF80A0000          <1>  mov edx,%1
  5486 000001DD B00B                <1>  mov al,ePutConsoleString
  5486 000001DF CD30                <1>  int _svc
  5487                                  			putConsoleString  czNewLine				;write newline to console
  5487 000001E1 BA[C2080000]        <1>  mov edx,%1
  5487 000001E6 B00B                <1>  mov al,ePutConsoleString
  5487 000001E8 CD30                <1>  int _svc
  5488 000001EA C3                      			ret							;return
  5489                                  ;-----------------------------------------------------------------------------------------------------------------------
  5490                                  ;
  5491                                  ;	Routine:	ConInt6
  5492                                  ;
  5493                                  ;	Description:	This routine issues an interrupt 6 to exercise the interrupt handler.
  5494                                  ;
  5495                                  ;-----------------------------------------------------------------------------------------------------------------------
  5496 000001EB 0F0B                    ConInt6			ud2							;raise bad opcode exception
  5497 000001ED C3                      			ret							;return (not executed)
  5498                                  ;-----------------------------------------------------------------------------------------------------------------------
  5499                                  ;
  5500                                  ;	Routine:	ConMalloc
  5501                                  ;
  5502                                  ;	Description:	This routine handles the MALLOC command.
  5503                                  ;
  5504                                  ;	Input:		wzConsoleInBuffer contains parameter(s)
  5505                                  ;
  5506                                  ;-----------------------------------------------------------------------------------------------------------------------
  5507 000001EE 53                      ConMalloc		push	ebx						;save non-volatile regs
  5508 000001EF 51                      			push	ecx						;
  5509 000001F0 56                      			push	esi						;
  5510 000001F1 57                      			push	edi						;
  5511                                  ;
  5512                                  ;	Get size parameter
  5513                                  ;
  5514 000001F2 BA580A0000              			mov	edx,wzConsoleInBuffer				;console input buffer address (params)
  5515 000001F7 BBA80A0000              			mov	ebx,wzConsoleToken				;console command token address
  5516 000001FC E8C8FEFFFF              			call	ConTakeToken					;take first param as token
  5517                                  ;
  5518                                  ;	Convert input parameter from decimal string to binary
  5519                                  ;
  5520 00000201 803DA80A000000          			cmp	byte [wzConsoleToken],0				;token found?
  5521 00000208 7434                    			je	.10						;no, branch
  5522 0000020A BAA80A0000              			mov	edx,wzConsoleToken				;first param as token address
  5523                                  
  5524                                  			decimalToUnsigned					;convert string token to unsigned
  5524 0000020F B005                <1>  mov al,eDecimalToUnsigned
  5524 00000211 CD30                <1>  int _svc
  5525                                  
  5526 00000213 85C0                    			test	eax,eax						;valid parameter?
  5527 00000215 7427                    			jz	.10						;no, branch
  5528                                  ;
  5529                                  ;	Allocate memory block
  5530                                  ;
  5531                                  			allocateMemory eax					;allocate memory
  5531 00000217 89C1                <1>  mov ecx,%1
  5531 00000219 B000                <1>  mov al,eAllocateMemory
  5531 0000021B CD30                <1>  int _svc
  5532                                  
  5533 0000021D 85C0                    			test	eax,eax						;memory allocated?
  5534 0000021F 741D                    			jz	.10						;no, branch
  5535                                  ;
  5536                                  ;	Report allocated memory block address
  5537                                  ;
  5538 00000221 BAF80A0000              			mov	edx,wzConsoleOutBuffer				;output buffer address
  5539 00000226 89C1                    			mov	ecx,eax						;memory address
  5540                                  
  5541                                  			unsignedToHexadecimal					;convert memory address to hex
  5541 00000228 B01B                <1>  mov al,eUnsignedToHexadecimal
  5541 0000022A CD30                <1>  int _svc
  5542                                  			putConsoleString wzConsoleOutBuffer			;display memory address
  5542 0000022C BAF80A0000          <1>  mov edx,%1
  5542 00000231 B00B                <1>  mov al,ePutConsoleString
  5542 00000233 CD30                <1>  int _svc
  5543                                  			putConsoleString czNewLine				;display new line
  5543 00000235 BA[C2080000]        <1>  mov edx,%1
  5543 0000023A B00B                <1>  mov al,ePutConsoleString
  5543 0000023C CD30                <1>  int _svc
  5544                                  
  5545 0000023E 5F                      .10			pop	edi						;restore non-volatile regs
  5546 0000023F 5E                      			pop	esi						;
  5547 00000240 59                      			pop	ecx						;
  5548 00000241 5B                      			pop	ebx						;
  5549 00000242 C3                      			ret							;return
  5550                                  ;-----------------------------------------------------------------------------------------------------------------------
  5551                                  ;
  5552                                  ;	Routine:	ConMem
  5553                                  ;
  5554                                  ;	Description:	This routine handles the MEMORY command and its MEM alias.
  5555                                  ;
  5556                                  ;	Input:		wzConsoleInBuffer contains parameter(s)
  5557                                  ;
  5558                                  ;-----------------------------------------------------------------------------------------------------------------------
  5559 00000243 53                      ConMem			push	ebx						;save non-volatile regs
  5560 00000244 56                      			push	esi						;
  5561 00000245 57                      			push	edi						;
  5562                                  ;
  5563                                  ;			update the source address if a parameter is given
  5564                                  ;
  5565 00000246 BA580A0000              			mov	edx,wzConsoleInBuffer				;console input buffer address (params)
  5566 0000024B BBA80A0000              			mov	ebx,wzConsoleToken				;console command token address
  5567 00000250 E874FEFFFF              			call	ConTakeToken					;take first param as token
  5568 00000255 803DA80A000000          			cmp	byte [wzConsoleToken],0				;token found?
  5569 0000025C 740E                    			je	.10						;no, branch
  5570 0000025E BAA80A0000              			mov	edx,wzConsoleToken				;first param as token address
  5571                                  
  5572                                  			hexadecimalToUnsigned					;convert string token to unsigned
  5572 00000263 B008                <1>  mov al,eHexadecimalToUnsigned
  5572 00000265 CD30                <1>  int _svc
  5573                                  
  5574 00000267 A3240A0000              			mov	[wfConsoleMemAddr],eax				;save console memory address
  5575                                  ;
  5576                                  ;			setup source address and row count
  5577                                  ;
  5578 0000026C 8B35240A0000            .10			mov	esi,[wfConsoleMemAddr]				;source memory address
  5579 00000272 31C9                    			xor	ecx,ecx						;zero register
  5580 00000274 B110                    			mov	cl,16						;row count
  5581                                  ;
  5582                                  ;			start the row with the source address in hexadecimal
  5583                                  ;
  5584 00000276 51                      .20			push	ecx						;save remaining rows
  5585 00000277 BFF80A0000              			mov	edi,wzConsoleOutBuffer				;output buffer address
  5586 0000027C 89FA                    			mov	edx,edi						;output buffer address
  5587 0000027E 89F1                    			mov	ecx,esi						;console memory address
  5588                                  
  5589                                  			unsignedToHexadecimal					;convert unsigned address to hex string
  5589 00000280 B01B                <1>  mov al,eUnsignedToHexadecimal
  5589 00000282 CD30                <1>  int _svc
  5590                                  
  5591 00000284 83C708                  			add	edi,8						;end of memory addr hexnum
  5592 00000287 B020                    			mov	al,' '						;ascii space
  5593 00000289 AA                      			stosb							;store delimiter
  5594                                  ;
  5595                                  ;			output 16 ASCII hexadecimal byte values for the row
  5596                                  ;
  5597 0000028A 31C9                    			xor	ecx,ecx						;zero register
  5598 0000028C B110                    			mov	cl,16						;loop count
  5599 0000028E 51                      .30			push	ecx						;save loop count
  5600 0000028F AC                      			lodsb							;memory byte
  5601 00000290 88C4                    			mov	ah,al						;memory byte
  5602 00000292 C0E804                  			shr	al,4						;high-order in bits 3-0
  5603 00000295 0C30                    			or	al,30h						;apply ascii numeric zone
  5604 00000297 3C3A                    			cmp	al,3ah						;numeric range?
  5605 00000299 7202                    			jb	.40						;yes, skip ahead
  5606 0000029B 0407                    			add	al,7						;adjust ascii for 'A'-'F'
  5607 0000029D AA                      .40			stosb							;store ascii hexadecimal of high-order
  5608 0000029E 88E0                    			mov	al,ah						;low-order in bits 3-0
  5609 000002A0 240F                    			and	al,0fh						;mask out high-order bits
  5610 000002A2 0C30                    			or	al,30h						;apply ascii numeric zone
  5611 000002A4 3C3A                    			cmp	al,3ah						;numeric range?
  5612 000002A6 7202                    			jb	.50						;yes, skip ahead
  5613 000002A8 0407                    			add	al,7						;adjust ascii for 'A'-'F'
  5614 000002AA AA                      .50			stosb							;store ascii hexadecimal of low-order
  5615 000002AB B020                    			mov	al,' '						;ascii space
  5616 000002AD AA                      			stosb							;store ascii space delimiter
  5617 000002AE 59                      			pop	ecx						;loop count
  5618 000002AF E2DD                    			loop	.30						;next
  5619                                  ;
  5620                                  ;			output printable ASCII character section for the row
  5621                                  ;
  5622 000002B1 83EE10                  			sub	esi,16						;reset source pointer
  5623 000002B4 B110                    			mov	cl,16						;loop count
  5624 000002B6 AC                      .60			lodsb							;source byte
  5625 000002B7 3C20                    			cmp	al,32						;printable? (low-range test)
  5626 000002B9 7204                    			jb	.70						;no, skip ahead
  5627 000002BB 3C80                    			cmp	al,128						;printable? (high-range test)
  5628 000002BD 7202                    			jb	.80						;yes, skip ahead
  5629 000002BF B020                    .70			mov	al,' '						;display space instead of printable
  5630 000002C1 AA                      .80			stosb							;store printable ascii byte
  5631 000002C2 E2F2                    			loop	.60						;next source byte
  5632 000002C4 30C0                    			xor	al,al						;nul-terminator
  5633 000002C6 AA                      			stosb							;terminate output line
  5634                                  ;
  5635                                  ;			display constructed output buffer and newline
  5636                                  ;
  5637                                  			putConsoleString wzConsoleOutBuffer			;display constructed output
  5637 000002C7 BAF80A0000          <1>  mov edx,%1
  5637 000002CC B00B                <1>  mov al,ePutConsoleString
  5637 000002CE CD30                <1>  int _svc
  5638                                  			putConsoleString czNewLine				;display new line
  5638 000002D0 BA[C2080000]        <1>  mov edx,%1
  5638 000002D5 B00B                <1>  mov al,ePutConsoleString
  5638 000002D7 CD30                <1>  int _svc
  5639                                  ;
  5640                                  ;			repeat until all lines displayed and preserve source address
  5641                                  ;
  5642 000002D9 59                      			pop	ecx						;remaining rows
  5643 000002DA E29A                    			loop	.20						;next row
  5644 000002DC 8935240A0000            			mov	[wfConsoleMemAddr],esi				;update console memory address
  5645 000002E2 5F                      			pop	edi						;restore regs
  5646 000002E3 5E                      			pop	esi						;
  5647 000002E4 5B                      			pop	ebx						;
  5648 000002E5 C3                      			ret							;return
  5649                                  ;-----------------------------------------------------------------------------------------------------------------------
  5650                                  ;
  5651                                  ;	Routine:	ConMinute
  5652                                  ;
  5653                                  ;	Description:	This routine Handles the MINUTE command.
  5654                                  ;
  5655                                  ;-----------------------------------------------------------------------------------------------------------------------
  5656                                  ConMinute		readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5656                              <1> ConMinute :
  5656 000002E6 BB480B0000          <1>  mov ebx,%1
  5656 000002EB B017                <1>  mov al,eReadRealTimeClock
  5656 000002ED CD30                <1>  int _svc
  5657                                  			putMinuteString   wsConsoleDateTime,wzConsoleOutBuffer	;format minute string
  5657 000002EF BB480B0000          <1>  mov ebx,%1
  5657 000002F4 BAF80A0000          <1>  mov edx,%2
  5657 000002F9 B00F                <1>  mov al,ePutMinuteString
  5657 000002FB CD30                <1>  int _svc
  5658                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5658 000002FD BAF80A0000          <1>  mov edx,%1
  5658 00000302 B00B                <1>  mov al,ePutConsoleString
  5658 00000304 CD30                <1>  int _svc
  5659                                  			putConsoleString  czNewLine				;write newline to console
  5659 00000306 BA[C2080000]        <1>  mov edx,%1
  5659 0000030B B00B                <1>  mov al,ePutConsoleString
  5659 0000030D CD30                <1>  int _svc
  5660 0000030F C3                      			ret							;return
  5661                                  ;-----------------------------------------------------------------------------------------------------------------------
  5662                                  ;
  5663                                  ;	Routine:	ConMonth
  5664                                  ;
  5665                                  ;	Description:	This routine Handles the MONTH command.
  5666                                  ;
  5667                                  ;-----------------------------------------------------------------------------------------------------------------------
  5668                                  ConMonth		readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5668                              <1> ConMonth :
  5668 00000310 BB480B0000          <1>  mov ebx,%1
  5668 00000315 B017                <1>  mov al,eReadRealTimeClock
  5668 00000317 CD30                <1>  int _svc
  5669                                  			putMonthString    wsConsoleDateTime,wzConsoleOutBuffer	;format month string
  5669 00000319 BB480B0000          <1>  mov ebx,%1
  5669 0000031E BAF80A0000          <1>  mov edx,%2
  5669 00000323 B010                <1>  mov al,ePutMonthString
  5669 00000325 CD30                <1>  int _svc
  5670                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5670 00000327 BAF80A0000          <1>  mov edx,%1
  5670 0000032C B00B                <1>  mov al,ePutConsoleString
  5670 0000032E CD30                <1>  int _svc
  5671                                  			putConsoleString  czNewLine				;write newline to console
  5671 00000330 BA[C2080000]        <1>  mov edx,%1
  5671 00000335 B00B                <1>  mov al,ePutConsoleString
  5671 00000337 CD30                <1>  int _svc
  5672 00000339 C3                      			ret							;return
  5673                                  ;-----------------------------------------------------------------------------------------------------------------------
  5674                                  ;
  5675                                  ;	Routine:	ConMonthName
  5676                                  ;
  5677                                  ;	Description:	This routine Handles the MONTH.NAME command.
  5678                                  ;
  5679                                  ;-----------------------------------------------------------------------------------------------------------------------
  5680                                  ConMonthName		readRealTimeClock  wsConsoleDateTime			;read RTC data into structure
  5680                              <1> ConMonthName :
  5680 0000033A BB480B0000          <1>  mov ebx,%1
  5680 0000033F B017                <1>  mov al,eReadRealTimeClock
  5680 00000341 CD30                <1>  int _svc
  5681                                  			putMonthNameString wsConsoleDateTime,wzConsoleOutBuffer	;format month name string
  5681 00000343 BB480B0000          <1>  mov ebx,%1
  5681 00000348 BAF80A0000          <1>  mov edx,%2
  5681 0000034D B011                <1>  mov al,ePutMonthNameString
  5681 0000034F CD30                <1>  int _svc
  5682                                  			putConsoleString   wzConsoleOutBuffer			;write string to console
  5682 00000351 BAF80A0000          <1>  mov edx,%1
  5682 00000356 B00B                <1>  mov al,ePutConsoleString
  5682 00000358 CD30                <1>  int _svc
  5683                                  			putConsoleString   czNewLine				;write newline to console
  5683 0000035A BA[C2080000]        <1>  mov edx,%1
  5683 0000035F B00B                <1>  mov al,ePutConsoleString
  5683 00000361 CD30                <1>  int _svc
  5684 00000363 C3                      			ret							;return
  5685                                  ;-----------------------------------------------------------------------------------------------------------------------
  5686                                  ;
  5687                                  ;	Routine:	ConPCIProbe
  5688                                  ;
  5689                                  ;	Description:	This routine handles the PCIProbe command.
  5690                                  ;
  5691                                  ;-----------------------------------------------------------------------------------------------------------------------
  5692 00000364 53                      ConPCIProbe		push	ebx						;save non-volatile regs
  5693                                  ;
  5694                                  ;			initialize variables
  5695                                  ;
  5696 00000365 30C0                    			xor	al,al						;zero register
  5697 00000367 A2540A0000              			mov	[wbConsolePCIBus],al				;initialize bus
  5698 0000036C A2550A0000              			mov	[wbConsolePCIDevice],al				;initialize device
  5699 00000371 A2560A0000              			mov	[wbConsolePCIFunction],al			;initialize function
  5700                                  ;
  5701                                  ;			construct PCI selector
  5702                                  ;
  5703 00000376 8A25540A0000            .10			mov	ah,[wbConsolePCIBus]				;AH = bbbb bbbb
  5704 0000037C 8A15550A0000            			mov	dl,[wbConsolePCIDevice]				;DL = ???d dddd
  5705 00000382 C0E203                  			shl	dl,3						;DL = dddd d000
  5706 00000385 A0560A0000              			mov	al,[wbConsolePCIFunction]			;AL = ???? ?fff
  5707 0000038A 2407                    			and	al,007h						;AL = 0000 0fff
  5708 0000038C 08D0                    			or	al,dl						;AL = dddd dfff
  5709 0000038E 0FB7C0                  			movzx	eax,ax						;0000 0000 0000 0000 bbbb bbbb dddd dfff
  5710 00000391 C1E008                  			shl	eax,8						;0000 0000 bbbb bbbb dddd dfff 0000 0000
  5711 00000394 0D00000080              			or	eax,80000000h					;1000 0000 bbbb bbbb dddd dfff 0000 0000
  5712 00000399 A3280A0000              			mov	[wfConsolePCISelector],eax			;save selector
  5713                                  ;
  5714                                  ;			read PCI data register
  5715                                  ;
  5716 0000039E 66BAF80C                			mov	dx,0cf8h					;register port
  5717 000003A2 EF                      			out	dx,eax						;select device
  5718 000003A3 66BAFC0C                			mov	dx,0cfch					;data port
  5719 000003A7 ED                      			in	eax,dx						;read register data
  5720 000003A8 A32C0A0000              			mov	[wfConsolePCIData],eax				;save data
  5721                                  ;
  5722                                  ;			interpret PCI data value and display finding
  5723                                  ;
  5724 000003AD 83F8FF                  			cmp	eax,0ffffffffh					;not defined?
  5725 000003B0 7447                    			je	.20						;yes, branch
  5726 000003B2 BAA80A0000              			mov	edx,wzConsoleToken				;output buffer
  5727 000003B7 E83D010000              			call	ConBuildPCIIdent				;build PCI bus, device, function ident
  5728                                  
  5729                                  			putConsoleString wzConsoleToken				;display bus as decimal
  5729 000003BC BAA80A0000          <1>  mov edx,%1
  5729 000003C1 B00B                <1>  mov al,ePutConsoleString
  5729 000003C3 CD30                <1>  int _svc
  5730                                  
  5731 000003C5 E873010000              			call	ConInterpretPCIData				;update flags based on data
  5732                                  
  5733                                  			putConsoleString czSpace
  5733 000003CA BA[45090000]        <1>  mov edx,%1
  5733 000003CF B00B                <1>  mov al,ePutConsoleString
  5733 000003D1 CD30                <1>  int _svc
  5734                                  			putConsoleString [wfConsolePCIVendorStr]
  5734 000003D3 8B15300A0000        <1>  mov edx,%1
  5734 000003D9 B00B                <1>  mov al,ePutConsoleString
  5734 000003DB CD30                <1>  int _svc
  5735                                  			putConsoleString czSpace
  5735 000003DD BA[45090000]        <1>  mov edx,%1
  5735 000003E2 B00B                <1>  mov al,ePutConsoleString
  5735 000003E4 CD30                <1>  int _svc
  5736                                  			putConsoleString [wfConsolePCIChipStr]
  5736 000003E6 8B15340A0000        <1>  mov edx,%1
  5736 000003EC B00B                <1>  mov al,ePutConsoleString
  5736 000003EE CD30                <1>  int _svc
  5737                                  			putConsoleString czNewLine				;display new line
  5737 000003F0 BA[C2080000]        <1>  mov edx,%1
  5737 000003F5 B00B                <1>  mov al,ePutConsoleString
  5737 000003F7 CD30                <1>  int _svc
  5738                                  ;
  5739                                  ;			step to next function, device, bus
  5740                                  ;
  5741 000003F9 FE05560A0000            .20			inc	byte [wbConsolePCIFunction]			;next function
  5742 000003FF 803D560A000008          			cmp	byte [wbConsolePCIFunction],8			;at limit?
  5743 00000406 0F826AFFFFFF            			jb	.10						;no, continue
  5744 0000040C C605560A000000          			mov	byte [wbConsolePCIFunction],0			;zero function
  5745 00000413 FE05550A0000            			inc	byte [wbConsolePCIDevice]			;next device
  5746 00000419 803D550A000020          			cmp	byte [wbConsolePCIDevice],32			;at limit?
  5747 00000420 0F8250FFFFFF            			jb	.10						;no, continue
  5748 00000426 C605550A000000          			mov	byte [wbConsolePCIDevice],0			;zero device
  5749 0000042D FE05540A0000            			inc	byte [wbConsolePCIBus]				;next bus
  5750 00000433 803D540A000000          			cmp	byte [wbConsolePCIBus],0			;at limit?
  5751 0000043A 0F8236FFFFFF            			jb	.10						;no, continue
  5752                                  
  5753 00000440 E9B2000000              			jmp	.30
  5754                                  
  5755                                  ;
  5756                                  ;			report if ethernet adapter found
  5757                                  ;
  5758 00000445 F605570A000080          			test	byte [wbConsoleHWFlags],EHWETHERNET		;ethernet h/w switch set?
  5759 0000044C 0F84A5000000            			jz	.30						;branch if no
  5760                                  
  5761                                  			putConsoleString czEthernetAdapterFound			;report adapter found
  5761 00000452 BA[A3080000]        <1>  mov edx,%1
  5761 00000457 B00B                <1>  mov al,ePutConsoleString
  5761 00000459 CD30                <1>  int _svc
  5762                                  ;
  5763                                  ;			read base address register 0 at offset 10h
  5764                                  ;
  5765 0000045B A1380A0000              			mov	eax,[wfConsoleEthernetDevice]			;adapter PCI selector
  5766 00000460 83C810                  			or	eax,10h						;set function bits
  5767 00000463 66BAF80C                			mov	dx,0cf8h					;register port
  5768 00000467 EF                      			out	dx,eax						;select register
  5769 00000468 66BAFC0C                			mov	dx,0cfch					;data port
  5770 0000046C ED                      			in	eax,dx						;register data
  5771 0000046D A33C0A0000              			mov	[wfConsoleEthernetMem],eax			;save ethernet memory mapped i/o addr
  5772                                  ;
  5773                                  ;			report base address register 0 value
  5774                                  ;
  5775 00000472 89C1                    			mov	ecx,eax						;unsigned integer param
  5776 00000474 BAA80A0000              			mov	edx,wzConsoleToken				;target buffer address
  5777                                  
  5778                                  			unsignedToHexadecimal					;convert unsigned to ASCII hex string
  5778 00000479 B01B                <1>  mov al,eUnsignedToHexadecimal
  5778 0000047B CD30                <1>  int _svc
  5779                                  			putConsoleString wzConsoleToken				;output string to console
  5779 0000047D BAA80A0000          <1>  mov edx,%1
  5779 00000482 B00B                <1>  mov al,ePutConsoleString
  5779 00000484 CD30                <1>  int _svc
  5780                                  			putConsoleString czNewLine				;output newline to console
  5780 00000486 BA[C2080000]        <1>  mov edx,%1
  5780 0000048B B00B                <1>  mov al,ePutConsoleString
  5780 0000048D CD30                <1>  int _svc
  5781                                  ;
  5782                                  ;			read base address register 2 at offset 18h
  5783                                  ;
  5784 0000048F A1380A0000              			mov	eax,[wfConsoleEthernetDevice]			;adapter PCI selector
  5785 00000494 83C818                  			or	eax,18h						;set function bits
  5786 00000497 66BAF80C                			mov	dx,0cf8h					;register port
  5787 0000049B EF                      			out	dx,eax						;select register
  5788 0000049C 66BAFC0C                			mov	dx,0cfch					;data port
  5789 000004A0 ED                      			in	eax,dx						;register data
  5790 000004A1 24FE                    			and	al,0feh						;clear bit zero
  5791 000004A3 A3400A0000              			mov	[wfConsoleEthernetPort],eax			;save ethernet i/o port
  5792                                  ;
  5793                                  ;			report base address register 2 value
  5794                                  ;
  5795 000004A8 89C1                    			mov	ecx,eax						;unsigned integer param
  5796 000004AA BAA80A0000              			mov	edx,wzConsoleToken				;target buffer address
  5797                                  
  5798                                  			unsignedToHexadecimal					;convert unsigned to ASCII hex string
  5798 000004AF B01B                <1>  mov al,eUnsignedToHexadecimal
  5798 000004B1 CD30                <1>  int _svc
  5799                                  			putConsoleString wzConsoleToken				;output string to console
  5799 000004B3 BAA80A0000          <1>  mov edx,%1
  5799 000004B8 B00B                <1>  mov al,ePutConsoleString
  5799 000004BA CD30                <1>  int _svc
  5800                                  			putConsoleString czNewLine				;output newline to console
  5800 000004BC BA[C2080000]        <1>  mov edx,%1
  5800 000004C1 B00B                <1>  mov al,ePutConsoleString
  5800 000004C3 CD30                <1>  int _svc
  5801                                  ;
  5802                                  ;			read ethernet control register using port i/o
  5803                                  ;
  5804 000004C5 A1400A0000              			mov	eax,[wfConsoleEthernetPort]			;ethernet i/o port
  5805 000004CA 6689C2                  			mov	dx,ax						;ethernet i/o port
  5806 000004CD 31C0                    			xor	eax,eax						;control register (zero)
  5807 000004CF EF                      			out	dx,eax						;select register
  5808 000004D0 6683C204                			add	dx,4						;data register
  5809 000004D4 ED                      			in	eax,dx						;read register data
  5810 000004D5 A3440A0000              			mov	[wfConsoleEthernetCtrl],eax			;save ethernet control register value
  5811                                  ;
  5812                                  ;			report adapter control register value
  5813                                  ;
  5814 000004DA 89C1                    			mov	ecx,eax						;unsigned integer param
  5815 000004DC BAA80A0000              			mov	edx,wzConsoleToken				;target buffer address
  5816                                  
  5817                                  			unsignedToHexadecimal					;convert unsigned to ASCII hex string
  5817 000004E1 B01B                <1>  mov al,eUnsignedToHexadecimal
  5817 000004E3 CD30                <1>  int _svc
  5818                                  			putConsoleString wzConsoleToken				;output string to console
  5818 000004E5 BAA80A0000          <1>  mov edx,%1
  5818 000004EA B00B                <1>  mov al,ePutConsoleString
  5818 000004EC CD30                <1>  int _svc
  5819                                  			putConsoleString czNewLine				;output newline to console
  5819 000004EE BA[C2080000]        <1>  mov edx,%1
  5819 000004F3 B00B                <1>  mov al,ePutConsoleString
  5819 000004F5 CD30                <1>  int _svc
  5820                                  
  5821 000004F7 5B                      .30			pop	ebx						;restore non-volatile regs
  5822 000004F8 C3                      			ret							;return
  5823                                  ;-----------------------------------------------------------------------------------------------------------------------
  5824                                  ;
  5825                                  ;	Routine:	ConBuildPCIIdent
  5826                                  ;
  5827                                  ;	Description:	This routine constructs a PCI identification string from the current PCI Bus, Device, and
  5828                                  ;			Function code values.
  5829                                  ;
  5830                                  ;	In:		DS:EDX	output buffer address
  5831                                  ;
  5832                                  ;-----------------------------------------------------------------------------------------------------------------------
  5833 000004F9 57                      ConBuildPCIIdent	push	edi						;save non-volatile regs
  5834 000004FA 89D7                    			mov	edi,edx						;output buffer address
  5835 000004FC A0540A0000              			mov	al,[wbConsolePCIBus]				;current PCI bus (0-255)
  5836 00000501 30E4                    			xor	ah,ah						;zero high-order dividend
  5837 00000503 B164                    			mov	cl,100						;divisor (10^2)
  5838 00000505 F6F1                    			div	cl						;AL=100's, AH=bus MOD 100
  5839 00000507 0C30                    			or	al,30h						;apply ASCII zone
  5840 00000509 FC                      			cld							;forward strings
  5841 0000050A AA                      			stosb							;store 100's digit
  5842 0000050B 88E0                    			mov	al,ah						;bus MOD 100
  5843 0000050D 30E4                    			xor	ah,ah						;zero high-order dividend
  5844 0000050F B10A                    			mov	cl,10						;divisor (10^1)
  5845 00000511 F6F1                    			div	cl						;AL=10's, AH=1's
  5846 00000513 660D3030                			or	ax,3030h					;apply ASCII zone
  5847 00000517 66AB                    			stosw							;store 10's and 1's
  5848 00000519 B02E                    			mov	al,EASCIIPERIOD					;ASCII period delimiter
  5849 0000051B AA                      			stosb							;store delimiter
  5850 0000051C A0550A0000              			mov	al,[wbConsolePCIDevice]				;current PCI device (0-15)
  5851 00000521 30E4                    			xor	ah,ah						;zero high order dividend
  5852 00000523 B10A                    			mov	cl,10						;divisor (10^1)
  5853 00000525 F6F1                    			div	cl						;AL=10's, AH=1's
  5854 00000527 660D3030                			or	ax,3030h					;apply ASCII zone
  5855 0000052B 66AB                    			stosw							;store 10's and 1's
  5856 0000052D B02E                    			mov	al,EASCIIPERIOD					;ASCII period delimiter
  5857 0000052F AA                      			stosb							;store delimiter
  5858 00000530 A0560A0000              			mov	al,[wbConsolePCIFunction]			;current PCI function (0-7)
  5859 00000535 0C30                    			or	al,30h						;apply ASCII zone
  5860 00000537 AA                      			stosb							;store 1's
  5861 00000538 30C0                    			xor	al,al						;null terminator
  5862 0000053A AA                      			stosb							;store terminator
  5863 0000053B 5F                      			pop	edi						;restore non-volatile regs
  5864 0000053C C3                      			ret							;return
  5865                                  ;-----------------------------------------------------------------------------------------------------------------------
  5866                                  ;
  5867                                  ;	Routine:	ConInterpretPCIData
  5868                                  ;
  5869                                  ;	Description:	This routine interprets the PCI vendor and device IDs.
  5870                                  ;
  5871                                  ;-----------------------------------------------------------------------------------------------------------------------
  5872 0000053D B8[86080000]            ConInterpretPCIData	mov	eax,czApple
  5873 00000542 66813D2C0A00006B10      			cmp	word [wwConsolePCIVendor],EPCIVENDORAPPLE	;Apple?
  5874 0000054B 751D                    			jne	.10						;no, branch
  5875 0000054D BA[77090000]            			mov	edx,czUSBController
  5876 00000552 66833D2E0A00003F        			cmp	word [wwConsolePCIChip],EPCIAPPLEUSB		;USB?
  5877 0000055A 0F84CA000000            			je	.80						;yes, branch
  5878 00000560 BA[D1080000]            			mov	edx,czOther					;other
  5879 00000565 E9C0000000              			jmp	.80						;continue
  5880 0000056A B8[BC080000]            .10			mov	eax,czIntel					;Intel
  5881 0000056F 66813D2C0A00008680      			cmp	word [wwConsolePCIVendor],EPCIVENDORINTEL	;Intel?
  5882 00000578 756F                    			jne	.20						;no, branch
  5883 0000057A BA[28090000]            			mov	edx,czPro1000MT					;Pro/1000 MT
  5884 0000057F 66813D2E0A00000F10      			cmp	word [wwConsolePCIChip],EPCIINTELPRO1000MT	;Pro/1000 MT?
  5885 00000588 0F849C000000            			je	.80						;yes, branch
  5886 0000058E BA[D7080000]            			mov	edx,czPCIAndMem					;PCI and Memory
  5887 00000593 66813D2E0A00003712      			cmp	word [wwConsolePCIChip],EPCIINTELPCIMEM		;PCI and Memory?
  5888 0000059C 0F8488000000            			je	.80						;yes, branch
  5889 000005A2 BA[8C080000]            			mov	edx,czAurealAD1881				;Aureal 1881 SOUNDMAX
  5890 000005A7 66813D2E0A00001524      			cmp	word [wwConsolePCIChip],EPCIINTELAD1881		;Aureal 1881 SOUNDMAX?
  5891 000005B0 7478                    			je	.80						;yes, branch
  5892 000005B2 BA[E6080000]            			mov	edx,czPIIX3PCItoIDEBridge			;PIIX3 PCI-to-IDE Bridge
  5893 000005B7 66813D2E0A00000070      			cmp	word [wwConsolePCIChip],EPCIINTELPIIX3		;PIIX3 PCI-to-IDE Bridge?
  5894 000005C0 7468                    			je	.80						;yes, branch
  5895 000005C2 BA[EE090000]            			mov	edx,cz82371ABBusMaster				;82371AB Bus Master
  5896 000005C7 66813D2E0A00001171      			cmp	word [wwConsolePCIChip],EPCIINTEL82371AB	;82371AB Bus Master?
  5897 000005D0 7458                    			je	.80						;yes, branch
  5898 000005D2 BA[FE080000]            			mov	edx,czPIIX4PowerMgmt				;PIIX4/4E/4M Power Mgmt Controller
  5899 000005D7 66813D2E0A00001371      			cmp	word [wwConsolePCIChip],EPCIINTELPIIX4		;PIIX4/4E/4M Power Mgmt Controller?
  5900 000005E0 7448                    			je	.80						;yes, branch
  5901 000005E2 BA[D1080000]            			mov	edx,czOther					;other
  5902 000005E7 EB41                    			jmp	.80						;continue
  5903 000005E9 B8[CA080000]            .20			mov	eax,czOracle					;Oracle
  5904 000005EE 66813D2C0A0000EE80      			cmp	word [wwConsolePCIVendor],EPCIVENDORORACLE	;Oracle?
  5905 000005F7 7527                    			jne	.30						;no, branch
  5906 000005F9 BA[98090000]            			mov	edx,czVirtualBoxGA				;VirtulaBox Graphics Adapter
  5907 000005FE 66813D2E0A0000EFBE      			cmp	word [wwConsolePCIChip],EPCIORACLEVBOXGA	;VirtualBox Graphics Adapter?
  5908 00000607 7421                    			je	.80						;yes, branch
  5909 00000609 BA[86090000]            			mov	edx,czVirtualBoxDevice				;VirtualBox Device
  5910 0000060E 66813D2E0A0000FECA      			cmp	word [wwConsolePCIChip],EPCIORACLEVBOXDEVICE	;VirtualBox Device?
  5911 00000617 7411                    			je	.80						;yes, branch
  5912 00000619 BA[D1080000]            			mov	edx,czOther					;other
  5913 0000061E EB0A                    			jmp	.80						;continue
  5914 00000620 B8[D1080000]            .30			mov	eax,czOther					;other
  5915 00000625 BA[D1080000]            			mov	edx,czOther					;other
  5916 0000062A A3300A0000              .80			mov	[wfConsolePCIVendorStr],eax			;save vendor string
  5917 0000062F 8915340A0000            			mov	[wfConsolePCIChipStr],edx			;save chip string
  5918 00000635 66813D2E0A00000F10      			cmp	word [wwConsolePCIChip],EPCIINTELPRO1000MT	;Pro/1000 MT Ethernet Adapter
  5919 0000063E 7511                    			jne	.90						;no, branch
  5920 00000640 800D570A000080          			or	byte [wbConsoleHWFlags],EHWETHERNET		;ethernet adapter found
  5921 00000647 A1280A0000              			mov	eax,[wfConsolePCISelector]			;PCI selector
  5922 0000064C A3380A0000              			mov	[wfConsoleEthernetDevice],eax			;save as ethernet device selector
  5923 00000651 C3                      .90			ret							;return
  5924                                  ;-----------------------------------------------------------------------------------------------------------------------
  5925                                  ;
  5926                                  ;	Routine:	ConSecond
  5927                                  ;
  5928                                  ;	Description:	This routine Handles the SECOND command.
  5929                                  ;
  5930                                  ;-----------------------------------------------------------------------------------------------------------------------
  5931                                  ConSecond		readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5931                              <1> ConSecond :
  5931 00000652 BB480B0000          <1>  mov ebx,%1
  5931 00000657 B017                <1>  mov al,eReadRealTimeClock
  5931 00000659 CD30                <1>  int _svc
  5932                                  			putSecondString   wsConsoleDateTime,wzConsoleOutBuffer	;format second string
  5932 0000065B BB480B0000          <1>  mov ebx,%1
  5932 00000660 BAF80A0000          <1>  mov edx,%2
  5932 00000665 B012                <1>  mov al,ePutSecondString
  5932 00000667 CD30                <1>  int _svc
  5933                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5933 00000669 BAF80A0000          <1>  mov edx,%1
  5933 0000066E B00B                <1>  mov al,ePutConsoleString
  5933 00000670 CD30                <1>  int _svc
  5934                                  			putConsoleString  czNewLine				;write newline to console
  5934 00000672 BA[C2080000]        <1>  mov edx,%1
  5934 00000677 B00B                <1>  mov al,ePutConsoleString
  5934 00000679 CD30                <1>  int _svc
  5935 0000067B C3                      			ret							;return
  5936                                  ;-----------------------------------------------------------------------------------------------------------------------
  5937                                  ;
  5938                                  ;	Routine:	ConTime
  5939                                  ;
  5940                                  ;	Description:	This routine Handles the TIME command.
  5941                                  ;
  5942                                  ;-----------------------------------------------------------------------------------------------------------------------
  5943                                  ConTime			readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5943                              <1> ConTime :
  5943 0000067C BB480B0000          <1>  mov ebx,%1
  5943 00000681 B017                <1>  mov al,eReadRealTimeClock
  5943 00000683 CD30                <1>  int _svc
  5944                                  			putTimeString	  wsConsoleDateTime,wzConsoleOutBuffer	;format time string
  5944 00000685 BB480B0000          <1>  mov ebx,%1
  5944 0000068A BAF80A0000          <1>  mov edx,%2
  5944 0000068F B013                <1>  mov al,ePutTimeString
  5944 00000691 CD30                <1>  int _svc
  5945                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5945 00000693 BAF80A0000          <1>  mov edx,%1
  5945 00000698 B00B                <1>  mov al,ePutConsoleString
  5945 0000069A CD30                <1>  int _svc
  5946                                  			putConsoleString  czNewLine				;write newline to console
  5946 0000069C BA[C2080000]        <1>  mov edx,%1
  5946 000006A1 B00B                <1>  mov al,ePutConsoleString
  5946 000006A3 CD30                <1>  int _svc
  5947 000006A5 C3                      			ret							;return
  5948                                  ;-----------------------------------------------------------------------------------------------------------------------
  5949                                  ;
  5950                                  ;	Routine:	ConWeekday
  5951                                  ;
  5952                                  ;	Description:	This routine handles the WEEKDAY command.
  5953                                  ;
  5954                                  ;-----------------------------------------------------------------------------------------------------------------------
  5955                                  ConWeekday		readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5955                              <1> ConWeekday :
  5955 000006A6 BB480B0000          <1>  mov ebx,%1
  5955 000006AB B017                <1>  mov al,eReadRealTimeClock
  5955 000006AD CD30                <1>  int _svc
  5956                                  			putWeekdayString  wsConsoleDateTime,wzConsoleOutBuffer	;format weekday string
  5956 000006AF BB480B0000          <1>  mov ebx,%1
  5956 000006B4 BAF80A0000          <1>  mov edx,%2
  5956 000006B9 B014                <1>  mov al,ePutWeekdayString
  5956 000006BB CD30                <1>  int _svc
  5957                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5957 000006BD BAF80A0000          <1>  mov edx,%1
  5957 000006C2 B00B                <1>  mov al,ePutConsoleString
  5957 000006C4 CD30                <1>  int _svc
  5958                                  			putConsoleString  czNewLine				;write newline to console
  5958 000006C6 BA[C2080000]        <1>  mov edx,%1
  5958 000006CB B00B                <1>  mov al,ePutConsoleString
  5958 000006CD CD30                <1>  int _svc
  5959 000006CF C3                      			ret							;return
  5960                                  ;-----------------------------------------------------------------------------------------------------------------------
  5961                                  ;
  5962                                  ;	Routine:	ConWeekdayName
  5963                                  ;
  5964                                  ;	Description:	This routine Handles the WEEKDAY.NAME command.
  5965                                  ;
  5966                                  ;-----------------------------------------------------------------------------------------------------------------------
  5967                                  ConWeekdayName		readRealTimeClock    wsConsoleDateTime				;read RTC data into structure
  5967                              <1> ConWeekdayName :
  5967 000006D0 BB480B0000          <1>  mov ebx,%1
  5967 000006D5 B017                <1>  mov al,eReadRealTimeClock
  5967 000006D7 CD30                <1>  int _svc
  5968                                  			putWeekdayNameString wsConsoleDateTime,wzConsoleOutBuffer	;format day name string
  5968 000006D9 BB480B0000          <1>  mov ebx,%1
  5968 000006DE BAF80A0000          <1>  mov edx,%2
  5968 000006E3 B015                <1>  mov al,ePutWeekdayNameString
  5968 000006E5 CD30                <1>  int _svc
  5969                                  			putConsoleString     wzConsoleOutBuffer				;write string to console
  5969 000006E7 BAF80A0000          <1>  mov edx,%1
  5969 000006EC B00B                <1>  mov al,ePutConsoleString
  5969 000006EE CD30                <1>  int _svc
  5970                                  			putConsoleString     czNewLine					;write newline to console
  5970 000006F0 BA[C2080000]        <1>  mov edx,%1
  5970 000006F5 B00B                <1>  mov al,ePutConsoleString
  5970 000006F7 CD30                <1>  int _svc
  5971 000006F9 C3                      			ret								;return
  5972                                  ;-----------------------------------------------------------------------------------------------------------------------
  5973                                  ;
  5974                                  ;	Routine:	ConYear
  5975                                  ;
  5976                                  ;	Description:	This routine Handles the YEAR command.
  5977                                  ;
  5978                                  ;-----------------------------------------------------------------------------------------------------------------------
  5979                                  ConYear			readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5979                              <1> ConYear :
  5979 000006FA BB480B0000          <1>  mov ebx,%1
  5979 000006FF B017                <1>  mov al,eReadRealTimeClock
  5979 00000701 CD30                <1>  int _svc
  5980                                  			putYearString	  wsConsoleDateTime,wzConsoleOutBuffer	;format year string
  5980 00000703 BB480B0000          <1>  mov ebx,%1
  5980 00000708 BAF80A0000          <1>  mov edx,%2
  5980 0000070D B016                <1>  mov al,ePutYearString
  5980 0000070F CD30                <1>  int _svc
  5981                                  			putConsoleString  wzConsoleOutBuffer			;write string to console
  5981 00000711 BAF80A0000          <1>  mov edx,%1
  5981 00000716 B00B                <1>  mov al,ePutConsoleString
  5981 00000718 CD30                <1>  int _svc
  5982                                  			putConsoleString  czNewLine				;write newline to console
  5982 0000071A BA[C2080000]        <1>  mov edx,%1
  5982 0000071F B00B                <1>  mov al,ePutConsoleString
  5982 00000721 CD30                <1>  int _svc
  5983 00000723 C3                      			ret							;return
  5984                                  ;-----------------------------------------------------------------------------------------------------------------------
  5985                                  ;
  5986                                  ;	Routine:	ConYearIsLeap
  5987                                  ;
  5988                                  ;	Description:	This routine handles the YEAR.ISLEAP command
  5989                                  ;
  5990                                  ;-----------------------------------------------------------------------------------------------------------------------
  5991                                  ConYearIsLeap		readRealTimeClock wsConsoleDateTime			;read RTC data into structure
  5991                              <1> ConYearIsLeap :
  5991 00000724 BB480B0000          <1>  mov ebx,%1
  5991 00000729 B017                <1>  mov al,eReadRealTimeClock
  5991 0000072B CD30                <1>  int _svc
  5992                                  			isLeapYear        wsConsoleDateTime			;indicate if year is leap year
  5992 0000072D BB480B0000          <1>  mov ebx,%1
  5992 00000732 B009                <1>  mov al,eIsLeapYear
  5992 00000734 CD30                <1>  int _svc
  5993                                  
  5994 00000736 E30B                    			jecxz	.10						;branch if not leap
  5995                                  
  5996                                  			putConsoleString  czYearIsLeap				;display year is leap message
  5996 00000738 BA[B4090000]        <1>  mov edx,%1
  5996 0000073D B00B                <1>  mov al,ePutConsoleString
  5996 0000073F CD30                <1>  int _svc
  5997                                  
  5998 00000741 EB09                    			jmp	.20						;continue
  5999                                  
  6000                                  .10			putConsoleString  czYearIsNotLeap			;display year is not leap mesage
  6000                              <1> .10 :
  6000 00000743 BA[CF090000]        <1>  mov edx,%1
  6000 00000748 B00B                <1>  mov al,ePutConsoleString
  6000 0000074A CD30                <1>  int _svc
  6001 0000074C C3                      .20			ret							;return
  6002                                  ;-----------------------------------------------------------------------------------------------------------------------
  6003                                  ;
  6004                                  ;	Routine:	ConVersion
  6005                                  ;
  6006                                  ;	Description:	This routine handles the VERSION command and its alias, VER.
  6007                                  ;
  6008                                  ;-----------------------------------------------------------------------------------------------------------------------
  6009                                  ConVersion		putConsoleString czTitle				;display version message
  6009                              <1> ConVersion :
  6009 0000074D BA[47090000]        <1>  mov edx,%1
  6009 00000752 B00B                <1>  mov al,ePutConsoleString
  6009 00000754 CD30                <1>  int _svc
  6010 00000756 C3                      			ret							;return
  6011                                  ;-----------------------------------------------------------------------------------------------------------------------
  6012                                  ;
  6013                                  ;	Tables
  6014                                  ;
  6015                                  ;-----------------------------------------------------------------------------------------------------------------------
  6016                                  										;---------------------------------------
  6017                                  										;  Command Jump Table
  6018                                  										;---------------------------------------
  6019                                  tConJmpTbl		equ	$						;command jump table
  6020 00000757 D0060000                			dd	ConWeekdayName	- ConCode			;weekday.name command routine offset
  6021 0000075B 24070000                			dd	ConYearIsLeap	- ConCode			;year.isleap command routine offset
  6022 0000075F 3A030000                			dd	ConMonthName	- ConCode			;month.name command routine offset
  6023 00000763 64030000                			dd	ConPCIProbe	- ConCode			;pciprobe command routine offset
  6024 00000767 7A010000                			dd	ConExit		- ConCode			;shutdown command routine offset
  6025 0000076B 4D070000                			dd	ConVersion	- ConCode			;version command routine offset
  6026 0000076F A6060000                			dd	ConWeekday	- ConCode			;weekday command routine offset
  6027 00000773 EE010000                			dd	ConMalloc	- ConCode			;malloc command routine offset
  6028 00000777 43020000                			dd	ConMem		- ConCode			;memory command routine offset
  6029 0000077B E6020000                			dd	ConMinute	- ConCode			;minute command routine offset
  6030 0000077F 52060000                			dd	ConSecond	- ConCode			;second command routine offset
  6031 00000783 21010000                			dd	ConClear	- ConCode			;clear command routine offset
  6032 00000787 64030000                			dd	ConPCIProbe	- ConCode			;lspci command routine offset
  6033 0000078B 10030000                			dd	ConMonth	- ConCode			;month command routine offset
  6034 0000078F 26010000                			dd	ConDate		- ConCode			;date command routine offset
  6035 00000793 7A010000                			dd	ConExit		- ConCode			;exit command routine offset
  6036 00000797 7F010000                			dd	ConFree		- ConCode			;free command routine offset
  6037 0000079B C1010000                			dd	ConHour		- ConCode			;hour command routine offset
  6038 0000079F EB010000                			dd	ConInt6		- ConCode			;int6 command routine offset
  6039 000007A3 7A010000                			dd	ConExit		- ConCode			;quit command routine offset
  6040 000007A7 7C060000                			dd	ConTime		- ConCode			;time command routine offset
  6041 000007AB FA060000                			dd	ConYear		- ConCode			;year command routine offset
  6042 000007AF 21010000                			dd	ConClear	- ConCode			;cls command routine offset
  6043 000007B3 50010000                			dd	ConDay		- ConCode			;day command routine offset
  6044 000007B7 43020000                			dd	ConMem		- ConCode			;mem command routine offset
  6045 000007BB 4D070000                			dd	ConVersion	- ConCode			;ver command routine offset
  6046                                  ECONJMPTBLL		equ	($-tConJmpTbl)					;table length
  6047                                  ECONJMPTBLCNT		equ	ECONJMPTBLL/4					;table entries
  6048                                  										;---------------------------------------
  6049                                  										;  Command Name Table
  6050                                  										;---------------------------------------
  6051                                  tConCmdTbl		equ	$						;command name table
  6052 000007BF 0D5745454B4441592E-     			db	13,"WEEKDAY.NAME",0				;weekday.name command
  6052 000007C8 4E414D4500         
  6053 000007CD 0C594541522E49534C-     			db	12,"YEAR.ISLEAP",0				;year.isleap command
  6053 000007D6 45415000           
  6054 000007DA 0B4D4F4E54482E4E41-     			db	11,"MONTH.NAME",0				;month.name command
  6054 000007E3 4D4500             
  6055 000007E6 0950434950524F4245-     			db	9,"PCIPROBE",0					;pciprobe command
  6055 000007EF 00                 
  6056 000007F0 0953485554444F574E-     			db	9,"SHUTDOWN",0					;shutdown command
  6056 000007F9 00                 
  6057 000007FA 0856455253494F4E00      			db	8,"VERSION",0					;version command
  6058 00000803 085745454B44415900      			db	8,"WEEKDAY",0					;weekday command
  6059 0000080C 074D414C4C4F4300        			db	7,"MALLOC",0					;malloc command
  6060 00000814 074D454D4F525900        			db	7,"MEMORY",0					;memory command
  6061 0000081C 074D494E55544500        			db	7,"MINUTE",0					;minute command
  6062 00000824 075345434F4E4400        			db	7,"SECOND",0					;second command
  6063 0000082C 06434C45415200          			db	6,"CLEAR",0					;clear command
  6064 00000833 064C5350434900          			db	6,"LSPCI",0					;lspci command (pciprobe alias)
  6065 0000083A 064D4F4E544800          			db	6,"MONTH",0					;month command
  6066 00000841 054441544500            			db	5,"DATE",0					;date command
  6067 00000847 054558495400            			db	5,"EXIT",0					;exit command
  6068 0000084D 054652454500            			db	5,"FREE",0					;free command
  6069 00000853 05484F555200            			db	5,"HOUR",0					;hour command
  6070 00000859 05494E543600            			db	5,"INT6",0					;int6 command
  6071 0000085F 055155495400            			db	5,"QUIT",0					;quit command
  6072 00000865 0554494D4500            			db	5,"TIME",0					;time command
  6073 0000086B 055945415200            			db	5,"YEAR",0					;year command
  6074 00000871 04434C5300              			db	4,"CLS",0					;cls command
  6075 00000876 0444415900              			db	4,"DAY",0					;day command
  6076 0000087B 044D454D00              			db	4,"MEM",0					;mem command
  6077 00000880 0456455200              			db	4,"VER",0					;ver command
  6078 00000885 00                      			db	0						;end of table
  6079                                  ;-----------------------------------------------------------------------------------------------------------------------
  6080                                  ;
  6081                                  ;	Constants
  6082                                  ;
  6083                                  ;-----------------------------------------------------------------------------------------------------------------------
  6084 00000886 4170706C6500            czApple			db	"Apple",0					;vendor name string
  6085 0000088C 41757265616C204144-     czAurealAD1881		db	"Aureal AD1881 SOUNDMAX",0			;soundmax string
  6085 00000895 3138383120534F554E-
  6085 0000089E 444D415800         
  6086 000008A3 45746865726E657420-     czEthernetAdapterFound	db	"Ethernet adapter found",13,10,0		;adapter found message
  6086 000008AC 616461707465722066-
  6086 000008B5 6F756E640D0A00     
  6087 000008BC 496E74656C00            czIntel			db	"Intel",0					;vendor name string
  6088 000008C2 0D0A00                  czNewLine		db	13,10,0						;new line string
  6089 000008C5 6F6B0D0A00              czOK			db	"ok",13,10,0					;ok string
  6090 000008CA 4F7261636C6500          czOracle		db	"Oracle",0					;vendor name string
  6091 000008D1 4F7468657200            czOther			db	"Other",0					;default name string
  6092 000008D7 5043492026204D656D-     czPCIAndMem		db	"PCI & Memory",0				;PCI and Memory string
  6092 000008E0 6F727900           
  6093 000008E4 2E00                    czPeriod		db	".",0						;period delimiter
  6094 000008E6 504949583320504349-     czPIIX3PCItoIDEBridge	db	"PIIX3 PCI-to-ISA Bridge",0			;pci-to-isa bridge string
  6094 000008EF 2D746F2D4953412042-
  6094 000008F8 726964676500       
  6095 000008FE 50494958342F34452F-     czPIIX4PowerMgmt	db	"PIIX4/4E/4M Power Management Controller",0	;power management controller string
  6095 00000907 344D20506F77657220-
  6095 00000910 4D616E6167656D656E-
  6095 00000919 7420436F6E74726F6C-
  6095 00000922 6C657200           
  6096 00000926 3A00                    czPrompt		db	":",0						;prompt string
  6097 00000928 50726F2F3130303020-     czPro1000MT		db	"Pro/1000 MT Ethernet Adapter",0		;Intel Pro/1000 MT Ethernet adapter strg
  6097 00000931 4D542045746865726E-
  6097 0000093A 657420416461707465-
  6097 00000943 7200               
  6098 00000945 2000                    czSpace			db	" ",0						;space delimiter
  6099 00000947 437573746F6D204F70-     czTitle			db	"Custom Operating System 1.0",13,10,0		;version string
  6099 00000950 65726174696E672053-
  6099 00000959 797374656D20312E30-
  6099 00000962 0D0A00             
  6100 00000965 556E6B6E6F776E2063-     czUnknownCommand	db	"Unknown command",13,10,0			;unknown command response string
  6100 0000096E 6F6D6D616E640D0A00 
  6101 00000977 55534220436F6E7472-     czUSBController		db	"USB Controller",0				;USB controller string
  6101 00000980 6F6C6C657200       
  6102 00000986 5669727475616C426F-     czVirtualBoxDevice	db	"VirtualBox Device",0				;Virtual Box device string
  6102 0000098F 782044657669636500 
  6103 00000998 5669727475616C426F-     czVirtualBoxGA		db	"VirtualBox Graphics Adapter",0			;Virtual Box graphics adapter string
  6103 000009A1 782047726170686963-
  6103 000009AA 732041646170746572-
  6103 000009B3 00                 
  6104 000009B4 546865207965617220-     czYearIsLeap		db	"The year is a leap year.",13,10,0		;leap year message
  6104 000009BD 69732061206C656170-
  6104 000009C6 20796561722E0D0A00 
  6105 000009CF 546865207965617220-     czYearIsNotLeap		db	"The year is not a leap year.",13,10,0		;not leap year message
  6105 000009D8 6973206E6F74206120-
  6105 000009E1 6C6561702079656172-
  6105 000009EA 2E0D0A00           
  6106 000009EE 383233373141422F45-     cz82371ABBusMaster	db	"82371AB/EB PCI Bus Master IDE Controller",0	;bus-master strin
  6106 000009F7 422050434920427573-
  6106 00000A00 204D61737465722049-
  6106 00000A09 444520436F6E74726F-
  6106 00000A12 6C6C657200         
  6107 00000A17 00<rept>                			times	4094-($-$$) db 0h				;zero fill to end of section
  6108 00000FFE 55AA                    			db	055h,0AAh					;end of section
  6109                                  ;=======================================================================================================================
  6110                                  ;
  6111                                  ;	Background Task								@disk: 009400	@mem: 006000
  6112                                  ;
  6113                                  ;	This task executes monitoring and self-correcting functions.
  6114                                  ;
  6115                                  ;			000000	+-----------------------------------------------+
  6116                                  ;				|  Real Mode Interrupt Vectors			|
  6117                                  ;			000400	+-----------------------------------------------+ DS,ES:0400
  6118                                  ;				|  Reserved BIOS Memory Area			|
  6119                                  ;			000800	+-----------------------------------------------+ DS,ES:0800
  6120                                  ;				|  Shared Kernel Memory Area			|
  6121                                  ;			001000	+-----------------------------------------------+		<-- GDTR
  6122                                  ;				|  Global Descriptor Table (GDT)		|
  6123                                  ;			001800	+-----------------------------------------------+		<-- IDTR
  6124                                  ;				|  Interrupt Descriptor Table (IDT)		|
  6125                                  ;			002000	+-----------------------------------------------+
  6126                                  ;				|  Interrupt Handlers				|
  6127                                  ;				|  Kernel Function Library			|
  6128                                  ;			004000	+===============================================+
  6129                                  ;				|  Console Task Stack Area			|
  6130                                  ;			004700	+-----------------------------------------------+
  6131                                  ;				|  Console Task Local Descriptor Table (LDT)	|
  6132                                  ;			004780	+-----------------------------------------------+
  6133                                  ;				|  Console Task Task State Segment (TSS)	|
  6134                                  ;			004800	+-----------------------------------------------+
  6135                                  ;				|  Console Task Message Queue			|
  6136                                  ;			005000	+-----------------------------------------------+
  6137                                  ;				|  Console Task Code				|
  6138                                  ;				|  Console Task Constants			|
  6139                                  ;			006000	+===============================================+
  6140                                  ;				|  Background Task Stack Area			|
  6141                                  ;	SS:SP --------> 006700	+-----------------------------------------------+ SS:0700	<-- LDTR = GDT.SEL 0060h
  6142                                  ;				|  Background Task Local Descriptor Table (LDT) |
  6143                                  ;			006780  +-----------------------------------------------+		<-- TR = GDT.SEL 0068h
  6144                                  ;				|  Background Task Task State Segment (TSS)	|
  6145                                  ;			006800	+-----------------------------------------------+
  6146                                  ;				|  Background Task Message Queue		|
  6147                                  ;	CS,CS:IP ----->	007000	+-----------------------------------------------+ CS:0000
  6148                                  ;				|  Background Task Code				|
  6149                                  ;				|  Background Task Constants			|
  6150                                  ;			008000	+===============================================+
  6151                                  ;
  6152                                  ;=======================================================================================================================
  6153                                  ;-----------------------------------------------------------------------------------------------------------------------
  6154                                  ;
  6155                                  ;	Background Task Stack							@disk: 009400	@mem:  006000
  6156                                  ;
  6157                                  ;	This is the stack for the background task. It supports 448 nested calls.
  6158                                  ;
  6159                                  ;-----------------------------------------------------------------------------------------------------------------------
  6160                                  section			bgstack							;background task stack
  6161 00000000 00<rept>                			times	1792-($-$$) db 0h				;zero fill to end of section
  6162                                  ;-----------------------------------------------------------------------------------------------------------------------
  6163                                  ;
  6164                                  ;	Background Task Local Descriptor Table					@disk: 009B00	@mem:  006700
  6165                                  ;
  6166                                  ;	This is the LDT for the background task. It defines the stack, code, data and queue segments as well as data
  6167                                  ;	aliases for the TSS LDT. Data aliases allow inspection and altering of the TSS and LDT. This LDT can hold up to
  6168                                  ;	16 descriptors. Six are initially defined.
  6169                                  ;
  6170                                  ;-----------------------------------------------------------------------------------------------------------------------
  6171                                  section			bgldt							;background task local descriptors
  6172 00000000 7F00806700934000        			dq	004093006780007Fh				;04 TSS alias		128B  @ 6780
  6173 00000008 7F00006700934000        			dq	004093006700007Fh				;0C LDT alias		128B  @ 6700
  6174 00000010 FF06006000934000        			dq	00409300600006FFh				;14 stack		1792B @ 6600
  6175 00000018 FFFF00000093CF00        			dq	00CF93000000FFFFh				;1C data		4GB   @ 0000
  6176 00000020 FF0F0070009B4000        			dq	00409B0070000FFFh				;24 code                4KB   @ 7000
  6177 00000028 FF07006800934000        			dq	00409300680007FFh				;2C message queue	2KB   @ 6800
  6178 00000030 00<rept>                			times	128-($-$$) db 0h				;zero fill to end of section
  6179                                  ;-----------------------------------------------------------------------------------------------------------------------
  6180                                  ;
  6181                                  ;	Background Task State Segment						@disk: 009B80	@mem:  006780
  6182                                  ;
  6183                                  ;	This is the TSS for the console task. All rings share the same stack. DS and ES are set to the console data
  6184                                  ;	segment. CS to console code.
  6185                                  ;
  6186                                  ;-----------------------------------------------------------------------------------------------------------------------
  6187                                  section			bgtss							;background task state segment
  6188 00000000 00000000                			dd	0						;00 back-link tss
  6189 00000004 00070000                			dd	0700h						;04 esp ring 0
  6190 00000008 14000000                			dd	0014h						;08 ss ring 0
  6191 0000000C 00070000                			dd	0700h						;0C esp ring 1
  6192 00000010 14000000                			dd	0014h						;10 es ring 1
  6193 00000014 00070000                			dd	0700h						;14 esp ring 2
  6194 00000018 14000000                			dd	0014h						;18 ss ring 2
  6195 0000001C 00000000                			dd	0						;1C cr ring 3
  6196 00000020 00000000                			dd	0						;20 eip
  6197 00000024 00020000                			dd	0200h						;24 eflags
  6198 00000028 00000000                			dd	0						;28 eax
  6199 0000002C 00000000                			dd	0						;2C ecx
  6200 00000030 00000000                			dd	0						;30 edx
  6201 00000034 00000000                			dd	0						;34 ebx
  6202 00000038 00070000                			dd	0700h						;38 esp ring 3
  6203 0000003C 00000000                			dd	0						;3C ebp
  6204 00000040 00000000                			dd	0						;40 esi
  6205 00000044 00000000                			dd	0						;44 edi
  6206 00000048 1C000000                			dd	001Ch						;48 es
  6207 0000004C 24000000                			dd	0024h						;4C cs
  6208 00000050 14000000                			dd	0014h						;50 ss ring 3
  6209 00000054 1C000000                			dd	001Ch						;54 ds
  6210 00000058 00000000                			dd	0						;58 fs
  6211 0000005C 00000000                			dd	0						;5c gs
  6212 00000060 70000000                			dd	ESELBACKGROUNDLDT				;60 ldt selector in gdt
  6213 00000064 00<rept>                			times	128-($-$$) db 0h				;zero fill to end of section
  6214                                  ;-----------------------------------------------------------------------------------------------------------------------
  6215                                  ;
  6216                                  ;	Background Task Message Queue						@disk: 009C00	@mem: 006800
  6217                                  ;
  6218                                  ;	The console message queue is 2048 bytes of memory organized as a queue of 510 double words (4 bytes each) and
  6219                                  ;	two double word values that act as indices. The queue is a FIFO that is fed by the keyboard hardware interrupt
  6220                                  ;	handler and consumed by a service routine called from a task. Each queue entry defines an input (keystroke)
  6221                                  ;	event.
  6222                                  ;
  6223                                  ;-----------------------------------------------------------------------------------------------------------------------
  6224                                  section			bgmque							;console message queue
  6225 00000000 08000000                			dd	8						;head pointer
  6226 00000004 08000000                			dd	8						;tail pointer
  6227 00000008 00000000<rept>          			times	510 dd 0					;queue elements
  6228                                  ;-----------------------------------------------------------------------------------------------------------------------
  6229                                  ;
  6230                                  ;	Background Task Code							@disk: 00A400	@mem: 007000
  6231                                  ;
  6232                                  ;-----------------------------------------------------------------------------------------------------------------------
  6233                                  section			bgcode	vstart=07000h					;labels relative to 7000h
  6234 00000000 E857000000              BackgroundCode		call	BgInitializeData				;initialize the background variables
  6235                                  
  6236                                  .10			readRealTimeClock wsBgDateTime				;read real-time clock data
  6236                              <1> .10 :
  6236 00000005 BB500B0000          <1>  mov ebx,%1
  6236 0000000A B017                <1>  mov al,eReadRealTimeClock
  6236 0000000C CD30                <1>  int _svc
  6237                                  			putTimeString     wsBgDateTime,wzBgTime			;create ASCII time string
  6237 0000000E BB500B0000          <1>  mov ebx,%1
  6237 00000013 BA580B0000          <1>  mov edx,%2
  6237 00000018 B013                <1>  mov al,ePutTimeString
  6237 0000001A CD30                <1>  int _svc
  6238                                  			compareMemory	  wzBgTime,wzBgTimeCmpr,EBGTIMELEN	;compare to previous time string
  6238 0000001C BA580B0000          <1>  mov edx,%1
  6238 00000021 BB610B0000          <1>  mov ebx,%2
  6238 00000026 B909000000          <1>  mov ecx,%3
  6238 0000002B B003                <1>  mov al,eCompareMemory
  6238 0000002D CD30                <1>  int _svc
  6239                                  
  6240 0000002F E3D4                    			jecxz	.10						;repeat if equal
  6241 00000031 06                      			push	es						;save non-volatile reg
  6242 00000032 6A20                    			push	ESELCGA						;load CGA selector ...
  6243 00000034 07                      			pop	es						;... into extra segment reg
  6244 00000035 BE580B0000              			mov	esi,wzBgTime					;string address
  6245 0000003A B518                    			mov	ch,24						;OIA row
  6246 0000003C B143                    			mov	cl,67						;OIA column
  6247                                  
  6248                                  			setConsoleString					;display string
  6248 0000003E B019                <1>  mov al,eSetConsoleString
  6248 00000040 CD30                <1>  int _svc
  6249                                  
  6250 00000042 07                      			pop	es						;restore non-volatile reg
  6251                                  
  6252                                  			copyMemory	  wzBgTime,wzBgTimeCmpr,EBGTIMELEN	;copy to comparison string
  6252 00000043 BA580B0000          <1>  mov edx,%1
  6252 00000048 BB610B0000          <1>  mov ebx,%2
  6252 0000004D B909000000          <1>  mov ecx,%3
  6252 00000052 B004                <1>  mov al,eCopyMemory
  6252 00000054 CD30                <1>  int _svc
  6253                                  			yield							;halt until interrupt
  6253 00000056 B01D                <1>  mov al,eYield
  6253 00000058 CD30                <1>  int _svc
  6254                                  
  6255 0000005A EBA9                    			jmp	.10						;continue
  6256                                  ;-----------------------------------------------------------------------------------------------------------------------
  6257                                  ;
  6258                                  ;	Routine:	BgInitializeData
  6259                                  ;
  6260                                  ;	Description:	This routine initializes background task variables.
  6261                                  ;
  6262                                  ;-----------------------------------------------------------------------------------------------------------------------
  6263 0000005C 51                      BgInitializeData	push	ecx						;save non-volatile regs
  6264 0000005D 57                      			push	edi						;
  6265 0000005E 06                      			push	es						;
  6266                                  ;
  6267                                  ;	Initialize console work areas
  6268                                  ;
  6269 0000005F 6A18                    			push	ESELDAT						;load OS data selector ...
  6270 00000061 07                      			pop	es						;... into extra segment register
  6271 00000062 BF500B0000              			mov	edi,EBGDATA					;OS console data address
  6272 00000067 30C0                    			xor	al,al						;initialization value
  6273 00000069 B91A000000              			mov	ecx,EBGDATALEN					;size of OS console data
  6274 0000006E FC                      			cld							;forward strings
  6275 0000006F F3AA                    			rep	stosb						;initialize data
  6276                                  ;
  6277                                  ;	Restore and return
  6278                                  ;
  6279 00000071 07                      			pop	es						;restore non-volatile regs
  6280 00000072 5F                      			pop	edi						;
  6281 00000073 59                      			pop	ecx						;
  6282 00000074 C3                      			ret							;return
  6283                                  ;-----------------------------------------------------------------------------------------------------------------------
  6284                                  ;
  6285                                  ;	Background Task Constants
  6286                                  ;
  6287                                  ;-----------------------------------------------------------------------------------------------------------------------
  6288 00000075 00<rept>                			times	4094-($-$$) db 0h				;zero fill to end of section
  6289 00000FFE 55AA                    			db	055h,0AAh					;end of section
  6290                                  %endif
  6291                                  %ifdef BUILDDISK
  6292                                  ;-----------------------------------------------------------------------------------------------------------------------
  6293                                  ;
  6294                                  ;	Free Disk Space								@disk: 00B400	@mem:  n/a
  6295                                  ;
  6296                                  ;	Following the convention introduced by DOS, we use the value 'F6' to indicate unused floppy disk storage.
  6297                                  ;
  6298                                  ;-----------------------------------------------------------------------------------------------------------------------
  6299                                  section			unused							;unused disk space
  6300 00000000 F6<rept>                			times	EBOOTDISKBYTES-0B400h db 0F6h			;fill to end of disk image
  6301                                  %endif
  6302                                  ;=======================================================================================================================
  6303                                  ;
  6304                                  ;	End of Program Code
  6305                                  ;
  6306                                  ;=======================================================================================================================
