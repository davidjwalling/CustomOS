     1                                  ;=======================================================================================================================
     2                                  ;
     3                                  ;       File:           os.asm
     4                                  ;
     5                                  ;       Project:        os.011
     6                                  ;
     7                                  ;       Description:    In this sample, the kernel is expanded to iterate across tasks in a task queue.
     8                                  ;
     9                                  ;       Revised:        July 4, 2018
    10                                  ;
    11                                  ;       Assembly:       nasm os.asm -f bin -o os.dat     -l os.dat.lst     -DBUILDBOOT
    12                                  ;                       nasm os.asm -f bin -o os.dsk     -l os.dsk.lst     -DBUILDDISK
    13                                  ;                       nasm os.asm -f bin -o os.com     -l os.com.lst     -DBUILDCOM
    14                                  ;                       nasm os.asm -f bin -o osprep.com -l osprep.com.lst -DBUILDPREP
    15                                  ;
    16                                  ;       Assembler:      Netwide Assembler (NASM) 2.13.03, Feb 7 2018
    17                                  ;
    18                                  ;       Notice:         Copyright (C) 2010-2018 David J. Walling. All Rights Reserved.
    19                                  ;
    20                                  ;=======================================================================================================================
    21                                  ;-----------------------------------------------------------------------------------------------------------------------
    22                                  ;
    23                                  ;       Assembly Directives
    24                                  ;
    25                                  ;       Use one of the following as an assembly directive (-D) with NASM.
    26                                  ;
    27                                  ;       BUILDBOOT       Creates os.dat, a 512-byte boot sector as a standalone file.
    28                                  ;       BUILDDISK       Creates os.dsk, a 1.44MB (3.5") floppy disk image file.
    29                                  ;       BUILDCOM        Creates os.com, the OS loader and kernel as a standalone DOS program.
    30                                  ;       BUILDPREP       Creates osprep.com, a DOS program that prepares a floppy disk to boot the OS
    31                                  ;
    32                                  ;-----------------------------------------------------------------------------------------------------------------------
    33                                  %ifdef BUILDDISK                                                                ;if we are building a disk image ...
    34                                  %define BUILDBOOT                                                               ;... build the boot sector
    35                                  %define BUILDCOM                                                                ;... and the OS kernel
    36                                  %endif
    37                                  %ifdef BUILDPREP                                                                ;if creating the disk prep program ...
    38                                  %define BUILDBOOT                                                               ;... also build the boot sector
    39                                  %endif
    40                                  ;-----------------------------------------------------------------------------------------------------------------------
    41                                  ;
    42                                  ;       Conventions
    43                                  ;
    44                                  ;       Alignment:      In this document, columns are numbered beginning with 1.
    45                                  ;                       Assembly instructions (mnemonics) begin in column 25.
    46                                  ;                       Assembly operands begin in column 33.
    47                                  ;                       Inline comments begin in column 81.
    48                                  ;                       Lines should not extend beyond column 120.
    49                                  ;
    50                                  ;       Arguments:      Arguments are passed as registers and generally follow this order: EAX, ECX, EDX, EBX.
    51                                  ;                       However, ECX may be used as the first parameter if a test for zero is required. EBX and EBP
    52                                  ;                       may be used as parameters if the routine is considered a "method" of an "object". In this
    53                                  ;                       case, EBX or EBP will address the object storage. If the routine is general-purpose string
    54                                  ;                       or character-array manipulator, ESI and EDI may be used as parameters to address input and/or
    55                                  ;                       ouput buffers, respectively.
    56                                  ;
    57                                  ;       Code Order:     Routines should appear in the order of their first likely use.
    58                                  ;                       Negative relative call or jump addresses indicate reuse.
    59                                  ;
    60                                  ;       Comments:       A comment that spans the entire line begins with a semicolon in column 1.
    61                                  ;                       A comment that accompanies code on a line begins with a semicolon in column 81.
    62                                  ;                       Register names in comments are in upper case (EAX, EDI).
    63                                  ;                       Hexadecimal values in comments are in lower case (01fh, 0dah).
    64                                  ;                       Routines are preceded with a comment box that includes the routine name, description, and
    65                                  ;                       register contents on entry and exit.
    66                                  ;
    67                                  ;       Constants:      Symbolic constants (equates) are named in all-caps beginning with 'E' (EDATAPORT).
    68                                  ;                       Constant stored values are named in camel case, starting with 'c' (cbMaxLines).
    69                                  ;                       The 2nd letter of the constant label indicates the storage type.
    70                                  ;
    71                                  ;                       cq......        constant quad-word (dq)
    72                                  ;                       cd......        constant double-word (dd)
    73                                  ;                       cw......        constant word (dw)
    74                                  ;                       cb......        constant byte (db)
    75                                  ;                       cz......        constant ASCIIZ (null-terminated) string
    76                                  ;
    77                                  ;       Instructions:   32-bit instructions are generally favored.
    78                                  ;                       8-bit instructions and data are preferred for flags and status fields, etc.
    79                                  ;                       16-bit instructions are avoided wherever possible to avoid prefix bytes.
    80                                  ;
    81                                  ;       Labels:         Labels within a routine are numeric and begin with a period (.10, .20).
    82                                  ;                       Labels within a routine begin at ".10" and increment by 10.
    83                                  ;
    84                                  ;       Literals:       Literal values defined by external standards should be defined as symbolic constants (equates).
    85                                  ;                       Hexadecimal literals in code are in upper case with a leading '0' and trailing 'h' (01Fh).
    86                                  ;                       Binary literal values in source code are encoded with a final 'b' (1010b).
    87                                  ;                       Decimal literal values in source code are strictly numerals (2048).
    88                                  ;                       Octal literal values are avoided.
    89                                  ;                       String literals are enclosed in double quotes, e.g. "Loading OS".
    90                                  ;                       Single character literals are enclosed in single quotes, e.g. 'A'.
    91                                  ;
    92                                  ;       Macros:         Macro names are in camel case, beginning with a lower-case letter (getDateString).
    93                                  ;                       Macro names describe an action and so DO begin with a verb.
    94                                  ;
    95                                  ;       Memory Use:     Operating system memory allocation is avoided wherever possible.
    96                                  ;                       Buffers are kept to as small a size as practicable.
    97                                  ;                       Data and code intermingling is avoided wherever possible.
    98                                  ;
    99                                  ;       Registers:      Register names in comments are in upper case (EAX, EDX).
   100                                  ;                       Register names in source code are in lower case (eax, edx).
   101                                  ;
   102                                  ;       Return Values:  Routines return result values in EAX or ECX or both. Routines should indicate failure by
   103                                  ;                       setting the carry flag to 1. Routines may prefer the use of ECX as a return value if the
   104                                  ;                       value is to be tested for null upon return (using the jecxz instruction).
   105                                  ;
   106                                  ;       Routines:       Routine names are in mixed case, capitalized (GetYear, ReadRealTimeClock).
   107                                  ;                       Routine names begin with a verb (Get, Read, Load).
   108                                  ;                       Routines should have a single entry address and a single exit instruction (ret, iretd, etc.).
   109                                  ;                       Routines that serve as wrappers for library functions carry the same name as the library
   110                                  ;                       function but begin with a leading underscore (_) character.
   111                                  ;
   112                                  ;       Structures:     Structure names are in all-caps (DATETIME).
   113                                  ;                       Structure names describe a "thing" and so do NOT begin with a verb.
   114                                  ;
   115                                  ;       Usage:          Registers EBX, ECX, EBP, SS, CS, DS and ES are preserved by routines.
   116                                  ;                       Registers ESI and EDI are preserved unless they are input parameters.
   117                                  ;                       Registers EAX and ECX are preferred for returning response/result values.
   118                                  ;                       Registers EBX and EBP are preferred for context (structure) address parameters.
   119                                  ;                       Registers EAX, ECX, EDX and EBX are preferred for integral parameters.
   120                                  ;
   121                                  ;       Variables:      Variables are named in camel case, starting with 'w'.
   122                                  ;                       The 2nd letter of the variable label indicates the storage type.
   123                                  ;
   124                                  ;                       wq......        variable quad-word (resq)
   125                                  ;                       wd......        variable double-word (resd)
   126                                  ;                       ww......        variable word (resw)
   127                                  ;                       wb......        variable byte (resb)
   128                                  ;                       ws......        writable structure
   129                                  ;
   130                                  ;-----------------------------------------------------------------------------------------------------------------------
   131                                  ;=======================================================================================================================
   132                                  ;
   133                                  ;       Equates
   134                                  ;
   135                                  ;       The equate (equ) statement defines a symbolic name for a fixed value so that such a value can be defined and
   136                                  ;       verified once and then used throughout the code. Using symbolic names simplifies searching for where logical
   137                                  ;       values are used. Equate names are in all-caps and begin with the letter 'E'. Equates are grouped into related
   138                                  ;       sets. Equates here are defined in the following groupings:
   139                                  ;
   140                                  ;       Hardware-Defined Values
   141                                  ;
   142                                  ;       ECRT...         6845 Cathode Ray Tube (CRT) Controller values
   143                                  ;       EFDC...         NEC 765 Floppy Disk Controller (FDC) values
   144                                  ;       EKEYB...        8042 or "PS/2 Controller" (Keyboard Controller) values
   145                                  ;       EPIC...         8259 Programmable Interrupt Controller (PIC) values
   146                                  ;       EPIT...         8253 Programmable Interval Timer (PIT) values
   147                                  ;       EX86...         Intel x86 CPU architecture values
   148                                  ;
   149                                  ;       Firmware-Defined Values
   150                                  ;
   151                                  ;       EBIOS...        Basic Input/Output System (BIOS) values
   152                                  ;
   153                                  ;       Standards-Based Values
   154                                  ;
   155                                  ;       EASCII...       American Standard Code for Information Interchange (ASCII) values
   156                                  ;
   157                                  ;       Operating System Values
   158                                  ;
   159                                  ;       EBOOT...        Boot sector and loader values
   160                                  ;       ECON...         Console values (dimensions and attributes)
   161                                  ;       EGDT...         Global Descriptor Table (GDT) selector values
   162                                  ;       EKEYF...        Keyboard status flags
   163                                  ;       EKRN...         Kernel values (fixed locations and sizes)
   164                                  ;       ELDT...         Local Descriptor Table (LDT) selector values
   165                                  ;       EMEM...         Memory Management values
   166                                  ;       EMSG...         Message identifers
   167                                  ;
   168                                  ;=======================================================================================================================
   169                                  ;-----------------------------------------------------------------------------------------------------------------------
   170                                  ;
   171                                  ;       Hardware-Defined Values
   172                                  ;
   173                                  ;-----------------------------------------------------------------------------------------------------------------------
   174                                  ;-----------------------------------------------------------------------------------------------------------------------
   175                                  ;
   176                                  ;       6845 Cathode Ray Tube (CRT) Controller                                  ECRT...
   177                                  ;
   178                                  ;       The Motorola 6845 CRT Controller (CRTC) is a programmable controller
   179                                  ;       for CGA, EGA, VGA and compatible video modes.
   180                                  ;
   181                                  ;-----------------------------------------------------------------------------------------------------------------------
   182                                  ECRTPORTHI              equ     003h                                            ;controller port hi
   183                                  ECRTPORTLO              equ     0D4h                                            ;controller port lo
   184                                  ECRTCURLOCHI            equ     00Eh                                            ;cursor loc reg hi
   185                                  ECRTCURLOCLO            equ     00Fh                                            ;cursor loc reg lo
   186                                  ;-----------------------------------------------------------------------------------------------------------------------
   187                                  ;
   188                                  ;       NEC 765 Floppy Disk Controller (FDC)                                    EFDC...
   189                                  ;
   190                                  ;       The NEC 765 FDC is a programmable controller for floppy disk drives.
   191                                  ;
   192                                  ;-----------------------------------------------------------------------------------------------------------------------
   193                                  EFDCPORTHI              equ     003h                                            ;controller port hi
   194                                  EFDCPORTLOOUT           equ     0F2h                                            ;digital output register lo
   195                                  EFDCPORTLOSTAT          equ     0F4h                                            ;main status register lo
   196                                  EFDCSTATBUSY            equ     010h                                            ;main status is busy
   197                                  EFDCMOTOROFF            equ     00Ch                                            ;motor off / enable / DMA
   198                                  ;-----------------------------------------------------------------------------------------------------------------------
   199                                  ;
   200                                  ;       8042 Keyboard Controller                                                EKEYB...
   201                                  ;
   202                                  ;       The 8042 Keyboard Controller (8042) is a programmable controller that accepts input signals from the keyboard
   203                                  ;       device. It also signals a hardware interrupt to the CPU when the low-order bit of I/O port 64h is set to zero.
   204                                  ;
   205                                  ;-----------------------------------------------------------------------------------------------------------------------
   206                                  EKEYBPORTDATA           equ     060h                                            ;data port
   207                                  EKEYBPORTSTAT           equ     064h                                            ;status port
   208                                  EKEYBCMDRESET           equ     0FEh                                            ;reset bit 0 to restart system
   209                                  EKEYBBITOUT             equ     001h                                            ;output buffer status bit
   210                                  EKEYBBITIN              equ     002h                                            ;input buffer status bit
   211                                  EKEYBCMDLAMPS           equ     0EDh                                            ;set/reset lamps command
   212                                  EKEYBWAITLOOP           equ     010000h                                         ;wait loop
   213                                                                                                                  ;---------------------------------------
   214                                                                                                                  ;       Keyboard Scan Codes
   215                                                                                                                  ;---------------------------------------
   216                                  EKEYBCTRLDOWN           equ     01Dh                                            ;control key down
   217                                  EKEYBPAUSEDOWN          equ     01Dh                                            ;pause key down (e1 1d ... )
   218                                  EKEYBSHIFTLDOWN         equ     02Ah                                            ;left shift key down
   219                                  EKEYBPRTSCRDOWN         equ     02Ah                                            ;print-screen key down (e0 2a ...)
   220                                  EKEYBSLASH              equ     035h                                            ;slash
   221                                  EKEYBSHIFTRDOWN         equ     036h                                            ;right shift key down
   222                                  EKEYBALTDOWN            equ     038h                                            ;alt key down
   223                                  EKEYBCAPSDOWN           equ     03Ah                                            ;caps-lock down
   224                                  EKEYBNUMDOWN            equ     045h                                            ;num-lock down
   225                                  EKEYBSCROLLDOWN         equ     046h                                            ;scroll-lock down
   226                                  EKEYBINSERTDOWN         equ     052h                                            ;insert down (e0 52)
   227                                  EKEYBUP                 equ     080h                                            ;up
   228                                  EKEYBCTRLUP             equ     09Dh                                            ;control key up
   229                                  EKEYBSHIFTLUP           equ     0AAh                                            ;left shift key up
   230                                  EKEYBSLASHUP            equ     0B5h                                            ;slash key up
   231                                  EKEYBSHIFTRUP           equ     0B6h                                            ;right shift key up
   232                                  EKEYBPRTSCRUP           equ     0B7h                                            ;print-screen key up (e0 b7 ...)
   233                                  EKEYBALTUP              equ     0B8h                                            ;alt key up
   234                                  EKEYBCAPSUP             equ     0BAh                                            ;caps-lock up
   235                                  EKEYBNUMUP              equ     0C5h                                            ;num-lock up
   236                                  EKEYBSCROLLUP           equ     0C6h                                            ;scroll-lock up
   237                                  EKEYBINSERTUP           equ     0D2h                                            ;insert up (e0 d2)
   238                                  EKEYBCODEEXT0           equ     0E0h                                            ;extended scan code 0
   239                                  EKEYBCODEEXT1           equ     0E1h                                            ;extended scan code 1
   240                                  ;-----------------------------------------------------------------------------------------------------------------------
   241                                  ;
   242                                  ;       8259 Peripheral Interrupt Controller                                    EPIC...
   243                                  ;
   244                                  ;       The 8259 Peripheral Interrupt Controller (PIC) is a programmable controller that accepts interrupt signals from
   245                                  ;       external devices and signals a hardware interrupt to the CPU.
   246                                  ;
   247                                  ;-----------------------------------------------------------------------------------------------------------------------
   248                                  EPICPORTPRI             equ     020h                                            ;primary control port 0
   249                                  EPICPORTPRI1            equ     021h                                            ;primary control port 1
   250                                  EPICPORTSEC             equ     0A0h                                            ;secondary control port 0
   251                                  EPICPORTSEC1            equ     0A1h                                            ;secondary control port 1
   252                                  EPICEOI                 equ     020h                                            ;non-specific EOI code
   253                                  ;-----------------------------------------------------------------------------------------------------------------------
   254                                  ;
   255                                  ;       8253 Programmable Interval Timer                                        EPIT...
   256                                  ;
   257                                  ;       The Intel 8253 Programmable Interval Timer (PIT) is a chip that produces a hardware interrupt (IRQ0)
   258                                  ;       approximately 18.2 times per second.
   259                                  ;
   260                                  ;-----------------------------------------------------------------------------------------------------------------------
   261                                  EPITDAYTICKS            equ     01800B0h                                        ;ticks per day
   262                                  ;-----------------------------------------------------------------------------------------------------------------------
   263                                  ;
   264                                  ;       x86 CPU Architecture                                                    ;EX86...
   265                                  ;
   266                                  ;-----------------------------------------------------------------------------------------------------------------------
   267                                  EX86DESCLEN             equ     8                                               ;size of a protected mode descriptor
   268                                  ;-----------------------------------------------------------------------------------------------------------------------
   269                                  ;
   270                                  ;       Motorola MC 146818 Real-Time Clock                                      ERTC...
   271                                  ;
   272                                  ;       The Motorola MC 146818 was the original real-time clock in PCs.
   273                                  ;
   274                                  ;-----------------------------------------------------------------------------------------------------------------------
   275                                  ERTCREGPORT             equ     070h                                            ;register select port
   276                                  ERTCDATAPORT            equ     071h                                            ;data port
   277                                  ERTCSECONDREG           equ     000h                                            ;second
   278                                  ERTCMINUTEREG           equ     002h                                            ;minute
   279                                  ERTCHOURREG             equ     004h                                            ;hour
   280                                  ERTCWEEKDAYREG          equ     006h                                            ;weekday
   281                                  ERTCDAYREG              equ     007h                                            ;day
   282                                  ERTCMONTHREG            equ     008h                                            ;month
   283                                  ERTCYEARREG             equ     009h                                            ;year of the century
   284                                  ERTCSTATUSREG           equ     00bh                                            ;status
   285                                  ERTCBASERAMLO           equ     015h                                            ;base RAM low
   286                                  ERTCBASERAMHI           equ     016h                                            ;base RAM high
   287                                  ERTCEXTRAMLO            equ     017h                                            ;extended RAM low
   288                                  ERTCEXTRAMHI            equ     018h                                            ;extended RAM high
   289                                  ERTCCENTURYREG          equ     032h                                            ;century
   290                                  ERTCBINARYVALS          equ     00000100b                                       ;values are binary
   291                                  ;-----------------------------------------------------------------------------------------------------------------------
   292                                  ;
   293                                  ;       x86 Descriptor Access Codes                                             EX86ACC...
   294                                  ;
   295                                  ;       The x86 architecture supports the classification of memory areas or segments. Segment attributes are defined by
   296                                  ;       structures known as descriptors. Within a descriptor are access type codes that define the type of the segment.
   297                                  ;
   298                                  ;       0.......        Segment is not present in memory (triggers int 11)
   299                                  ;       1.......        Segment is present in memory
   300                                  ;       .LL.....        Segment is of privilege level LL (0,1,2,3)
   301                                  ;       ...0....        Segment is a system segment
   302                                  ;       ...00010                Local Descriptor Table
   303                                  ;       ...00101                Task Gate
   304                                  ;       ...010B1                Task State Segment (B:0=Available,1=Busy)
   305                                  ;       ...01100                Call Gate (386)
   306                                  ;       ...01110                Interrupt Gate (386)
   307                                  ;       ...01111                Trap Gate (386)
   308                                  ;       ...1...A        Segment is a code or data (A:1=Accesssed)
   309                                  ;       ...10DW.                Data (D:1=Expand Down,W:1=Writable)
   310                                  ;       ...11CR.                Code (C:1=Conforming,R:1=Readable)
   311                                  ;
   312                                  ;-----------------------------------------------------------------------------------------------------------------------
   313                                  EX86ACCLDT              equ     10000010b                                       ;local descriptor table
   314                                  EX86ACCTASK             equ     10000101b                                       ;task gate
   315                                  EX86ACCTSS              equ     10001001b                                       ;task-state segment
   316                                  EX86ACCGATE             equ     10001100b                                       ;call gate
   317                                  EX86ACCINT              equ     10001110b                                       ;interrupt gate
   318                                  EX86ACCTRAP             equ     10001111b                                       ;trap gate
   319                                  EX86ACCDATA             equ     10010011b                                       ;upward writable data
   320                                  EX86ACCCODE             equ     10011011b                                       ;non-conforming readable code
   321                                  ;-----------------------------------------------------------------------------------------------------------------------
   322                                  ;
   323                                  ;       Firmware-Defined Values
   324                                  ;
   325                                  ;-----------------------------------------------------------------------------------------------------------------------
   326                                  ;-----------------------------------------------------------------------------------------------------------------------
   327                                  ;
   328                                  ;       BIOS Interrupts and Functions                                           EBIOS...
   329                                  ;
   330                                  ;       Basic Input/Output System (BIOS) functions are grouped and accessed by issuing an interrupt call. Each
   331                                  ;       BIOS interrupt supports several funtions. The function code is typically passed in the AH register.
   332                                  ;
   333                                  ;-----------------------------------------------------------------------------------------------------------------------
   334                                  EBIOSINTVIDEO           equ     010h                                            ;video services interrupt
   335                                  EBIOSFNSETVMODE         equ     000h                                            ;video set mode function
   336                                  EBIOSMODETEXT80         equ     003h                                            ;video mode 80x25 text
   337                                  EBIOSFNTTYOUTPUT        equ     00Eh                                            ;video TTY output function
   338                                  EBIOSINTDISKETTE        equ     013h                                            ;diskette services interrupt
   339                                  EBIOSFNREADSECTOR       equ     002h                                            ;diskette read sector function
   340                                  EBIOSFNWRITESECTOR      equ     003h                                            ;diskette write sector function
   341                                  EBIOSINTMISC            equ     015h                                            ;miscellaneous services interrupt
   342                                  EBIOSFNINITPROTMODE     equ     089h                                            ;initialize protected mode fn
   343                                  EBIOSINTKEYBOARD        equ     016h                                            ;keyboard services interrupt
   344                                  EBIOSFNKEYSTATUS        equ     001h                                            ;keyboard status function
   345                                  ;-----------------------------------------------------------------------------------------------------------------------
   346                                  ;
   347                                  ;       Standards-Based Values
   348                                  ;
   349                                  ;-----------------------------------------------------------------------------------------------------------------------
   350                                  ;-----------------------------------------------------------------------------------------------------------------------
   351                                  ;
   352                                  ;       ASCII                                                                   EASCII...
   353                                  ;
   354                                  ;-----------------------------------------------------------------------------------------------------------------------
   355                                  EASCIIBACKSPACE         equ     008h                                            ;backspace
   356                                  EASCIILINEFEED          equ     00Ah                                            ;line feed
   357                                  EASCIIRETURN            equ     00Dh                                            ;carriage return
   358                                  EASCIIESCAPE            equ     01Bh                                            ;escape
   359                                  EASCIISPACE             equ     020h                                            ;space
   360                                  EASCIIPERIOD            equ     02Eh                                            ;period
   361                                  EASCIIUPPERA            equ     041h                                            ;'A'
   362                                  EASCIIUPPERZ            equ     05Ah                                            ;'Z'
   363                                  EASCIILOWERA            equ     061h                                            ;'a'
   364                                  EASCIILOWERZ            equ     07Ah                                            ;'z'
   365                                  EASCIITILDE             equ     07Eh                                            ;'~'
   366                                  EASCIIBORDSGLVERT       equ     0B3h                                            ;vertical single border
   367                                  EASCIIBORDSGLUPRRGT     equ     0BFh                                            ;upper-right single border
   368                                  EASCIIBORDSGLLWRLFT     equ     0C0h                                            ;lower-left single border
   369                                  EASCIIBORDSGLHORZ       equ     0C4h                                            ;horizontal single border
   370                                  EASCIIBORDSGLLWRRGT     equ     0D9h                                            ;lower-right single border
   371                                  EASCIIBORDSGLUPRLFT     equ     0DAh                                            ;upper-left single border
   372                                  EASCIICASE              equ     00100000b                                       ;case bit
   373                                  EASCIICASEMASK          equ     11011111b                                       ;case mask
   374                                  ;-----------------------------------------------------------------------------------------------------------------------
   375                                  ;
   376                                  ;       PCI                                                                     EPCI...
   377                                  ;
   378                                  ;-----------------------------------------------------------------------------------------------------------------------
   379                                  EPCIVENDORAPPLE         equ     106Bh                                           ;Apple
   380                                  EPCIVENDORINTEL         equ     8086h                                           ;Intel
   381                                  EPCIVENDORORACLE        equ     80EEh                                           ;Oracle
   382                                  EPCIAPPLEUSB            equ     003Fh                                           ;USB Controller
   383                                  EPCIINTELPRO1000MT      equ     100Fh                                           ;Pro/1000 MT Ethernet Adapter
   384                                  EPCIINTELPCIMEM         equ     1237h                                           ;PCI & Memory
   385                                  EPCIINTELAD1881         equ     2415h                                           ;Aureal AD1881 SOUNDMAX
   386                                  EPCIINTELPIIX3          equ     7000h                                           ;PIIX3 PCI-to-ISA Bridge (Triton II)
   387                                  EPCIINTEL82371AB        equ     7111h                                           ;82371AB/EB PCI Bus Master IDE Cntrlr
   388                                  EPCIINTELPIIX4          equ     7113h                                           ;PIIX4/4E/4M Power Mgmt Cntrlr
   389                                  EPCIORACLEVBOXGA        equ     0BEEFh                                          ;VirtualBox Graphics Adapter
   390                                  EPCIORACLEVBOXDEVICE    equ     0CAFEh                                          ;VirtualBox Device
   391                                  ;-----------------------------------------------------------------------------------------------------------------------
   392                                  ;
   393                                  ;       Operating System Values
   394                                  ;
   395                                  ;-----------------------------------------------------------------------------------------------------------------------
   396                                  ;-----------------------------------------------------------------------------------------------------------------------
   397                                  ;       Background Task Identifiers                                             EBG...
   398                                  ;-----------------------------------------------------------------------------------------------------------------------
   399                                  EBGTIMELEN              equ     9                                               ;length of time string HH:MM:SS\0
   400                                  ;-----------------------------------------------------------------------------------------------------------------------
   401                                  ;
   402                                  ;       Boot Sector and Loader Constants                                        EBOOT...
   403                                  ;
   404                                  ;       Equates in this section support the boot sector and the 16-bit operating system loader, which will be
   405                                  ;       responsible for placing the CPU into protected mode and calling the initial operating system task.
   406                                  ;
   407                                  ;-----------------------------------------------------------------------------------------------------------------------
   408                                  EBOOTSTACKTOP           equ     0100h                                           ;boot sector stack top relative to DS
   409                                  EBOOTSECTORBYTES        equ     512                                             ;bytes per sector
   410                                  EBOOTDIRENTRIES         equ     224                                             ;directory entries
   411                                  EBOOTDISKSECTORS        equ     2880                                            ;sectors per disk
   412                                  EBOOTDISKBYTES          equ     (EBOOTSECTORBYTES*EBOOTDISKSECTORS)             ;bytes per disk
   413                                  EBOOTFATBASE            equ     (EBOOTSTACKTOP+EBOOTSECTORBYTES)                ;offset of FAT I/O buffer rel to DS
   414                                  EBOOTMAXTRIES           equ     5                                               ;max read retries
   415                                  ;-----------------------------------------------------------------------------------------------------------------------
   416                                  ;       Console Constants                                                       ECON...
   417                                  ;-----------------------------------------------------------------------------------------------------------------------
   418                                  ECONCOLS                equ     80                                              ;columns per row
   419                                  ECONROWS                equ     24                                              ;console rows
   420                                  ECONOIAROW              equ     24                                              ;operator information area row
   421                                  ECONCOLBYTES            equ     2                                               ;bytes per column
   422                                  ECONROWBYTES            equ     (ECONCOLS*ECONCOLBYTES)                         ;bytes per row
   423                                  ECONROWDWORDS           equ     (ECONROWBYTES/4)                                ;double-words per row
   424                                  ECONCLEARDWORD          equ     007200720h                                      ;attribute and ASCII space
   425                                  ECONOIADWORD            equ     070207020h                                      ;attribute and ASCII space
   426                                  ;-----------------------------------------------------------------------------------------------------------------------
   427                                  ;       Global Descriptor Table (GDT) Selectors                                 EGDT...
   428                                  ;-----------------------------------------------------------------------------------------------------------------------
   429                                  EGDTALIAS               equ     008h                                            ;gdt alias selector
   430                                  EGDTOSDATA              equ     018h                                            ;kernel data selector
   431                                  EGDTCGA                 equ     020h                                            ;cga video selector
   432                                  EGDTLOADERCODE          equ     030h                                            ;loader code selector
   433                                  EGDTOSCODE              equ     048h                                            ;os kernel code selector
   434                                  EGDTLOADERLDT           equ     050h                                            ;loader local descriptor table selector
   435                                  EGDTLOADERTSS           equ     058h                                            ;loader task state segment selector
   436                                  EGDTCONSOLELDT          equ     060h                                            ;console local descriptor table selector
   437                                  EGDTCONSOLETSS          equ     068h                                            ;console task state segment selector
   438                                  ESELBACKGROUNDLDT       equ     070h                                            ;background local descr table selector
   439                                  ESELBACKGROUNDTSS       equ     078h                                            ;background task state segment selector
   440                                  ESELKEYBOARDMQ          equ     080h                                            ;keyboard focus message queue (IRQ1)
   441                                  ;-----------------------------------------------------------------------------------------------------------------------
   442                                  ;       LDT Selectors                                                           ESEL...
   443                                  ;-----------------------------------------------------------------------------------------------------------------------
   444                                  ESELMQ                  equ     02Ch                                            ;console task message queue
   445                                  ;-----------------------------------------------------------------------------------------------------------------------
   446                                  ;       Keyboard Flags                                                          EKEYF...
   447                                  ;-----------------------------------------------------------------------------------------------------------------------
   448                                  EKEYFCTRLLEFT           equ     00000001b                                       ;left control
   449                                  EKEYFSHIFTLEFT          equ     00000010b                                       ;left shift
   450                                  EKEYFALTLEFT            equ     00000100b                                       ;left alt
   451                                  EKEYFCTRLRIGHT          equ     00001000b                                       ;right control
   452                                  EKEYFSHIFTRIGHT         equ     00010000b                                       ;right shift
   453                                  EKEYFSHIFT              equ     00010010b                                       ;left or right shift
   454                                  EKEYFALTRIGHT           equ     00100000b                                       ;right alt
   455                                  EKEYFLOCKSCROLL         equ     00000001b                                       ;scroll-lock flag
   456                                  EKEYFLOCKNUM            equ     00000010b                                       ;num-lock flag
   457                                  EKEYFLOCKCAPS           equ     00000100b                                       ;cap-lock flag
   458                                  EKEYFTIMEOUT            equ     10000000b                                       ;controller timeout
   459                                  ;-----------------------------------------------------------------------------------------------------------------------
   460                                  ;       Kernel Constants                                                        EKRN...
   461                                  ;-----------------------------------------------------------------------------------------------------------------------
   462                                  EKRNDATASEG             equ     00000h                                          ;kernel data segment (0000:0800)
   463                                  EKRNCODEBASE            equ     1000h                                           ;kernel base address (0000:1000)
   464                                  EKRNCODESEG             equ     (EKRNCODEBASE >> 4)                             ;kernel code segment (0100:0000)
   465                                  EKRNCODELEN             equ     7000h                                           ;kernel code size (1000h to 8000h)
   466                                  EKRNCODESRCADR          equ     500h                                            ;kernel code offset to loader DS:
   467                                  EKRNHEAPSIZE            equ     80000000h                                       ;kernel heap size
   468                                  EKRNHEAPBASE            equ     10000h                                          ;kernel heap base
   469                                  ;-----------------------------------------------------------------------------------------------------------------------
   470                                  ;       Local Descriptor Table (LDT) Selectors                                  ELDT...
   471                                  ;-----------------------------------------------------------------------------------------------------------------------
   472                                  ELDTMQ                  equ     02Ch                                            ;console task message queue
   473                                  ;-----------------------------------------------------------------------------------------------------------------------
   474                                  ;       Hardware Flags
   475                                  ;-----------------------------------------------------------------------------------------------------------------------
   476                                  EHWETHERNET             equ     80h                                             ;ethernet adapter found
   477                                  ;-----------------------------------------------------------------------------------------------------------------------
   478                                  ;       Memory Management Constants                                             EMEM...
   479                                  ;-----------------------------------------------------------------------------------------------------------------------
   480                                  EMEMMINSIZE             equ     256                                             ;minimum heap block size (incl. hdr)
   481                                  EMEMFREECODE            equ     "FREE"                                          ;free memory signature
   482                                  EMEMUSERCODE            equ     "USER"                                          ;user memory signature
   483                                  EMEMWIPEBYTE            equ     000h                                            ;byte value to wipe storage
   484                                  ;-----------------------------------------------------------------------------------------------------------------------
   485                                  ;       Message Identifiers                                                     EMSG...
   486                                  ;-----------------------------------------------------------------------------------------------------------------------
   487                                  EMSGKEYDOWN             equ     041000000h                                      ;key-down
   488                                  EMSGKEYUP               equ     041010000h                                      ;key-up
   489                                  EMSGKEYCHAR             equ     041020000h                                      ;character
   490                                  ;=======================================================================================================================
   491                                  ;
   492                                  ;       Structures
   493                                  ;
   494                                  ;=======================================================================================================================
   495                                  ;-----------------------------------------------------------------------------------------------------------------------
   496                                  ;
   497                                  ;       DATETIME
   498                                  ;
   499                                  ;       The DATETIME structure stores date and time values from the real-time clock.
   500                                  ;
   501                                  ;-----------------------------------------------------------------------------------------------------------------------
   502                                  struc                   DATETIME
   503 00000000 <res 00000001>          .second                 resb    1                                               ;seconds
   504 00000001 <res 00000001>          .minute                 resb    1                                               ;minutes
   505 00000002 <res 00000001>          .hour                   resb    1                                               ;hours
   506 00000003 <res 00000001>          .weekday                resb    1                                               ;day of week
   507 00000004 <res 00000001>          .day                    resb    1                                               ;day of month
   508 00000005 <res 00000001>          .month                  resb    1                                               ;month of year
   509 00000006 <res 00000001>          .year                   resb    1                                               ;year of century
   510 00000007 <res 00000001>          .century                resb    1                                               ;century
   511                                  EDATETIMELEN            equ     ($-.second)
   512                                  endstruc
   513                                  ;-----------------------------------------------------------------------------------------------------------------------
   514                                  ;
   515                                  ;       MEMBLOCK
   516                                  ;
   517                                  ;       The MEMBLOCK structure defines a memory block.
   518                                  ;
   519                                  ;-----------------------------------------------------------------------------------------------------------------------
   520                                  struc                   MEMBLOCK
   521 00000000 <res 00000004>          .signature              resd    1                                               ;starting signature
   522 00000004 <res 00000004>          .bytes                  resd    1                                               ;block size in bytes
   523 00000008 <res 00000004>          .owner                  resd    1                                               ;owning task
   524 0000000C <res 00000004>          .reserved               resd    1                                               ;reserved
   525 00000010 <res 00000004>          .nextcontig             resd    1                                               ;next contiguous block
   526 00000014 <res 00000004>          .previouscontig         resd    1                                               ;previous contiguous block
   527 00000018 <res 00000004>          .nextblock              resd    1                                               ;next free/task block
   528 0000001C <res 00000004>          .previousblock          resd    1                                               ;previous free/task block
   529                                  EMEMBLOCKLEN            equ     ($-.signature)
   530                                  endstruc
   531                                  ;-----------------------------------------------------------------------------------------------------------------------
   532                                  ;
   533                                  ;       MEMROOT
   534                                  ;
   535                                  ;       The MEMROOT structure defines starting and ending addresses of memory block chains.
   536                                  ;
   537                                  ;-----------------------------------------------------------------------------------------------------------------------
   538                                  struc                   MEMROOT
   539 00000000 <res 00000004>          .firstcontig            resd    1                                               ;first contiguous block
   540 00000004 <res 00000004>          .lastcontig             resd    1                                               ;last contiguous block
   541 00000008 <res 00000004>          .firstfree              resd    1                                               ;first free block
   542 0000000C <res 00000004>          .lastfree               resd    1                                               ;last free block
   543 00000010 <res 00000004>          .firsttask              resd    1                                               ;first task block
   544 00000014 <res 00000004>          .lasttask               resd    1                                               ;last task block
   545                                  EMEMROOTLEN             equ     ($-.firstcontig)
   546                                  endstruc
   547                                  ;-----------------------------------------------------------------------------------------------------------------------
   548                                  ;
   549                                  ;       MQUEUE
   550                                  ;
   551                                  ;       The MQUEUE structure maps memory used for a message queue.
   552                                  ;
   553                                  ;-----------------------------------------------------------------------------------------------------------------------
   554                                  struc                   MQUEUE
   555 00000000 <res 00000004>          MQHead                  resd    1                                               ;000 head ptr
   556 00000004 <res 00000004>          MQTail                  resd    1                                               ;004 tail ptr
   557 00000008 <res 000003F8>          MQData                  resd    254                                             ;message queue
   558                                  endstruc
   559                                  ;-----------------------------------------------------------------------------------------------------------------------
   560                                  ;
   561                                  ;       OSDATA
   562                                  ;
   563                                  ;       The OSDATA structure maps low-memory addresses used by the BIOS and the OS. Areas that may be in use by DOS or
   564                                  ;       other host operating systems that may be running when this OS is launched are avoided.
   565                                  ;
   566                                  ;-----------------------------------------------------------------------------------------------------------------------
   567                                  struc                   OSDATA
   568 00000000 <res 00000400>                                  resb    0400h                                           ;000 real mode interrupt vectors
   569 00000400 <res 00000002>                                  resw    1                                               ;400 COM1 port address
   570 00000402 <res 00000002>                                  resw    1                                               ;402 COM2 port address
   571 00000404 <res 00000002>                                  resw    1                                               ;404 COM3 port address
   572 00000406 <res 00000002>                                  resw    1                                               ;406 COM4 port address
   573 00000408 <res 00000002>                                  resw    1                                               ;408 LPT1 port address
   574 0000040A <res 00000002>                                  resw    1                                               ;40a LPT2 port address
   575 0000040C <res 00000002>                                  resw    1                                               ;40c LPT3 port address
   576 0000040E <res 00000002>                                  resw    1                                               ;40e LPT4 port address
   577 00000410 <res 00000002>                                  resb    2                                               ;410 equipment list flags
   578 00000412 <res 00000001>                                  resb    1                                               ;412 errors in PCjr infrared keybd link
   579 00000413 <res 00000002>          wwROMMemSize            resw    1                                               ;413 memory size (kb) INT 12h
   580 00000415 <res 00000001>                                  resb    1                                               ;415 mfr error test scratchpad
   581 00000416 <res 00000001>                                  resb    1                                               ;416 PS/2 BIOS control flags
   582 00000417 <res 00000001>                                  resb    1                                               ;417 keyboard flag byte 0
   583 00000418 <res 00000001>                                  resb    1                                               ;418 keyboard flag byte 1
   584 00000419 <res 00000001>                                  resb    1                                               ;419 alternate keypad entry
   585 0000041A <res 00000002>                                  resw    1                                               ;41a keyboard buffer head offset
   586 0000041C <res 00000002>                                  resw    1                                               ;41c keyboard buffer tail offset
   587 0000041E <res 00000020>                                  resb    32                                              ;41e keyboard buffer
   588 0000043E <res 00000001>          wbFDCStatus             resb    1                                               ;43e drive recalibration status
   589 0000043F <res 00000001>          wbFDCControl            resb    1                                               ;43f FDC motor status/control byte
   590 00000440 <res 00000001>          wbFDCMotor              resb    1                                               ;440 FDC motor timeout byte
   591 00000441 <res 00000001>                                  resb    1                                               ;441 status of last diskette operation
   592 00000442 <res 00000007>                                  resb    7                                               ;442 NEC diskette controller status
   593 00000449 <res 00000001>                                  resb    1                                               ;449 current video mode
   594 0000044A <res 00000002>                                  resw    1                                               ;44a screen columns
   595 0000044C <res 00000002>                                  resw    1                                               ;44c video regen buffer size
   596 0000044E <res 00000002>                                  resw    1                                               ;44e current video page offset
   597 00000450 <res 00000010>                                  resw    8                                               ;450 cursor postions of pages 1-8
   598 00000460 <res 00000001>                                  resb    1                                               ;460 cursor ending scanline
   599 00000461 <res 00000001>                                  resb    1                                               ;461 cursor start scanline
   600 00000462 <res 00000001>                                  resb    1                                               ;462 active display page number
   601 00000463 <res 00000002>                                  resw    1                                               ;463 CRTC base port address
   602 00000465 <res 00000001>                                  resb    1                                               ;465 CRT mode control register value
   603 00000466 <res 00000001>                                  resb    1                                               ;466 CGA current color palette mask
   604 00000467 <res 00000002>                                  resw    1                                               ;467 CS:IP for 286 return from PROT MODE
   605 00000469 <res 00000003>                                  resb    3                                               ;469 vague
   606 0000046C <res 00000004>          wdClockTicks            resd    1                                               ;46c clock ticks
   607 00000470 <res 00000001>          wbClockDays             resb    1                                               ;470 clock days
   608 00000471 <res 00000001>                                  resb    1                                               ;471 bios break flag
   609 00000472 <res 00000002>                                  resw    1                                               ;472 soft reset
   610 00000474 <res 00000001>                                  resb    1                                               ;474 last hard disk operation status
   611 00000475 <res 00000001>                                  resb    1                                               ;475 hard disks attached
   612 00000476 <res 00000001>                                  resb    1                                               ;476 XT fised disk drive control byte
   613 00000477 <res 00000001>                                  resb    1                                               ;477 port offset to current fixed disk adapter
   614 00000478 <res 00000004>                                  resb    4                                               ;478 LPT timeout values
   615 0000047C <res 00000004>                                  resb    4                                               ;47c COM timeout values
   616 00000480 <res 00000002>                                  resw    1                                               ;480 keyboard buffer start offset
   617 00000482 <res 00000002>                                  resw    1                                               ;482 keyboard buffer end offset
   618 00000484 <res 00000001>                                  resb    1                                               ;484 Rows on screen less 1 (EGA+)
   619 00000485 <res 00000001>                                  resb    1                                               ;485 point height of character matrix (EGA+)
   620 00000486 <res 00000001>                                  resb    1                                               ;486 PC Jr initial keybd delay
   621 00000487 <res 00000001>                                  resb    1                                               ;487 EGA+ video mode ops
   622 00000488 <res 00000001>                                  resb    1                                               ;488 EGA feature bit switches
   623 00000489 <res 00000001>                                  resb    1                                               ;489 VGA video display data area
   624 0000048A <res 00000001>                                  resb    1                                               ;48a EGA+ display combination code
   625 0000048B <res 00000001>                                  resb    1                                               ;48b last diskette data rate selected
   626 0000048C <res 00000001>                                  resb    1                                               ;48c hard disk status from controller
   627 0000048D <res 00000001>                                  resb    1                                               ;48d hard disk error from controller
   628 0000048E <res 00000001>                                  resb    1                                               ;48e hard disk interrupt control flag
   629 0000048F <res 00000001>                                  resb    1                                               ;48f combination hard/floppy disk card
   630 00000490 <res 00000004>                                  resb    4                                               ;490 drive 0,1,2,3 media state
   631 00000494 <res 00000001>                                  resb    1                                               ;494 track currently seeked to on drive 0
   632 00000495 <res 00000001>                                  resb    1                                               ;495 track currently seeked to on drive 1
   633 00000496 <res 00000001>                                  resb    1                                               ;496 keyboard mode/type
   634 00000497 <res 00000001>                                  resb    1                                               ;497 keyboard LED flags
   635 00000498 <res 00000004>                                  resd    1                                               ;498 pointer to user wait complete flag
   636 0000049C <res 00000004>                                  resd    1                                               ;49c user wait time-out value in microseconds
   637 000004A0 <res 00000001>                                  resb    1                                               ;4a0 RTC wait function flag
   638 000004A1 <res 00000001>                                  resb    1                                               ;4a1 LANA DMA channel flags
   639 000004A2 <res 00000002>                                  resb    2                                               ;4a2 status of LANA 0,1
   640 000004A4 <res 00000004>                                  resd    1                                               ;4a4 saved hard disk interrupt vector
   641 000004A8 <res 00000004>                                  resd    1                                               ;4a8 BIOS video save/override pointer table addr
   642 000004AC <res 00000008>                                  resb    8                                               ;4ac reserved
   643 000004B4 <res 00000001>                                  resb    1                                               ;4b4 keyboard NMI control flags
   644 000004B5 <res 00000004>                                  resd    1                                               ;4b5 keyboard break pending flags
   645 000004B9 <res 00000001>                                  resb    1                                               ;4b9 Port 60 single byte queue
   646 000004BA <res 00000001>                                  resb    1                                               ;4ba scan code of last key
   647 000004BB <res 00000001>                                  resb    1                                               ;4bb NMI buffer head pointer
   648 000004BC <res 00000001>                                  resb    1                                               ;4bc NMI buffer tail pointer
   649 000004BD <res 00000010>                                  resb    16                                              ;4bd NMI scan code buffer
   650 000004CD <res 00000001>                                  resb    1                                               ;4cd unknown
   651 000004CE <res 00000002>                                  resw    1                                               ;4de day counter
   652 000004D0 <res 00000020>                                  resb    32                                              ;4d0 unknown
   653 000004F0 <res 00000010>                                  resb    16                                              ;4f0 intra-app comm area
   654 00000500 <res 00000001>                                  resb    1                                               ;500 print-screen status byte
   655 00000501 <res 00000003>                                  resb    3                                               ;501 used by BASIC
   656 00000504 <res 00000001>                                  resb    1                                               ;504 DOS single diskette mode
   657 00000505 <res 0000000A>                                  resb    10                                              ;505 POST work area
   658 0000050F <res 00000001>                                  resb    1                                               ;50f BASIC shell flag
   659 00000510 <res 00000002>                                  resw    1                                               ;510 BASIC default DS (DEF SEG)
   660 00000512 <res 00000004>                                  resd    1                                               ;512 BASIC INT 1C interrupt handler
   661 00000516 <res 00000004>                                  resd    1                                               ;516 BASIC INT 23 interrupt handler
   662 0000051A <res 00000004>                                  resd    1                                               ;51a BASIC INT 24 interrupt handler
   663 0000051E <res 00000002>                                  resw    1                                               ;51e unknown
   664 00000520 <res 00000002>                                  resw    1                                               ;520 DOS dynamic storage
   665 00000522 <res 0000000E>                                  resb    14                                              ;522 DOS diskette initialization table (INT 1e)
   666 00000530 <res 00000004>                                  resb    4                                               ;530 MODE command
   667 00000534 <res 000001CC>                                  resb    460                                             ;534 unused
   668 00000700 <res 00000100>                                  resb    256                                             ;700 i/o drivers from io.sys/ibmbio.com
   669                                  ;-----------------------------------------------------------------------------------------------------------------------
   670                                  ;
   671                                  ;       Kernel Variables                                                        @disk: N/A      @mem: 000800
   672                                  ;
   673                                  ;       Kernel variables may be accessed by interrupts or by the initial task (Console).
   674                                  ;
   675                                  ;-----------------------------------------------------------------------------------------------------------------------
   676                                  ;-----------------------------------------------------------------------------------------------------------------------
   677                                  ;
   678                                  ;       Kernel Data
   679                                  ;
   680                                  ;       These variables are not task-specific. They are initialized by the OS loader before the system is placed into
   681                                  ;       protected mode. This is necessary because as soon as the system enters protected mode, the timer interrupt
   682                                  ;       (IRQ0) will begin to reference the task selectors queue to implement task switching.
   683                                  ;
   684                                  ;-----------------------------------------------------------------------------------------------------------------------
   685                                                          alignb  4
   686                                  EKERNELDATA             equ     ($)
   687 00000800 <res 00000200>          wwTaskQueue             resw    256                                             ;task selector queue
   688 00000A00 <res 00000004>          wdFarJumpEIP            resd    1                                               ;destination EIP of next task (ignored)
   689 00000A04 <res 00000002>          wwFarJumpSelector       resw    1                                               ;destination task gate
   690 00000A06 <res 00000001>          wbTaskIndex             resb    1                                               ;task selector index
   691 00000A07 <res 00000001>          wbInCriticalSection     resb    1                                               ;task in critical section
   692                                  EKERNELDATALEN          equ     ($-EKERNELDATA)
   693                                  ;-----------------------------------------------------------------------------------------------------------------------
   694                                  ;
   695                                  ;       Console Task Variables
   696                                  ;
   697                                  ;       These variables are exclusve to the console task. These variables are initialized by the console task when
   698                                  ;       the console task starts.
   699                                  ;
   700                                  ;-----------------------------------------------------------------------------------------------------------------------
   701                                                          alignb  4
   702                                  ECONDATA                equ     ($)
   703 00000A08 <res 00000004>          wdConsoleMemBase        resd    1                                               ;console memory address
   704 00000A0C <res 00000004>          wdConsoleHeapSize       resd    1                                               ;kernel heap size
   705 00000A10 <res 00000004>          wdBaseMemSize           resd    1                                               ;base memory size (int 12h)
   706 00000A14 <res 00000004>          wdExtendedMemSize       resd    1                                               ;extended memory size (int 12h)
   707 00000A18 <res 00000004>          wdROMMemSize            resd    1                                               ;ROM memory size
   708 00000A1C <res 00000004>          wdConsolePCISelector    resd    1                                               ;PCI selector (bbbbbbbb dddddfff)
   709                                  wdConsolePCIData        equ     $                                               ;PCI register data value
   710 00000A20 <res 00000002>          wwConsolePCIVendor      resw    1                                               ;PCI data vendor
   711 00000A22 <res 00000002>          wwConsolePCIChip        resw    1                                               ;PCI data chip
   712 00000A24 <res 00000004>          wdConsolePCIVendorStr   resd    1                                               ;PCI vendor name string addr
   713 00000A28 <res 00000004>          wdConsolePCIChipStr     resd    1                                               ;PCI device name string addr
   714 00000A2C <res 00000004>          wdConsoleEthernetDevice resd    1                                               ;PCI ethernet adapter selector
   715 00000A30 <res 00000004>          wdConsoleEthernetMem    resd    1                                               ;PCI ethernet memory mapped i/o address
   716 00000A34 <res 00000004>          wdConsoleEthernetPort   resd    1                                               ;PCI ethernet i/o port
   717 00000A38 <res 00000004>          wdConsoleEthernetCtrl   resd    1                                               ;PCI ethernet control register value
   718 00000A3C <res 00000001>          wbConsoleColumn         resb    1                                               ;console column
   719 00000A3D <res 00000001>          wbConsoleRow            resb    1                                               ;console row
   720 00000A3E <res 00000001>          wbConsoleShift          resb    1                                               ;console shift flags
   721 00000A3F <res 00000001>          wbConsoleLock           resb    1                                               ;console lock flags
   722 00000A40 <res 00000001>          wbConsoleStatus         resb    1                                               ;controller status
   723 00000A41 <res 00000001>          wbConsoleScan0          resb    1                                               ;scan code
   724 00000A42 <res 00000001>          wbConsoleScan1          resb    1                                               ;scan code
   725 00000A43 <res 00000001>          wbConsoleScan2          resb    1                                               ;scan code
   726 00000A44 <res 00000001>          wbConsoleScan3          resb    1                                               ;scan code
   727 00000A45 <res 00000001>          wbConsoleScan4          resb    1                                               ;scan code
   728 00000A46 <res 00000001>          wbConsoleScan5          resb    1                                               ;scan code
   729 00000A47 <res 00000001>          wbConsoleChar           resb    1                                               ;ASCII code
   730 00000A48 <res 00000001>          wbConsolePCIBus         resb    1                                               ;PCI bus
   731 00000A49 <res 00000001>          wbConsolePCIDevice      resb    1                                               ;PCI device
   732 00000A4A <res 00000001>          wbConsolePCIFunction    resb    1                                               ;PCI function
   733 00000A4B <res 00000001>          wbConsoleHWFlags        resb    1                                               ;Hardware Flags
   734 00000A4C <res 00000050>          wzConsoleInBuffer       resb    80                                              ;command input buffer
   735 00000A9C <res 00000050>          wzConsoleToken          resb    80                                              ;token buffer
   736 00000AEC <res 00000050>          wzConsoleOutBuffer      resb    80                                              ;response output buffer
   737 00000B3C <res 0000000B>          wzBaseMemSize           resb    11                                              ;CMOS base memory bytes     zz,zzz,zz9\0
   738 00000B47 <res 0000000B>          wzROMMemSize            resb    11                                              ;ROM base memory bytes      zz,zzz,zz9\0
   739 00000B52 <res 0000000B>          wzExtendedMemSize       resb    11                                              ;CMOS extended memory bytes zz,zzz,zz9\0
   740 00000B5D <res 00000018>          wsConsoleMemRoot        resb    EMEMROOTLEN                                     ;kernel base memory map
   741 00000B75 <res 00000008>          wsConsoleDateTime       resb    EDATETIMELEN                                    ;date-time buffer
   742                                  ECONDATALEN             equ     ($-ECONDATA)                                    ;size of console data area
   743                                  ;-----------------------------------------------------------------------------------------------------------------------
   744                                  ;
   745                                  ;       Background Task Variables
   746                                  ;
   747                                  ;       These variables are exclusve to the background task. These variables are initialized by the background task when
   748                                  ;       the task starts.
   749                                  ;
   750                                  ;-----------------------------------------------------------------------------------------------------------------------
   751 00000B7D <res 00000003>                                  alignb  4
   752                                  EBGDATA                 equ     ($)
   753 00000B80 <res 00000008>          wsBgDateTime            resb    EDATETIMELEN                                    ;date-time buffer
   754 00000B88 <res 00000009>          wzBgTime                resb    EBGTIMELEN                                      ;time string buffer
   755 00000B91 <res 00000009>          wzBgTimeCmpr            resb    EBGTIMELEN                                      ;time string comparison buffer
   756                                  EBGDATALEN              equ     ($-EBGDATA)
   757                                  ;-----------------------------------------------------------------------------------------------------------------------
   758                                  ;
   759                                  ;       End of OS Variables
   760                                  ;
   761                                  ;-----------------------------------------------------------------------------------------------------------------------
   762                                  endstruc
   763                                  ;-----------------------------------------------------------------------------------------------------------------------
   764                                  ;
   765                                  ;       Macros
   766                                  ;
   767                                  ;       These macros are used to assist in defining descriptor tables and interrupt table offsets.
   768                                  ;
   769                                  ;-----------------------------------------------------------------------------------------------------------------------
   770                                  %macro                  mint    1
   771                                  _%1                     equ     ($-$$) / EX86DESCLEN
   772                                                          dq      ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
   773                                  %endmacro
   774                                  %macro                  mtrap   1
   775                                  _%1                     equ     ($-$$) / EX86DESCLEN
   776                                                          dq      ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
   777                                  %endmacro
   778                                  %macro                  menter  1
   779                                  ?%1                     equ     ($-$$)
   780                                  %endmacro
   781                                  %macro                  tsvce   1
   782                                  e%1                     equ     ($-tsvc)/4
   783                                                          dd      %1
   784                                  %endmacro
   785                                  %ifdef BUILDBOOT
   786                                  ;=======================================================================================================================
   787                                  ;
   788                                  ;       Boot Sector                                                             @disk: 000000   @mem: 007c00
   789                                  ;
   790                                  ;       The first sector of the disk is the boot sector. The BIOS will load the boot sector into memory and pass
   791                                  ;       control to the code at the start of the sector. The boot sector code is responsible for loading the operating
   792                                  ;       system into memory. The boot sector contains a disk parameter table describing the geometry and allocation
   793                                  ;       of the disk. Following the disk parameter table is code to load the operating system kernel into memory.
   794                                  ;
   795                                  ;       The "cpu" directive limits emitted code to those instructions supported by the most primitive processor
   796                                  ;       we expect to ever execute our code. The "vstart" parameter indicates addressability of symbols so as to
   797                                  ;       emulate the DOS .COM program model. Although the BIOS is expected to load the boot sector at address 7c00,
   798                                  ;       we do not make that assumption. The CPU starts in 16-bit addressing mode. A three-byte jump instruction is
   799                                  ;       immediately followed by a disk parameter table.
   800                                  ;
   801                                  ;=======================================================================================================================
   802                                                          cpu     8086                                            ;assume minimal CPU
   803                                  section                 boot    vstart=0100h                                    ;emulate .COM (CS,DS,ES=PSP) addressing
   804                                                          bits    16                                              ;16-bit code at power-up
   805                                  %ifdef BUILDPREP
   806                                  Boot                    jmp     word Prep                                       ;jump to preparation code
   807                                  %else
   808                                  Boot                    jmp     word Boot.10                                    ;jump over parameter table
   809                                  %endif
   810                                  ;-----------------------------------------------------------------------------------------------------------------------
   811                                  ;
   812                                  ;       Disk Parameter Table
   813                                  ;
   814                                  ;       The disk parameter table informs the BIOS of the floppy disk architecture. Here, we use parameters for the
   815                                  ;       3.5" 1.44MB floppy disk since this format is widely supported by virtual machine hypervisors.
   816                                  ;
   817                                  ;-----------------------------------------------------------------------------------------------------------------------
   818                                                          db      "CustomOS"                                      ;eight-byte label
   819                                  cwSectorBytes           dw      EBOOTSECTORBYTES                                ;bytes per sector
   820                                  cbClusterSectors        db      1                                               ;sectors per cluster
   821                                  cwReservedSectors       dw      1                                               ;reserved sectors
   822                                  cbFatCount              db      2                                               ;file allocation table copies
   823                                  cwDirEntries            dw      EBOOTDIRENTRIES                                 ;max directory entries
   824                                  cwDiskSectors           dw      EBOOTDISKSECTORS                                ;sectors per disk
   825                                  cbDiskType              db      0F0h                                            ;1.44MB
   826                                  cwFatSectors            dw      9                                               ;sectors per FAT copy
   827                                  cbTrackSectors          equ     $                                               ;sectors per track (as byte)
   828                                  cwTrackSectors          dw      18                                              ;sectors per track (as word)
   829                                  cwDiskSides             dw      2                                               ;sides per disk
   830                                  cwSpecialSectors        dw      0                                               ;special sectors
   831                                  ;
   832                                  ;       BIOS typically loads the boot sector at absolute address 7c00 and sets the stack pointer at 512 bytes past the
   833                                  ;       end of the boot sector. But, since BIOS code varies, we don't make any assumptions as to where our boot sector
   834                                  ;       is loaded. For example, the initial CS:IP could be 0:7c00, 700:c00, 7c0:0, etc. So, to avoid assumptions, we
   835                                  ;       first normalize CS:IP to get the absolute segment address in BX. The comments below show the effect of this code
   836                                  ;       given several possible starting values for CS:IP.
   837                                  ;
   838                                                                                                                  ;CS:IP   0:7c00 700:c00 7c0:0
   839                                  Boot.10                 call    word .20                                        ;[ESP] =   7c21     c21    21
   840                                  .@20                    equ     $-$$                                            ;.@20 = 021h
   841                                  .20                     pop     ax                                              ;AX =      7c21     c21    21
   842                                                          sub     ax,.@20                                         ;AX =      7c00     c00     0
   843                                                          mov     cl,4                                            ;shift count
   844                                                          shr     ax,cl                                           ;AX =       7c0      c0     0
   845                                                          mov     bx,cs                                           ;BX =         0     700   7c0
   846                                                          add     bx,ax                                           ;BX =       7c0     7c0   7c0
   847                                  ;
   848                                  ;       Now, since we are assembling our boot code to emulate the addressing of a .COM file, we want the DS and ES
   849                                  ;       registers to be set to where a Program Segment Prefix (PSP) would be, exactly 100h (256) bytes prior to
   850                                  ;       the start of our code. This will correspond to our assembled data address offsets. Note that we instructed
   851                                  ;       the assembler to produce addresses for our symbols that are offset from our code by 100h. See the "vstart"
   852                                  ;       parameter for the "section" directive above. We also set SS to the PSP and SP to the address of our i/o
   853                                  ;       buffer. This leaves 256 bytes of usable stack from 7b0:0 to 7b0:100.
   854                                  ;
   855                                                          sub     bx,16                                           ;BX = 07b0
   856                                                          mov     ds,bx                                           ;DS = 07b0 = psp
   857                                                          mov     es,bx                                           ;ES = 07b0 = psp
   858                                                          mov     ss,bx                                           ;SS = 07b0 = psp (ints disabled)
   859                                                          mov     sp,EBOOTSTACKTOP                                ;SP = 0100       (ints enabled)
   860                                  ;
   861                                  ;       Our boot addressability is now set up according to the following diagram.
   862                                  ;
   863                                  ;       DS,ES,SS -----> 007b00  +-----------------------------------------------+ DS:0000
   864                                  ;                               |  Boot Stack & Boot PSP (Unused)               |
   865                                  ;                               |  256 = 100h bytes                             |
   866                                  ;       SS:SP --------> 007c00  +-----------------------------------------------+ DS:0100  07b0:0100
   867                                  ;                               |  Boot Sector (vstart=0100h)                   |
   868                                  ;                               |  1 sector = 512 = 200h bytes                  |
   869                                  ;                       007e00  +-----------------------------------------------+ DS:0300
   870                                  ;                               |  File Allocation Table (FAT) I/O Buffer       |
   871                                  ;                               |  9x512-byte sectors = 4,608 = 1200h bytes     |
   872                                  ;                       009000  +-----------------------------------------------+ DS:1500  08f0:0100
   873                                  ;                               |  Directory Sector Buffer & Kernel Load Area   |
   874                                  ;                               |  2 sectors = 1024 = 400h bytes
   875                                  ;                       009400  +-----------------------------------------------+ DS:1900
   876                                  ;
   877                                  ;       On entry, DL indicates the drive being booted from.
   878                                  ;
   879                                                          mov     [wbDrive],dl                                    ;[wbDrive] = drive being booted from
   880                                  ;
   881                                  ;       Compute directory i/o buffer address.
   882                                  ;
   883                                                          mov     ax,[cwFatSectors]                               ;AX = 0009 = FAT sectors
   884                                                          mul     word [cwSectorBytes]                            ;DX:AX = 0000:1200 = FAT bytes
   885                                                          add     ax,EBOOTFATBASE                                 ;AX = 1500 = end of FAT buffer
   886                                                          mov     [wwDirBuffer],ax                                ;[wwDirBuffer] = 1500
   887                                  ;
   888                                  ;       Compute segment where os.com will be loaded.
   889                                  ;
   890                                                          shr     ax,cl                                           ;AX = 0150
   891                                                          add     ax,bx                                           ;AX = 0150 + 07b0 = 0900
   892                                                          sub     ax,16                                           ;AX = 08f0
   893                                                          mov     [wwLoadSegment],ax                              ;[wwLoadSegment] = 08f0
   894                                  ;
   895                                  ;       Set the video mode to 80 column, 25 row, text.
   896                                  ;
   897                                                          mov     ax,EBIOSFNSETVMODE<<8|EBIOSMODETEXT80           ;set mode function, 80x25 text mode
   898                                                          int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
   899                                  ;
   900                                  ;       Write a message to the console so we know we have our addressability established.
   901                                  ;
   902                                                          mov     si,czLoadMsg                                    ;loading message
   903                                                          call    BootPrint                                       ;display loader message
   904                                  ;
   905                                  ;       Initialize the number of directory sectors to search.
   906                                  ;
   907                                                          mov     ax,[cwDirEntries]                               ;AX = 224 = max dir entries
   908                                                          mov     [wwEntriesLeft],ax                              ;[wwEntriesLeft] = 224
   909                                  ;
   910                                  ;       Compute number of directory sectors and initialize overhead count.
   911                                  ;
   912                                                          mov     cx,ax                                           ;CX = 00e0 = 224 entries
   913                                                          mul     word [cwEntryLen]                               ;DX:AX = 224 * 32 = 7168
   914                                                          div     word [cwSectorBytes]                            ;AX = 7168 / 512 = 14 = dir sectors
   915                                                          mov     [wwOverhead],ax                                 ;[wwOverhead] = 000e
   916                                  ;
   917                                  ;       Compute directory entries per sector.
   918                                  ;
   919                                                          xchg    ax,cx                                           ;DX:AX = 0:00e0, CX = 0000e
   920                                                          div     cx                                              ;AX = 0010 = entries per dir sector
   921                                                          mov     [wwSectorEntries],ax                            ;[wwSectorEntries] = 0010
   922                                  ;
   923                                  ;       Compute first logical directory sector and update overhead count.
   924                                  ;
   925                                                          mov     ax,[cwFatSectors]                               ;AX = 0009 = FAT sectors per copy
   926                                                          mul     byte [cbFatCount]                               ;AX = 0012 = FAT sectors
   927                                                          add     ax,[cwReservedSectors]                          ;AX = 0013 = FAT plus reserved
   928                                                          add     ax,[cwSpecialSectors]                           ;AX = 0013 = FAT + reserved + special
   929                                                          mov     [wwLogicalSector],ax                            ;[wwLogicalSector] = 0013
   930                                                          add     [wwOverhead],ax                                 ;[wwOverhead] = 0021 = res+spec+FAT+dir
   931                                  ;
   932                                  ;       Read directory sector.
   933                                  ;
   934                                  .30                     mov     al,1                                            ;sector count
   935                                                          mov     [wbReadCount],al                                ;[wbReadCount] = 01
   936                                                          mov     bx,[wwDirBuffer]                                ;BX = 1500
   937                                                          call    ReadSector                                      ;read sector into es:bx
   938                                  ;
   939                                  ;       Setup variables to search this directory sector.
   940                                  ;
   941                                                          mov     ax,[wwEntriesLeft]                              ;directory entries to search
   942                                                          cmp     ax,[wwSectorEntries]                            ;need to search more sectors?
   943                                                          jna     .40                                             ;no, continue
   944                                                          mov     ax,[wwSectorEntries]                            ;yes, limit search to sector
   945                                  .40                     sub     [wwEntriesLeft],ax                              ;update entries left to searh
   946                                                          mov     si,cbKernelProgram                              ;program name
   947                                                          mov     di,[wwDirBuffer]                                ;DI = 1500
   948                                  ;
   949                                  ;       Loop through directory sectors searching for kernel program.
   950                                  ;
   951                                  .50                     push    si                                              ;save kernel name address
   952                                                          push    di                                              ;save dir i/o buffer address
   953                                                          mov     cx,11                                           ;length of 8+3 name
   954                                                          cld                                                     ;forward strings
   955                                                          repe    cmpsb                                           ;compare entry name
   956                                                          pop     di                                              ;restore dir i/o buffer address
   957                                                          pop     si                                              ;restore kernel name address
   958                                                          je      .60                                             ;exit loop if found
   959                                                          add     di,[cwEntryLen]                                 ;point to next dir entry
   960                                                          dec     ax                                              ;decrement remaining entries
   961                                                          jnz     .50                                             ;next entry
   962                                  ;
   963                                  ;       Repeat search if we are not at the end of the directory.
   964                                  ;
   965                                                          inc     word [wwLogicalSector]                          ;increment logical sector
   966                                                          cmp     word [wwEntriesLeft],0                          ;done with directory?
   967                                                          jne     .30                                             ;no, get next sector
   968                                                          mov     si,czNoKernel                                   ;missing kernel message
   969                                                          jmp     BootExit                                        ;display message and exit
   970                                  ;
   971                                  ;       If we find the kernel program in the directory, read the FAT.
   972                                  ;
   973                                  .60                     mov     ax,[cwReservedSectors]                          ;AX = 0001
   974                                                          mov     [wwLogicalSector],ax                            ;start past boot sector
   975                                                          mov     ax,[cwFatSectors]                               ;AX = 0009
   976                                                          mov     [wbReadCount],al                                ;[wbReadCount] = 09
   977                                                          mov     bx,EBOOTFATBASE                                 ;BX = 0300
   978                                                          call    ReadSector                                      ;read FAT into buffer
   979                                  ;
   980                                  ;       Get the starting cluster of the kernel program and target address.
   981                                  ;
   982                                                          mov     ax,[di+26]                                      ;AX = starting cluster of file
   983                                                          les     bx,[wwLoadOffset]                               ;ES:BX = kernel load add (08f0:0100)
   984                                  ;
   985                                  ;       Read each program cluster into RAM.
   986                                  ;
   987                                  .70                     push    ax                                              ;save cluster nbr
   988                                                          sub     ax,2                                            ;AX = cluster nbr base 0
   989                                                          mov     cl,[cbClusterSectors]                           ;CL = sectors per cluster
   990                                                          mov     [wbReadCount],cl                                ;save sectors to read
   991                                                          xor     ch,ch                                           ;CX = sectors per cluster
   992                                                          mul     cx                                              ;DX:AX = logical cluster sector
   993                                                          add     ax,[wwOverhead]                                 ;AX = kernel sector nbr
   994                                                          mov     [wwLogicalSector],ax                            ;save logical sector nbr
   995                                                          call    ReadSector                                      ;read sectors into ES:BX
   996                                  ;
   997                                  ;       Update buffer pointer for next cluster.
   998                                  ;
   999                                                          mov     al,[cbClusterSectors]                           ;AL = sectors per cluster
  1000                                                          xor     ah,ah                                           ;AX = sectors per cluster
  1001                                                          mul     word [cwSectorBytes]                            ;DX:AX = cluster bytes
  1002                                                          add     bx,ax                                           ;BX = next cluster target address
  1003                                                          pop     ax                                              ;AX = restore cluster nbr
  1004                                  ;
  1005                                  ;       Compute next cluster number.
  1006                                  ;
  1007                                                          mov     cx,ax                                           ;CX = cluster nbr
  1008                                                          mov     di,ax                                           ;DI = cluster nbr
  1009                                                          shr     ax,1                                            ;AX = cluster/2
  1010                                                          mov     dx,ax                                           ;DX = cluster/2
  1011                                                          add     ax,dx                                           ;AX = 2*(cluster/2)
  1012                                                          add     ax,dx                                           ;AX = 3*(cluster/2)
  1013                                                          and     di,1                                            ;get low bit
  1014                                                          add     di,ax                                           ;add one if cluster is odd
  1015                                                          add     di,EBOOTFATBASE                                 ;add FAT buffer address
  1016                                                          mov     ax,[di]                                         ;get cluster bytes
  1017                                  ;
  1018                                  ;       Adjust cluster nbr by 4 bits if cluster is odd; test for end of chain.
  1019                                  ;
  1020                                                          test    cl,1                                            ;is cluster odd?
  1021                                                          jz      .80                                             ;no, skip ahead
  1022                                                          mov     cl,4                                            ;shift count
  1023                                                          shr     ax,cl                                           ;shift nybble low
  1024                                  .80                     and     ax,0FFFh                                        ;mask for 24 bits; next cluster nbr
  1025                                                          cmp     ax,0FFFh                                        ;end of chain?
  1026                                                          jne     .70                                             ;no, continue
  1027                                  ;
  1028                                  ;       Transfer control to the operating system program.
  1029                                  ;
  1030                                                          db      0EAh                                            ;jmp seg:offset
  1031                                  wwLoadOffset            dw      0100h                                           ;kernel entry offset
  1032                                  wwLoadSegment           dw      08F0h                                           ;kernel entry segment (computed)
  1033                                  ;
  1034                                  ;       Read [wbReadCount] disk sectors from [wwLogicalSector] into ES:BX.
  1035                                  ;
  1036                                  ReadSector              mov     ax,[cwTrackSectors]                             ;AX = sectors per track
  1037                                                          mul     word [cwDiskSides]                              ;DX:AX = sectors per cylinder
  1038                                                          mov     cx,ax                                           ;CX = sectors per cylinder
  1039                                                          mov     ax,[wwLogicalSector]                            ;DX:AX = logical sector
  1040                                                          div     cx                                              ;AX = cylinder; DX = cyl sector
  1041                                                          mov     [wbTrack],al                                    ;[wbTrack] = cylinder
  1042                                                          mov     ax,dx                                           ;AX = cyl sector
  1043                                                          div     byte [cbTrackSectors]                           ;AH = sector, AL = head
  1044                                                          inc     ah                                              ;AH = sector (1,2,3,...)
  1045                                                          mov     [wbHead],ax                                     ;[wbHead]= head, [wwSectorTrack]= sector
  1046                                  ;
  1047                                  ;       Try maxtries times to read sector.
  1048                                  ;
  1049                                                          mov     cx,EBOOTMAXTRIES                                ;CX = 0005
  1050                                  .10                     push    bx                                              ;save buffer address
  1051                                                          push    cx                                              ;save retry count
  1052                                                          mov     dx,[wwDriveHead]                                ;DH = head, DL = drive
  1053                                                          mov     cx,[wwSectorTrack]                              ;CH = track, CL = sector
  1054                                                          mov     ax,[wwReadCountCommand]                         ;AH = fn., AL = sector count
  1055                                                          int     EBIOSINTDISKETTE                                ;read sector
  1056                                                          pop     cx                                              ;restore retry count
  1057                                                          pop     bx                                              ;restore buffer address
  1058                                                          jnc     BootReturn                                      ;skip ahead if done
  1059                                                          loop    .10                                             ;retry
  1060                                  ;
  1061                                  ;       Handle disk error: convert to ASCII and store in error string.
  1062                                  ;
  1063                                                          mov     al,ah                                           ;AL = bios error code
  1064                                                          xor     ah,ah                                           ;AX = bios error code
  1065                                                          mov     dl,16                                           ;divisor for base 16
  1066                                                          div     dl                                              ;AL = hi order, AH = lo order
  1067                                                          or      ax,03030h                                       ;apply ASCII zone bits
  1068                                                          cmp     ah,03Ah                                         ;range test ASCII numeral
  1069                                                          jb      .20                                             ;continue if numeral
  1070                                                          add     ah,7                                            ;adjust for ASCII 'A'-'F'
  1071                                  .20                     cmp     al,03Ah                                         ;range test ASCII numeral
  1072                                                          jb      .30                                             ;continue if numeral
  1073                                                          add     ah,7                                            ;adjust for ASCII 'A'-'F'
  1074                                  .30                     mov     [wzErrorCode],ax                                ;store ASCII error code
  1075                                                          mov     si,czErrorMsg                                   ;error message address
  1076                                  BootExit                call    BootPrint                                       ;display messge to console
  1077                                  ;
  1078                                  ;       Wait for a key press.
  1079                                  ;
  1080                                  .10                     mov     ah,EBIOSFNKEYSTATUS                             ;BIOS keyboard status function
  1081                                                          int     EBIOSINTKEYBOARD                                ;get keyboard status
  1082                                                          jnz     .20                                             ;continue if key pressed
  1083                                                          sti                                                     ;enable maskable interrupts
  1084                                                          hlt                                                     ;wait for interrupt
  1085                                                          jmp     .10                                             ;repeat
  1086                                  ;
  1087                                  ;       Reset the system.
  1088                                  ;
  1089                                  .20                     mov     al,EKEYBCMDRESET                                ;8042 pulse output port pin
  1090                                                          out     EKEYBPORTSTAT,al                                ;drive B0 low to restart
  1091                                  .30                     sti                                                     ;enable maskable interrupts
  1092                                                          hlt                                                     ;stop until reset, int, nmi
  1093                                                          jmp     .30                                             ;loop until restart kicks in
  1094                                  ;
  1095                                  ;       Display text message.
  1096                                  ;
  1097                                  BootPrint               cld                                                     ;forward strings
  1098                                  .10                     lodsb                                                   ;load next byte at DS:SI in AL
  1099                                                          test    al,al                                           ;end of string?
  1100                                                          jz      BootReturn                                      ;... yes, exit our loop
  1101                                                          mov     ah,EBIOSFNTTYOUTPUT                             ;BIOS teletype function
  1102                                                          int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
  1103                                                          jmp     .10                                             ;repeat until done
  1104                                  BootReturn              ret                                                     ;return
  1105                                  ;-----------------------------------------------------------------------------------------------------------------------
  1106                                  ;
  1107                                  ;       Constants
  1108                                  ;
  1109                                  ;-----------------------------------------------------------------------------------------------------------------------
  1110                                                          align   2
  1111                                  cwEntryLen              dw      32                                              ;length of directory entry
  1112                                  cbKernelProgram         db      "OS      COM"                                   ;kernel program name
  1113                                  czLoadMsg               db      "Loading OS",13,10,0                            ;loading message
  1114                                  czErrorMsg              db      "Disk error "                                   ;error message
  1115                                  wzErrorCode             db      020h,020h,0                                     ;error code and null terminator
  1116                                  czNoKernel              db      "OS missing",0                                  ;missing kernel message
  1117                                  ;-----------------------------------------------------------------------------------------------------------------------
  1118                                  ;
  1119                                  ;       Work Areas
  1120                                  ;
  1121                                  ;-----------------------------------------------------------------------------------------------------------------------
  1122                                                          align   2
  1123                                  wwDirBuffer             dw      0                                               ;directory i/o buffer address
  1124                                  wwEntriesLeft           dw      0                                               ;directory entries to search
  1125                                  wwOverhead              dw      0                                               ;overhead sectors
  1126                                  wwSectorEntries         dw      0                                               ;directory entries per sector
  1127                                  wwLogicalSector         dw      0                                               ;current logical sector
  1128                                  wwReadCountCommand      equ     $                                               ;read count and command
  1129                                  wbReadCount             db      0                                               ;sectors to read
  1130                                  cbReadCommand           db      EBIOSFNREADSECTOR                               ;BIOS read disk fn code
  1131                                  wwDriveHead             equ     $                                               ;drive, head (word)
  1132                                  wbDrive                 db      0                                               ;drive
  1133                                  wbHead                  db      0                                               ;head
  1134                                  wwSectorTrack           equ     $                                               ;sector, track (word)
  1135                                                          db      0                                               ;sector
  1136                                  wbTrack                 db      0                                               ;track
  1137                                                          times   510-($-$$) db 0h                                ;zero fill to end of sector
  1138                                                          db      055h,0AAh                                       ;end of sector signature
  1139                                  %endif
  1140                                  %ifdef BUILDPREP
  1141                                  ;=======================================================================================================================
  1142                                  ;
  1143                                  ;       Diskette Preparation Code
  1144                                  ;
  1145                                  ;       This routine writes the OS boot sector code to a formatted floppy diskette. The diskette parameter table,
  1146                                  ;       which is located in the first 30 bytes of the boot sector is first read from the diskette and overlayed onto
  1147                                  ;       the OS bootstrap code so that the diskette format parameters are preserved.
  1148                                  ;
  1149                                  ;=======================================================================================================================
  1150                                  ;
  1151                                  ;       Query the user to insert a flopppy diskette and press enter or cancel.
  1152                                  ;
  1153                                  Prep                    mov     si,czPrepMsg10                                  ;starting message address
  1154                                                          call    BootPrint                                       ;display message
  1155                                  ;
  1156                                  ;       Exit if the Escape key is pressed or loop until Enter is pressed.
  1157                                  ;
  1158                                  .10                     mov     ah,EBIOSFNKEYSTATUS                             ;BIOS keyboard status function
  1159                                                          int     EBIOSINTKEYBOARD                                ;get keyboard status
  1160                                                          jnz     .20                                             ;continue if key pressed
  1161                                                          sti                                                     ;enable interrupts
  1162                                                          hlt                                                     ;wait for interrupt
  1163                                                          jmp     .10                                             ;repeat
  1164                                  .20                     cmp     al,EASCIIRETURN                                 ;Enter key pressed?
  1165                                                          je      .30                                             ;yes, branch
  1166                                                          cmp     al,EASCIIESCAPE                                 ;Escape key pressed?
  1167                                                          jne     .10                                             ;no, repeat
  1168                                                          jmp     .120                                            ;yes, exit program
  1169                                  ;
  1170                                  ;       Display writing-sector message and patch the JMP instruction.
  1171                                  ;
  1172                                  .30                     mov     si,czPrepMsg12                                  ;writing-sector message address
  1173                                                          call    BootPrint                                       ;display message
  1174                                                          mov     bx,Boot+1                                       ;address of JMP instruction operand
  1175                                                          mov     ax,01Bh                                         ;address past disk parameter table
  1176                                                          mov     [bx],ax                                         ;update the JMP instruction
  1177                                  ;
  1178                                  ;       Try to read the boot sector.
  1179                                  ;
  1180                                                          mov     cx,EBOOTMAXTRIES                                ;try up to five times
  1181                                  .40                     push    cx                                              ;save remaining tries
  1182                                                          mov     bx,wcPrepInBuf                                  ;input buffer address
  1183                                                          mov     dx,0                                            ;head zero, drive zero
  1184                                                          mov     cx,1                                            ;track zero, sector one
  1185                                                          mov     al,1                                            ;one sector
  1186                                                          mov     ah,EBIOSFNREADSECTOR                            ;read function
  1187                                                          int     EBIOSINTDISKETTE                                ;attempt the read
  1188                                                          pop     cx                                              ;restore remaining retries
  1189                                                          jnc     .50                                             ;skip ahead if successful
  1190                                                          loop    .40                                             ;try again
  1191                                                          mov     si,czPrepMsg20                                  ;read-error message address
  1192                                                          jmp     .70                                             ;branch to error routine
  1193                                  ;
  1194                                  ;       Copy diskette parms from input buffer to output buffer.
  1195                                  ;
  1196                                  .50                     mov     si,wcPrepInBuf                                  ;input buffer address
  1197                                                          add     si,11                                           ;skip over JMP and system ID
  1198                                                          mov     di,Boot                                         ;output buffer address
  1199                                                          add     di,11                                           ;skip over JMP and system ID
  1200                                                          mov     cx,19                                           ;length of diskette parameters
  1201                                                          cld                                                     ;forward string copies
  1202                                                          rep     movsb                                           ;copy diskette parameters
  1203                                  ;
  1204                                  ;       Try to write boot sector to diskette.
  1205                                  ;
  1206                                                          mov     cx,EBOOTMAXTRIES                                ;try up to five times
  1207                                  .60                     push    cx                                              ;save remaining tries
  1208                                                          mov     bx,Boot                                         ;output buffer address
  1209                                                          mov     dx,0                                            ;head zero, drive zero
  1210                                                          mov     cx,1                                            ;track zero, sector one
  1211                                                          mov     al,1                                            ;one sector
  1212                                                          mov     ah,EBIOSFNWRITESECTOR                           ;write function
  1213                                                          int     EBIOSINTDISKETTE                                ;attempt the write
  1214                                                          pop     cx                                              ;restore remaining retries
  1215                                                          jnc     .100                                            ;skip ahead if successful
  1216                                                          loop    .60                                             ;try again
  1217                                                          mov     si,czPrepMsg30                                  ;write-error message address
  1218                                  ;
  1219                                  ;       Convert the error code to ASCII and display the error message.
  1220                                  ;
  1221                                  .70                     push    ax                                              ;save error code
  1222                                                          mov     al,ah                                           ;copy error code
  1223                                                          mov     ah,0                                            ;AX = error code
  1224                                                          mov     dl,10h                                          ;hexadecimal divisor
  1225                                                          idiv    dl                                              ;AL = hi-order, AH = lo-order
  1226                                                          or      ax,03030h                                       ;add ASCII zone digits
  1227                                                          cmp     ah,03Ah                                         ;AH ASCII numeral?
  1228                                                          jb      .80                                             ;yes, continue
  1229                                                          add     ah,7                                            ;no, make ASCII 'A'-'F'
  1230                                  .80                     cmp     al,03Ah                                         ;ASCII numeral?
  1231                                                          jb      .90                                             ;yes, continue
  1232                                                          add     al,7                                            ;no, make ASCII
  1233                                  .90                     mov     [si+17],ax                                      ;put ASCII error code in message
  1234                                                          call    BootPrint                                       ;write error message
  1235                                                          pop     ax                                              ;restore error code
  1236                                  ;
  1237                                  ;       Display the completion message.
  1238                                  ;
  1239                                  .100                    mov     si,czPrepMsgOK                                  ;assume successful completion
  1240                                                          mov     al,ah                                           ;BIOS return code
  1241                                                          cmp     al,0                                            ;success?
  1242                                                          je      .110                                            ;yes, continue
  1243                                                          mov     si,czPrepMsgErr1                                ;disk parameter error message
  1244                                                          cmp     al,1                                            ;disk parameter error?
  1245                                                          je      .110                                            ;yes, continue
  1246                                                          mov     si,czPrepMsgErr2                                ;address mark not found message
  1247                                                          cmp     al,2                                            ;address mark not found?
  1248                                                          je      .110                                            ;yes, continue
  1249                                                          mov     si,czPrepMsgErr3                                ;protected disk message
  1250                                                          cmp     al,3                                            ;protected disk?
  1251                                                          je      .110                                            ;yes, continue
  1252                                                          mov     si,czPrepMsgErr6                                ;diskette removed message
  1253                                                          cmp     al,6                                            ;diskette removed?
  1254                                                          je      .110                                            ;yes, continue
  1255                                                          mov     si,czPrepMsgErr80                               ;drive timed out message
  1256                                                          cmp     al,80H                                          ;drive timed out?
  1257                                                          je      .110                                            ;yes, continue
  1258                                                          mov     si,czPrepMsgErrXX                               ;unknown error message
  1259                                  .110                    call    BootPrint                                       ;display result message
  1260                                  .120                    mov     ax,04C00H                                       ;terminate with zero result code
  1261                                                          int     021h                                            ;terminate DOS program
  1262                                                          ret                                                     ;return (should not execute)
  1263                                  ;-----------------------------------------------------------------------------------------------------------------------
  1264                                  ;
  1265                                  ;       Diskette Preparation Messages
  1266                                  ;
  1267                                  ;-----------------------------------------------------------------------------------------------------------------------
  1268                                  czPrepMsg10             db      13,10,"CustomOS Boot-Diskette Preparation Program"
  1269                                                          db      13,10,"Copyright (C) 2010-2018 David J. Walling. All rights reserved."
  1270                                                          db      13,10
  1271                                                          db      13,10,"This program overwrites the boot sector of a diskette with startup code that"
  1272                                                          db      13,10,"will load the operating system into memory when the computer is restarted."
  1273                                                          db      13,10,"To proceed, place a formatted diskette into drive A: and press the Enter key."
  1274                                                          db      13,10,"To exit this program without preparing a diskette, press the Escape key."
  1275                                                          db      13,10,0
  1276                                  czPrepMsg12             db      13,10,"Writing the boot sector to the diskette ..."
  1277                                                          db      13,10,0
  1278                                  czPrepMsg20             db      13,10,"The error-code .. was returned from the BIOS while reading from the disk."
  1279                                                          db      13,10,0
  1280                                  czPrepMsg30             db      13,10,"The error-code .. was returned from the BIOS while writing to the disk."
  1281                                                          db      13,10,0
  1282                                  czPrepMsgOK             db      13,10,"The boot-sector was written to the diskette. Before booting your computer with"
  1283                                                          db      13,10,"this diskette, make sure that the file OS.COM is copied onto the diskette."
  1284                                                          db      13,10,0
  1285                                  czPrepMsgErr1           db      13,10,"(01) Invalid Disk Parameter"
  1286                                                          db      13,10,"This is an internal error caused by an invalid value being passed to a system"
  1287                                                          db      13,10,"function. The OSBOOT.COM file may be corrupt. Copy or download the file again"
  1288                                                          db      13,10,"and retry."
  1289                                                          db      13,10,0
  1290                                  czPrepMsgErr2           db      13,10,"(02) Address Mark Not Found"
  1291                                                          db      13,10,"This error indicates a physical problem with the floppy diskette. Please retry"
  1292                                                          db      13,10,"using another diskette."
  1293                                                          db      13,10,0
  1294                                  czPrepMsgErr3           db      13,10,"(03) Protected Disk"
  1295                                                          db      13,10,"This error is usually caused by attempting to write to a write-protected disk."
  1296                                                          db      13,10,"Check the 'write-protect' setting on the disk or retry using using another disk."
  1297                                                          db      13,10,0
  1298                                  czPrepMsgErr6           db      13,10,"(06) Diskette Removed"
  1299                                                          db      13,10,"This error may indicate that the floppy diskette has been removed from the"
  1300                                                          db      13,10,"diskette drive. On some systems, this code may also occur if the diskette is"
  1301                                                          db      13,10,"'write protected.' Please verify that the diskette is not write-protected and"
  1302                                                          db      13,10,"is properly inserted in the diskette drive."
  1303                                                          db      13,10,0
  1304                                  czPrepMsgErr80          db      13,10,"(80) Drive Timed Out"
  1305                                                          db      13,10,"This error usually indicates that no diskette is in the diskette drive. Please"
  1306                                                          db      13,10,"make sure that the diskette is properly seated in the drive and retry."
  1307                                                          db      13,10,0
  1308                                  czPrepMsgErrXX          db      13,10,"(??) Unknown Error"
  1309                                                          db      13,10,"The error-code returned by the BIOS is not a recognized error. Please consult"
  1310                                                          db      13,10,"your computer's technical reference for a description of this error code."
  1311                                                          db      13,10,0
  1312                                  wcPrepInBuf             equ     $
  1313                                  %endif
  1314                                  %ifdef BUILDDISK
  1315                                  ;=======================================================================================================================
  1316                                  ;
  1317                                  ;       File Allocation Tables
  1318                                  ;
  1319                                  ;       The disk contains two copies of the File Allocation Table (FAT). On our disk, each FAT copy is 1200h bytes in
  1320                                  ;       length. Each FAT entry contains the logical number of the next cluster. The first two entries are reserved. Our
  1321                                  ;       OS.COM file will be 7400h bytes in length. The first 400h bytes are the 16-bit loader code. The remaining 7000h
  1322                                  ;       bytes are the 32-bit kernel code. Our disk parameter table defines a cluster as containing one sector and each
  1323                                  ;       sector having 200h bytes. Therefore, our FAT table must reserve 58 clusters for OS.COM. The clusters used by
  1324                                  ;       OS.COM, then, will be cluster 2 through 59. The entry for cluster 59 is set to "0fffh" to indicate that it is
  1325                                  ;       the last cluster in the chain.
  1326                                  ;
  1327                                  ;       Every three bytes encode two FAT entries as follows:
  1328                                  ;
  1329                                  ;       db      0abh,0cdh,0efh  ;even cluster: 0dabh, odd cluster: 0efch
  1330                                  ;
  1331                                  ;=======================================================================================================================
  1332                                  ;-----------------------------------------------------------------------------------------------------------------------
  1333                                  ;
  1334                                  ;       FAT copy 1                                                              @disk: 000200   @mem: n/a
  1335                                  ;
  1336                                  ;-----------------------------------------------------------------------------------------------------------------------
  1337                                  section                 fat1                                                    ;first copy of FAT
  1338                                                          db      0F0h,0FFh,0FFh, 003h,040h,000h                  ;clusters 0-3           ff0 fff 003 004
  1339                                                          db      005h,060h,000h, 007h,080h,000h                  ;custters 4-7           005 006 007 008
  1340                                                          db      009h,0A0h,000h, 00Bh,0C0h,000h                  ;clusters 8-11          009 00a 00b 00c
  1341                                                          db      00Dh,0E0h,000h, 00Fh,000h,001h                  ;clusters 12-15         00d 00e 00f 010
  1342                                                          db      011h,020h,001h, 013h,040h,001h                  ;clusters 16-19         011 012 013 014
  1343                                                          db      015h,060h,001h, 017h,080h,001h                  ;clusters 20-23         015 016 017 018
  1344                                                          db      019h,0A0h,001h, 01Bh,0C0h,001h                  ;clusters 24-27         019 01a 01b 01c
  1345                                                          db      01Dh,0E0h,001h, 01Fh,000h,002h                  ;clusters 28-31         01d 01e 01f 020
  1346                                                          db      021h,020h,002h, 023h,040h,002h                  ;clusters 32-35         021 022 023 024
  1347                                                          db      025h,060h,002h, 027h,080h,002h                  ;clusters 36-39         025 026 027 028
  1348                                                          db      029h,0A0h,002h, 02Bh,0C0h,002h                  ;clusters 40-43         029 02A 02B 02C
  1349                                                          db      02Dh,0E0h,002h, 02Fh,000h,003h                  ;clusters 44-47         02D 02E 02F 030
  1350                                                          db      031h,020h,003h, 033h,040h,003h                  ;clusters 48-51         031 032 033 034
  1351                                                          db      035h,060h,003h, 037h,080h,003h                  ;clusters 52-55         035 036 037 038
  1352                                                          db      039h,0A0h,003h, 03Bh,0F0h,0FFh                  ;clusters 56-59         039 03A 03B FFF
  1353                                                          times   (9*512)-($-$$) db 0                             ;zero fill to end of section
  1354                                  ;-----------------------------------------------------------------------------------------------------------------------
  1355                                  ;
  1356                                  ;       FAT copy 2                                                              @disk: 001400   @mem: n/a
  1357                                  ;
  1358                                  ;-----------------------------------------------------------------------------------------------------------------------
  1359                                  section                 fat2                                                    ;second copy of FAT
  1360                                                          db      0F0h,0FFh,0FFh, 003h,040h,000h                  ;clusters 0-3           ff0 fff 003 004
  1361                                                          db      005h,060h,000h, 007h,080h,000h                  ;custters 4-7           005 006 007 008
  1362                                                          db      009h,0A0h,000h, 00Bh,0C0h,000h                  ;clusters 8-11          009 00a 00b 00c
  1363                                                          db      00Dh,0E0h,000h, 00Fh,000h,001h                  ;clusters 12-15         00d 00e 00f 010
  1364                                                          db      011h,020h,001h, 013h,040h,001h                  ;clusters 16-19         011 012 013 014
  1365                                                          db      015h,060h,001h, 017h,080h,001h                  ;clusters 20-23         015 016 017 018
  1366                                                          db      019h,0A0h,001h, 01Bh,0C0h,001h                  ;clusters 24-27         019 01a 01b 01c
  1367                                                          db      01Dh,0E0h,001h, 01Fh,000h,002h                  ;clusters 28-31         01d 01e 01f 020
  1368                                                          db      021h,020h,002h, 023h,040h,002h                  ;clusters 32-35         021 022 023 024
  1369                                                          db      025h,060h,002h, 027h,080h,002h                  ;clusters 36-39         025 026 027 028
  1370                                                          db      029h,0A0h,002h, 02Bh,0C0h,002h                  ;clusters 40-43         029 02A 02B 02C
  1371                                                          db      02Dh,0E0h,002h, 02Fh,000h,003h                  ;clusters 44-47         02D 02E 02F 030
  1372                                                          db      031h,020h,003h, 033h,040h,003h                  ;clusters 48-51         031 032 033 034
  1373                                                          db      035h,060h,003h, 037h,080h,003h                  ;clusters 52-55         035 036 037 038
  1374                                                          db      039h,0A0h,003h, 03Bh,0F0h,0FFh                  ;clusters 56-59         039 03A 03B FFF
  1375                                                          times   (9*512)-($-$$) db 0                             ;zero fill to end of section
  1376                                  ;-----------------------------------------------------------------------------------------------------------------------
  1377                                  ;
  1378                                  ;       Diskette Directory                                                      @disk: 002600   @mem: n/a
  1379                                  ;
  1380                                  ;       The disk contains one copy of the diskette directory. Each directory entry is 32 bytes long. Our directory
  1381                                  ;       contains only one entry. Unused entries are set to all nulls. The directory immediately follows the second FAT
  1382                                  ;       copy.
  1383                                  ;
  1384                                  ;-----------------------------------------------------------------------------------------------------------------------
  1385                                  section                 dir                                                     ;diskette directory
  1386                                                          db      "OS      COM"                                   ;file name (must contain spaces)
  1387                                                          db      020h                                            ;attribute (archive bit set)
  1388                                                          times   10 db 0                                         ;unused
  1389                                                          dw      0h                                              ;time
  1390                                                          db      01000001b                                       ;mmm = 10 MOD 8 = 2; ddddd = 1
  1391                                                          db      01001001b                                       ;yyyyyyy = 2016-1980 = 36 = 24h; m/8 = 1
  1392                                                          dw      2                                               ;first cluster
  1393                                                          dd      07200h                                          ;file size
  1394                                                          times   (EBOOTDIRENTRIES*32)-($-$$) db 0h               ;zero fill to end of section
  1395                                  %endif
  1396                                  %ifdef BUILDCOM
  1397                                  ;=======================================================================================================================
  1398                                  ;
  1399                                  ;       OS.COM
  1400                                  ;
  1401                                  ;       The operating system file is assembled at the start of the data area of the floppy disk image, which
  1402                                  ;       immediately follows the directory. This corresponds to logical cluster 2, even though the physical address of
  1403                                  ;       this sector on the disk varies depending on the disk type. The os.com file consists of two parts, the OS loader
  1404                                  ;       and the OS kernel. The Loader is 16-bit code that receives control directly from the boot sector code after the
  1405                                  ;       OS.COM file is loaded into memory. The kernel is 32-bit code that receives control after the Loader has
  1406                                  ;       initialized protected-mode tables and 32-bit interrupt handlers and switched the CPU into protected mode.
  1407                                  ;
  1408                                  ;       Our loader addressability is set up according to the following diagram.
  1409                                  ;
  1410                                  ;       SS -----------> 007b00  +-----------------------------------------------+ SS:0000
  1411                                  ;                               |  Boot Stack & Boot PSP (Unused)               |
  1412                                  ;                               |  256 = 100h bytes                             |
  1413                                  ;       SS:SP --------> 007c00  +-----------------------------------------------+ SS:0100  07b0:0100
  1414                                  ;                               |  Boot Sector (vstart=0100h)                   |
  1415                                  ;                               |  1 sector = 512 = 200h bytes                  |
  1416                                  ;                       007e00  +-----------------------------------------------+
  1417                                  ;                               |  File Allocation Table (FAT) I/O Buffer       |
  1418                                  ;                               |  9 x 512-byte sectors = 4,608 = 1200h bytes   |
  1419                                  ;                               |                                               |
  1420                                  ;       CS,DS,ES -----> 008f00  |  Loader PSP (Unused)                          | DS:0000
  1421                                  ;                               |                                               |
  1422                                  ;       CS:IP --------> 009000  +-----------------------------------------------+ DS:0100  08f0:0100
  1423                                  ;                               |  Loader Code                                  |
  1424                                  ;                               |  2 sectors = 1024 = 400h bytes                |
  1425                                  ;                       009400  +-----------------------------------------------+ DS:0500
  1426                                  ;
  1427                                  ;=======================================================================================================================
  1428                                  ;-----------------------------------------------------------------------------------------------------------------------
  1429                                  ;
  1430                                  ;       OS Loader                                                               @disk: 004200   @mem: 009000
  1431                                  ;
  1432                                  ;       This code is the operating system loader. It resides on the boot disk at the start of the data area, following
  1433                                  ;       the directory. The loader occupies several clusters that are mapped in the file allocation tables above.
  1434                                  ;       The loader executes 16-bit instructions in real mode. It performs several initialization functions such as
  1435                                  ;       determining whether the CPU and other resources are sufficient to run the operating system. If all minimum
  1436                                  ;       resources are present, the loader initializes protected mode tables, places the CPU into protected mode and
  1437                                  ;       starts the console task. Since the loader was called either from the bootstrap or as a .com file on the boot
  1438                                  ;       disk, we can assume that the initial IP is 0x100 and not perform any absolute address fix-ups on our segment
  1439                                  ;       registers.
  1440                                  ;
  1441                                  ;-----------------------------------------------------------------------------------------------------------------------
  1442                                                          cpu     8086                                            ;assume minimal CPU
  1443                                  section                 loader  vstart=0100h                                    ;use .COM compatible addressing
  1444                                                          bits    16                                              ;this is 16-bit code
  1445 00000000 0E                      Loader                  push    cs                                              ;use the code segment
  1446 00000001 1F                                              pop     ds                                              ;...as our data segment
  1447 00000002 0E                                              push    cs                                              ;use the code segment
  1448 00000003 07                                              pop     es                                              ;...as our extra segment
  1449                                  ;
  1450                                  ;       Write a message to the console so we know we have our addressability established.
  1451                                  ;
  1452 00000004 BE[7D01]                                        mov     si,czStartingMsg                                ;starting message
  1453 00000007 E8C900                                          call    PutTTYString                                    ;display loader message
  1454                                  ;
  1455                                  ;       Determine the CPU type, generally. Exit if the CPU is not at least an 80386.
  1456                                  ;
  1457 0000000A E8A600                                          call    GetCPUType                                      ;AL = cpu type
  1458 0000000D BE[EA00]                                        mov     si,czCPUErrorMsg                                ;loader error message
  1459 00000010 3C03                                            cmp     al,3                                            ;80386+?
  1460 00000012 7303E98700                                      jb      LoaderExit                                      ;no, exit with error message
  1461                                                          cpu     386                                             ;allow 80386 instructions
  1462 00000017 BE[5501]                                        mov     si,czCPUOKMsg                                   ;cpu ok message
  1463 0000001A E8B600                                          call    PutTTYString                                    ;display message
  1464                                  ;
  1465                                  ;       Initialize kernel data areas. The task queue is initialized here because as soon as we enter protected mode,
  1466                                  ;       the timer interrupt code will begin inspecting the task queue to determine if a task switch must be made. To
  1467                                  ;       start with, we set every 16th queue element to reference the background task selector. This will ensure that
  1468                                  ;       the background task, which updates the visible clock on the console, will be called at least once per second.
  1469                                  ;
  1470 0000001D 6A00                                            push    EKRNDATASEG                                     ;load kernel data segment address ...
  1471 0000001F 07                                              pop     es                                              ;... into extra segment reg
  1472 00000020 BF0008                                          mov     di,wwTaskQueue                                  ;task queue address
  1473 00000023 B94000                                          mov     cx,64                                           ;outer loop
  1474 00000026 51                      .10                     push    cx                                              ;save remaining outer iterations
  1475 00000027 B90300                                          mov     cx,3                                            ;inner loop
  1476 0000002A B86800                                          mov     ax,EGDTCONSOLETSS                               ;console task state segment selector
  1477 0000002D FC                                              cld                                                     ;forward strings
  1478 0000002E F3AB                                            rep     stosw                                           ;store selectors in task queue
  1479 00000030 B87800                                          mov     ax,ESELBACKGROUNDTSS                            ;background task state segment selector
  1480 00000033 AB                                              stosw                                                   ;store selector in task queue
  1481 00000034 59                                              pop     cx                                              ;restore remaining outer iterations
  1482 00000035 E2EF                                            loop    .10                                             ;next
  1483 00000037 31C0                                            xor     ax,ax                                           ;zero register
  1484 00000039 B104                                            mov     cl,4                                            ;remaining words to reset
  1485 0000003B F3AB                                            rep     stosw                                           ;reset remaining kernel data
  1486                                  ;
  1487                                  ;       Fixup the GDT descriptor for the current (loader) code segment.
  1488                                  ;
  1489 0000003D BE0005                                          mov     si,EKRNCODESRCADR                               ;GDT offset
  1490 00000040 8CC8                                            mov     ax,cs                                           ;AX:SI = gdt source
  1491 00000042 C1C004                                          rol     ax,4                                            ;AX = phys addr bits 11-0,15-12
  1492 00000045 88C1                                            mov     cl,al                                           ;CL = phys addr bits 3-0,15-12
  1493 00000047 24F0                                            and     al,0F0h                                         ;AL = phys addr bits 11-0
  1494 00000049 80E10F                                          and     cl,00Fh                                         ;CL = phys addr bits 15-12
  1495 0000004C 894432                                          mov     word [si+EGDTLOADERCODE+2],ax                   ;lo-order loader code (0-15)
  1496 0000004F 884C34                                          mov     byte [si+EGDTLOADERCODE+4],cl                   ;lo-order loader code (16-23)
  1497 00000052 BE[5E01]                                        mov     si,czGDTOKMsg                                   ;GDT prepared message
  1498 00000055 E87B00                                          call    PutTTYString                                    ;display message
  1499                                  ;
  1500                                  ;       Move the 32-bit kernel to its appropriate memory location.
  1501                                  ;
  1502 00000058 680001                                          push    EKRNCODESEG                                     ;use kernel code segment ...
  1503 0000005B 07                                              pop     es                                              ;... as target segment
  1504 0000005C 31FF                                            xor     di,di                                           ;ES:DI = target address
  1505 0000005E BE0005                                          mov     si,EKRNCODESRCADR                               ;DS:SI = source address
  1506 00000061 B90070                                          mov     cx,EKRNCODELEN                                  ;CX = kernel size
  1507 00000064 FC                                              cld                                                     ;forward strings
  1508 00000065 F3A4                                            rep     movsb                                           ;copy kernel image
  1509 00000067 BE[6D01]                                        mov     si,czKernelLoadedMsg                            ;kernel moved message
  1510 0000006A E86600                                          call    PutTTYString                                    ;display message
  1511                                  ;
  1512                                  ;       Switch to protected mode.
  1513                                  ;
  1514 0000006D 31F6                                            xor     si,si                                           ;ES:SI = gdt addr
  1515 0000006F 8ED6                                            mov     ss,si                                           ;protected mode ss
  1516 00000071 BC0010                                          mov     sp,EKRNCODEBASE                                 ;initial stack immediate before code
  1517 00000074 B489                                            mov     ah,EBIOSFNINITPROTMODE                          ;initialize protected mode fn.
  1518 00000076 BB2820                                          mov     bx,02028h                                       ;BH,BL = IRQ int bases
  1519 00000079 BA1F00                                          mov     dx,001Fh                                        ;outer delay loop count
  1520 0000007C B9FFFF                  .20                     mov     cx,0FFFFh                                       ;inner delay loop count
  1521 0000007F E2FE                                            loop    $                                               ;wait out pending interrupts
  1522 00000081 4A                                              dec     dx                                              ;restore outer loop count
  1523 00000082 75F8                                            jnz     .20                                             ;continue outer loop
  1524 00000084 CD15                                            int     EBIOSINTMISC                                    ;call BIOS to set protected mode
  1525                                  ;
  1526                                  ;       Enable hardware and maskable interrupts.
  1527                                  ;
  1528 00000086 30C0                                            xor     al,al                                           ;enable all registers code
  1529 00000088 E621                                            out     EPICPORTPRI1,al                                 ;enable all primary 8259A ints
  1530 0000008A E6A1                                            out     EPICPORTSEC1,al                                 ;enable all secondary 8259A ints
  1531 0000008C FB                                              sti                                                     ;enable maskable interrupts
  1532                                  ;
  1533                                  ;       Load the Task State Segment (TSS) and Local Descriptor Table (LDT) registers and jump to the initial task.
  1534                                  ;
  1535 0000008D 2E0F001E[E200]                                  ltr     [cs:cwLoaderTSS]                                ;load task register
  1536 00000093 2E0F0016[E000]                                  lldt    [cs:cwLoaderLDT]                                ;load local descriptor table register
  1537 00000099 EA00006800                                      jmp     EGDTCONSOLETSS:0                                ;jump to task state segment selector
  1538                                  ;-----------------------------------------------------------------------------------------------------------------------
  1539                                  ;
  1540                                  ;       Routine:        LoaderExit
  1541                                  ;
  1542                                  ;       Description:    This routine displays the message at DS:SI, waits for a keypress and resets the system.
  1543                                  ;
  1544                                  ;       In:             DS:SI   string address
  1545                                  ;
  1546                                  ;-----------------------------------------------------------------------------------------------------------------------
  1547 0000009E E83200                  LoaderExit              call    PutTTYString                                    ;display error message
  1548                                  ;
  1549                                  ;       Now we want to wait for a keypress. We can use a keyboard interrupt function for this (INT 16h, AH=0).
  1550                                  ;       However, some hypervisor BIOS implementations have been seen to implement the "wait" as simply a fast
  1551                                  ;       iteration of the keyboard status function call (INT 16h, AH=1), causing a max CPU condition. So, instead,
  1552                                  ;       we will use the keyboard status call and iterate over a halt (HLT) instruction until a key is pressed.
  1553                                  ;       By convention, we enable maskable interrupts with STI before issuing HLT, so as not to catch fire.
  1554                                  ;
  1555 000000A1 B401                    .30                     mov     ah,EBIOSFNKEYSTATUS                             ;keyboard status function
  1556 000000A3 CD16                                            int     EBIOSINTKEYBOARD                                ;call BIOS keyboard interrupt
  1557 000000A5 7504                                            jnz     .40                                             ;exit if key pressed
  1558 000000A7 FB                                              sti                                                     ;enable maskable interrupts
  1559 000000A8 F4                                              hlt                                                     ;wait for interrupt
  1560 000000A9 EBF6                                            jmp     .30                                             ;repeat until keypress
  1561                                  ;
  1562                                  ;       Now that a key has been pressed, we signal the system to restart by driving the B0 line on the 8042
  1563                                  ;       keyboard controller low (OUT 64h,0feh). The restart may take some microseconds to kick in, so we issue
  1564                                  ;       HLT until the system resets.
  1565                                  ;
  1566 000000AB B0FE                    .40                     mov     al,EKEYBCMDRESET                                ;8042 pulse output port pin
  1567 000000AD E664                                            out     EKEYBPORTSTAT,al                                ;drive B0 low to restart
  1568 000000AF FB                      .50                     sti                                                     ;enable maskable interrupts
  1569 000000B0 F4                                              hlt                                                     ;stop until reset, int, nmi
  1570 000000B1 EBFC                                            jmp     .50                                             ;loop until restart kicks in
  1571                                  ;-----------------------------------------------------------------------------------------------------------------------
  1572                                  ;
  1573                                  ;       Routine:        GetCPUType
  1574                                  ;
  1575                                  ;       Description:    The loader needs only to determine that the cpu is at least an 80386 or an equivalent. Note that
  1576                                  ;                       the CPUID instruction was not introduced until the SL-enhanced 80486 and Pentium processors, so
  1577                                  ;                       to distinguish whether we have at least an 80386, other means must be used.
  1578                                  ;
  1579                                  ;       Out:            AX      0 = 808x, v20, etc.
  1580                                  ;                               1 = 80186
  1581                                  ;                               2 = 80286
  1582                                  ;                               3 = 80386
  1583                                  ;
  1584                                  ;-----------------------------------------------------------------------------------------------------------------------
  1585 000000B3 B001                    GetCPUType              mov     al,1                                            ;AL = 1
  1586 000000B5 B120                                            mov     cl,32                                           ;shift count
  1587 000000B7 D2E8                                            shr     al,cl                                           ;try a 32-bit shift
  1588 000000B9 08C0                                            or      al,al                                           ;did the shift happen?
  1589 000000BB 7415                                            jz      .10                                             ;yes, cpu is 808x, v20, etc.
  1590                                                          cpu     186
  1591 000000BD 54                                              push    sp                                              ;save stack pointer
  1592 000000BE 59                                              pop     cx                                              ;...into cx
  1593 000000BF 39E1                                            cmp     cx,sp                                           ;did sp decrement before push?
  1594 000000C1 750F                                            jne     .10                                             ;yes, cpu is 80186
  1595                                                          cpu     286
  1596 000000C3 40                                              inc     ax                                              ;AX = 2
  1597 000000C4 0F0106[E400]                                    sgdt    [cbLoaderGDT]                                   ;store gdt reg in work area
  1598 000000C9 8A0E[E900]                                      mov     cl,[cbLoaderGDTHiByte]                          ;CL = hi-order byte
  1599 000000CD FEC1                                            inc     cl                                              ;was hi-byte of GDTR 0xff?
  1600 000000CF 7401                                            jz      .10                                             ;yes, cpu is 80286
  1601 000000D1 40                                              inc     ax                                              ;AX = 3
  1602 000000D2 C3                      .10                     ret                                                     ;return
  1603                                  ;-----------------------------------------------------------------------------------------------------------------------
  1604                                  ;
  1605                                  ;       Routine:        PutTTYString
  1606                                  ;
  1607                                  ;       Description:    This routine sends a NUL-terminated string of characters to the TTY output device. We use the
  1608                                  ;                       TTY output function of the BIOS video interrupt, passing the address of the string in DS:SI
  1609                                  ;                       and the BIOS teletype function code in AH. After a return from the BIOS interrupt, we repeat
  1610                                  ;                       for the next string character until a NUL is found. Note that we clear the direction flag (DF)
  1611                                  ;                       with CLD before the first LODSB. The direction flag is not guaranteed to be preseved between
  1612                                  ;                       calls within the OS. However, the "int" instruction does store the EFLAGS register on the
  1613                                  ;                       stack and restores it on return. Therefore, clearing the direction flag before subsequent calls
  1614                                  ;                       to LODSB is not needed.
  1615                                  ;
  1616                                  ;       In:             DS:SI   address of string
  1617                                  ;
  1618                                  ;       Out:            DF      0
  1619                                  ;                       ZF      1
  1620                                  ;                       AL      0
  1621                                  ;
  1622                                  ;-----------------------------------------------------------------------------------------------------------------------
  1623 000000D3 FC                      PutTTYString            cld                                                     ;forward strings
  1624 000000D4 AC                      .10                     lodsb                                                   ;load next byte at DS:SI in AL
  1625 000000D5 84C0                                            test    al,al                                           ;end of string?
  1626 000000D7 7406                                            jz      .20                                             ;... yes, exit our loop
  1627 000000D9 B40E                                            mov     ah,EBIOSFNTTYOUTPUT                             ;BIOS teletype function
  1628 000000DB CD10                                            int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
  1629 000000DD EBF5                                            jmp     .10                                             ;repeat until done
  1630 000000DF C3                      .20                     ret                                                     ;return
  1631                                  ;-----------------------------------------------------------------------------------------------------------------------
  1632                                  ;
  1633                                  ;       Loader Data
  1634                                  ;
  1635                                  ;       The loader data is updated to include constants defining the initial (Loader) TSS and LDT selectors in the
  1636                                  ;       GDT, a work area to build the GDTR, and additional text messages.
  1637                                  ;
  1638                                  ;-----------------------------------------------------------------------------------------------------------------------
  1639                                                          align   2
  1640 000000E0 5000                    cwLoaderLDT             dw      EGDTLOADERLDT                                   ;loader local descriptor table selector
  1641 000000E2 5800                    cwLoaderTSS             dw      EGDTLOADERTSS                                   ;loader task state segment selector
  1642 000000E4 00<rept>                cbLoaderGDT             times   5 db 0                                          ;6-byte GDTR work area
  1643 000000E9 00                      cbLoaderGDTHiByte       db      0                                               ;hi-order byte
  1644 000000EA 546865206F70657261-     czCPUErrorMsg           db      "The operating system requires an i386 or later processor.",13,10
  1644 000000F3 74696E672073797374-
  1644 000000FC 656D20726571756972-
  1644 00000105 657320616E20693338-
  1644 0000010E 36206F72206C617465-
  1644 00000117 722070726F63657373-
  1644 00000120 6F722E0D0A         
  1645 00000125 506C65617365207072-                             db      "Please press any key to restart the computer.",13,10,0
  1645 0000012E 65737320616E79206B-
  1645 00000137 657920746F20726573-
  1645 00000140 746172742074686520-
  1645 00000149 636F6D70757465722E-
  1645 00000152 0D0A00             
  1646 00000155 435055204F4B0D0A00      czCPUOKMsg              db      "CPU OK",13,10,0                                ;CPU level ok message
  1647 0000015E 474454207072657061-     czGDTOKMsg              db      "GDT prepared",13,10,0                          ;global descriptor table ok message
  1647 00000167 7265640D0A00       
  1648 0000016D 4B65726E656C206C6F-     czKernelLoadedMsg       db      "Kernel loaded",13,10,0                         ;kernel loaded message
  1648 00000176 616465640D0A00     
  1649 0000017D 5374617274696E6720-     czStartingMsg           db      "Starting OS",13,10,0                           ;starting message
  1649 00000186 4F530D0A00         
  1650 0000018B 00<rept>                                        times   1024-($-$$) db 0h                               ;zero fill to end of sector
  1651                                  ;=======================================================================================================================
  1652                                  ;
  1653                                  ;       OS Kernel                                                               @disk: 004600   @mem: 001000
  1654                                  ;
  1655                                  ;       This code is the operating system kernel. It resides on the boot disk image as part of the OS.COM file,
  1656                                  ;       following the 16-bit loader code above. The Kernel executes only 32-bit code in protected mode and contains one
  1657                                  ;       task, the Console, which performs a loop accepting user input from external devices (keyboard, etc.), processes
  1658                                  ;       commands and displays ouput to video memory. The Kernel also includes a library of system functions accessible
  1659                                  ;       through software interrupt 58 (30h). Finally, the Kernel provides CPU and hardware interrupt handlers.
  1660                                  ;
  1661                                  ;=======================================================================================================================
  1662                                  ;=======================================================================================================================
  1663                                  ;
  1664                                  ;       Kernel Tables
  1665                                  ;
  1666                                  ;=======================================================================================================================
  1667                                  ;-----------------------------------------------------------------------------------------------------------------------
  1668                                  ;
  1669                                  ;       Global Descriptor Table                                                 @disk: 004600   @mem: 001000
  1670                                  ;
  1671                                  ;       The Global Descriptor Table (GDT) consists of eight-byte descriptors that define reserved memory areas. The
  1672                                  ;       first descriptor must be all nulls.
  1673                                  ;
  1674                                  ;       6   5         4         3         2         1         0
  1675                                  ;       3210987654321098765432109876543210987654321098765432109876543210
  1676                                  ;       ----------------------------------------------------------------
  1677                                  ;       h......hffffmmmma......ab......................bn..............n
  1678                                  ;       00000000                        all areas have base addresses below 2^24
  1679                                  ;               0100                    (0x4) 32-bit single-byte granularity
  1680                                  ;               1100                    (0xC) 32-bit 4KB granularity
  1681                                  ;                   1001                present, ring-0, selector
  1682                                  ;
  1683                                  ;       h...h   hi-order base address (bits 24-31)
  1684                                  ;       ffff    flags
  1685                                  ;       mmmm    hi-order limit (bits 16-19)
  1686                                  ;       a...a   access
  1687                                  ;       b...b   lo-order base address (bits 0-23)
  1688                                  ;       n...n   lo-order limit (bits 0-15)
  1689                                  ;
  1690                                  ;-----------------------------------------------------------------------------------------------------------------------
  1691                                  section                 gdt                                                     ;global descriptor table
  1692 00000000 0000000000000000                                dq      0000000000000000h                               ;00 required null selector
  1693 00000008 FF07001000934000                                dq      00409300100007FFh                               ;08 2KB  writable data  (GDT alias)
  1694 00000010 FF07001800934000                                dq      00409300180007FFh                               ;10 2KB  writable data  (IDT alias)
  1695 00000018 FFFF00000093CF00                                dq      00CF93000000FFFFh                               ;18 4GB  writable data  (kernel)     DS:
  1696 00000020 FF0F00800B934000                                dq      0040930B80000FFFh                               ;20 4KB  writable data  (CGA)        ES:
  1697 00000028 FF0F000000934000                                dq      0040930000000FFFh                               ;28 4KB  writable stack (Loader)     SS:
  1698 00000030 FFFF0000009B0000                                dq      00009B000000FFFFh                               ;30 64KB readable code  (loader)     CS:
  1699 00000038 FFFF0000FF9B0000                                dq      00009BFF0000FFFFh                               ;38 64KB readable code  (BIOS)
  1700 00000040 FFFF000400934000                                dq      004093000400FFFFh                               ;40 64KB writable data  (BIOS)
  1701 00000048 FF1F0020009B4000                                dq      00409B0020001FFFh                               ;48 8KB  readable code  (kernel)
  1702 00000050 7F00000F00824000                                dq      004082000F00007Fh                               ;50 80B  writable LDT   (loader)
  1703 00000058 7F00800F00894000                                dq      004089000F80007Fh                               ;58 80B  writable TSS   (loader)
  1704 00000060 7F00004700824000                                dq      004082004700007Fh                               ;60 80B  writable LDT   (console)
  1705 00000068 7F00804700894000                                dq      004089004780007Fh                               ;88 80B  writable TSS   (console)
  1706 00000070 7F00006700824000                                dq      004082006700007Fh                               ;70 80B  writable LDT   (background)
  1707 00000078 7F00806700894000                                dq      004089006780007Fh                               ;78 80B  writable TSS   (background)
  1708 00000080 FF07004800934000                                dq      00409300480007FFh                               ;80 2KB  foreground task message queue
  1709 00000088 00<rept>                                        times   2048-($-$$) db 0h                               ;zero fill to end of section
  1710                                  ;-----------------------------------------------------------------------------------------------------------------------
  1711                                  ;
  1712                                  ;       Interrupt Descriptor Table                                              @disk: 004e00   @mem: 001800
  1713                                  ;
  1714                                  ;       The Interrupt Descriptor Table (IDT) consists of one eight-byte entry (descriptor) for each interrupt. The
  1715                                  ;       descriptors here are of two kinds, interrupt gates and trap gates. The "mint" and "mtrap" macros define the
  1716                                  ;       descriptors, taking only the name of the entry point for the code handling the interrupt.
  1717                                  ;
  1718                                  ;       6   5         4         3         2         1         0
  1719                                  ;       3210987654321098765432109876543210987654321098765432109876543210
  1720                                  ;       ----------------------------------------------------------------
  1721                                  ;       h..............hPzzStttt00000000S..............Sl..............l
  1722                                  ;
  1723                                  ;       h...h   high-order offset (bits 16-31)
  1724                                  ;       P       present (0=unused interrupt)
  1725                                  ;       zz      descriptor privilege level
  1726                                  ;       S       storage segment (must be zero for IDT)
  1727                                  ;       tttt    type: 0101=task, 1110=int, 1111=trap
  1728                                  ;       S...S   handling code selector in GDT
  1729                                  ;       l...l   lo-order offset (bits 0-15)
  1730                                  ;
  1731                                  ;-----------------------------------------------------------------------------------------------------------------------
  1732                                  section                 idt                                                     ;interrupt descriptor table
  1733                                                          mint    dividebyzero                                    ;00 divide by zero
  1733                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1733 00000000 00004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1734                                                          mint    singlestep                                      ;01 single step
  1734                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1734 00000008 0C004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1735                                                          mint    nmi                                             ;02 non-maskable
  1735                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1735 00000010 18004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1736                                                          mint    break                                           ;03 break
  1736                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1736 00000018 24004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1737                                                          mint    into                                            ;04 into
  1737                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1737 00000020 30004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1738                                                          mint    bounds                                          ;05 bounds
  1738                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1738 00000028 3C004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1739                                                          mint    badopcode                                       ;06 bad op code
  1739                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1739 00000030 48004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1740                                                          mint    nocoproc                                        ;07 no coprocessor
  1740                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1740 00000038 54004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1741                                                          mint    doublefault                                     ;08 double-fault
  1741                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1741 00000040 60004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1742                                                          mint    operand                                         ;09 operand
  1742                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1742 00000048 6C004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1743                                                          mint    badtss                                          ;0a bad TSS
  1743                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1743 00000050 78004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1744                                                          mint    notpresent                                      ;0b not-present
  1744                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1744 00000058 84004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1745                                                          mint    stacklimit                                      ;0c stack limit
  1745                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1745 00000060 90004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1746                                                          mint    protection                                      ;0d general protection fault
  1746                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1746 00000068 9C004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1747                                                          mint    int14                                           ;0e (reserved)
  1747                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1747 00000070 A8004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1748                                                          mint    int15                                           ;0f (reserved)
  1748                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1748 00000078 B4004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1749                                                          mint    coproccalc                                      ;10 (reserved)
  1749                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1749 00000080 C0004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1750                                                          mint    int17                                           ;11 (reserved)
  1750                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1750 00000088 CC004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1751                                                          mint    int18                                           ;12 (reserved)
  1751                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1751 00000090 D5004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1752                                                          mint    int19                                           ;13 (reserved)
  1752                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1752 00000098 DE004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1753                                                          mint    int20                                           ;14 (reserved)
  1753                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1753 000000A0 E7004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1754                                                          mint    int21                                           ;15 (reserved)
  1754                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1754 000000A8 F0004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1755                                                          mint    int22                                           ;16 (reserved)
  1755                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1755 000000B0 F9004800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1756                                                          mint    int23                                           ;17 (reserved)
  1756                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1756 000000B8 02014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1757                                                          mint    int24                                           ;18 (reserved)
  1757                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1757 000000C0 0B014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1758                                                          mint    int25                                           ;19 (reserved)
  1758                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1758 000000C8 14014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1759                                                          mint    int26                                           ;1a (reserved)
  1759                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1759 000000D0 1D014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1760                                                          mint    int27                                           ;1b (reserved)
  1760                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1760 000000D8 26014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1761                                                          mint    int28                                           ;1c (reserved)
  1761                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1761 000000E0 2F014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1762                                                          mint    int29                                           ;1d (reserved)
  1762                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1762 000000E8 38014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1763                                                          mint    int30                                           ;1e (reserved)
  1763                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1763 000000F0 41014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1764                                                          mint    int31                                           ;1f (reserved)
  1764                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1764 000000F8 4A014800008E0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCINT << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1765                                                          mtrap   clocktick                                       ;20 IRQ0 clock tick
  1765                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1765 00000100 31054800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1766                                                          mtrap   keyboard                                        ;21 IRQ1 keyboard
  1766                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1766 00000108 BF054800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1767                                                          mtrap   iochannel                                       ;22 IRQ2 second 8259A cascade
  1767                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1767 00000110 2B094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1768                                                          mtrap   com2                                            ;23 IRQ3 com2
  1768                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1768 00000118 2E094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1769                                                          mtrap   com1                                            ;24 IRQ4 com1
  1769                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1769 00000120 31094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1770                                                          mtrap   lpt2                                            ;25 IRQ5 lpt2
  1770                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1770 00000128 34094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1771                                                          mtrap   diskette                                        ;26 IRQ6 diskette
  1771                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1771 00000130 37094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1772                                                          mtrap   lpt1                                            ;27 IRQ7 lpt1
  1772                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1772 00000138 4B094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1773                                                          mtrap   rtclock                                         ;28 IRQ8 real-time clock
  1773                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1773 00000140 4E094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1774                                                          mtrap   retrace                                         ;29 IRQ9 CGA vertical retrace
  1774                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1774 00000148 51094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1775                                                          mtrap   irq10                                           ;2a IRQA (reserved)
  1775                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1775 00000150 54094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1776                                                          mtrap   irq11                                           ;2b IRQB (reserved)
  1776                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1776 00000158 57094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1777                                                          mtrap   ps2mouse                                        ;2c IRQC ps/2 mouse
  1777                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1777 00000160 5A094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1778                                                          mtrap   coprocessor                                     ;2d IRQD coprocessor
  1778                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1778 00000168 5D094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1779                                                          mtrap   fixeddisk                                       ;2e IRQE fixed disk
  1779                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1779 00000170 60094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1780                                                          mtrap   irq15                                           ;2f IRQF (reserved)
  1780                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1780 00000178 63094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1781                                                          mtrap   svc                                             ;30 OS services
  1781                              <1> _%1 equ ($-$$) / EX86DESCLEN
  1781 00000180 74094800008F0000    <1>  dq ((?%1 >> 16) << 32) | (EX86ACCTRAP << 40) | ((EGDTOSCODE & 0FFFFh) << 16) | (?%1 & 0FFFFh)
  1782 00000188 00<rept>                                        times   2048-($-$$) db 0h                               ;zero fill to end of section
  1783                                  ;=======================================================================================================================
  1784                                  ;
  1785                                  ;       Interrupt Handlers                                                      @disk: 005600   @mem:  002000
  1786                                  ;
  1787                                  ;       Interrupt handlers are 32-bit routines that receive control either in response to events or by direct
  1788                                  ;       invocation from other kernel code. The interrupt handlers are of three basic types. CPU interrupts occur when a
  1789                                  ;       CPU exception is detected. Hardware interrupts occur when an external device (timer, keyboard, disk, etc.)
  1790                                  ;       signals the CPU on an interrupt request line (IRQ). Software interrupts occur when directly called by other code
  1791                                  ;       using the INT instruction. Each interrupt handler routine is defined by using our "menter" macro, which simply
  1792                                  ;       establishes a label defining the offset address of the entry point from the start of the kernel section. This
  1793                                  ;       label is referenced in the "mint" and "mtrap" macros found in the IDT to specify the address of the handlers.
  1794                                  ;
  1795                                  ;=======================================================================================================================
  1796                                  section                 kernel  vstart=0h                                       ;data offsets relative to 0
  1797                                                          cpu     386                                             ;allow 80386 instructions
  1798                                                          bits    32                                              ;this is 32-bit code
  1799                                  ;=======================================================================================================================
  1800                                  ;
  1801                                  ;       CPU Interrupt Handlers
  1802                                  ;
  1803                                  ;       The first 32 entries in the Interrupt Descriptor Table are reserved for use by CPU interrupts. The handling
  1804                                  ;       of these interrupts is expanded here to display the contents of registers at the time of the interrupt.
  1805                                  ;
  1806                                  ;=======================================================================================================================
  1807                                  ;-----------------------------------------------------------------------------------------------------------------------
  1808                                  ;
  1809                                  ;       INT0    Divide By Zero
  1810                                  ;
  1811                                  ;-----------------------------------------------------------------------------------------------------------------------
  1812                                                          menter  dividebyzero                                    ;divide by zero
  1812                              <1> ?%1 equ ($-$$)
  1813 00000000 6A00                                            push    0                                               ;store interrupt nbr
  1814 00000002 68[29030000]                                    push    czIntDivideByZero                               ;store message offset
  1815 00000007 E947010000                                      jmp     ReportInterrupt                                 ;report interrupt
  1816                                  ;-----------------------------------------------------------------------------------------------------------------------
  1817                                  ;
  1818                                  ;       INT1    Single Step
  1819                                  ;
  1820                                  ;-----------------------------------------------------------------------------------------------------------------------
  1821                                                          menter  singlestep                                      ;single step
  1821                              <1> ?%1 equ ($-$$)
  1822 0000000C 6A01                                            push    1                                               ;store interrupt nbr
  1823 0000000E 68[3A030000]                                    push    czIntSingleStep                                 ;store message offset
  1824 00000013 E93B010000                                      jmp     ReportInterrupt                                 ;report interrupt
  1825                                  ;-----------------------------------------------------------------------------------------------------------------------
  1826                                  ;
  1827                                  ;       INT2    Non-Maskable Interrupt
  1828                                  ;
  1829                                  ;-----------------------------------------------------------------------------------------------------------------------
  1830                                                          menter  nmi                                             ;non-maskable
  1830                              <1> ?%1 equ ($-$$)
  1831 00000018 6A02                                            push    2                                               ;store interrupt nbr
  1832 0000001A 68[46030000]                                    push    czIntNonMaskable                                ;store message offset
  1833 0000001F E92F010000                                      jmp     ReportInterrupt                                 ;report interrupt
  1834                                  ;-----------------------------------------------------------------------------------------------------------------------
  1835                                  ;
  1836                                  ;       INT3    Break
  1837                                  ;
  1838                                  ;-----------------------------------------------------------------------------------------------------------------------
  1839                                                          menter  break                                           ;break
  1839                              <1> ?%1 equ ($-$$)
  1840 00000024 6A03                                            push    3                                               ;store interrupt nbr
  1841 00000026 68[5D030000]                                    push    czIntBreak                                      ;store message offset
  1842 0000002B E923010000                                      jmp     ReportInterrupt                                 ;report interrupt
  1843                                  ;-----------------------------------------------------------------------------------------------------------------------
  1844                                  ;
  1845                                  ;       INT4    Into
  1846                                  ;
  1847                                  ;-----------------------------------------------------------------------------------------------------------------------
  1848                                                          menter  into                                            ;into
  1848                              <1> ?%1 equ ($-$$)
  1849 00000030 6A04                                            push    4                                               ;store interrupt nbr
  1850 00000032 68[63030000]                                    push    czIntInto                                       ;store message offset
  1851 00000037 E917010000                                      jmp     ReportInterrupt                                 ;report interrupt
  1852                                  ;-----------------------------------------------------------------------------------------------------------------------
  1853                                  ;
  1854                                  ;       INT5    Bounds
  1855                                  ;
  1856                                  ;-----------------------------------------------------------------------------------------------------------------------
  1857                                                          menter  bounds                                          ;bounds
  1857                              <1> ?%1 equ ($-$$)
  1858 0000003C 6A05                                            push    5                                               ;store interrupt nbr
  1859 0000003E 68[68030000]                                    push    czIntBounds                                     ;store message offset
  1860 00000043 E90B010000                                      jmp     ReportInterrupt                                 ;report interrupt
  1861                                  ;-----------------------------------------------------------------------------------------------------------------------
  1862                                  ;
  1863                                  ;       INT6    Bad Operation Code
  1864                                  ;
  1865                                  ;-----------------------------------------------------------------------------------------------------------------------
  1866                                                          menter  badopcode                                       ;bad opcode interrupt
  1866                              <1> ?%1 equ ($-$$)
  1867 00000048 6A06                                            push    6                                               ;store interrupt nbr
  1868 0000004A 68[6F030000]                                    push    czIntBadOpCode                                  ;store message offset
  1869 0000004F E9FF000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1870                                  ;-----------------------------------------------------------------------------------------------------------------------
  1871                                  ;
  1872                                  ;       INT7    No Coprocessor
  1873                                  ;
  1874                                  ;-----------------------------------------------------------------------------------------------------------------------
  1875                                                          menter  nocoproc                                        ;no coprocessor interrupt
  1875                              <1> ?%1 equ ($-$$)
  1876 00000054 6A07                                            push    7                                               ;store interrupt nbr
  1877 00000056 68[82030000]                                    push    czIntNoCoprocessor                              ;store message offset
  1878 0000005B E9F3000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1879                                  ;-----------------------------------------------------------------------------------------------------------------------
  1880                                  ;
  1881                                  ;       INT8    Double Fault
  1882                                  ;
  1883                                  ;-----------------------------------------------------------------------------------------------------------------------
  1884                                                          menter  doublefault                                     ;doublefault interrupt
  1884                              <1> ?%1 equ ($-$$)
  1885 00000060 6A08                                            push    8                                               ;store interrupt nbr
  1886 00000062 68[91030000]                                    push    czIntDoubleFault                                ;store message offset
  1887 00000067 E9E7000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1888                                  ;-----------------------------------------------------------------------------------------------------------------------
  1889                                  ;
  1890                                  ;       INT9    Operand
  1891                                  ;
  1892                                  ;-----------------------------------------------------------------------------------------------------------------------
  1893                                                          menter  operand                                         ;operand interrupt
  1893                              <1> ?%1 equ ($-$$)
  1894 0000006C 6A09                                            push    9                                               ;store interrupt nbr
  1895 0000006E 68[9E030000]                                    push    czIntOperand                                    ;store message offset
  1896 00000073 E9DB000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1897                                  ;-----------------------------------------------------------------------------------------------------------------------
  1898                                  ;
  1899                                  ;       INT10   Bad Task State Segment
  1900                                  ;
  1901                                  ;-----------------------------------------------------------------------------------------------------------------------
  1902                                                          menter  badtss                                          ;bad TSS interrupt
  1902                              <1> ?%1 equ ($-$$)
  1903 00000078 6A0A                                            push    10                                              ;store interrupt nbr
  1904 0000007A 68[A6030000]                                    push    czIntBadTSS                                     ;store message offset
  1905 0000007F E9CF000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1906                                  ;-----------------------------------------------------------------------------------------------------------------------
  1907                                  ;
  1908                                  ;       INT11   Not Present
  1909                                  ;
  1910                                  ;-----------------------------------------------------------------------------------------------------------------------
  1911                                                          menter  notpresent                                      ;not present interrupt
  1911                              <1> ?%1 equ ($-$$)
  1912 00000084 6A0B                                            push    11                                              ;store interrupt nbr
  1913 00000086 68[BD030000]                                    push    czIntNotPresent                                 ;store message offset
  1914 0000008B E9C3000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1915                                  ;-----------------------------------------------------------------------------------------------------------------------
  1916                                  ;
  1917                                  ;       INT12   Stack Limit
  1918                                  ;
  1919                                  ;-----------------------------------------------------------------------------------------------------------------------
  1920                                                          menter  stacklimit                                      ;stack limit interrupt
  1920                              <1> ?%1 equ ($-$$)
  1921 00000090 6A0C                                            push    12                                              ;store interrupt nbr
  1922 00000092 68[C9030000]                                    push    czIntStackLimit                                 ;store message offset
  1923 00000097 E9B7000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1924                                  ;-----------------------------------------------------------------------------------------------------------------------
  1925                                  ;
  1926                                  ;       INT13   General Protection Fault
  1927                                  ;
  1928                                  ;-----------------------------------------------------------------------------------------------------------------------
  1929                                                          menter  protection                                      ;protection fault interrupt
  1929                              <1> ?%1 equ ($-$$)
  1930 0000009C 6A0D                                            push    13                                              ;store interrupt nbr
  1931 0000009E 68[D5030000]                                    push    czIntProtection                                 ;store message offset
  1932 000000A3 E9AB000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1933                                  ;-----------------------------------------------------------------------------------------------------------------------
  1934                                  ;
  1935                                  ;       INT14   Reserved
  1936                                  ;
  1937                                  ;-----------------------------------------------------------------------------------------------------------------------
  1938                                                          menter  int14                                           ;(reserved)
  1938                              <1> ?%1 equ ($-$$)
  1939 000000A8 6A0E                                            push    14                                              ;store interrupt nbr
  1940 000000AA 68[06040000]                                    push    czIntReserved                                   ;store message offset
  1941 000000AF E99F000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1942                                  ;-----------------------------------------------------------------------------------------------------------------------
  1943                                  ;
  1944                                  ;       INT15   Reserved
  1945                                  ;
  1946                                  ;-----------------------------------------------------------------------------------------------------------------------
  1947                                                          menter  int15                                           ;(reserved)
  1947                              <1> ?%1 equ ($-$$)
  1948 000000B4 6A0F                                            push    15                                              ;store interrupt nbr
  1949 000000B6 68[06040000]                                    push    czIntReserved                                   ;store message offset
  1950 000000BB E993000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1951                                  ;-----------------------------------------------------------------------------------------------------------------------
  1952                                  ;
  1953                                  ;       INT16   Coprocessor Calculation
  1954                                  ;
  1955                                  ;-----------------------------------------------------------------------------------------------------------------------
  1956                                                          menter  coproccalc                                      ;coprocessor calculation
  1956                              <1> ?%1 equ ($-$$)
  1957 000000C0 6A10                                            push    16                                              ;store interrupt nbr
  1958 000000C2 68[EE030000]                                    push    czIntCoprocessorCalc                            ;store message offset
  1959 000000C7 E987000000                                      jmp     ReportInterrupt                                 ;report interrupt
  1960                                  ;-----------------------------------------------------------------------------------------------------------------------
  1961                                  ;
  1962                                  ;       INT17   Reserved
  1963                                  ;
  1964                                  ;-----------------------------------------------------------------------------------------------------------------------
  1965                                                          menter  int17                                           ;(reserved)
  1965                              <1> ?%1 equ ($-$$)
  1966 000000CC 6A11                                            push    17                                              ;store interrupt nbr
  1967 000000CE 68[06040000]                                    push    czIntReserved                                   ;store message offset
  1968 000000D3 EB7E                                            jmp     ReportInterrupt                                 ;report interrupt
  1969                                  ;-----------------------------------------------------------------------------------------------------------------------
  1970                                  ;
  1971                                  ;       INT18   Reserved
  1972                                  ;
  1973                                  ;-----------------------------------------------------------------------------------------------------------------------
  1974                                                          menter  int18                                           ;(reserved)
  1974                              <1> ?%1 equ ($-$$)
  1975 000000D5 6A12                                            push    18                                              ;store interrupt nbr
  1976 000000D7 68[06040000]                                    push    czIntReserved                                   ;store message offset
  1977 000000DC EB75                                            jmp     ReportInterrupt                                 ;report interrupt
  1978                                  ;-----------------------------------------------------------------------------------------------------------------------
  1979                                  ;
  1980                                  ;       INT19   Reserved
  1981                                  ;
  1982                                  ;-----------------------------------------------------------------------------------------------------------------------
  1983                                                          menter  int19                                           ;(reserved)
  1983                              <1> ?%1 equ ($-$$)
  1984 000000DE 6A13                                            push    19                                              ;store interrupt nbr
  1985 000000E0 68[06040000]                                    push    czIntReserved                                   ;store message offset
  1986 000000E5 EB6C                                            jmp     ReportInterrupt                                 ;report interrupt
  1987                                  ;-----------------------------------------------------------------------------------------------------------------------
  1988                                  ;
  1989                                  ;       INT20   Reserved
  1990                                  ;
  1991                                  ;-----------------------------------------------------------------------------------------------------------------------
  1992                                                          menter  int20                                           ;(reserved)
  1992                              <1> ?%1 equ ($-$$)
  1993 000000E7 6A14                                            push    20                                              ;store interrupt nbr
  1994 000000E9 68[06040000]                                    push    czIntReserved                                   ;store message offset
  1995 000000EE EB63                                            jmp     ReportInterrupt                                 ;report interrupt
  1996                                  ;-----------------------------------------------------------------------------------------------------------------------
  1997                                  ;
  1998                                  ;       INT21   Reserved
  1999                                  ;
  2000                                  ;-----------------------------------------------------------------------------------------------------------------------
  2001                                                          menter  int21                                           ;(reserved)
  2001                              <1> ?%1 equ ($-$$)
  2002 000000F0 6A15                                            push    21                                              ;store interrupt nbr
  2003 000000F2 68[06040000]                                    push    czIntReserved                                   ;store message offset
  2004 000000F7 EB5A                                            jmp     ReportInterrupt                                 ;report interrupt
  2005                                  ;-----------------------------------------------------------------------------------------------------------------------
  2006                                  ;
  2007                                  ;       INT22   Reserved
  2008                                  ;
  2009                                  ;-----------------------------------------------------------------------------------------------------------------------
  2010                                                          menter  int22                                           ;(reserved)
  2010                              <1> ?%1 equ ($-$$)
  2011 000000F9 6A16                                            push    22                                              ;store interrupt nbr
  2012 000000FB 68[06040000]                                    push    czIntReserved                                   ;store message offset
  2013 00000100 EB51                                            jmp     ReportInterrupt                                 ;report interrupt
  2014                                  ;-----------------------------------------------------------------------------------------------------------------------
  2015                                  ;
  2016                                  ;       INT23   Reserved
  2017                                  ;
  2018                                  ;-----------------------------------------------------------------------------------------------------------------------
  2019                                                          menter  int23                                           ;(reserved)
  2019                              <1> ?%1 equ ($-$$)
  2020 00000102 6A17                                            push    23                                              ;store interrupt nbr
  2021 00000104 68[06040000]                                    push    czIntReserved                                   ;store message offset
  2022 00000109 EB48                                            jmp     ReportInterrupt                                 ;report interrupt
  2023                                  ;-----------------------------------------------------------------------------------------------------------------------
  2024                                  ;
  2025                                  ;       INT24   Reserved
  2026                                  ;
  2027                                  ;-----------------------------------------------------------------------------------------------------------------------
  2028                                                          menter  int24                                           ;(reserved)
  2028                              <1> ?%1 equ ($-$$)
  2029 0000010B 6A18                                            push    24                                              ;store interrupt nbr
  2030 0000010D 68[06040000]                                    push    czIntReserved                                   ;store message offset
  2031 00000112 EB3F                                            jmp     ReportInterrupt                                 ;report interrupt
  2032                                  ;-----------------------------------------------------------------------------------------------------------------------
  2033                                  ;
  2034                                  ;       INT25   Reserved
  2035                                  ;
  2036                                  ;-----------------------------------------------------------------------------------------------------------------------
  2037                                                          menter  int25                                           ;(reserved)
  2037                              <1> ?%1 equ ($-$$)
  2038 00000114 6A19                                            push    25                                              ;store interrupt nbr
  2039 00000116 68[06040000]                                    push    czIntReserved                                   ;store message offset
  2040 0000011B EB36                                            jmp     ReportInterrupt                                 ;report interrupt
  2041                                  ;-----------------------------------------------------------------------------------------------------------------------
  2042                                  ;
  2043                                  ;       INT26   Reserved
  2044                                  ;
  2045                                  ;-----------------------------------------------------------------------------------------------------------------------
  2046                                                          menter  int26                                           ;(reserved)
  2046                              <1> ?%1 equ ($-$$)
  2047 0000011D 6A1A                                            push    26                                              ;store interrupt nbr
  2048 0000011F 68[06040000]                                    push    czIntReserved                                   ;store message offset
  2049 00000124 EB2D                                            jmp     ReportInterrupt                                 ;report interrupt
  2050                                  ;-----------------------------------------------------------------------------------------------------------------------
  2051                                  ;
  2052                                  ;       INT27   Reserved
  2053                                  ;
  2054                                  ;-----------------------------------------------------------------------------------------------------------------------
  2055                                                          menter  int27                                           ;(reserved)
  2055                              <1> ?%1 equ ($-$$)
  2056 00000126 6A1B                                            push    27                                              ;store interrupt nbr
  2057 00000128 68[06040000]                                    push    czIntReserved                                   ;store message offset
  2058 0000012D EB24                                            jmp     ReportInterrupt                                 ;report interrupt
  2059                                  ;-----------------------------------------------------------------------------------------------------------------------
  2060                                  ;
  2061                                  ;       INT28   Reserved
  2062                                  ;
  2063                                  ;-----------------------------------------------------------------------------------------------------------------------
  2064                                                          menter  int28                                           ;(reserved)
  2064                              <1> ?%1 equ ($-$$)
  2065 0000012F 6A1C                                            push    28                                              ;store interrupt nbr
  2066 00000131 68[06040000]                                    push    czIntReserved                                   ;store message offset
  2067 00000136 EB1B                                            jmp     ReportInterrupt                                 ;report interrupt
  2068                                  ;-----------------------------------------------------------------------------------------------------------------------
  2069                                  ;
  2070                                  ;       INT29   Reserved
  2071                                  ;
  2072                                  ;-----------------------------------------------------------------------------------------------------------------------
  2073                                                          menter  int29                                           ;(reserved)
  2073                              <1> ?%1 equ ($-$$)
  2074 00000138 6A1D                                            push    29                                              ;store interrupt nbr
  2075 0000013A 68[06040000]                                    push    czIntReserved                                   ;store message offset
  2076 0000013F EB12                                            jmp     ReportInterrupt                                 ;report interrupt
  2077                                  ;-----------------------------------------------------------------------------------------------------------------------
  2078                                  ;
  2079                                  ;       INT30   Reserved
  2080                                  ;
  2081                                  ;-----------------------------------------------------------------------------------------------------------------------
  2082                                                          menter  int30                                           ;(reserved)
  2082                              <1> ?%1 equ ($-$$)
  2083 00000141 6A1E                                            push    30                                              ;store interrupt nbr
  2084 00000143 68[06040000]                                    push    czIntReserved                                   ;store message offset
  2085 00000148 EB09                                            jmp     ReportInterrupt                                 ;report interrupt
  2086                                  ;-----------------------------------------------------------------------------------------------------------------------
  2087                                  ;
  2088                                  ;       INT31   Reserved
  2089                                  ;
  2090                                  ;-----------------------------------------------------------------------------------------------------------------------
  2091                                                          menter  int31                                           ;(reserved)
  2091                              <1> ?%1 equ ($-$$)
  2092 0000014A 6A1F                                            push    31                                              ;store interrupt nbr
  2093 0000014C 68[06040000]                                    push    czIntReserved                                   ;store message offset
  2094 00000151 EB00                                            jmp     ReportInterrupt                                 ;report interrupt
  2095                                  ;-----------------------------------------------------------------------------------------------------------------------
  2096                                  ;
  2097                                  ;       Routine:        ReportInterrupt
  2098                                  ;
  2099                                  ;       Description:    This routine will be used to respond to processor interrupts that are not otherwise handled.
  2100                                  ;                       At this stage, we simply restore the stack and return from the interrupt.
  2101                                  ;
  2102                                  ;       In:             [esp+16]        eflags                                  stored by interrupt call
  2103                                  ;                       [esp+12]        cs                                      stored by interrupt call
  2104                                  ;                       [esp+8]         eip                                     stored by interrupt call
  2105                                  ;                       [esp+4]         interrupt number (0-31)                 stored by push instruction
  2106                                  ;                       [esp+0]         error message address                   stored by push instructions
  2107                                  ;
  2108                                  ;       Out:            N/A             This routine does not exit.
  2109                                  ;
  2110                                  ;-----------------------------------------------------------------------------------------------------------------------
  2111 00000153 1E                      ReportInterrupt         push    ds                                              ;save DS at time of interrupt
  2112 00000154 06                                              push    es                                              ;save ES at time of interrupt
  2113 00000155 60                                              pushad                                                  ;save EAX,ECX,EDX,EBX,EBP,ESP,ESI,EDI
  2114 00000156 89E5                                            mov     ebp,esp                                         ;ebp --> [EDI]
  2115                                  ;
  2116                                  ;       Addressability to registers at the time of the interrupt is now established as:
  2117                                  ;
  2118                                  ;                       [ebp+56]        eflags
  2119                                  ;                       [ebp+52]        cs
  2120                                  ;                       [ebp+48]        eip
  2121                                  ;                       [ebp+44]        interrupt number (0-31)
  2122                                  ;                       [ebp+40]        error message address
  2123                                  ;                       [ebp+36]        ds
  2124                                  ;                       [ebp+32]        es
  2125                                  ;                       [ebp+28]        eax
  2126                                  ;                       [ebp+24]        ecx
  2127                                  ;                       [ebp+20]        edx
  2128                                  ;                       [ebp+16]        ebx
  2129                                  ;                       [ebp+12]        esp
  2130                                  ;                       [ebp+8]         ebp
  2131                                  ;                       [ebp+4]         esi
  2132                                  ;                       [ebp+0]         edi
  2133                                  ;
  2134 00000158 0E                                              push    cs                                              ;load code selector ...
  2135 00000159 1F                                              pop     ds                                              ;... into DS
  2136 0000015A 6A20                                            push    EGDTCGA                                         ;load CGA memory selector ...
  2137 0000015C 07                                              pop     es                                              ;... into ES
  2138                                  ;
  2139                                  ;       Display the interrupt report boundary box
  2140                                  ;
  2141 0000015D B10D                                            mov     cl,13                                           ;column
  2142 0000015F B506                                            mov     ch,6                                            ;row
  2143 00000161 B232                                            mov     dl,50                                           ;width
  2144 00000163 B608                                            mov     dh,8                                            ;height
  2145 00000165 B707                                            mov     bh,07h                                          ;attribute
  2146 00000167 E84C030000                                      call    DrawTextDialogBox                               ;draw text dialog box
  2147                                  ;
  2148                                  ;       Display the report header
  2149                                  ;
  2150 0000016C B10F                                            mov     cl,15                                           ;column
  2151 0000016E B507                                            mov     ch,7                                            ;row
  2152 00000170 BE[0F040000]                                    mov     esi,czIntHeader                                 ;interrupt message header
  2153 00000175 E8BD110000                                      call    SetConsoleString                                ;draw text string
  2154                                  ;
  2155                                  ;       Display the interrupt description label
  2156                                  ;
  2157 0000017A B10F                                            mov     cl,15                                           ;column
  2158 0000017C B508                                            mov     ch,8                                            ;row
  2159 0000017E BE[3E040000]                                    mov     esi,czIntLabel                                  ;interrupt message description lead
  2160 00000183 E8AF110000                                      call    SetConsoleString                                ;draw text string
  2161                                  ;
  2162                                  ;       Display the interrupt number
  2163                                  ;
  2164 00000188 8B452C                                          mov     eax,[ebp+44]                                    ;interrupt number
  2165 0000018B B11A                                            mov     cl,26                                           ;column
  2166 0000018D B508                                            mov     ch,8                                            ;row
  2167 0000018F E84C0E0000                                      call    PutConsoleHexByte                               ;draw ASCII hex byte
  2168                                  ;
  2169                                  ;       Display the interrupt name
  2170                                  ;
  2171 00000194 B11D                                            mov     cl,29                                           ;column
  2172 00000196 B508                                            mov     ch,8                                            ;row
  2173 00000198 8B7528                                          mov     esi,[ebp+40]                                    ;interrupt-specific message
  2174 0000019B E897110000                                      call    SetConsoleString                                ;display interrupt description
  2175                                  ;
  2176                                  ;       Display the register values header
  2177                                  ;
  2178 000001A0 B10F                                            mov     cl,15                                           ;column
  2179 000001A2 B50A                                            mov     ch,10                                           ;row
  2180 000001A4 BE[4A040000]                                    mov     esi,czIntRegsHeader                             ;interrupt registers header
  2181 000001A9 E889110000                                      call    SetConsoleString                                ;draw text string
  2182                                  ;
  2183                                  ;       Display the EAX register label and value
  2184                                  ;
  2185 000001AE B10F                                            mov     cl,15                                           ;column
  2186 000001B0 B50B                                            mov     ch,11                                           ;row
  2187 000001B2 BE[72040000]                                    mov     esi,czIntEAX                                    ;register EAX label
  2188 000001B7 E87B110000                                      call    SetConsoleString                                ;draw label
  2189 000001BC 8B451C                                          mov     eax,[ebp+28]                                    ;EAX value at interrupt
  2190 000001BF B113                                            mov     cl,19                                           ;column
  2191 000001C1 B50B                                            mov     ch,11                                           ;row
  2192 000001C3 E83E0E0000                                      call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2193                                  ;
  2194                                  ;       Display the ECX register label and value
  2195                                  ;
  2196 000001C8 B10F                                            mov     cl,15                                           ;column
  2197 000001CA B50C                                            mov     ch,12                                           ;row
  2198 000001CC BE[77040000]                                    mov     esi,czIntECX                                    ;label
  2199 000001D1 E861110000                                      call    SetConsoleString                                ;draw label
  2200 000001D6 8B4518                                          mov     eax,[ebp+24]                                    ;ECX value at interrupt
  2201 000001D9 B113                                            mov     cl,19                                           ;column
  2202 000001DB B50C                                            mov     ch,12                                           ;row
  2203 000001DD E8240E0000                                      call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2204                                  ;
  2205                                  ;       Display the EDX register label and value
  2206                                  ;
  2207 000001E2 B10F                                            mov     cl,15                                           ;column
  2208 000001E4 B50D                                            mov     ch,13                                           ;row
  2209 000001E6 BE[7C040000]                                    mov     esi,czIntEDX                                    ;label
  2210 000001EB E847110000                                      call    SetConsoleString                                ;draw label
  2211 000001F0 8B4514                                          mov     eax,[ebp+20]                                    ;EDX value at interrupt
  2212 000001F3 B113                                            mov     cl,19                                           ;column
  2213 000001F5 B50D                                            mov     ch,13                                           ;row
  2214 000001F7 E80A0E0000                                      call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2215                                  ;
  2216                                  ;       Display the EBX register label and value
  2217                                  ;
  2218 000001FC B10F                                            mov     cl,15                                           ;column
  2219 000001FE B50E                                            mov     ch,14                                           ;row
  2220 00000200 BE[81040000]                                    mov     esi,czIntEBX                                    ;label
  2221 00000205 E82D110000                                      call    SetConsoleString                                ;draw label
  2222 0000020A 8B4510                                          mov     eax,[ebp+16]                                    ;EBX value at interrupt
  2223 0000020D B113                                            mov     cl,19                                           ;column
  2224 0000020F B50E                                            mov     ch,14                                           ;row
  2225 00000211 E8F00D0000                                      call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2226                                  ;
  2227                                  ;       Display the ESI register label and value
  2228                                  ;
  2229 00000216 B11D                                            mov     cl,29                                           ;column
  2230 00000218 B50B                                            mov     ch,11                                           ;row
  2231 0000021A BE[86040000]                                    mov     esi,czIntESI                                    ;label
  2232 0000021F E813110000                                      call    SetConsoleString                                ;draw label
  2233 00000224 8B4504                                          mov     eax,[ebp+4]                                     ;ESI
  2234 00000227 B121                                            mov     cl,33                                           ;column
  2235 00000229 B50B                                            mov     ch,11                                           ;row
  2236 0000022B E8D60D0000                                      call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2237                                  ;
  2238                                  ;       Display the EDI register label and value
  2239                                  ;
  2240 00000230 B11D                                            mov     cl,29                                           ;column
  2241 00000232 B50C                                            mov     ch,12                                           ;row
  2242 00000234 BE[8B040000]                                    mov     esi,czIntEDI                                    ;label
  2243 00000239 E8F9100000                                      call    SetConsoleString                                ;draw label
  2244 0000023E 8B4500                                          mov     eax,[ebp+0]                                     ;EDI
  2245 00000241 B121                                            mov     cl,33                                           ;column
  2246 00000243 B50C                                            mov     ch,12                                           ;row
  2247 00000245 E8BC0D0000                                      call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2248                                  ;
  2249                                  ;       Display the EBP register label and value
  2250                                  ;
  2251 0000024A B11D                                            mov     cl,29                                           ;column
  2252 0000024C B50D                                            mov     ch,13                                           ;row
  2253 0000024E BE[90040000]                                    mov     esi,czIntEBP                                    ;label
  2254 00000253 E8DF100000                                      call    SetConsoleString                                ;draw label
  2255 00000258 8B4508                                          mov     eax,[ebp+8]                                     ;EBP
  2256 0000025B B121                                            mov     cl,33                                           ;column
  2257 0000025D B50D                                            mov     ch,13                                           ;row
  2258 0000025F E8A20D0000                                      call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2259                                  ;
  2260                                  ;       Display the DS register label and value
  2261                                  ;
  2262 00000264 B12A                                            mov     cl,42                                           ;column
  2263 00000266 B50B                                            mov     ch,11                                           ;row
  2264 00000268 BE[9A040000]                                    mov     esi,czIntDS                                     ;label
  2265 0000026D E8C5100000                                      call    SetConsoleString                                ;draw label
  2266 00000272 31C0                                            xor     eax,eax                                         ;zero register
  2267 00000274 668B4524                                        mov     ax,[ebp+36]                                     ;DS
  2268 00000278 B12E                                            mov     cl,46                                           ;column
  2269 0000027A B50B                                            mov     ch,11                                           ;row
  2270 0000027C E8950D0000                                      call    PutConsoleHexWord                               ;draw ASCII hex word
  2271                                  ;
  2272                                  ;       Display the ES register label and value
  2273                                  ;
  2274 00000281 B12A                                            mov     cl,42                                           ;column
  2275 00000283 B50C                                            mov     ch,12                                           ;row
  2276 00000285 BE[9F040000]                                    mov     esi,czIntES                                     ;label
  2277 0000028A E8A8100000                                      call    SetConsoleString                                ;draw label
  2278 0000028F 31C0                                            xor     eax,eax                                         ;zero register
  2279 00000291 668B4520                                        mov     ax,[ebp+32]                                     ;ES
  2280 00000295 B12E                                            mov     cl,46                                           ;column
  2281 00000297 B50C                                            mov     ch,12                                           ;row
  2282 00000299 E8780D0000                                      call    PutConsoleHexWord                               ;draw ASCII hex word
  2283                                  ;
  2284                                  ;       Display the SS register label and value
  2285                                  ;
  2286 0000029E B12A                                            mov     cl,42                                           ;column
  2287 000002A0 B50D                                            mov     ch,13                                           ;row
  2288 000002A2 BE[A4040000]                                    mov     esi,czIntSS                                     ;label
  2289 000002A7 E88B100000                                      call    SetConsoleString                                ;draw label
  2290 000002AC 31C0                                            xor     eax,eax                                         ;zero register
  2291 000002AE 668CD0                                          mov     ax,ss                                           ;SS
  2292 000002B1 B12E                                            mov     cl,46                                           ;column
  2293 000002B3 B50D                                            mov     ch,13                                           ;row
  2294 000002B5 E85C0D0000                                      call    PutConsoleHexWord                               ;draw ASCII hex word
  2295                                  ;
  2296                                  ;       Display the CS register lable and value
  2297                                  ;
  2298 000002BA B12A                                            mov     cl,42                                           ;column
  2299 000002BC B50E                                            mov     ch,14                                           ;row
  2300 000002BE BE[A9040000]                                    mov     esi,czIntCS                                     ;label
  2301 000002C3 E86F100000                                      call    SetConsoleString                                ;draw label
  2302 000002C8 31C0                                            xor     eax,eax                                         ;zero register
  2303 000002CA 668B4534                                        mov     ax,[ebp+52]                                     ;CS
  2304 000002CE B12E                                            mov     cl,46                                           ;column
  2305 000002D0 B50E                                            mov     ch,14                                           ;row
  2306 000002D2 E83F0D0000                                      call    PutConsoleHexWord                               ;draw ASCII hex word
  2307                                  ;
  2308                                  ;       Display the EFLAGS register label and value
  2309                                  ;
  2310 000002D7 B133                                            mov     cl,51                                           ;column
  2311 000002D9 B50B                                            mov     ch,11                                           ;row
  2312 000002DB BE[AE040000]                                    mov     esi,czIntEFLAGS                                 ;label
  2313 000002E0 E852100000                                      call    SetConsoleString                                ;draw label
  2314 000002E5 8B4538                                          mov     eax,[ebp+56]                                    ;EFLAGS
  2315 000002E8 B137                                            mov     cl,55                                           ;column
  2316 000002EA B50B                                            mov     ch,11                                           ;row
  2317 000002EC E8150D0000                                      call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2318                                  ;
  2319                                  ;       Display the ESP register label and value
  2320                                  ;
  2321 000002F1 B133                                            mov     cl,51                                           ;column
  2322 000002F3 B50D                                            mov     ch,13                                           ;row
  2323 000002F5 BE[95040000]                                    mov     esi,czIntESP                                    ;label
  2324 000002FA E838100000                                      call    SetConsoleString                                ;draw label
  2325 000002FF 8B450C                                          mov     eax,[ebp+12]                                    ;ESP
  2326 00000302 B137                                            mov     cl,55                                           ;column
  2327 00000304 B50D                                            mov     ch,13                                           ;row
  2328 00000306 E8FB0C0000                                      call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2329                                  ;
  2330                                  ;       Display the EIP register label and value
  2331                                  ;
  2332 0000030B B133                                            mov     cl,51                                           ;column
  2333 0000030D B50E                                            mov     ch,14                                           ;row
  2334 0000030F BE[B3040000]                                    mov     esi,czIntEIP                                    ;label
  2335 00000314 E81E100000                                      call    SetConsoleString                                ;draw label
  2336 00000319 8B4530                                          mov     eax,[ebp+48]                                    ;EIP
  2337 0000031C B137                                            mov     cl,55                                           ;column
  2338 0000031E B50E                                            mov     ch,14                                           ;row
  2339 00000320 E8E10C0000                                      call    PutConsoleHexDword                              ;draw ASCII hex doubleword
  2340                                  ;
  2341                                  ;       Halt and loop until reset
  2342                                  ;
  2343 00000325 FB                      .10                     sti                                                     ;enable maskable interrupts
  2344 00000326 F4                                              hlt                                                     ;halt processor
  2345 00000327 EBFC                                            jmp     .10                                             ;resume on interrupt
  2346                                  ;-----------------------------------------------------------------------------------------------------------------------
  2347                                  ;
  2348                                  ;       Processor Interrupt Name Strings
  2349                                  ;
  2350                                  ;-----------------------------------------------------------------------------------------------------------------------
  2351 00000329 4469766973696F6E20-     czIntDivideByZero       db      "Division by zero",0
  2351 00000332 6279207A65726F00   
  2352 0000033A 53696E676C65207374-     czIntSingleStep         db      "Single step",0
  2352 00000343 657000             
  2353 00000346 4E6F6E2D6D61736B61-     czIntNonMaskable        db      "Non-maskable interrupt",0
  2353 0000034F 626C6520696E746572-
  2353 00000358 7275707400         
  2354 0000035D 427265616B00            czIntBreak              db      "Break",0
  2355 00000363 496E746F00              czIntInto               db      "Into",0
  2356 00000368 426F756E647300          czIntBounds             db      "Bounds",0
  2357 0000036F 426164204F70657261-     czIntBadOpCode          db      "Bad Operation Code",0
  2357 00000378 74696F6E20436F6465-
  2357 00000381 00                 
  2358 00000382 4E6F20436F70726F63-     czIntNoCoprocessor      db      "No Coprocessor",0
  2358 0000038B 6573736F7200       
  2359 00000391 446F75626C65204661-     czIntDoubleFault        db      "Double Fault",0
  2359 0000039A 756C7400           
  2360 0000039E 4F706572616E6400        czIntOperand            db      "Operand",0
  2361 000003A6 426164205461736B20-     czIntBadTSS             db      "Bad Task State Segment",0
  2361 000003AF 537461746520536567-
  2361 000003B8 6D656E7400         
  2362 000003BD 4E6F74205072657365-     czIntNotPresent         db      "Not Present",0
  2362 000003C6 6E7400             
  2363 000003C9 537461636B204C696D-     czIntStackLimit         db      "Stack Limit",0
  2363 000003D2 697400             
  2364 000003D5 47656E6572616C2050-     czIntProtection         db      "General Protection Fault",0
  2364 000003DE 726F74656374696F6E-
  2364 000003E7 204661756C7400     
  2365 000003EE 436F70726F63657373-     czIntCoprocessorCalc    db      "Coprocessor Calculation",0
  2365 000003F7 6F722043616C63756C-
  2365 00000400 6174696F6E00       
  2366 00000406 526573657276656400      czIntReserved           db      "Reserved",0
  2367                                  ;-----------------------------------------------------------------------------------------------------------------------
  2368                                  ;
  2369                                  ;       Processor Interrupt Handling Strings
  2370                                  ;
  2371                                  ;-----------------------------------------------------------------------------------------------------------------------
  2372 0000040F 416E20756E68616E64-     czIntHeader             db      "An unhandled processor interrupt has occurred:",0
  2372 00000418 6C65642070726F6365-
  2372 00000421 73736F7220696E7465-
  2372 0000042A 727275707420686173-
  2372 00000433 206F63637572726564-
  2372 0000043C 3A00               
  2373 0000043E 496E74657272757074-     czIntLabel              db      "Interrupt #",0
  2373 00000447 202300             
  2374 0000044A 526567697374657273-     czIntRegsHeader         db      "Registers at the time of the interrupt:",0
  2374 00000453 206174207468652074-
  2374 0000045C 696D65206F66207468-
  2374 00000465 6520696E7465727275-
  2374 0000046E 70743A00           
  2375 00000472 4541583A00              czIntEAX                db      "EAX:",0
  2376 00000477 4543583A00              czIntECX                db      "ECX:",0
  2377 0000047C 4544583A00              czIntEDX                db      "EDX:",0
  2378 00000481 4542583A00              czIntEBX                db      "EBX:",0
  2379 00000486 4553493A00              czIntESI                db      "ESI:",0
  2380 0000048B 4544493A00              czIntEDI                db      "EDI:",0
  2381 00000490 4542503A00              czIntEBP                db      "EBP:",0
  2382 00000495 4553503A00              czIntESP                db      "ESP:",0
  2383 0000049A 2044533A00              czIntDS                 db      " DS:",0
  2384 0000049F 2045533A00              czIntES                 db      " ES:",0
  2385 000004A4 2053533A00              czIntSS                 db      " SS:",0
  2386 000004A9 2043533A00              czIntCS                 db      " CS:",0
  2387 000004AE 464C473A00              czIntEFLAGS             db      "FLG:",0
  2388 000004B3 4549503A00              czIntEIP                db      "EIP:",0
  2389                                  ;-----------------------------------------------------------------------------------------------------------------------
  2390                                  ;
  2391                                  ;       Routine:        DrawTextDialogBox
  2392                                  ;
  2393                                  ;       Description:    This routine opens a text-mode dialog box with an ASCII border.
  2394                                  ;
  2395                                  ;       In:             CL      upper left column (0-79)
  2396                                  ;                       CH      upper left row (0-24)
  2397                                  ;                       DL      column width, excluding border
  2398                                  ;                       DH      row height, excluding border
  2399                                  ;                       BH      color attribute
  2400                                  ;
  2401                                  ;-----------------------------------------------------------------------------------------------------------------------
  2402 000004B8 51                      DrawTextDialogBox       push    ecx                                             ;save non-volatile regs
  2403 000004B9 56                                              push    esi                                             ;
  2404 000004BA 57                                              push    edi                                             ;
  2405 000004BB 06                                              push    es                                              ;
  2406 000004BC 6A20                                            push    EGDTCGA                                         ;load CGA selector ...
  2407 000004BE 07                                              pop     es                                              ;... into ES
  2408                                  ;
  2409                                  ;       Compute target display offset
  2410                                  ;
  2411 000004BF 31C0                                            xor     eax,eax                                         ;zero register
  2412 000004C1 88E8                                            mov     al,ch                                           ;row
  2413 000004C3 B4A0                                            mov     ah,ECONROWBYTES                                 ;mulitplicand
  2414 000004C5 F6E4                                            mul     ah                                              ;row offset
  2415 000004C7 00C8                                            add     al,cl                                           ;add column
  2416 000004C9 80D400                                          adc     ah,0                                            ;add overflow
  2417 000004CC 00C8                                            add     al,cl                                           ;add column
  2418 000004CE 80D400                                          adc     ah,0                                            ;add overflow
  2419 000004D1 89C7                                            mov     edi,eax                                         ;target row offset
  2420                                  ;
  2421                                  ;       Display top border row
  2422                                  ;
  2423 000004D3 57                                              push    edi                                             ;save target row offset
  2424 000004D4 88FC                                            mov     ah,bh                                           ;attribute
  2425 000004D6 B0DA                                            mov     al,EASCIIBORDSGLUPRLFT                          ;upper-left single border
  2426 000004D8 66AB                                            stosw                                                   ;display character and attribute
  2427 000004DA B0C4                                            mov     al,EASCIIBORDSGLHORZ                            ;horizontal single border
  2428 000004DC 31C9                                            xor     ecx,ecx                                         ;zero register
  2429 000004DE 88D1                                            mov     cl,dl                                           ;width, excluding border
  2430 000004E0 F366AB                                          rep     stosw                                           ;display horizontal border
  2431 000004E3 B0BF                                            mov     al,EASCIIBORDSGLUPRRGT                          ;upper-right single border
  2432 000004E5 66AB                                            stosw                                                   ;display character and attribute
  2433 000004E7 5F                                              pop     edi                                             ;restore target row offset
  2434 000004E8 81C7A0000000                                    add     edi,ECONROWBYTES                                ;next row
  2435                                  ;
  2436                                  ;       Display dialog box body rows
  2437                                  ;
  2438 000004EE 31C9                                            xor     ecx,ecx                                         ;zero register
  2439 000004F0 88F1                                            mov     cl,dh                                           ;height, excluding border
  2440 000004F2 51                      .10                     push    ecx                                             ;save remaining rows
  2441 000004F3 57                                              push    edi                                             ;save target row offset
  2442 000004F4 88FC                                            mov     ah,bh                                           ;attribute
  2443 000004F6 B0B3                                            mov     al,EASCIIBORDSGLVERT                            ;vertical single border
  2444 000004F8 66AB                                            stosw                                                   ;display character and attribute
  2445 000004FA B020                                            mov     al,EASCIISPACE                                  ;space
  2446 000004FC 31C9                                            xor     ecx,ecx                                         ;zero register
  2447 000004FE 88D1                                            mov     cl,dl                                           ;width, excluding border
  2448 00000500 F366AB                                          rep     stosw                                           ;display row
  2449 00000503 B0B3                                            mov     al,EASCIIBORDSGLVERT                            ;vertical single border
  2450 00000505 66AB                                            stosw                                                   ;display character and attribute
  2451 00000507 5F                                              pop     edi                                             ;restore target row offset
  2452 00000508 81C7A0000000                                    add     edi,ECONROWBYTES                                ;next row
  2453 0000050E 59                                              pop     ecx                                             ;remaining rows
  2454 0000050F E2E1                                            loop    .10                                             ;next row
  2455                                  ;
  2456                                  ;       Display bottom border row
  2457                                  ;
  2458 00000511 57                                              push    edi                                             ;save target row offset
  2459 00000512 88FC                                            mov     ah,bh                                           ;attribute
  2460 00000514 B0C0                                            mov     al,EASCIIBORDSGLLWRLFT                          ;lower-left single border
  2461 00000516 66AB                                            stosw                                                   ;display character and attribute
  2462 00000518 B0C4                                            mov     al,EASCIIBORDSGLHORZ                            ;horizontal single border
  2463 0000051A 31C9                                            xor     ecx,ecx                                         ;zero register
  2464 0000051C 88D1                                            mov     cl,dl                                           ;width, excluding border
  2465 0000051E F366AB                                          rep     stosw                                           ;display horizontal border
  2466 00000521 B0D9                                            mov     al,EASCIIBORDSGLLWRRGT                          ;lower-right single border
  2467 00000523 66AB                                            stosw                                                   ;display character and attribute
  2468 00000525 5F                                              pop     edi                                             ;restore target row offset
  2469 00000526 81C7A0000000                                    add     edi,ECONROWBYTES                                ;next row
  2470                                  ;
  2471                                  ;       Restore and return
  2472                                  ;
  2473 0000052C 07                                              pop     es                                              ;restore non-volatile regs
  2474 0000052D 5F                                              pop     edi                                             ;
  2475 0000052E 5E                                              pop     esi                                             ;
  2476 0000052F 59                                              pop     ecx                                             ;
  2477 00000530 C3                                              ret                                                     ;return
  2478                                  ;=======================================================================================================================
  2479                                  ;
  2480                                  ;       Hardware Device Interupts
  2481                                  ;
  2482                                  ;       The next 16 interrupts are defined as our hardware interrupts. These interrupts vectors (20h-2Fh) are mapped to
  2483                                  ;       the hardware interrupts IRQ0-IRQF by the BIOS when the call to the BIOS is made invoking BIOS function 89h
  2484                                  ;       (BX=2028h).
  2485                                  ;
  2486                                  ;=======================================================================================================================
  2487                                  ;-----------------------------------------------------------------------------------------------------------------------
  2488                                  ;
  2489                                  ;       IRQ0    Clock Tick Interrupt
  2490                                  ;
  2491                                  ;       PC compatible systems contain or emulate the function of the Intel 8253 Programmable Interval Timer (PIT).
  2492                                  ;       Channel 0 of this chip decrements an internal counter to zero and then issues a hardware interrupt. The default
  2493                                  ;       rate at which IRQ0 occurs is approximately 18.2 times per second or, more accurately, 1,573,040 times per day.
  2494                                  ;
  2495                                  ;       Every time IRQ0 occurs, a counter at 40:6c is incremented. When the number of ticks reaches the maximum for one
  2496                                  ;       day, the counter is set to zero and the number of days counter at 40:70 is incremented.
  2497                                  ;
  2498                                  ;       This handler also decrements the floppy drive motor count at 40:40 if it is not zero. When this count reaches
  2499                                  ;       zero, the floppy disk motors are turned off.
  2500                                  ;
  2501                                  ;-----------------------------------------------------------------------------------------------------------------------
  2502                                                          menter  clocktick                                       ;clock tick interrupt
  2502                              <1> ?%1 equ ($-$$)
  2503 00000531 50                                              push    eax                                             ;save non-volatile regs
  2504 00000532 52                                              push    edx                                             ;
  2505 00000533 1E                                              push    ds                                              ;
  2506                                  ;
  2507                                  ;       Update the clock tick count and the elapsed days as needed.
  2508                                  ;
  2509 00000534 6A18                                            push    EGDTOSDATA                                      ;load OS data selector ...
  2510 00000536 1F                                              pop     ds                                              ;... into data segment register
  2511 00000537 A16C040000                                      mov     eax,[wdClockTicks]                              ;EAX = clock ticks
  2512 0000053C 40                                              inc     eax                                             ;increment clock ticks
  2513 0000053D 3DB0001800                                      cmp     eax,EPITDAYTICKS                                ;clock ticks per day?
  2514 00000542 7208                                            jb      irq0.10                                         ;no, skip ahead
  2515 00000544 FE0570040000                                    inc     byte [wbClockDays]                              ;increment clock days
  2516 0000054A 31C0                                            xor     eax,eax                                         ;reset clock ticks
  2517 0000054C A36C040000              irq0.10                 mov     dword [wdClockTicks],eax                        ;save clock ticks
  2518                                  ;
  2519                                  ;       Decrement floppy disk motor timeout.
  2520                                  ;
  2521 00000551 803D4004000000                                  cmp     byte [wbFDCMotor],0                             ;floppy motor timeout?
  2522 00000558 741E                                            je      irq0.20                                         ;yes, skip ahead
  2523 0000055A FE0D40040000                                    dec     byte [wbFDCMotor]                               ;decrement motor timeout
  2524 00000560 7516                                            jnz     irq0.20                                         ;skip ahead if non-zero
  2525                                  ;
  2526                                  ;       Turn off the floppy disk motor if appropriate.
  2527                                  ;
  2528 00000562 FB                                              sti                                                     ;enable maskable interrupts
  2529 00000563 B603                    irq0.15                 mov     dh,EFDCPORTHI                                   ;FDC controller port hi
  2530 00000565 B2F4                                            mov     dl,EFDCPORTLOSTAT                               ;FDC main status register
  2531 00000567 EC                                              in      al,dx                                           ;FDC main status byte
  2532 00000568 A810                                            test    al,EFDCSTATBUSY                                 ;test FDC main status for busy
  2533 0000056A 75F7                                            jnz     irq0.15                                         ;wait while busy
  2534 0000056C B00C                                            mov     al,EFDCMOTOROFF                                 ;motor-off / enable/ DMA setting
  2535 0000056E A23F040000                                      mov     byte [wbFDCControl],al                          ;save motor-off setting
  2536 00000573 B603                                            mov     dh,EFDCPORTHI                                   ;FDC port hi
  2537 00000575 B2F2                                            mov     dl,EFDCPORTLOOUT                                ;FDC digital output register
  2538 00000577 EE                                              out     dx,al                                           ;turn motor off
  2539                                  ;
  2540                                  ;       Signal the end of the hardware interrupt.
  2541                                  ;
  2542 00000578 E81F0E0000              irq0.20                 call    PutPrimaryEndOfInt                              ;send end-of-interrupt to PIC
  2543                                  ;
  2544                                  ;       Determine if a task switch is appropriate
  2545                                  ;
  2546 0000057D 803D070A000000                                  cmp     byte [wbInCriticalSection],0                    ;any task holding a critical section?
  2547 00000584 7535                                            jne     irq0.30                                         ;yes, do not switch tasks
  2548 00000586 FE05060A0000                                    inc     byte [wbTaskIndex]                              ;increment task queue index (0-255)
  2549 0000058C 0FB605060A0000                                  movzx   eax,byte [wbTaskIndex]                          ;load task queue index
  2550 00000593 668B940000080000                                mov     dx,[wwTaskQueue+eax*2]                          ;next task selector
  2551 0000059B 660F00C8                                        str     ax                                              ;current task selector
  2552 0000059F 6639C2                                          cmp     dx,ax                                           ;next task same is current task?
  2553 000005A2 7417                                            je      irq0.30                                         ;yes, skip task switch
  2554                                  ;
  2555                                  ;       Switch task
  2556                                  ;
  2557 000005A4 06                                              push    es                                              ;save extra segment register
  2558 000005A5 6A08                                            push    EGDTALIAS                                         ;load GDT alias selector ...
  2559 000005A7 07                                              pop     es                                              ;... into extra segment reg
  2560 000005A8 26806005FD                                      and     byte [es:eax+5],0FDh                            ;reset task-busy bit of current task
  2561 000005AD 07                                              pop     es                                              ;restore extra segment register
  2562 000005AE 668915040A0000                                  mov     word [wwFarJumpSelector],dx                     ;set next task selector in jmp instr
  2563 000005B5 FF2D000A0000                                    jmp     far [wdFarJumpEIP]                              ;jump to next task
  2564                                  ;
  2565                                  ;       Restore and return
  2566                                  ;
  2567 000005BB 1F                      irq0.30                 pop     ds                                              ;restore modified regs
  2568 000005BC 5A                                              pop     edx                                             ;
  2569 000005BD 58                                              pop     eax                                             ;
  2570 000005BE CF                                              iretd                                                   ;return
  2571                                  ;-----------------------------------------------------------------------------------------------------------------------
  2572                                  ;
  2573                                  ;       IRQ1    Keyboard Interrupt
  2574                                  ;
  2575                                  ;       This handler is called when an IRQ1 hardware interrupt occurs, caused by a keyboard event. The scan-code(s)
  2576                                  ;       corresponding to the keyboard event are read and message events are appended to the message queue. Since this
  2577                                  ;       code is called in response to a hardware interrupt, no task switch occurs. We need to preseve the state of
  2578                                  ;       ALL modified registers upon return. Note that keyboard messages are added to the keyboard focus message queue.
  2579                                  ;       This is a queue referenced in the global descriptor table and must always reference the message queue for the
  2580                                  ;       task that has the keyboard focus. To direct keyboard messages to another task, update the GDT descriptor to
  2581                                  ;       point to the message queue for that task.
  2582                                  ;
  2583                                  ;-----------------------------------------------------------------------------------------------------------------------
  2584                                                          menter  keyboard                                        ;keyboard interrrupt
  2584                              <1> ?%1 equ ($-$$)
  2585 000005BF 50                                              push    eax                                             ;save non-volatile regs
  2586 000005C0 53                                              push    ebx                                             ;
  2587 000005C1 51                                              push    ecx                                             ;
  2588 000005C2 56                                              push    esi                                             ;
  2589 000005C3 1E                                              push    ds                                              ;
  2590 000005C4 6A18                                            push    EGDTOSDATA                                      ;load OS data selector ...
  2591 000005C6 1F                                              pop     ds                                              ;... into data segment register
  2592 000005C7 30C0                                            xor     al,al                                           ;zero
  2593 000005C9 A2410A0000                                      mov     [wbConsoleScan0],al                             ;clear scan code 0
  2594 000005CE A2420A0000                                      mov     [wbConsoleScan1],al                             ;clear scan code 1
  2595 000005D3 A2430A0000                                      mov     [wbConsoleScan2],al                             ;clear scan code 2
  2596 000005D8 A2440A0000                                      mov     [wbConsoleScan3],al                             ;clear scan code 3
  2597 000005DD A2450A0000                                      mov     [wbConsoleScan4],al                             ;clear scan code 4
  2598 000005E2 A2460A0000                                      mov     [wbConsoleScan5],al                             ;clear scan code 5
  2599 000005E7 B020                                            mov     al,' '                                          ;space
  2600 000005E9 A2470A0000                                      mov     [wbConsoleChar],al                              ;set character to space
  2601 000005EE B080                                            mov     al,EKEYFTIMEOUT                                 ;controller timeout flag
  2602 000005F0 F6D0                                            not     al                                              ;controller timeout mask
  2603 000005F2 2005400A0000                                    and     [wbConsoleStatus],al                            ;clear controller timeout flag
  2604 000005F8 8A1D3E0A0000                                    mov     bl,[wbConsoleShift]                             ;shift flags
  2605 000005FE 8A3D3F0A0000                                    mov     bh,[wbConsoleLock]                              ;lock flags
  2606 00000604 E8480E0000                                      call    WaitForKeyOutBuffer                             ;controller timeout?
  2607 00000609 0F8404020000                                    jz      irq1.140                                        ;yes, skip ahead
  2608 0000060F E460                                            in      al,EKEYBPORTDATA                                ;read scan code 0
  2609 00000611 A2410A0000                                      mov     [wbConsoleScan0],al                             ;save scan code 0
  2610 00000616 88C4                                            mov     ah,al                                           ;copy scan code 0
  2611 00000618 B002                                            mov     al,EKEYFSHIFTLEFT                               ;left shift flag
  2612 0000061A 80FC2A                                          cmp     ah,EKEYBSHIFTLDOWN                              ;left shift key down code?
  2613 0000061D 0F84E0000000                                    je      irq1.30                                         ;yes, set flag
  2614 00000623 80FCAA                                          cmp     ah,EKEYBSHIFTLUP                                ;left shift key up code?
  2615 00000626 0F84DB000000                                    je      irq1.40                                         ;yes, reset flag
  2616 0000062C B010                                            mov     al,EKEYFSHIFTRIGHT                              ;right shift flag
  2617 0000062E 80FC36                                          cmp     ah,EKEYBSHIFTRDOWN                              ;right shift key down code?
  2618 00000631 0F84CC000000                                    je      irq1.30                                         ;yes, set flag
  2619 00000637 80FCB6                                          cmp     ah,EKEYBSHIFTRUP                                ;right shift key up code?
  2620 0000063A 0F84C7000000                                    je      irq1.40                                         ;yes, reset flag
  2621 00000640 B001                                            mov     al,EKEYFCTRLLEFT                                ;left control flag
  2622 00000642 80FC1D                                          cmp     ah,EKEYBCTRLDOWN                                ;control key down code?
  2623 00000645 0F84B8000000                                    je      irq1.30                                         ;yes, set flag
  2624 0000064B 80FC9D                                          cmp     ah,EKEYBCTRLUP                                  ;control key up code?
  2625 0000064E 0F84B3000000                                    je      irq1.40                                         ;yes, reset flag
  2626 00000654 B004                                            mov     al,EKEYFALTLEFT                                 ;left alt flag
  2627 00000656 80FC38                                          cmp     ah,EKEYBALTDOWN                                 ;alt key down code?
  2628 00000659 0F84A4000000                                    je      irq1.30                                         ;yes, set flag
  2629 0000065F 80FCB8                                          cmp     ah,EKEYBALTUP                                   ;alt key up code?
  2630 00000662 0F849F000000                                    je      irq1.40                                         ;yes, reset flag
  2631 00000668 B004                                            mov     al,EKEYFLOCKCAPS                                ;caps-lock flag
  2632 0000066A 80FC3A                                          cmp     ah,EKEYBCAPSDOWN                                ;caps-lock key down code?
  2633 0000066D 0F849A000000                                    je      irq1.50                                         ;yes, toggle lamps and flags
  2634 00000673 B002                                            mov     al,EKEYFLOCKNUM                                 ;num-lock flag
  2635 00000675 80FC45                                          cmp     ah,EKEYBNUMDOWN                                 ;num-lock key down code?
  2636 00000678 0F848F000000                                    je      irq1.50                                         ;yes, toggle lamps and flags
  2637 0000067E B001                                            mov     al,EKEYFLOCKSCROLL                              ;scroll-lock flag
  2638 00000680 80FC46                                          cmp     ah,EKEYBSCROLLDOWN                              ;scroll-lock key down code?
  2639 00000683 0F8484000000                                    je      irq1.50                                         ;yes, toggle lamps and flags
  2640 00000689 80FCE0                                          cmp     ah,EKEYBCODEEXT0                                ;extended scan code 0?
  2641 0000068C 0F8598000000                                    jne     irq1.70                                         ;no, skip ahead
  2642 00000692 E8BA0D0000                                      call    WaitForKeyOutBuffer                             ;controller timeout?
  2643 00000697 0F8476010000                                    jz      irq1.140                                        ;yes, skip ahead
  2644 0000069D E460                                            in      al,EKEYBPORTDATA                                ;read scan code 1
  2645 0000069F A2420A0000                                      mov     [wbConsoleScan1],al                             ;save scan code 1
  2646 000006A4 88C4                                            mov     ah,al                                           ;copy scan code 1
  2647 000006A6 B008                                            mov     al,EKEYFCTRLRIGHT                               ;right control flag
  2648 000006A8 80FC1D                                          cmp     ah,EKEYBCTRLDOWN                                ;control key down code?
  2649 000006AB 7456                                            je      irq1.30                                         ;yes, set flag
  2650 000006AD 80FC9D                                          cmp     ah,EKEYBCTRLUP                                  ;control key up code?
  2651 000006B0 7455                                            je      irq1.40                                         ;yes, reset flag
  2652 000006B2 B020                                            mov     al,EKEYFALTRIGHT                                ;right alt flag
  2653 000006B4 80FC38                                          cmp     ah,EKEYBALTDOWN                                 ;alt key down code?
  2654 000006B7 744A                                            je      irq1.30                                         ;yes, set flag
  2655 000006B9 80FCB8                                          cmp     ah,EKEYBALTUP                                   ;alt key up code?
  2656 000006BC 7449                                            je      irq1.40                                         ;yes, reset flag
  2657 000006BE 80FC35                                          cmp     ah,EKEYBSLASH                                   ;slash down code?
  2658 000006C1 0F84D2000000                                    je      irq1.80                                         ;yes, skip ahead
  2659 000006C7 80FCB5                                          cmp     ah,EKEYBSLASHUP                                 ;slash up code?
  2660 000006CA 0F84C9000000                                    je      irq1.80                                         ;yes, skip ahead
  2661 000006D0 80FC2A                                          cmp     ah,EKEYBPRTSCRDOWN                              ;print screen down code?
  2662 000006D3 7405                                            je      irq1.10                                         ;yes, continue
  2663 000006D5 80FCB7                                          cmp     ah,EKEYBPRTSCRUP                                ;print screen up code?
  2664 000006D8 7524                                            jne     irq1.20                                         ;no, skip ahead
  2665 000006DA E8720D0000              irq1.10                 call    WaitForKeyOutBuffer                             ;controller timeout?
  2666 000006DF 0F842E010000                                    jz      irq1.140                                        ;yes, skip ahead
  2667 000006E5 E460                                            in      al,EKEYBPORTDATA                                ;read scan code 2
  2668 000006E7 A2430A0000                                      mov     [wbConsoleScan2],al                             ;save scan code 2
  2669 000006EC E8600D0000                                      call    WaitForKeyOutBuffer                             ;controller timeout?
  2670 000006F1 0F841C010000                                    jz      irq1.140                                        ;yes, skip ahead
  2671 000006F7 E460                                            in      al,EKEYBPORTDATA                                ;read scan code 3
  2672 000006F9 A2440A0000                                      mov     [wbConsoleScan3],al                             ;read scan code 3
  2673 000006FE E918010000              irq1.20                 jmp     irq1.150                                        ;finish keyboard handling
  2674 00000703 08C3                    irq1.30                 or      bl,al                                           ;set shift flag
  2675 00000705 EB0D                                            jmp     irq1.60                                         ;skip ahead
  2676 00000707 F6D0                    irq1.40                 not     al                                              ;convert flag to mask
  2677 00000709 20C3                                            and     bl,al                                           ;reset shift flag
  2678 0000070B EB07                                            jmp     irq1.60                                         ;skip ahead
  2679 0000070D 30C7                    irq1.50                 xor     bh,al                                           ;toggle lock flag
  2680 0000070F E80E0D0000                                      call    SetKeyboardLamps                                ;update keyboard lamps
  2681 00000714 881D3E0A0000            irq1.60                 mov     [wbConsoleShift],bl                             ;save shift flags
  2682 0000071A 883D3F0A0000                                    mov     [wbConsoleLock],bh                              ;save lock flags
  2683 00000720 E859090000                                      call    PutConsoleOIAShift                              ;update OIA indicators
  2684 00000725 E9F1000000                                      jmp     irq1.150                                        ;finish keyboard handling
  2685 0000072A 80FCE1                  irq1.70                 cmp     ah,EKEYBCODEEXT1                                ;extended scan code 1?
  2686 0000072D 756A                                            jne     irq1.80                                         ;no continue
  2687 0000072F E81D0D0000                                      call    WaitForKeyOutBuffer                             ;controller timeout?
  2688 00000734 0F84D9000000                                    jz      irq1.140                                        ;yes, skip ahead
  2689 0000073A E460                                            in      al,EKEYBPORTDATA                                ;read scan code 1
  2690 0000073C A2420A0000                                      mov     [wbConsoleScan1],al                             ;save scan code 1
  2691 00000741 88C4                                            mov     ah,al                                           ;copy scan code 1
  2692 00000743 80FC1D                                          cmp     ah,EKEYBPAUSEDOWN                               ;pause key down code?
  2693 00000746 0F85CF000000                                    jne     irq1.150                                        ;no, finish keyboard handling
  2694 0000074C E8000D0000                                      call    WaitForKeyOutBuffer                             ;controller timeout?
  2695 00000751 0F84BC000000                                    jz      irq1.140                                        ;yes, skip ahead
  2696 00000757 E460                                            in      al,EKEYBPORTDATA                                ;read scan code 2
  2697 00000759 A2430A0000                                      mov     [wbConsoleScan2],al                             ;save scan code 2
  2698 0000075E E8EE0C0000                                      call    WaitForKeyOutBuffer                             ;controller timeout?
  2699 00000763 0F84AA000000                                    jz      irq1.140                                        ;yes, skip ahead
  2700 00000769 E460                                            in      al,EKEYBPORTDATA                                ;read scan code 3
  2701 0000076B A2440A0000                                      mov     [wbConsoleScan3],al                             ;save scan code 3
  2702 00000770 E8DC0C0000                                      call    WaitForKeyOutBuffer                             ;controller timeout?
  2703 00000775 0F8498000000                                    jz      irq1.140                                        ;yes, skip ahead
  2704 0000077B E460                                            in      al,EKEYBPORTDATA                                ;read scan code 4
  2705 0000077D A2450A0000                                      mov     [wbConsoleScan4],al                             ;save scan code 4
  2706 00000782 E8CA0C0000                                      call    WaitForKeyOutBuffer                             ;controller timeout?
  2707 00000787 0F8486000000                                    jz      irq1.140                                        ;yes, skip ahead
  2708 0000078D E460                                            in      al,EKEYBPORTDATA                                ;read scan code 5
  2709 0000078F A2460A0000                                      mov     [wbConsoleScan5],al                             ;save scan code 5
  2710 00000794 E982000000                                      jmp     irq1.150                                        ;continue
  2711 00000799 30C0                    irq1.80                 xor     al,al                                           ;assume no ASCII translation
  2712 0000079B F6C480                                          test    ah,EKEYBUP                                      ;release code?
  2713 0000079E 7571                                            jnz     irq1.130                                        ;yes, skip ahead
  2714 000007A0 BE[2B080000]                                    mov     esi,tscan2ascii                                 ;scan-to-ascii table address
  2715 000007A5 F6C312                                          test    bl,EKEYFSHIFT                                   ;either shift key down?
  2716 000007A8 7405                                            jz      irq1.90                                         ;no, skip ahead
  2717 000007AA BE[AB080000]                                    mov     esi,tscan2shift                                 ;scan-to-shifted table address
  2718 000007AF 0FB6CC                  irq1.90                 movzx   ecx,ah                                          ;scan code offset
  2719 000007B2 2E8A0431                                        mov     al,[cs:ecx+esi]                                 ;al = ASCII code
  2720 000007B6 F6C704                                          test    bh,EKEYFLOCKCAPS                                ;caps-lock on?
  2721 000007B9 7411                                            jz      irq1.100                                        ;no skip ahead
  2722 000007BB 88C1                                            mov     cl,al                                           ;copy ASCII code
  2723 000007BD 80E1DF                                          and     cl,EASCIICASEMASK                               ;clear case mask of copy
  2724 000007C0 80F941                                          cmp     cl,EASCIIUPPERA                                 ;less than 'A'?
  2725 000007C3 7207                                            jb      irq1.100                                        ;yes, skip ahead
  2726 000007C5 80F95A                                          cmp     cl,EASCIIUPPERZ                                 ;greater than 'Z'?
  2727 000007C8 7702                                            ja      irq1.100                                        ;yes, skip ahead
  2728 000007CA 3420                                            xor     al,EASCIICASE                                   ;switch case
  2729 000007CC A2470A0000              irq1.100                mov     [wbConsoleChar],al                              ;save ASCII code
  2730 000007D1 BA00000041              irq1.110                mov     edx,EMSGKEYDOWN                                 ;assume key-down event
  2731 000007D6 F6C480                                          test    ah,EKEYBUP                                      ;release scan-code?
  2732 000007D9 7405                                            jz      irq1.120                                        ;no, skip ahead
  2733 000007DB BA00000141                                      mov     edx,EMSGKEYUP                                   ;key-up event
  2734 000007E0 25FFFF0000              irq1.120                and     eax,0FFFFh                                      ;clear high-order word
  2735 000007E5 09C2                                            or      edx,eax                                         ;msg id and codes
  2736 000007E7 31C9                                            xor     ecx,ecx                                         ;null param
  2737 000007E9 50                                              push    eax                                             ;save codes
  2738 000007EA B880000000                                      mov     eax,ESELKEYBOARDMQ                              ;keyboard focus message queue
  2739 000007EF E89E0A0000                                      call    PutMessage                                      ;put message to console
  2740 000007F4 58                                              pop     eax                                             ;restore codes
  2741 000007F5 84C0                                            test    al,al                                           ;ASCII translation?
  2742 000007F7 7418                                            jz      irq1.130                                        ;no, skip ahead
  2743 000007F9 BA00000241                                      mov     edx,EMSGKEYCHAR                                 ;key-character event
  2744 000007FE 25FFFF0000                                      and     eax,0FFFFh                                      ;clear high-order word
  2745 00000803 09C2                                            or      edx,eax                                         ;msg id and codes
  2746 00000805 31C9                                            xor     ecx,ecx                                         ;null param
  2747 00000807 B880000000                                      mov     eax,ESELKEYBOARDMQ                              ;keyboard focus message queue
  2748 0000080C E8810A0000                                      call    PutMessage                                      ;put message to console
  2749 00000811 EB08                    irq1.130                jmp     irq1.150                                        ;finish keyboard handling
  2750 00000813 B080                    irq1.140                mov     al,EKEYFTIMEOUT                                 ;controller timeout flag
  2751 00000815 0805400A0000                                    or      [wbConsoleStatus],al                            ;set controller timeout flag
  2752 0000081B E806080000              irq1.150                call    PutConsoleOIAChar                               ;update operator info area
  2753 00000820 E8770B0000                                      call    PutPrimaryEndOfInt                              ;send end-of-interrupt to PIC
  2754 00000825 1F                                              pop     ds                                              ;restore non-volatile regs
  2755 00000826 5E                                              pop     esi                                             ;
  2756 00000827 59                                              pop     ecx                                             ;
  2757 00000828 5B                                              pop     ebx                                             ;
  2758 00000829 58                                              pop     eax                                             ;
  2759 0000082A CF                                              iretd                                                   ;return
  2760                                  ;-----------------------------------------------------------------------------------------------------------------------
  2761                                  ;       Scan-Code to ASCII Translation Tables
  2762                                  ;-----------------------------------------------------------------------------------------------------------------------
  2763 0000082B 001B313233343536        tscan2ascii             db      000h,01Bh,031h,032h,033h,034h,035h,036h         ;00-07
  2764 00000833 373839302D3D0809                                db      037h,038h,039h,030h,02Dh,03Dh,008h,009h         ;08-0f
  2765 0000083B 7177657274797569                                db      071h,077h,065h,072h,074h,079h,075h,069h         ;10-17
  2766 00000843 6F705B5D0D006173                                db      06Fh,070h,05Bh,05Dh,00Dh,000h,061h,073h         ;18-1f
  2767 0000084B 646667686A6B6C3B                                db      064h,066h,067h,068h,06Ah,06Bh,06Ch,03Bh         ;20-27
  2768 00000853 2760005C7A786376                                db      027h,060h,000h,05Ch,07Ah,078h,063h,076h         ;28-2f
  2769 0000085B 626E6D2C2E2F002A                                db      062h,06Eh,06Dh,02Ch,02Eh,02Fh,000h,02Ah         ;30-37
  2770 00000863 0020000000000000                                db      000h,020h,000h,000h,000h,000h,000h,000h         ;38-3f
  2771 0000086B 0000000000000037                                db      000h,000h,000h,000h,000h,000h,000h,037h         ;40-47
  2772 00000873 38392D3435362B31                                db      038h,039h,02Dh,034h,035h,036h,02Bh,031h         ;48-4f
  2773 0000087B 3233302E00000000                                db      032h,033h,030h,02Eh,000h,000h,000h,000h         ;50-57
  2774 00000883 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;58-5f
  2775 0000088B 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;60-67
  2776 00000893 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;68-6f
  2777 0000089B 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;70-77
  2778 000008A3 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;78-7f
  2779 000008AB 001B21402324255E        tscan2shift             db      000h,01Bh,021h,040h,023h,024h,025h,05Eh         ;80-87
  2780 000008B3 262A28295F2B0800                                db      026h,02Ah,028h,029h,05Fh,02Bh,008h,000h         ;88-8f
  2781 000008BB 5157455254595549                                db      051h,057h,045h,052h,054h,059h,055h,049h         ;90-97
  2782 000008C3 4F507B7D0D004153                                db      04Fh,050h,07Bh,07Dh,00Dh,000h,041h,053h         ;98-9f
  2783 000008CB 444647484A4B4C3A                                db      044h,046h,047h,048h,04Ah,04Bh,04Ch,03Ah         ;a0-a7
  2784 000008D3 227E007C5A584356                                db      022h,07Eh,000h,07Ch,05Ah,058h,043h,056h         ;a8-af
  2785 000008DB 424E4D3C3E3F002A                                db      042h,04Eh,04Dh,03Ch,03Eh,03Fh,000h,02Ah         ;b0-b7
  2786 000008E3 0020000000000000                                db      000h,020h,000h,000h,000h,000h,000h,000h         ;b8-bf
  2787 000008EB 0000000000000037                                db      000h,000h,000h,000h,000h,000h,000h,037h         ;c0-c7
  2788 000008F3 38392D3435362B31                                db      038h,039h,02Dh,034h,035h,036h,02Bh,031h         ;c8-cf
  2789 000008FB 3233302E00000000                                db      032h,033h,030h,02Eh,000h,000h,000h,000h         ;d0-d7
  2790 00000903 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;d8-df
  2791 0000090B 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;e0-e7
  2792 00000913 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;e8-ef
  2793 0000091B 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;f0-f7
  2794 00000923 0000000000000000                                db      000h,000h,000h,000h,000h,000h,000h,000h         ;f8-ff
  2795                                  ;-----------------------------------------------------------------------------------------------------------------------
  2796                                  ;
  2797                                  ;       IRQ2    Secondary 8259A Cascade Hardware Interrupt
  2798                                  ;
  2799                                  ;-----------------------------------------------------------------------------------------------------------------------
  2800                                                          menter  iochannel                                       ;secondary 8259A cascade
  2800                              <1> ?%1 equ ($-$$)
  2801 0000092B 50                                              push    eax                                             ;save modified regs
  2802 0000092C EB3F                                            jmp     hwint                                           ;end interrupt and return
  2803                                  ;-----------------------------------------------------------------------------------------------------------------------
  2804                                  ;
  2805                                  ;       IRQ3    Communication Port 2 Hardware Interrupt
  2806                                  ;
  2807                                  ;-----------------------------------------------------------------------------------------------------------------------
  2808                                                          menter  com2                                            ;serial port 2 interrupt
  2808                              <1> ?%1 equ ($-$$)
  2809 0000092E 50                                              push    eax                                             ;save modified regs
  2810 0000092F EB3C                                            jmp     hwint                                           ;end interrupt and return
  2811                                  ;-----------------------------------------------------------------------------------------------------------------------
  2812                                  ;
  2813                                  ;       IRQ4    Communication Port 1 Hardware Interrupt
  2814                                  ;
  2815                                  ;-----------------------------------------------------------------------------------------------------------------------
  2816                                                          menter  com1                                            ;serial port 1 interrupt
  2816                              <1> ?%1 equ ($-$$)
  2817 00000931 50                                              push    eax                                             ;save modified regs
  2818 00000932 EB39                                            jmp     hwint                                           ;end interrupt and return
  2819                                  ;-----------------------------------------------------------------------------------------------------------------------
  2820                                  ;
  2821                                  ;       IRQ5    Parallel Port 2 Hardware Interrupt
  2822                                  ;
  2823                                  ;-----------------------------------------------------------------------------------------------------------------------
  2824                                                          menter  lpt2                                            ;parallel port 2 interrupt
  2824                              <1> ?%1 equ ($-$$)
  2825 00000934 50                                              push    eax                                             ;save modified regs
  2826 00000935 EB36                                            jmp     hwint                                           ;end interrupt and return
  2827                                  ;-----------------------------------------------------------------------------------------------------------------------
  2828                                  ;
  2829                                  ;       IRQ6    Diskette Hardware Interrupt
  2830                                  ;
  2831                                  ;-----------------------------------------------------------------------------------------------------------------------
  2832                                                          menter  diskette                                        ;floppy disk interrupt
  2832                              <1> ?%1 equ ($-$$)
  2833 00000937 50                                              push    eax                                             ;save non-volatile regs
  2834 00000938 1E                                              push    ds                                              ;
  2835 00000939 6A18                                            push    EGDTOSDATA                                      ;load OS data selector ...
  2836 0000093B 1F                                              pop     ds                                              ;... into DS register
  2837 0000093C A03E040000                                      mov     al,[wbFDCStatus]                                ;AL = FDC calibration status
  2838 00000941 0C80                                            or      al,10000000b                                    ;set IRQ flag
  2839 00000943 A23E040000                                      mov     [wbFDCStatus],al                                ;update FDC calibration status
  2840 00000948 1F                                              pop     ds                                              ;restore non-volatile regs
  2841 00000949 EB22                                            jmp     hwint                                           ;end primary PIC interrupt
  2842                                  ;-----------------------------------------------------------------------------------------------------------------------
  2843                                  ;
  2844                                  ;       IRQ7    Parallel Port 1 Hardware Interrupt
  2845                                  ;
  2846                                  ;-----------------------------------------------------------------------------------------------------------------------
  2847                                                          menter  lpt1                                            ;parallel port 1 interrupt
  2847                              <1> ?%1 equ ($-$$)
  2848 0000094B 50                                              push    eax                                             ;save modified regs
  2849 0000094C EB1F                                            jmp     hwint                                           ;end interrupt and return
  2850                                  ;-----------------------------------------------------------------------------------------------------------------------
  2851                                  ;
  2852                                  ;       IRQ8    Real-time Clock Hardware Interrupt
  2853                                  ;
  2854                                  ;-----------------------------------------------------------------------------------------------------------------------
  2855                                                          menter  rtclock                                         ;real-time clock interrupt
  2855                              <1> ?%1 equ ($-$$)
  2856 0000094E 50                                              push    eax                                             ;save modified regs
  2857 0000094F EB15                                            jmp     hwwint                                          ;end interrupt and return
  2858                                  ;-----------------------------------------------------------------------------------------------------------------------
  2859                                  ;
  2860                                  ;       IRQ9    CGA Vertical Retrace Hardware Interrupt
  2861                                  ;
  2862                                  ;-----------------------------------------------------------------------------------------------------------------------
  2863                                                          menter  retrace                                         ;CGA vertical retrace interrupt
  2863                              <1> ?%1 equ ($-$$)
  2864 00000951 50                                              push    eax                                             ;save modified regs
  2865 00000952 EB12                                            jmp     hwwint                                          ;end interrupt and return
  2866                                  ;-----------------------------------------------------------------------------------------------------------------------
  2867                                  ;
  2868                                  ;       IRQ10   Reserved Hardware Interrupt
  2869                                  ;
  2870                                  ;-----------------------------------------------------------------------------------------------------------------------
  2871                                                          menter  irq10                                           ;reserved
  2871                              <1> ?%1 equ ($-$$)
  2872 00000954 50                                              push    eax                                             ;save modified regs
  2873 00000955 EB0F                                            jmp     hwwint                                          ;end interrupt and return
  2874                                  ;-----------------------------------------------------------------------------------------------------------------------
  2875                                  ;
  2876                                  ;       IRQ11   Reserved Hardware Interrupt
  2877                                  ;
  2878                                  ;-----------------------------------------------------------------------------------------------------------------------
  2879                                                          menter  irq11                                           ;reserved
  2879                              <1> ?%1 equ ($-$$)
  2880 00000957 50                                              push    eax                                             ;save modified regs
  2881 00000958 EB0C                                            jmp     hwwint                                          ;end interrupt and return
  2882                                  ;-----------------------------------------------------------------------------------------------------------------------
  2883                                  ;
  2884                                  ;       IRQ12   PS/2 Mouse Hardware Interrupt
  2885                                  ;
  2886                                  ;-----------------------------------------------------------------------------------------------------------------------
  2887                                                          menter  ps2mouse                                        ;PS/2 mouse interrupt
  2887                              <1> ?%1 equ ($-$$)
  2888 0000095A 50                                              push    eax                                             ;save modified regs
  2889 0000095B EB09                                            jmp     hwwint                                          ;end interrupt and return
  2890                                  ;-----------------------------------------------------------------------------------------------------------------------
  2891                                  ;
  2892                                  ;       IRQ13   Coprocessor Hardware Interrupt
  2893                                  ;
  2894                                  ;-----------------------------------------------------------------------------------------------------------------------
  2895                                                          menter  coprocessor                                     ;coprocessor interrupt
  2895                              <1> ?%1 equ ($-$$)
  2896 0000095D 50                                              push    eax                                             ;save modified regs
  2897 0000095E EB06                                            jmp     hwwint                                          ;end interrupt and return
  2898                                  ;-----------------------------------------------------------------------------------------------------------------------
  2899                                  ;
  2900                                  ;       IRQ14   Fixed Disk Hardware Interrupt
  2901                                  ;
  2902                                  ;-----------------------------------------------------------------------------------------------------------------------
  2903                                                          menter  fixeddisk                                       ;fixed disk interrupt
  2903                              <1> ?%1 equ ($-$$)
  2904 00000960 50                                              push    eax                                             ;save modified regs
  2905 00000961 EB03                                            jmp     hwwint                                          ;end interrupt and return
  2906                                  ;-----------------------------------------------------------------------------------------------------------------------
  2907                                  ;
  2908                                  ;       IRQ15   Reserved Hardware Interrupt
  2909                                  ;
  2910                                  ;-----------------------------------------------------------------------------------------------------------------------
  2911                                                          menter  irq15                                           ;reserved
  2911                              <1> ?%1 equ ($-$$)
  2912 00000963 50                                              push    eax                                             ;save modified regs
  2913 00000964 EB00                                            jmp     hwwint                                          ;end interrupt and return
  2914                                  ;-----------------------------------------------------------------------------------------------------------------------
  2915                                  ;
  2916                                  ;       Exit from hardware interrupt
  2917                                  ;
  2918                                  ;-----------------------------------------------------------------------------------------------------------------------
  2919 00000966 E8370A0000              hwwint                  call    PutSecondaryEndOfInt                            ;send EOI to secondary PIC
  2920 0000096B EB05                                            jmp     hwint90                                         ;skip ahead
  2921 0000096D E82A0A0000              hwint                   call    PutPrimaryEndOfInt                              ;send EOI to primary PIC
  2922 00000972 58                      hwint90                 pop     eax                                             ;restore modified regs
  2923 00000973 CF                                              iretd                                                   ;return from interrupt
  2924                                  ;-----------------------------------------------------------------------------------------------------------------------
  2925                                  ;
  2926                                  ;       INT 30h Operating System Software Service Interrupt
  2927                                  ;
  2928                                  ;       Interrupt 30h is used by our operating system as an entry point for many commonly-used subroutines reusable by
  2929                                  ;       any task. These routines include low-level i/o functions that shield applications from having to handle
  2930                                  ;       device-specific communications. On entry to this interrupt, AL contains a function number that is used to load
  2931                                  ;       the entry address of the specific function from a table.
  2932                                  ;
  2933                                  ;-----------------------------------------------------------------------------------------------------------------------
  2934                                                          menter  svc
  2934                              <1> ?%1 equ ($-$$)
  2935 00000974 3C20                                            cmp     al,maxtsvc                                      ;is our function out of range?
  2936 00000976 730D                                            jae     svc90                                           ;yes, skip ahead
  2937 00000978 0FB6C0                                          movzx   eax,al                                          ;function
  2938 0000097B C1E002                                          shl     eax,2                                           ;offset into table
  2939 0000097E 2EFF90[86090000]                                call    dword [cs:tsvc+eax]                             ;far call to indirect address
  2940 00000985 CF                      svc90                   iretd                                                   ;return from interrupt
  2941                                  ;-----------------------------------------------------------------------------------------------------------------------
  2942                                  ;
  2943                                  ;       Service Request Table
  2944                                  ;
  2945                                  ;
  2946                                  ;       These tsvce macros expand to define an address vector table for the service request interrupt (int 30h).
  2947                                  ;
  2948                                  ;-----------------------------------------------------------------------------------------------------------------------
  2949                                  tsvc                    tsvce   AllocateMemory                                  ;allocate memory block
  2949                              <1> tsvc :
  2949                              <1> e%1 equ ($-tsvc)/4
  2949 00000986 [2C0C0000]          <1>  dd %1
  2950                                                          tsvce   ClearConsoleScreen                              ;clear console screen
  2950                              <1> e%1 equ ($-tsvc)/4
  2950 0000098A [BA120000]          <1>  dd %1
  2951                                                          tsvce   CompareMemory                                   ;compare memory
  2951                              <1> e%1 equ ($-tsvc)/4
  2951 0000098E [870E0000]          <1>  dd %1
  2952                                                          tsvce   CopyMemory                                      ;copy memory
  2952                              <1> e%1 equ ($-tsvc)/4
  2952 00000992 [A40E0000]          <1>  dd %1
  2953                                                          tsvce   DecimalToUnsigned                               ;convert decimal string to unsigned integer
  2953                              <1> e%1 equ ($-tsvc)/4
  2953 00000996 [48110000]          <1>  dd %1
  2954                                                          tsvce   FreeMemory                                      ;free memory block
  2954                              <1> e%1 equ ($-tsvc)/4
  2954 0000099A [4A0D0000]          <1>  dd %1
  2955                                                          tsvce   GetBaseMemSize                                  ;get base RAM size in bytes
  2955                              <1> e%1 equ ($-tsvc)/4
  2955 0000099E [47130000]          <1>  dd %1
  2956                                                          tsvce   GetConsoleString                                ;get string input
  2956                              <1> e%1 equ ($-tsvc)/4
  2956 000009A2 [FA0E0000]          <1>  dd %1
  2957                                                          tsvce   GetExtendedMemSize                              ;get extended RAM size in bytes
  2957                              <1> e%1 equ ($-tsvc)/4
  2957 000009A6 [58130000]          <1>  dd %1
  2958                                                          tsvce   GetROMMemSize                                   ;get RAM size as reported by INT 12h
  2958                              <1> e%1 equ ($-tsvc)/4
  2958 000009AA [69130000]          <1>  dd %1
  2959                                                          tsvce   HexadecimalToUnsigned                           ;convert hexadecimal string to unsigned integer
  2959                              <1> e%1 equ ($-tsvc)/4
  2959 000009AE [7B110000]          <1>  dd %1
  2960                                                          tsvce   IsLeapYear                                      ;return ecx=1 if leap year
  2960                              <1> e%1 equ ($-tsvc)/4
  2960 000009B2 [140A0000]          <1>  dd %1
  2961                                                          tsvce   PlaceCursor                                     ;place the cursor at the current loc
  2961                              <1> e%1 equ ($-tsvc)/4
  2961 000009B6 [72130000]          <1>  dd %1
  2962                                                          tsvce   PutConsoleString                                ;tty output asciiz string
  2962                              <1> e%1 equ ($-tsvc)/4
  2962 000009BA [18110000]          <1>  dd %1
  2963                                                          tsvce   PutDateString                                   ;put MM/DD/YYYY string
  2963                              <1> e%1 equ ($-tsvc)/4
  2963 000009BE [2F0A0000]          <1>  dd %1
  2964                                                          tsvce   PutDayString                                    ;put DD string
  2964                              <1> e%1 equ ($-tsvc)/4
  2964 000009C2 [700A0000]          <1>  dd %1
  2965                                                          tsvce   PutHourString                                   ;put hh string
  2965                              <1> e%1 equ ($-tsvc)/4
  2965 000009C6 [7E0A0000]          <1>  dd %1
  2966                                                          tsvce   PutMinuteString                                 ;put mm string
  2966                              <1> e%1 equ ($-tsvc)/4
  2966 000009CA [8C0A0000]          <1>  dd %1
  2967                                                          tsvce   PutMonthString                                  ;put MM string
  2967                              <1> e%1 equ ($-tsvc)/4
  2967 000009CE [9A0A0000]          <1>  dd %1
  2968                                                          tsvce   PutMonthNameString                              ;put name(MM) string
  2968                              <1> e%1 equ ($-tsvc)/4
  2968 000009D2 [A80A0000]          <1>  dd %1
  2969                                                          tsvce   PutSecondString                                 ;put ss string
  2969                              <1> e%1 equ ($-tsvc)/4
  2969 000009D6 [CC0A0000]          <1>  dd %1
  2970                                                          tsvce   PutTimeString                                   ;put HH:MM:SS string
  2970                              <1> e%1 equ ($-tsvc)/4
  2970 000009DA [D90A0000]          <1>  dd %1
  2971                                                          tsvce   PutWeekdayString                                ;put weekday string
  2971                              <1> e%1 equ ($-tsvc)/4
  2971 000009DE [0E0B0000]          <1>  dd %1
  2972                                                          tsvce   PutWeekdayNameString                            ;put name(weekday) string
  2972                              <1> e%1 equ ($-tsvc)/4
  2972 000009E2 [1C0B0000]          <1>  dd %1
  2973                                                          tsvce   PutYearString                                   ;put YYYY string
  2973                              <1> e%1 equ ($-tsvc)/4
  2973 000009E6 [3F0B0000]          <1>  dd %1
  2974                                                          tsvce   ReadRealTimeClock                               ;get real-time clock date and time
  2974                              <1> e%1 equ ($-tsvc)/4
  2974 000009EA [A8130000]          <1>  dd %1
  2975                                                          tsvce   ResetSystem                                     ;reset system using 8042 chip
  2975                              <1> e%1 equ ($-tsvc)/4
  2975 000009EE [13140000]          <1>  dd %1
  2976                                                          tsvce   SetConsoleString                                ;set console string
  2976                              <1> e%1 equ ($-tsvc)/4
  2976 000009F2 [37130000]          <1>  dd %1
  2977                                                          tsvce   UnsignedToDecimalString                         ;convert unsigned integer to decimal string
  2977                              <1> e%1 equ ($-tsvc)/4
  2977 000009F6 [99110000]          <1>  dd %1
  2978                                                          tsvce   UnsignedToHexadecimal                           ;convert unsigned integer to hexadecimal string
  2978                              <1> e%1 equ ($-tsvc)/4
  2978 000009FA [3D120000]          <1>  dd %1
  2979                                                          tsvce   UpperCaseString                                 ;upper-case string
  2979                              <1> e%1 equ ($-tsvc)/4
  2979 000009FE [B60E0000]          <1>  dd %1
  2980                                                          tsvce   Yield                                           ;halt until interrupt
  2980                              <1> e%1 equ ($-tsvc)/4
  2980 00000A02 [45110000]          <1>  dd %1
  2981                                  maxtsvc                 equ     ($-tsvc)/4                                      ;function out of range
  2982                                  ;-----------------------------------------------------------------------------------------------------------------------
  2983                                  ;
  2984                                  ;       Service Request Macros
  2985                                  ;
  2986                                  ;       These macros provide positional parameterization of service request calls.
  2987                                  ;
  2988                                  ;-----------------------------------------------------------------------------------------------------------------------
  2989                                  %macro                  allocateMemory 1
  2990                                                          mov     ecx,%1                                          ;bytes to allocate
  2991                                                          mov     al,eAllocateMemory                              ;allocate memory fn.
  2992                                                          int     _svc                                            ;invoke OS service
  2993                                  %endmacro
  2994                                  %macro                  clearConsoleScreen 0
  2995                                                          mov     al,eClearConsoleScreen                          ;function code
  2996                                                          int     _svc                                            ;invoke OS service
  2997                                  %endmacro
  2998                                  %macro                  compareMemory 0
  2999                                                          mov     al,eCompareMemory                               ;function code
  3000                                                          int     _svc                                            ;invoke OS service
  3001                                  %endmacro
  3002                                  %macro                  decimalToUnsigned 0
  3003                                                          mov     al,eDecimalToUnsigned                           ;function code
  3004                                                          int     _svc                                            ;invoke OS servie
  3005                                  %endmacro
  3006                                  %macro                  compareMemory 3
  3007                                                          mov     edx,%1                                          ;first memory address
  3008                                                          mov     ebx,%2                                          ;second memory address
  3009                                                          mov     ecx,%3                                          ;length
  3010                                                          mov     al,eCompareMemory                               ;function code
  3011                                                          int     _svc                                            ;invoke OS service
  3012                                  %endmacro
  3013                                  %macro                  copyMemory 3
  3014                                                          mov     edx,%1                                          ;first memory address
  3015                                                          mov     ebx,%2                                          ;second memory address
  3016                                                          mov     ecx,%3                                          ;length
  3017                                                          mov     al,eCopyMemory                                  ;function code
  3018                                                          int     _svc                                            ;invoke OS service
  3019                                  %endmacro
  3020                                  %macro                  freeMemory 1
  3021                                                          mov     edx,%1                                          ;address of memory block
  3022                                                          mov     al,eFreeMemory                                  ;function code
  3023                                                          int     _svc                                            ;invoke OS service
  3024                                  %endmacro
  3025                                  %macro                  getBaseMemSize 0
  3026                                                          mov     al,eGetBaseMemSize                              ;function code
  3027                                                          int     _svc                                            ;invoke OS service
  3028                                  %endmacro
  3029                                  %macro                  getConsoleString 4
  3030                                                          mov     edx,%1                                          ;buffer address
  3031                                                          mov     ecx,%2                                          ;max characters
  3032                                                          mov     bh,%3                                           ;echo indicator
  3033                                                          mov     bl,%4                                           ;terminator
  3034                                                          mov     al,eGetConsoleString                            ;function code
  3035                                                          int     _svc                                            ;invoke OS service
  3036                                  %endmacro
  3037                                  %macro                  getExtendedMemSize 0
  3038                                                          mov     al,eGetExtendedMemSize                          ;function code
  3039                                                          int     _svc                                            ;invoke OS service
  3040                                  %endmacro
  3041                                  %macro                  getROMMemSize 0
  3042                                                          mov     al,eGetROMMemSize                               ;function code
  3043                                                          int     _svc                                            ;invoke OS service
  3044                                  %endmacro
  3045                                  %macro                  hexadecimalToUnsigned 0
  3046                                                          mov     al,eHexadecimalToUnsigned                       ;function code
  3047                                                          int     _svc                                            ;invoke OS service
  3048                                  %endmacro
  3049                                  %macro                  isLeapYear 1
  3050                                                          mov     ebx,%1                                          ;DATETIME addr
  3051                                                          mov     al,eIsLeapYear                                  ;function code
  3052                                                          int     _svc                                            ;invoke OS service
  3053                                  %endmacro
  3054                                  %macro                  placeCursor 0
  3055                                                          mov     al,ePlaceCursor                                 ;function code
  3056                                                          int     _svc                                            ;invoke OS service
  3057                                  %endmacro
  3058                                  %macro                  putConsoleString 1
  3059                                                          mov     edx,%1                                          ;string address
  3060                                                          mov     al,ePutConsoleString                            ;function code
  3061                                                          int     _svc                                            ;invoke OS service
  3062                                  %endmacro
  3063                                  %macro                  putDateString 0
  3064                                                          mov     al,ePutDateString                               ;function code
  3065                                                          int     _svc                                            ;invoke OS service
  3066                                  %endmacro
  3067                                  %macro                  putDateString 2
  3068                                                          mov     ebx,%1                                          ;DATETIME addr
  3069                                                          mov     edx,%2                                          ;output buffer addr
  3070                                                          mov     al,ePutDateString                               ;function code
  3071                                                          int     _svc                                            ;invoke OS service
  3072                                  %endmacro
  3073                                  %macro                  putDayString 2
  3074                                                          mov     ebx,%1                                          ;DATETIME addr
  3075                                                          mov     edx,%2                                          ;output buffer addr
  3076                                                          mov     al,ePutDayString                                ;function code
  3077                                                          int     _svc                                            ;invoke OS service
  3078                                  %endmacro
  3079                                  %macro                  putHourString 2
  3080                                                          mov     ebx,%1                                          ;DATETIME addr
  3081                                                          mov     edx,%2                                          ;output buffer addr
  3082                                                          mov     al,ePutHourString                               ;function code
  3083                                                          int     _svc                                            ;invoke OS service
  3084                                  %endmacro
  3085                                  %macro                  putMinuteString 2
  3086                                                          mov     ebx,%1                                          ;DATETIME addr
  3087                                                          mov     edx,%2                                          ;output buffer addr
  3088                                                          mov     al,ePutMinuteString                             ;function code
  3089                                                          int     _svc                                            ;invoke OS service
  3090                                  %endmacro
  3091                                  %macro                  putMonthString 2
  3092                                                          mov     ebx,%1                                          ;DATETIME addr
  3093                                                          mov     edx,%2                                          ;output buffer addr
  3094                                                          mov     al,ePutMonthString                              ;function code
  3095                                                          int     _svc                                            ;invoke OS service
  3096                                  %endmacro
  3097                                  %macro                  putMonthNameString 2
  3098                                                          mov     ebx,%1                                          ;DATETIME addr
  3099                                                          mov     edx,%2                                          ;output buffer addr
  3100                                                          mov     al,ePutMonthNameString                          ;function code
  3101                                                          int     _svc                                            ;invoke OS service
  3102                                  %endmacro
  3103                                  %macro                  putSecondString 2
  3104                                                          mov     ebx,%1                                          ;DATETIME addr
  3105                                                          mov     edx,%2                                          ;output buffer addr
  3106                                                          mov     al,ePutSecondString                             ;function code
  3107                                                          int     _svc                                            ;invoke OS service
  3108                                  %endmacro
  3109                                  %macro                  putTimeString 0
  3110                                                          mov     al,ePutTimeString                               ;function code
  3111                                                          int     _svc                                            ;invoke OS service
  3112                                  %endmacro
  3113                                  %macro                  putTimeString 2
  3114                                                          mov     ebx,%1                                          ;DATETIME addr
  3115                                                          mov     edx,%2                                          ;output buffer addr
  3116                                                          mov     al,ePutTimeString                               ;function code
  3117                                                          int     _svc                                            ;invoke OS service
  3118                                  %endmacro
  3119                                  %macro                  putWeekdayString 2
  3120                                                          mov     ebx,%1                                          ;DATETIME addr
  3121                                                          mov     edx,%2                                          ;output buffer addr
  3122                                                          mov     al,ePutWeekdayString                            ;function code
  3123                                                          int     _svc                                            ;invoke OS service
  3124                                  %endmacro
  3125                                  %macro                  putWeekdayNameString 2
  3126                                                          mov     ebx,%1                                          ;DATETIME addr
  3127                                                          mov     edx,%2                                          ;output buffer addr
  3128                                                          mov     al,ePutWeekdayNameString                        ;function code
  3129                                                          int     _svc                                            ;invoke OS service
  3130                                  %endmacro
  3131                                  %macro                  putYearString 2
  3132                                                          mov     ebx,%1                                          ;DATETIME addr
  3133                                                          mov     edx,%2                                          ;output buffer addr
  3134                                                          mov     al,ePutYearString                               ;function code
  3135                                                          int     _svc                                            ;invoke OS service
  3136                                  %endmacro
  3137                                  %macro                  readRealTimeClock 0
  3138                                                          mov     al,eReadRealTimeClock                           ;function code
  3139                                                          int     _svc                                            ;invoke OS service
  3140                                  %endmacro
  3141                                  %macro                  readRealTimeClock 1
  3142                                                          mov     ebx,%1                                          ;DATETIME addr
  3143                                                          mov     al,eReadRealTimeClock                           ;function code
  3144                                                          int     _svc                                            ;invoke OS service
  3145                                  %endmacro
  3146                                  %macro                  resetSystem 0
  3147                                                          mov     al,eResetSystem                                 ;function code
  3148                                                          int     _svc                                            ;invoke OS service
  3149                                  %endmacro
  3150                                  %macro                  setConsoleString 0
  3151                                                          mov     al,eSetConsoleString                            ;function code
  3152                                                          int     _svc                                            ;invoke OS service
  3153                                  %endmacro
  3154                                  %macro                  unsignedToDecimalString 0
  3155                                                          mov     al,eUnsignedToDecimalString                     ;function code
  3156                                                          int     _svc                                            ;invoke OS service
  3157                                  %endmacro
  3158                                  %macro                  unsignedToHexadecimal 0
  3159                                                          mov     al,eUnsignedToHexadecimal                       ;function code
  3160                                                          int     _svc                                            ;invoke OS service
  3161                                  %endmacro
  3162                                  %macro                  upperCaseString 0
  3163                                                          mov     al,eUpperCaseString                             ;function code
  3164                                                          int     _svc                                            ;invoke OS service
  3165                                  %endmacro
  3166                                  %macro                  yield 0
  3167                                                          mov     al,eYield                                       ;function code
  3168                                                          int     _svc                                            ;invoke OS service
  3169                                  %endmacro
  3170                                  ;=======================================================================================================================
  3171                                  ;
  3172                                  ;       Kernel Function Library
  3173                                  ;
  3174                                  ;=======================================================================================================================
  3175                                  ;=======================================================================================================================
  3176                                  ;
  3177                                  ;       Date and Time Helper Routines
  3178                                  ;
  3179                                  ;       GetYear
  3180                                  ;       IsLeapYear
  3181                                  ;       PutDateString
  3182                                  ;       PutDayString
  3183                                  ;       PutHourString
  3184                                  ;       PutMinuteString
  3185                                  ;       PutMonthString
  3186                                  ;       PutMonthNameString
  3187                                  ;       PutSecondString
  3188                                  ;       PutTimeString
  3189                                  ;       PutWeekdayString
  3190                                  ;       PutWeekdayNameString
  3191                                  ;       PutYearString
  3192                                  ;
  3193                                  ;=======================================================================================================================
  3194                                  ;-----------------------------------------------------------------------------------------------------------------------
  3195                                  ;
  3196                                  ;       Routine:        GetYear
  3197                                  ;
  3198                                  ;       Description:    Return the four-digit year (century * 100 + year of century)
  3199                                  ;
  3200                                  ;       In:             DS:EBX  DATETIME address
  3201                                  ;
  3202                                  ;       Out:            ECX     year
  3203                                  ;
  3204                                  ;-----------------------------------------------------------------------------------------------------------------------
  3205 00000A06 0FB64B07                GetYear                 movzx   ecx,byte [ebx+DATETIME.century]                 ;century
  3206 00000A0A 6BC964                                          imul    ecx,100                                         ;century * 100
  3207 00000A0D 0FB64306                                        movzx   eax,byte [ebx+DATETIME.year]                    ;year of century
  3208 00000A11 01C1                                            add     ecx,eax                                         ;year (YYYY)
  3209 00000A13 C3                                              ret                                                     ;return
  3210                                  ;-----------------------------------------------------------------------------------------------------------------------
  3211                                  ;
  3212                                  ;       Routine:        IsLeapYear
  3213                                  ;
  3214                                  ;       Description:    This routine returns an indicator if the current year is a leap year.
  3215                                  ;
  3216                                  ;       In:             DS:EBX  DATETIME ADDRESS
  3217                                  ;
  3218                                  ;       Out:            ECX     0 = not a leap year
  3219                                  ;                               1 = leap year
  3220                                  ;
  3221                                  ;-----------------------------------------------------------------------------------------------------------------------
  3222 00000A14 E8EDFFFFFF              IsLeapYear              call    GetYear                                         ;ECX = YYYY
  3223 00000A19 89C8                                            mov     eax,ecx                                         ;EAX = YYYY
  3224 00000A1B 31C9                                            xor     ecx,ecx                                         ;assume not leap year
  3225 00000A1D A803                                            test    al,00000011b                                    ;multiple of four?
  3226 00000A1F 750D                                            jnz     .no                                             ;no, branch
  3227 00000A21 B264                                            mov     dl,100                                          ;divisor
  3228 00000A23 F6F2                                            div     dl                                              ;divide by 100
  3229 00000A25 84E4                                            test    ah,ah                                           ;multiple of 100?
  3230 00000A27 7504                                            jnz     .yes                                            ;yes, branch
  3231 00000A29 A803                                            test    al,00000011b                                    ;multiple of 400?
  3232 00000A2B 7501                                            jnz     .no                                             ;no, branch
  3233 00000A2D 41                      .yes                    inc     ecx                                             ;indicate leap
  3234 00000A2E C3                      .no                     ret                                                     ;return
  3235                                  ;-----------------------------------------------------------------------------------------------------------------------
  3236                                  ;
  3237                                  ;       Routine:        PutDateString
  3238                                  ;
  3239                                  ;       Description:    This routine returns an ASCIIZ mm/dd/yyyy string at ds:edx from the date in the DATETIME
  3240                                  ;                       structure at ds:ebx.
  3241                                  ;
  3242                                  ;       In:             DS:EBX  DATETIME address
  3243                                  ;                       DS:EDX  output buffer address
  3244                                  ;
  3245                                  ;-----------------------------------------------------------------------------------------------------------------------
  3246 00000A2F 51                      PutDateString           push    ecx                                             ;save non-volatile regs
  3247 00000A30 57                                              push    edi                                             ;
  3248 00000A31 06                                              push    es                                              ;
  3249 00000A32 1E                                              push    ds                                              ;store data selector ...
  3250 00000A33 07                                              pop     es                                              ;... in extra segment reg
  3251 00000A34 89D7                                            mov     edi,edx                                         ;output buffer address
  3252 00000A36 B10A                                            mov     cl,10                                           ;divisor
  3253 00000A38 BA30302F00                                      mov     edx,0002F3030h                                  ;ASCIIZ "00/" (reversed)
  3254 00000A3D 0FB64305                                        movzx   eax,byte [ebx+DATETIME.month]                   ;month
  3255 00000A41 F6F1                                            div     cl                                              ;AH = rem; AL = quotient
  3256 00000A43 09D0                                            or      eax,edx                                         ;apply ASCII zones and delimiter
  3257 00000A45 FC                                              cld                                                     ;forward strings
  3258 00000A46 AB                                              stosd                                                   ;store "mm/"nul
  3259 00000A47 4F                                              dec     edi                                             ;address of terminator
  3260 00000A48 0FB64304                                        movzx   eax,byte [ebx+DATETIME.day]                     ;day
  3261 00000A4C F6F1                                            div     cl                                              ;AH = rem; AL = quotient
  3262 00000A4E 09D0                                            or      eax,edx                                         ;apply ASCII zones and delimiter
  3263 00000A50 AB                                              stosd                                                   ;store "dd/"nul
  3264 00000A51 4F                                              dec     edi                                             ;address of terminator
  3265 00000A52 0FB64307                                        movzx   eax,byte [ebx+DATETIME.century]                 ;century
  3266 00000A56 F6F1                                            div     cl                                              ;AH = rem; AL = quotient
  3267 00000A58 09D0                                            or      eax,edx                                         ;apply ASCII zones and delimiter
  3268 00000A5A AB                                              stosd                                                   ;store "cc/"null
  3269 00000A5B 4F                                              dec     edi                                             ;address of terminator
  3270 00000A5C 4F                                              dec     edi                                             ;address of delimiter
  3271 00000A5D 0FB64306                                        movzx   eax,byte [ebx+DATETIME.year]                    ;year (yy)
  3272 00000A61 F6F1                                            div     cl                                              ;AH = rem; AL = quotient
  3273 00000A63 09D0                                            or      eax,edx                                         ;apply ASCII zones and delimiter
  3274 00000A65 AA                                              stosb                                                   ;store quotient
  3275 00000A66 88E0                                            mov     al,ah                                           ;remainder
  3276 00000A68 AA                                              stosb                                                   ;store remainder
  3277 00000A69 30C0                                            xor     al,al                                           ;null terminator
  3278 00000A6B AA                                              stosb                                                   ;store terminator
  3279 00000A6C 07                                              pop     es                                              ;restore non-volatile regs
  3280 00000A6D 5F                                              pop     edi                                             ;
  3281 00000A6E 59                                              pop     ecx                                             ;
  3282 00000A6F C3                                              ret                                                     ;return
  3283                                  ;-----------------------------------------------------------------------------------------------------------------------
  3284                                  ;
  3285                                  ;       Routine:        PutDayString
  3286                                  ;
  3287                                  ;       Description:    This routine returns an ASCIIZ dd string at ds:edx from the date in the DATETIME
  3288                                  ;                       structure at ds:ebx.
  3289                                  ;
  3290                                  ;       In:             DS:EBX  DATETIME address
  3291                                  ;                       DS:EDX  output buffer address
  3292                                  ;
  3293                                  ;-----------------------------------------------------------------------------------------------------------------------
  3294 00000A70 51                      PutDayString            push    ecx                                             ;save non-volatile regs
  3295 00000A71 0FB64B04                                        movzx   ecx,byte [ebx+DATETIME.day]                     ;day
  3296 00000A75 B701                                            mov     bh,1                                            ;trim leading zeros; no commas
  3297 00000A77 E81D070000                                      call    UnsignedToDecimalString                         ;store ASCII decimal string
  3298 00000A7C 59                                              pop     ecx                                             ;
  3299 00000A7D C3                                              ret                                                     ;return
  3300                                  ;-----------------------------------------------------------------------------------------------------------------------
  3301                                  ;
  3302                                  ;       Routine:        PutHourString
  3303                                  ;
  3304                                  ;       Description:    This routine returns an ASCIIZ hh string at ds:edx from the date in the DATETIME
  3305                                  ;                       structure at ds:ebx.
  3306                                  ;
  3307                                  ;       In:             DS:EBX  DATETIME address
  3308                                  ;                       DS:EDX  output buffer address
  3309                                  ;
  3310                                  ;-----------------------------------------------------------------------------------------------------------------------
  3311 00000A7E 51                      PutHourString           push    ecx                                             ;save non-volatile regs
  3312 00000A7F 0FB64B02                                        movzx   ecx,byte [ebx+DATETIME.hour]                    ;hour
  3313 00000A83 B701                                            mov     bh,1                                            ;trim leading zeros; no commas
  3314 00000A85 E80F070000                                      call    UnsignedToDecimalString                         ;store ASCII decimal string
  3315 00000A8A 59                                              pop     ecx                                             ;
  3316 00000A8B C3                                              ret                                                     ;return
  3317                                  ;-----------------------------------------------------------------------------------------------------------------------
  3318                                  ;
  3319                                  ;       Routine:        PutMinuteString
  3320                                  ;
  3321                                  ;       Description:    This routine returns an ASCIIZ mm string at ds:edx from the date in the DATETIME
  3322                                  ;                       structure at ds:ebx.
  3323                                  ;
  3324                                  ;       In:             DS:EBX  DATETIME address
  3325                                  ;                       DS:EDX  output buffer address
  3326                                  ;
  3327                                  ;-----------------------------------------------------------------------------------------------------------------------
  3328 00000A8C 51                      PutMinuteString         push    ecx                                             ;save non-volatile regs
  3329 00000A8D 0FB64B01                                        movzx   ecx,byte [ebx+DATETIME.minute]                  ;minute
  3330 00000A91 B701                                            mov     bh,1                                            ;trim leading zeros; no commas
  3331 00000A93 E801070000                                      call    UnsignedToDecimalString                         ;store ASCII decimal string
  3332 00000A98 59                                              pop     ecx                                             ;
  3333 00000A99 C3                                              ret                                                     ;return
  3334                                  ;-----------------------------------------------------------------------------------------------------------------------
  3335                                  ;
  3336                                  ;       Routine:        PutMonthString
  3337                                  ;
  3338                                  ;       Description:    This routine returns an ASCIIZ mm string at ds:edx from the date in the DATETIME
  3339                                  ;                       structure at ds:ebx.
  3340                                  ;
  3341                                  ;       In:             DS:EBX  DATETIME address
  3342                                  ;                       DS:EDX  output buffer address
  3343                                  ;
  3344                                  ;-----------------------------------------------------------------------------------------------------------------------
  3345 00000A9A 51                      PutMonthString          push    ecx                                             ;save non-volatile regs
  3346 00000A9B 0FB64B05                                        movzx   ecx,byte [ebx+DATETIME.month]                   ;month
  3347 00000A9F B701                                            mov     bh,1                                            ;trim leading zeros; no commas
  3348 00000AA1 E8F3060000                                      call    UnsignedToDecimalString                         ;store ASCII decimal string
  3349 00000AA6 59                                              pop     ecx                                             ;
  3350 00000AA7 C3                                              ret                                                     ;return
  3351                                  ;-----------------------------------------------------------------------------------------------------------------------
  3352                                  ;
  3353                                  ;       Routine:        PutMonthNameString
  3354                                  ;
  3355                                  ;       Description:    This routine returns an ASCIIZ name(mm) string at ds:edx from the date in the DATETIME
  3356                                  ;                       structure at ds:ebx.
  3357                                  ;
  3358                                  ;       In:             DS:EBX  DATETIME address
  3359                                  ;                       DS:EDX  output buffer address
  3360                                  ;
  3361                                  ;-----------------------------------------------------------------------------------------------------------------------
  3362 00000AA8 56                      PutMonthNameString      push    esi                                             ;save non-volatile regs
  3363 00000AA9 57                                              push    edi                                             ;
  3364 00000AAA 1E                                              push    ds                                              ;
  3365 00000AAB 06                                              push    es                                              ;
  3366 00000AAC 1E                                              push    ds                                              ;load data selector ...
  3367 00000AAD 07                                              pop     es                                              ;... into extra segment
  3368 00000AAE 89D7                                            mov     edi,edx                                         ;output buffer address
  3369 00000AB0 0FB64305                                        movzx   eax,byte [ebx+DATETIME.month]                   ;month (1-12)
  3370 00000AB4 48                                              dec     eax                                             ;month (0-11)
  3371 00000AB5 C1E002                                          shl     eax,2                                           ;offset into month name lookup table
  3372 00000AB8 0E                                              push    cs                                              ;load code selector ...
  3373 00000AB9 1F                                              pop     ds                                              ;... into data segment
  3374 00000ABA 8BB0[FC0B0000]                                  mov     esi,[tMonthNames+eax]                           ;month name address
  3375 00000AC0 FC                                              cld                                                     ;forward strings
  3376 00000AC1 AC                      .10                     lodsb                                                   ;name character
  3377 00000AC2 AA                                              stosb                                                   ;store in output buffer
  3378 00000AC3 84C0                                            test    al,al                                           ;end of string?
  3379 00000AC5 75FA                                            jnz     .10                                             ;no, continue
  3380 00000AC7 07                                              pop     es                                              ;restore non-volatile regs
  3381 00000AC8 1F                                              pop     ds                                              ;
  3382 00000AC9 5F                                              pop     edi                                             ;
  3383 00000ACA 5E                                              pop     esi                                             ;
  3384 00000ACB C3                                              ret                                                     ;return
  3385                                  ;-----------------------------------------------------------------------------------------------------------------------
  3386                                  ;
  3387                                  ;       Routine:        PutSecondString
  3388                                  ;
  3389                                  ;       Description:    This routine returns an ASCIIZ ss string at ds:edx from the date in the DATETIME
  3390                                  ;                       structure at ds:ebx.
  3391                                  ;
  3392                                  ;       In:             DS:EBX  DATETIME address
  3393                                  ;                       DS:EDX  output buffer address
  3394                                  ;
  3395                                  ;-----------------------------------------------------------------------------------------------------------------------
  3396 00000ACC 51                      PutSecondString         push    ecx                                             ;save non-volatile regs
  3397 00000ACD 0FB60B                                          movzx   ecx,byte [ebx+DATETIME.second]                  ;second
  3398 00000AD0 B701                                            mov     bh,1                                            ;trim leading zeros; no commas
  3399 00000AD2 E8C2060000                                      call    UnsignedToDecimalString                         ;store ASCII decimal string
  3400 00000AD7 59                                              pop     ecx                                             ;
  3401 00000AD8 C3                                              ret                                                     ;return
  3402                                  ;-----------------------------------------------------------------------------------------------------------------------
  3403                                  ;
  3404                                  ;       Routine:        PutTimeString
  3405                                  ;
  3406                                  ;       Description:    This routine returns an ASCIIZ hh:mm:ss string at ds:edx from the date in the DATETIME
  3407                                  ;                       structure at ds:ebx.
  3408                                  ;
  3409                                  ;       In:             DS:EBX  DATETIME address
  3410                                  ;                       DS:EDX  output buffer address
  3411                                  ;
  3412                                  ;-----------------------------------------------------------------------------------------------------------------------
  3413 00000AD9 51                      PutTimeString           push    ecx                                             ;save non-volatile regs
  3414 00000ADA 57                                              push    edi                                             ;
  3415 00000ADB 06                                              push    es                                              ;
  3416 00000ADC 1E                                              push    ds                                              ;store data selector ...
  3417 00000ADD 07                                              pop     es                                              ;... in extra segment reg
  3418 00000ADE 89D7                                            mov     edi,edx                                         ;output buffer address
  3419 00000AE0 B10A                                            mov     cl,10                                           ;divisor
  3420 00000AE2 BA30303A00                                      mov     edx,003a3030h                                   ;ASCIIZ "00:" (reversed)
  3421 00000AE7 0FB64302                                        movzx   eax,byte [ebx+DATETIME.hour]                    ;hour
  3422 00000AEB F6F1                                            div     cl                                              ;ah = rem; al = quotient
  3423 00000AED 09D0                                            or      eax,edx                                         ;apply ASCII zones and delimiter
  3424 00000AEF FC                                              cld                                                     ;forward strings
  3425 00000AF0 AB                                              stosd                                                   ;store "mm/"nul
  3426 00000AF1 4F                                              dec     edi                                             ;address of terminator
  3427 00000AF2 0FB64301                                        movzx   eax,byte [ebx+DATETIME.minute]                  ;minute
  3428 00000AF6 F6F1                                            div     cl                                              ;ah = rem; al = quotient
  3429 00000AF8 09D0                                            or      eax,edx                                         ;apply ASCII zones and delimiter
  3430 00000AFA AB                                              stosd                                                   ;store "dd/"nul
  3431 00000AFB 4F                                              dec     edi                                             ;address of terminator
  3432 00000AFC 0FB603                                          movzx   eax,byte [ebx+DATETIME.second]                  ;second
  3433 00000AFF F6F1                                            div     cl                                              ;ah = rem; al = quotient
  3434 00000B01 09D0                                            or      eax,edx                                         ;apply ASCII zones and delimiter
  3435 00000B03 AA                                              stosb                                                   ;store quotient
  3436 00000B04 88E0                                            mov     al,ah                                           ;remainder
  3437 00000B06 AA                                              stosb                                                   ;store remainder
  3438 00000B07 30C0                                            xor     al,al                                           ;null terminator
  3439 00000B09 AA                                              stosb                                                   ;store terminator
  3440 00000B0A 07                                              pop     es                                              ;restore non-volatile regs
  3441 00000B0B 5F                                              pop     edi                                             ;
  3442 00000B0C 59                                              pop     ecx                                             ;
  3443 00000B0D C3                                              ret                                                     ;return
  3444                                  ;-----------------------------------------------------------------------------------------------------------------------
  3445                                  ;
  3446                                  ;       Routine:        PutWeekdayString
  3447                                  ;
  3448                                  ;       Description:    This routine returns an ASCIIZ weekday string at ds:edx from the date in the DATETIME
  3449                                  ;                       structure at ds:ebx.
  3450                                  ;
  3451                                  ;       In:             DS:EBX  DATETIME address
  3452                                  ;                       DS:EDX  output buffer address
  3453                                  ;
  3454                                  ;-----------------------------------------------------------------------------------------------------------------------
  3455 00000B0E 51                      PutWeekdayString        push    ecx                                             ;save non-volatile regs
  3456 00000B0F 0FB64B03                                        movzx   ecx,byte [ebx+DATETIME.weekday]                 ;weekday
  3457 00000B13 B701                                            mov     bh,1                                            ;trim leading zeros; no commas
  3458 00000B15 E87F060000                                      call    UnsignedToDecimalString                         ;store ASCII decimal string
  3459 00000B1A 59                                              pop     ecx                                             ;
  3460 00000B1B C3                                              ret                                                     ;return
  3461                                  ;-----------------------------------------------------------------------------------------------------------------------
  3462                                  ;
  3463                                  ;       Routine:        PutWeekdayNameString
  3464                                  ;
  3465                                  ;       Description:    This routine returns an ASCIIZ name(weekday) string at ds:edx from the date in the DATETIME
  3466                                  ;                       structure at ds:ebx.
  3467                                  ;
  3468                                  ;       In:             DS:EBX  DATETIME address
  3469                                  ;                       DS:EDX  output buffer address
  3470                                  ;
  3471                                  ;-----------------------------------------------------------------------------------------------------------------------
  3472 00000B1C 56                      PutWeekdayNameString    push    esi                                             ;save non-volatile regs
  3473 00000B1D 57                                              push    edi                                             ;
  3474 00000B1E 1E                                              push    ds                                              ;
  3475 00000B1F 06                                              push    es                                              ;
  3476 00000B20 1E                                              push    ds                                              ;load data selector ...
  3477 00000B21 07                                              pop     es                                              ;... into extra segment
  3478 00000B22 89D7                                            mov     edi,edx                                         ;output buffer address
  3479 00000B24 0FB64303                                        movzx   eax,byte [ebx+DATETIME.weekday]                 ;weekday (0-6)
  3480 00000B28 C1E002                                          shl     eax,2                                           ;offset into day name lookup table
  3481 00000B2B 0E                                              push    cs                                              ;load code selector ...
  3482 00000B2C 1F                                              pop     ds                                              ;... into data segment
  3483 00000B2D 8BB0[E00B0000]                                  mov     esi,[tDayNames+eax]                             ;day name address
  3484 00000B33 FC                                              cld                                                     ;forward strings
  3485 00000B34 AC                      .10                     lodsb                                                   ;name character
  3486 00000B35 AA                                              stosb                                                   ;store in output buffer
  3487 00000B36 84C0                                            test    al,al                                           ;end of string?
  3488 00000B38 75FA                                            jnz     .10                                             ;no, continue
  3489 00000B3A 07                                              pop     es                                              ;restore non-volatile regs
  3490 00000B3B 1F                                              pop     ds                                              ;
  3491 00000B3C 5F                                              pop     edi                                             ;
  3492 00000B3D 5E                                              pop     esi                                             ;
  3493 00000B3E C3                                              ret                                                     ;return
  3494                                  ;-----------------------------------------------------------------------------------------------------------------------
  3495                                  ;
  3496                                  ;       Routine:        PutYearString
  3497                                  ;
  3498                                  ;       Description:    This routine returns an ASCIIZ yyyy string at ds:edx from the date in the DATETIME
  3499                                  ;                       structure at ds:ebx.
  3500                                  ;
  3501                                  ;       In:             DS:EBX  DATETIME address
  3502                                  ;                       DS:EDX  output buffer address
  3503                                  ;
  3504                                  ;-----------------------------------------------------------------------------------------------------------------------
  3505 00000B3F 51                      PutYearString           push    ecx                                             ;save non-volatile regs
  3506 00000B40 E8C1FEFFFF                                      call    GetYear                                         ;ECX = YYYY
  3507 00000B45 B701                                            mov     bh,1                                            ;trim leading zeros; no commas
  3508 00000B47 E84D060000                                      call    UnsignedToDecimalString                         ;store decimal string at DS:EDX
  3509 00000B4C 59                                              pop     ecx                                             ;restore non-volatile regs
  3510 00000B4D C3                                              ret                                                     ;return
  3511                                  ;-----------------------------------------------------------------------------------------------------------------------
  3512                                  ;
  3513                                  ;       Day Names
  3514                                  ;
  3515                                  ;-----------------------------------------------------------------------------------------------------------------------
  3516 00000B4E 53756E64617900          czSunday                db      "Sunday",0
  3517 00000B55 4D6F6E64617900          czMonday                db      "Monday",0
  3518 00000B5C 5475657364617900        czTuesday               db      "Tuesday",0
  3519 00000B64 5765646E6573646179-     czWednesday             db      "Wednesday",0
  3519 00000B6D 00                 
  3520 00000B6E 546875727364617900      czThursday              db      "Thursday",0
  3521 00000B77 46726964617900          czFriday                db      "Friday",0
  3522 00000B7E 536174757264617900      czSaturday              db      "Saturday",0
  3523                                  ;-----------------------------------------------------------------------------------------------------------------------
  3524                                  ;
  3525                                  ;       Month Names
  3526                                  ;
  3527                                  ;-----------------------------------------------------------------------------------------------------------------------
  3528 00000B87 4A616E7561727900        czJanuary               db      "January",0
  3529 00000B8F 466562727561727900      czFebruary              db      "February",0
  3530 00000B98 4D6172636800            czMarch                 db      "March",0
  3531 00000B9E 417072696C00            czApril                 db      "April",0
  3532 00000BA4 4D617900                czMay                   db      "May",0
  3533 00000BA8 4A756E6500              czJune                  db      "June",0
  3534 00000BAD 4A756C7900              czJuly                  db      "July",0
  3535 00000BB2 41756775737400          czAugust                db      "August",0
  3536 00000BB9 53657074656D626572-     czSeptember             db      "September",0
  3536 00000BC2 00                 
  3537 00000BC3 4F63746F62657200        czOctober               db      "October",0
  3538 00000BCB 4E6F76656D62657200      czNovember              db      "November",0
  3539 00000BD4 446563656D62657200      czDecember              db      "December",0
  3540                                  ;-----------------------------------------------------------------------------------------------------------------------
  3541                                  ;
  3542                                  ;       Day Names Lookup Table
  3543                                  ;
  3544                                  ;-----------------------------------------------------------------------------------------------------------------------
  3545 00000BDD 90<rept>                                        align   4
  3546                                  tDayNames               equ     $
  3547 00000BE0 [4E0B0000]                                      dd      czSunday
  3548 00000BE4 [550B0000]                                      dd      czMonday
  3549 00000BE8 [5C0B0000]                                      dd      czTuesday
  3550 00000BEC [640B0000]                                      dd      czWednesday
  3551 00000BF0 [6E0B0000]                                      dd      czThursday
  3552 00000BF4 [770B0000]                                      dd      czFriday
  3553 00000BF8 [7E0B0000]                                      dd      czSaturday
  3554                                  EDAYNAMESTBLL           equ     ($-tDayNames)
  3555                                  EDAYNAMESTBLCNT         equ     EDAYNAMESTBLL/4
  3556                                  ;-----------------------------------------------------------------------------------------------------------------------
  3557                                  ;
  3558                                  ;       Month Names Lookup Table
  3559                                  ;
  3560                                  ;-----------------------------------------------------------------------------------------------------------------------
  3561                                                          align   4
  3562                                  tMonthNames             equ     $
  3563 00000BFC [870B0000]                                      dd      czJanuary
  3564 00000C00 [8F0B0000]                                      dd      czFebruary
  3565 00000C04 [980B0000]                                      dd      czMarch
  3566 00000C08 [9E0B0000]                                      dd      czApril
  3567 00000C0C [A40B0000]                                      dd      czMay
  3568 00000C10 [A80B0000]                                      dd      czJune
  3569 00000C14 [AD0B0000]                                      dd      czJuly
  3570 00000C18 [B20B0000]                                      dd      czAugust
  3571 00000C1C [B90B0000]                                      dd      czSeptember
  3572 00000C20 [C30B0000]                                      dd      czOctober
  3573 00000C24 [CB0B0000]                                      dd      czNovember
  3574 00000C28 [D40B0000]                                      dd      czDecember
  3575                                  EMONTHNAMESTBLL         equ     ($-tMonthNames)
  3576                                  EMONTHNAMESTBLCNT       equ     EMONTHNAMESTBLL/4
  3577                                  ;=======================================================================================================================
  3578                                  ;
  3579                                  ;       Memory Helper Routines
  3580                                  ;
  3581                                  ;       AllocateMemory
  3582                                  ;       FreeMemory
  3583                                  ;
  3584                                  ;=======================================================================================================================
  3585                                  ;-----------------------------------------------------------------------------------------------------------------------
  3586                                  ;
  3587                                  ;       Routine:        AllocateMemory
  3588                                  ;
  3589                                  ;       Description:    This routine allocates a memory block for the given task.
  3590                                  ;
  3591                                  ;       In:             ECX     bytes of memory to allocate
  3592                                  ;
  3593                                  ;       Out:            EAX     !0      address of user portion of newly allocated memory block
  3594                                  ;                               0       unable to allocate memory
  3595                                  ;
  3596                                  ;-----------------------------------------------------------------------------------------------------------------------
  3597 00000C2C 53                      AllocateMemory          push    ebx                                             ;save non-volatile regs
  3598 00000C2D 51                                              push    ecx                                             ;
  3599 00000C2E 56                                              push    esi                                             ;
  3600 00000C2F 1E                                              push    ds                                              ;
  3601                                  ;
  3602                                  ;       Address kernel memory structures
  3603                                  ;
  3604 00000C30 6A18                                            push    EGDTOSDATA                                      ;load OS data GDT selector ...
  3605 00000C32 1F                                              pop     ds                                              ;... into data segment reg
  3606 00000C33 BE5D0B0000                                      mov     esi,wsConsoleMemRoot                            ;memory root structure address
  3607                                  ;
  3608                                  ;       Set requested size to minimum block size if requested size is too small.
  3609                                  ;
  3610 00000C38 81F900010000                                    cmp     ecx,EMEMMINSIZE                                 ;is requested size too small?
  3611 00000C3E 7305                                            jae     .10                                             ;no, branch
  3612 00000C40 B900010000                                      mov     ecx,EMEMMINSIZE                                 ;set requested size to minimum
  3613 00000C45 83C120                  .10                     add     ecx,EMEMBLOCKLEN                                ;add header block length
  3614                                  ;
  3615                                  ;       Find the first free memory block large enough to satisfy the request.
  3616                                  ;
  3617 00000C48 8B4608                                          mov     eax,[esi+MEMROOT.firstfree]                     ;first free block ptr
  3618 00000C4B 85C0                    .20                     test    eax,eax                                         ;end of free block chain?
  3619 00000C4D 0F84F2000000                                    jz      .220                                            ;yes, branch
  3620 00000C53 3B4804                                          cmp     ecx,[eax+MEMBLOCK.bytes]                        ;free block big enough?
  3621 00000C56 7605                                            jbe     .30                                             ;yes, branch
  3622 00000C58 8B4018                                          mov     eax,[eax+MEMBLOCK.nextblock]                    ;next free block addr
  3623 00000C5B EBEE                                            jmp     .20                                             ;continue
  3624                                  ;-----------------------------------------------------------------------------------------------------------------------
  3625                                  ;
  3626                                  ;       Address the previous and next free memory blocks.
  3627                                  ;
  3628 00000C5D 8B581C                  .30                     mov     ebx,[eax+MEMBLOCK.previousblock]                ;previous free block addr
  3629 00000C60 8B5018                                          mov     edx,[eax+MEMBLOCK.nextblock]                    ;next free block addr
  3630                                  ;
  3631                                  ;       Remove the free memory block from the forward free memory block chain.
  3632                                  ;
  3633 00000C63 85DB                                            test    ebx,ebx                                         ;any previous free memory block?
  3634 00000C65 7405                                            jz      .40                                             ;no, branch
  3635 00000C67 895318                                          mov     [ebx+MEMBLOCK.nextblock],edx                    ;remove free block from forwrad chain
  3636 00000C6A EB03                                            jmp     .50                                             ;continue
  3637 00000C6C 895608                  .40                     mov     [esi+MEMROOT.firstfree],edx                     ;next free is now also the first free
  3638                                  ;
  3639                                  ;       Remove the free memory block from the reverse free memory block chain.
  3640                                  ;
  3641 00000C6F 85D2                    .50                     test    edx,edx                                         ;any next free memory block?
  3642 00000C71 7405                                            jz      .60                                             ;no, branch
  3643 00000C73 895A1C                                          mov     [edx+MEMBLOCK.previousblock],ebx                ;remove free block from reverse chain
  3644 00000C76 EB03                                            jmp     .70                                             ;continue
  3645 00000C78 895E0C                  .60                     mov     [esi+MEMROOT.lastfree],ebx                      ;previous free is now also the last free
  3646                                  ;-----------------------------------------------------------------------------------------------------------------------
  3647                                  ;
  3648                                  ;       Determine if the free memory block can be split.
  3649                                  ;
  3650 00000C7B 8B5804                  .70                     mov     ebx,[eax+MEMBLOCK.bytes]                        ;size of free memory block
  3651 00000C7E 29CB                                            sub     ebx,ecx                                         ;subtract requested memory size
  3652 00000C80 81FB00010000                                    cmp     ebx,EMEMMINSIZE                                 ;remaining block can stand alone?
  3653 00000C86 7263                                            jb      .150                                            ;no, branch
  3654                                  ;
  3655                                  ;       We know that our block can be split to create a new free memory block. We update the size of our free memory
  3656                                  ;       block to the requested memory size. We update the next contiguous block pointer to point just past the end
  3657                                  ;       of the requested memory size.
  3658                                  ;
  3659 00000C88 894804                                          mov     [eax+MEMBLOCK.bytes],ecx                        ;shorten memory block size
  3660 00000C8B 89C2                                            mov     edx,eax                                         ;memory block address
  3661 00000C8D 01CA                                            add     edx,ecx                                         ;address new new next contig block
  3662 00000C8F 8B4810                                          mov     ecx,[eax+MEMBLOCK.nextcontig]                   ;next contig block address
  3663 00000C92 895010                                          mov     [eax+MEMBLOCK.nextcontig],edx                   ;update next contig block address
  3664                                  ;
  3665                                  ;       If there is a next contiguous block, we update that memory block's previous contig pointer to point to the new
  3666                                  ;       free block we are splitting off. If there is no next contiguous block, we update the last contig block pointer.
  3667                                  ;
  3668 00000C95 E305                                            jecxz   .80                                             ;no next contig, branch
  3669 00000C97 895114                                          mov     [ecx+MEMBLOCK.previouscontig],edx               ;update previous contig pointer
  3670 00000C9A EB03                                            jmp     .90                                             ;continue
  3671 00000C9C 895604                  .80                     mov     [esi+MEMROOT.lastcontig],edx                    ;update last contig pointer
  3672                                  ;
  3673                                  ;       Now that the contig block pointers have been updated, we initialize the new free block members.
  3674                                  ;
  3675 00000C9F 895A04                  .90                     mov     [edx+MEMBLOCK.bytes],ebx                        ;set the block size
  3676 00000CA2 894A10                                          mov     [edx+MEMBLOCK.nextcontig],ecx                   ;set the next contig block addr
  3677 00000CA5 894214                                          mov     [edx+MEMBLOCK.previouscontig],eax               ;set the previous contig block addr
  3678 00000CA8 BB46524545                                      mov     ebx,EMEMFREECODE                                ;free memory signature
  3679 00000CAD 891A                                            mov     [edx+MEMBLOCK.signature],ebx                    ;set the block signature
  3680 00000CAF 31DB                                            xor     ebx,ebx                                         ;zero register
  3681 00000CB1 895A0C                                          mov     [edx+MEMBLOCK.reserved],ebx                     ;set reserved
  3682 00000CB4 895A08                                          mov     [edx+MEMBLOCK.owner],ebx                        ;set the owner
  3683                                  ;
  3684                                  ;       Find the proper location in the free block chain for the new free block
  3685                                  ;
  3686 00000CB7 8B5A04                                          mov     ebx,[edx+MEMBLOCK.bytes]                        ;free block size
  3687 00000CBA 8B4E08                                          mov     ecx,[esi+MEMROOT.firstfree]                     ;first free block addr
  3688 00000CBD E30A                    .100                    jecxz   .110                                            ;branch if at end of chain
  3689 00000CBF 3B5904                                          cmp     ebx,[ecx+MEMBLOCK.bytes]                        ;new block smaller or equal?
  3690 00000CC2 7605                                            jbe     .110                                            ;yes, branch
  3691 00000CC4 8B4918                                          mov     ecx,[ecx+MEMBLOCK.nextblock]                    ;next free block addr
  3692 00000CC7 EBF4                                            jmp     .100                                            ;continue
  3693                                  ;
  3694                                  ;       Having found the proper location for our new free block, we store the address of the following free block, or
  3695                                  ;       zero if our new free block is larger than any other, as our next free block. Then, we take the address of our
  3696                                  ;       next block's previous block or the global last-free block as our new previous block and update the previous
  3697                                  ;       block of hte next block, if there is one.
  3698                                  ;
  3699 00000CC9 894A18                  .110                    mov     [edx+MEMBLOCK.nextblock],ecx                    ;set the new free block's next ptr
  3700 00000CCC 8B5E0C                                          mov     ebx,[esi+MEMROOT.lastfree]                      ;last free block addr
  3701 00000CCF E308                                            jecxz   .120                                            ;branch if no next block
  3702 00000CD1 8B591C                                          mov     ebx,[ecx+MEMBLOCK.previousblock]                ;next block's previous block
  3703 00000CD4 89511C                                          mov     [ecx+MEMBLOCK.previousblock],edx                ;set the next block's previous block
  3704 00000CD7 EB03                                            jmp     .130                                            ;continue
  3705 00000CD9 89560C                  .120                    mov     [esi+MEMROOT.lastfree],edx                      ;set the new last free block
  3706                                  ;
  3707                                  ;       Store our previous block pointer. If we have a previous free block, update that block's next block pointer to
  3708                                  ;       point to the new block. Since the new block may now be the first or last user block, we update the first and/or
  3709                                  ;       last user block pointers if necessary.
  3710                                  ;
  3711 00000CDC 895A1C                  .130                    mov     [edx+MEMBLOCK.previousblock],ebx                ;set the previous block pointer
  3712 00000CDF 85DB                                            test    ebx,ebx                                         ;is there a previous block?
  3713 00000CE1 7405                                            jz      .140                                            ;no, branch
  3714 00000CE3 895318                                          mov     [ebx+MEMBLOCK.nextblock],edx                    ;set the previous block's next ptr
  3715 00000CE6 EB03                                            jmp     .150                                            ;continue
  3716 00000CE8 895608                  .140                    mov     [esi+MEMROOT.firstfree],edx                     ;set the new first free ptr
  3717                                  ;
  3718                                  ;       Update the newly allocated block's owner and signature.
  3719                                  ;
  3720 00000CEB BA55534552              .150                    mov     edx,EMEMUSERCODE                                ;user memory signature
  3721 00000CF0 8910                                            mov     [eax+MEMBLOCK.signature],edx                    ;set the block signature
  3722 00000CF2 31D2                                            xor     edx,edx                                         ;zero register
  3723 00000CF4 660F00CA                                        str     dx                                              ;load the task state register
  3724 00000CF8 895008                                          mov     [eax+MEMBLOCK.owner],edx                        ;set the block owner
  3725                                  ;
  3726                                  ;       Remove the allocated block from the free block chain and insert it into the user block chain.
  3727                                  ;
  3728 00000CFB 8B4E10                                          mov     ecx,[esi+MEMROOT.firsttask]                     ;first task block
  3729 00000CFE E323                    .160                    jecxz   .180                                            ;branch if at end of chain
  3730 00000D00 3B5108                                          cmp     edx,[ecx+MEMBLOCK.owner]                        ;does this block belong to the task?
  3731 00000D03 721E                                            jb      .180                                            ;branch if block belongs to next task
  3732 00000D05 7405                                            je      .170                                            ;branch if block belongs to this task
  3733 00000D07 8B4918                                          mov     ecx,[ecx+MEMBLOCK.nextblock]                    ;next task block
  3734 00000D0A EBF2                                            jmp     .160                                            ;continue
  3735                                  ;
  3736                                  ;       We have found the start of our task's user block chain or the start of the next task's user block chain. If we
  3737                                  ;       have found the next task's chain, then we have no other user memory for this task and we can simply add the
  3738                                  ;       block here. If we are at the start of our task's user block chain, then we need to further seek for the proper
  3739                                  ;       place to insert the block.
  3740                                  ;
  3741 00000D0C 8B5004                  .170                    mov     edx,[eax+MEMBLOCK.bytes]                        ;size of block in bytes
  3742 00000D0F 3B5104                                          cmp     edx,[ecx+MEMBLOCK.bytes]                        ;less or equal to chain block?
  3743 00000D12 760F                                            jbe     .180                                            ;yes, branch
  3744 00000D14 8B4918                                          mov     ecx,[ecx+MEMBLOCK.nextblock]                    ;next chain block address
  3745 00000D17 85C9                                            test    ecx,ecx                                         ;end of chain?
  3746 00000D19 7408                                            jz      .180                                            ;yes, branch
  3747 00000D1B 8B5008                                          mov     edx,[eax+MEMBLOCK.owner]                        ;owning task
  3748 00000D1E 3B5108                                          cmp     edx,[ecx+MEMBLOCK.owner]                        ;same task?
  3749 00000D21 74E9                                            je      .170                                            ;yes, continue search
  3750                                  ;
  3751                                  ;       We have found the proper place in our task's user-block chain to insert our new user block. It may also be the
  3752                                  ;       end of the user-block chain. To insert our new user block, first we update the next-block pointer. Then, we load
  3753                                  ;       the next-block's previous-block pointer or the global last-user block pointer if we have no next-block. If we
  3754                                  ;       do have a previous-block, we update that block's next-block pointer.
  3755                                  ;
  3756 00000D23 894818                  .180                    mov     [eax+MEMBLOCK.nextblock],ecx                    ;set the next task block
  3757 00000D26 8B5E14                                          mov     ebx,[esi+MEMROOT.lasttask]                      ;last task block
  3758 00000D29 E308                                            jecxz   .190                                            ;branch if no next-task block
  3759 00000D2B 8B591C                                          mov     ebx,[ecx+MEMBLOCK.previousblock]                ;next-task's previous-task block
  3760 00000D2E 89411C                                          mov     [ecx+MEMBLOCK.previousblock],eax                ;update next-task block's previous-task
  3761 00000D31 EB03                                            jmp     .200                                            ;continue
  3762 00000D33 894614                  .190                    mov     [esi+MEMROOT.lasttask],eax                      ;new block is the last user-block
  3763                                  ;
  3764                                  ;       Now wes tore our previous-block pointer and, if we have a previous-free block, we update that block's next-
  3765                                  ;       block pointer to point to our block. Since our block may now be the first or last user-block, we update the
  3766                                  ;       global first and/or last user-block pointers if necessary.
  3767                                  ;
  3768 00000D36 89581C                  .200                    mov     [eax+MEMBLOCK.previousblock],ebx                ;set the previous task block
  3769 00000D39 85DB                                            test    ebx,ebx                                         ;do we have a previous task block?
  3770 00000D3B 7405                                            jz      .210                                            ;no, branch
  3771 00000D3D 894318                                          mov     [ebx+MEMBLOCK.nextblock],eax                    ;set previous-block's next-task block
  3772 00000D40 EB03                                            jmp     .220                                            ;continue
  3773 00000D42 894610                  .210                    mov     [esi+MEMROOT.firsttask],eax                     ;new block is the first user-block
  3774                                  ;
  3775                                  ;       Restore registers and return to caller.
  3776                                  ;
  3777 00000D45 1F                      .220                    pop     ds                                              ;restore non-volatie regs
  3778 00000D46 5E                                              pop     esi                                             ;
  3779 00000D47 59                                              pop     ecx                                             ;
  3780 00000D48 5B                                              pop     ebx                                             ;
  3781 00000D49 C3                                              ret                                                     ;return
  3782                                  ;-----------------------------------------------------------------------------------------------------------------------
  3783                                  ;
  3784                                  ;       Routine:        FreeMemory
  3785                                  ;
  3786                                  ;       Description:    This routine frees a memory block for the given task. The address provided in EDX points to the
  3787                                  ;                       memory block header. The memory block must be USER memory, not a FREE memory block. If the block
  3788                                  ;                       is adjacent to a contiguous FREE memory block, then the blocks are merged. The residual FREE
  3789                                  ;                       memory is repositioned in the FREE memory block chain according to size. The user portion of the
  3790                                  ;                       block, following the block header, is reset (wiped) with the memory wipe value.
  3791                                  ;
  3792                                  ;       In:             EDX     memory block to free, relative to EGDTOSDATA
  3793                                  ;
  3794                                  ;       Out:            EAX     -1      invalid memory block
  3795                                  ;                               0       memory block freed
  3796                                  ;
  3797                                  ;-----------------------------------------------------------------------------------------------------------------------
  3798 00000D4A 53                      FreeMemory              push    ebx                                             ;save non-volatile regs
  3799 00000D4B 51                                              push    ecx                                             ;
  3800 00000D4C 56                                              push    esi                                             ;
  3801 00000D4D 57                                              push    edi                                             ;
  3802 00000D4E 1E                                              push    ds                                              ;
  3803 00000D4F 06                                              push    es                                              ;
  3804                                  ;
  3805                                  ;       Address the root memory structure
  3806                                  ;
  3807 00000D50 6A18                                            push    EGDTOSDATA                                      ;load OS data selector ...
  3808 00000D52 07                                              pop     es                                              ;... into extra segment reg
  3809 00000D53 6A18                                            push    EGDTOSDATA                                      ;load OS data selector ...
  3810 00000D55 1F                                              pop     ds                                              ;... into data segment reg
  3811 00000D56 BE5D0B0000                                      mov     esi,wsConsoleMemRoot                            ;memory root structure
  3812 00000D5B 89D7                                            mov     edi,edx                                         ;memory block address
  3813                                  ;
  3814                                  ;       If the block is FREE, return success. Otherwise, if it is not USER, return with error.
  3815                                  ;
  3816 00000D5D 31C0                                            xor     eax,eax                                         ;indicate success
  3817 00000D5F 813F46524545                                    cmp     dword [edi+MEMBLOCK.signature],EMEMFREECODE     ;is the block FREE?
  3818 00000D65 0F8415010000                                    je      .240                                            ;yes, branch
  3819 00000D6B 48                                              dec     eax                                             ;indicate failure
  3820 00000D6C 813F55534552                                    cmp     dword [edi+MEMBLOCK.signature],EMEMUSERCODE     ;is the block USER?
  3821 00000D72 0F8508010000                                    jne     .240                                            ;no, branch
  3822                                  ;-----------------------------------------------------------------------------------------------------------------------
  3823                                  ;
  3824                                  ;       Unlink the USER memory block.
  3825                                  ;
  3826                                  ;-----------------------------------------------------------------------------------------------------------------------
  3827                                  ;
  3828                                  ;       Set the block signature. Reset owner.
  3829                                  ;
  3830 00000D78 C70746524545                                    mov     dword [edi+MEMBLOCK.signature],EMEMFREECODE     ;set FREE block signature
  3831 00000D7E 31C0                                            xor     eax,eax                                         ;zero register
  3832 00000D80 894708                                          mov     [edi+MEMBLOCK.owner],eax                        ;zero block owner
  3833                                  ;
  3834                                  ;       Wipe user area.
  3835                                  ;
  3836 00000D83 57                                              push    edi                                             ;save block address
  3837 00000D84 8B4F04                                          mov     ecx,[edi+MEMBLOCK.bytes]                        ;block size
  3838 00000D87 83E920                                          sub     ecx,EMEMBLOCKLEN                                ;subtract header size
  3839 00000D8A 83C720                                          add     edi,EMEMBLOCKLEN                                ;point to user area
  3840 00000D8D B000                                            mov     al,EMEMWIPEBYTE                                 ;memory wipe byte
  3841 00000D8F F3AA                                            rep     stosb                                           ;clear memory
  3842 00000D91 5F                                              pop     edi                                             ;restore block address
  3843                                  ;
  3844                                  ;       Address the preceding and following USER memory blocks
  3845                                  ;
  3846 00000D92 8B5F1C                                          mov     ebx,[edi+MEMBLOCK.previousblock]                ;previous block pointer
  3847 00000D95 8B4F18                                          mov     ecx,[edi+MEMBLOCK.nextblock]                    ;next block pointer
  3848                                  ;
  3849                                  ;       If a USER block precedes this block, update that block's next pointer. Otherwise, update the first task
  3850                                  ;       pointer to point to the USER block following this block.
  3851                                  ;
  3852 00000D98 85DB                                            test    ebx,ebx                                         ;is there a previous block?
  3853 00000D9A 7405                                            jz      .10                                             ;no, branch
  3854 00000D9C 894B18                                          mov     [ebx+MEMBLOCK.nextblock],ecx                    ;update previous block's next pointer
  3855 00000D9F EB03                                            jmp     .20                                             ;continue
  3856 00000DA1 894E10                  .10                     mov     [esi+MEMROOT.firsttask],ecx                     ;update first USER pointer
  3857                                  ;
  3858                                  ;       If a USER block follows this block, update that block's previous pointer. Otherwise, update the last task
  3859                                  ;       pointer to point to the USER block preceding this block.
  3860                                  ;
  3861 00000DA4 E305                    .20                     jecxz   .30                                             ;branch if no next block
  3862 00000DA6 89591C                                          mov     [ecx+MEMBLOCK.previousblock],ebx                ;update next block's previous pointer
  3863 00000DA9 EB03                                            jmp     .40                                             ;continue
  3864 00000DAB 895E14                  .30                     mov     [esi+MEMROOT.lasttask],ebx                      ;update last USER pointer
  3865                                  ;-----------------------------------------------------------------------------------------------------------------------
  3866                                  ;
  3867                                  ;       Merge with a previous contiguous FREE memory block.
  3868                                  ;
  3869                                  ;-----------------------------------------------------------------------------------------------------------------------
  3870                                  ;
  3871                                  ;       Address the preceding and following contiguous memory blocks.
  3872                                  ;
  3873 00000DAE 8B5F14                  .40                     mov     ebx,[edi+MEMBLOCK.previouscontig]               ;previous contiguous block ptr
  3874 00000DB1 8B4F10                                          mov     ecx,[edi+MEMBLOCK.nextcontig]                   ;next contiguous block ptr
  3875                                  ;
  3876                                  ;       Verify we have a previous contiguous FREE block.
  3877                                  ;
  3878 00000DB4 85DB                                            test    ebx,ebx                                         ;is there a previous block?
  3879 00000DB6 7442                                            jz      .100                                            ;no, branch
  3880 00000DB8 813B46524545                                    cmp     dword [ebx+MEMBLOCK.signature],EMEMFREECODE     ;is the previous block FREE?
  3881 00000DBE 753A                                            jne     .100                                            ;no, branch
  3882                                  ;
  3883                                  ;       Update adjacent block's contiguous pointers.
  3884                                  ;
  3885 00000DC0 894B10                                          mov     [ebx+MEMBLOCK.nextcontig],ecx                   ;update previous contig's next contig
  3886 00000DC3 E305                                            jecxz   .50                                             ;branch if no next contiguous block
  3887 00000DC5 895914                                          mov     [ecx+MEMBLOCK.previouscontig],ebx               ;update next congit's previous contig
  3888 00000DC8 EB03                                            jmp     .60                                             ;continue
  3889 00000DCA 895E04                  .50                     mov     [esi+MEMROOT.lastcontig],ebx                    ;update last contig pointer
  3890                                  ;
  3891                                  ;       Update the size of the merged FREE block.
  3892                                  ;
  3893 00000DCD 8B4704                  .60                     mov     eax,[edi+MEMBLOCK.bytes]                        ;current block size
  3894 00000DD0 014304                                          add     [ebx+MEMBLOCK.bytes],eax                        ;update previous block's size
  3895                                  ;
  3896                                  ;       Having merged our new free block into the previous free block, make the previous free block the current block
  3897                                  ;
  3898 00000DD3 B920000000                                      mov     ecx,EMEMBLOCKLEN                                ;block header length
  3899 00000DD8 B000                                            mov     al,EMEMWIPEBYTE                                 ;memory wipe byte
  3900 00000DDA F3AA                                            rep     stosb                                           ;clear memory header
  3901 00000DDC 89DF                                            mov     edi,ebx                                         ;current block is now previous block
  3902                                  ;-----------------------------------------------------------------------------------------------------------------------
  3903                                  ;
  3904                                  ;       Unlink the previous contiguous FREE memory block
  3905                                  ;
  3906                                  ;-----------------------------------------------------------------------------------------------------------------------
  3907                                  ;
  3908                                  ;       Address the preceding and following USER memory blocks
  3909                                  ;
  3910 00000DDE 8B5F1C                                          mov     ebx,[edi+MEMBLOCK.previousblock]                ;previous block pointer
  3911 00000DE1 8B4F18                                          mov     ecx,[edi+MEMBLOCK.nextblock]                    ;next block pointer
  3912                                  ;
  3913                                  ;       Update the previous block's next-block pointer if there is a previous block. Otherwise, update the first free
  3914                                  ;       block pointer.
  3915                                  ;
  3916 00000DE4 85DB                                            test    ebx,ebx                                         ;is there a previous block?
  3917 00000DE6 7405                                            jz      .70                                             ;no, branch
  3918 00000DE8 894B18                                          mov     [ebx+MEMBLOCK.nextblock],ecx                    ;update previous block's next pointer
  3919 00000DEB EB03                                            jmp     .80                                             ;branch
  3920 00000DED 894E08                  .70                     mov     [esi+MEMROOT.firstfree],ecx                     ;update first FREE block pointer
  3921                                  ;
  3922                                  ;       Update the next block's previous-block pointer if there is a next block. Otherwise, update the last free block
  3923                                  ;       pointer.
  3924                                  ;
  3925 00000DF0 E305                    .80                     jecxz   .90                                             ;branch if no next block
  3926 00000DF2 89591C                                          mov     [ecx+MEMBLOCK.previousblock],ebx                ;update next block's previous pointer
  3927 00000DF5 EB03                                            jmp     .100                                            ;continue
  3928 00000DF7 895E0C                  .90                     mov     [esi+MEMROOT.lastfree],ebx                      ;update last FREE block pointer
  3929                                  ;-----------------------------------------------------------------------------------------------------------------------
  3930                                  ;
  3931                                  ;       Merge with a following contiguous FREE memory block.
  3932                                  ;
  3933                                  ;-----------------------------------------------------------------------------------------------------------------------
  3934                                  ;
  3935                                  ;       Verify we have a following contiguous FREE block.
  3936                                  ;
  3937 00000DFA 8B4F10                  .100                    mov     ecx,[edi+MEMBLOCK.nextcontig]                   ;next contiguous block ptr
  3938 00000DFD E34B                                            jecxz   .170                                            ;branch if no next contiguous block
  3939 00000DFF 813946524545                                    cmp     dword [ecx+MEMBLOCK.signature],EMEMFREECODE     ;is the next-contiguous block free?
  3940 00000E05 7543                                            jne     .170                                            ;no, branch
  3941                                  ;
  3942                                  ;       Add the size of the following adjacent FREE block to this block's size.
  3943                                  ;
  3944 00000E07 8B4104                                          mov     eax,[ecx+MEMBLOCK.bytes]                        ;next contiguous (free) block size
  3945 00000E0A 014704                                          add     [edi+MEMBLOCK.bytes],eax                        ;add size to this block's size
  3946                                  ;
  3947                                  ;       Unlink the following contiguous FREE block from the contiguous block chain.
  3948                                  ;
  3949 00000E0D 8B4110                                          mov     eax,[ecx+MEMBLOCK.nextcontig]                   ;following block's next-contig ptr
  3950 00000E10 894710                                          mov     [edi+MEMBLOCK.nextcontig],eax                   ;update this block's next-contig ptr
  3951 00000E13 85C0                                            test    eax,eax                                         ;does a block follow the next contig blk
  3952 00000E15 7405                                            jz      .110                                            ;no, branch
  3953 00000E17 897814                                          mov     [eax+MEMBLOCK.previouscontig],edi               ;update following block's prev contig
  3954 00000E1A EB03                                            jmp     .120                                            ;continue
  3955 00000E1C 897E04                  .110                    mov     [esi+MEMROOT.lastcontig],edi                    ;update last contig block ptr
  3956                                  ;-----------------------------------------------------------------------------------------------------------------------
  3957                                  ;
  3958                                  ;       Unlink the following contiguous FREE memory block
  3959                                  ;
  3960                                  ;-----------------------------------------------------------------------------------------------------------------------
  3961                                  ;
  3962                                  ;       Unlink the following adjacent FREE block from the FREE block chain.
  3963                                  ;
  3964 00000E1F 57                      .120                    push    edi                                             ;save this block
  3965 00000E20 89CF                                            mov     edi,ecx                                         ;next contiguous block
  3966 00000E22 51                                              push    ecx                                             ;save next contiguous block
  3967                                  ;
  3968                                  ;       Address the preceding and following USER memory blocks
  3969                                  ;
  3970 00000E23 8B5F1C                                          mov     ebx,[edi+MEMBLOCK.previousblock]                ;next contig's previous block pointer
  3971 00000E26 8B4F18                                          mov     ecx,[edi+MEMBLOCK.nextblock]                    ;next contig's next block pointer
  3972                                  ;
  3973                                  ;       Update the previous block's next-block pointer if there is a previous block. Otherwise, update the first free
  3974                                  ;       block pointer.
  3975                                  ;
  3976 00000E29 85DB                                            test    ebx,ebx                                         ;is there a previous block?
  3977 00000E2B 7405                                            jz      .130                                            ;no, branch
  3978 00000E2D 894B18                                          mov     [ebx+MEMBLOCK.nextblock],ecx                    ;update next contig's prev blk next-ptr
  3979 00000E30 EB03                                            jmp     .140                                            ;branch
  3980 00000E32 894E08                  .130                    mov     [esi+MEMROOT.firstfree],ecx                     ;update first FREE block pointer
  3981                                  ;
  3982                                  ;       Update the next block's previous-block pointer if there is a next block. Otherwise, update the last free block
  3983                                  ;       pointer.
  3984                                  ;
  3985 00000E35 E305                    .140                    jecxz   .150                                            ;branch if no next block
  3986 00000E37 89591C                                          mov     [ecx+MEMBLOCK.previousblock],ebx                ;update next contig's next blk prev-ptr
  3987 00000E3A EB03                                            jmp     .160                                            ;continue
  3988 00000E3C 895E0C                  .150                    mov     [esi+MEMROOT.lastfree],ebx                      ;update last FREE block pointer
  3989                                  ;
  3990                                  ;       Clear next contiguous block's header
  3991                                  ;
  3992 00000E3F 5F                      .160                    pop     edi                                             ;next congiguous block pointer
  3993 00000E40 B920000000                                      mov     ecx,EMEMBLOCKLEN                                ;memory block header length
  3994 00000E45 B000                                            mov     al,EMEMWIPEBYTE                                 ;memory wipe byte
  3995 00000E47 F3AA                                            rep     stosb                                           ;clear memory header
  3996 00000E49 5F                                              pop     edi                                             ;this block's pointer
  3997                                  ;-----------------------------------------------------------------------------------------------------------------------
  3998                                  ;
  3999                                  ;       Insert the final FREE block back into the block chain.
  4000                                  ;
  4001                                  ;-----------------------------------------------------------------------------------------------------------------------
  4002                                  ;
  4003                                  ;       Walk the FREE memory chain until a block is found that is larger than or equal in size to the block being
  4004                                  ;       inserted. The block being inserted will be inserted before that block or after the last block found if none
  4005                                  ;       all are smaller in size.
  4006                                  ;
  4007 00000E4A 8B5F04                  .170                    mov     ebx,[edi+MEMBLOCK.bytes]                        ;size of block
  4008 00000E4D 8B4E08                                          mov     ecx,[esi+MEMROOT.firstfree]                     ;first free block ptr
  4009 00000E50 E30A                    .180                    jecxz   .190                                            ;exit if no ptr
  4010 00000E52 3B5904                                          cmp     ebx,[ecx+MEMBLOCK.bytes]                        ;next block bigger?
  4011 00000E55 7205                                            jb      .190                                            ;yes, branch
  4012 00000E57 8B4918                                          mov     ecx,[ecx+MEMBLOCK.nextblock]                    ;next free memory block
  4013 00000E5A EBF4                                            jmp     .180                                            ;continue
  4014                                  ;
  4015                                  ;       Set the next-block pointer. Determine the previous-block, which may be the last FREE block if we found no
  4016                                  ;       larger free block. Update the next block's previous block pointer.
  4017                                  ;
  4018 00000E5C 894F18                  .190                    mov     [edi+MEMBLOCK.nextblock],ecx                    ;set the next block ptr
  4019 00000E5F 8B5E0C                                          mov     ebx,[esi+MEMROOT.lastfree]                      ;assume all blocks smaller
  4020 00000E62 E308                                            jecxz   .200                                            ;branch if no block found
  4021 00000E64 8B591C                                          mov     ebx,[ecx+MEMBLOCK.previousblock]                ;next block's previous block ptr
  4022 00000E67 89791C                                          mov     [ecx+MEMBLOCK.previousblock],edi                ;update next block's previous ptr
  4023 00000E6A EB03                                            jmp     .210                                            ;continue
  4024 00000E6C 897E0C                  .200                    mov     [esi+MEMROOT.lastfree],edi                      ;this block is now the last free
  4025                                  ;
  4026                                  ;       Set our previous block pointer to either the previous pointer of the found block or the last free block.
  4027                                  ;       If there is no previous block pointer, then this block now the first FREE block. Otherwise update that block's
  4028                                  ;       next pointer.
  4029                                  ;
  4030 00000E6F 895F1C                  .210                    mov     [edi+MEMBLOCK.previousblock],ebx                ;set the previous block ptr
  4031 00000E72 85DB                                            test    ebx,ebx                                         ;do we have a previous block?
  4032 00000E74 7405                                            jz      .220                                            ;no, branch
  4033 00000E76 897B18                                          mov     [ebx+MEMBLOCK.nextblock],edi                    ;update previous block's next block ptr
  4034 00000E79 EB03                                            jmp     .230                                            ;continue
  4035 00000E7B 897E08                  .220                    mov     [esi+MEMROOT.firstfree],edi                     ;update first free ptr
  4036                                  ;
  4037                                  ;       The memory free has completed.
  4038                                  ;
  4039 00000E7E 31C0                    .230                    xor     eax,eax                                         ;indicate success
  4040                                  ;
  4041                                  ;       Restore and return.
  4042                                  ;
  4043 00000E80 07                      .240                    pop     es                                              ;restore non-volatile regs
  4044 00000E81 1F                                              pop     ds                                              ;
  4045 00000E82 5F                                              pop     edi                                             ;
  4046 00000E83 5E                                              pop     esi                                             ;
  4047 00000E84 59                                              pop     ecx                                             ;
  4048 00000E85 5B                                              pop     ebx                                             ;
  4049 00000E86 C3                                              ret                                                     ;return
  4050                                  ;=======================================================================================================================
  4051                                  ;
  4052                                  ;       String Helper Routines
  4053                                  ;
  4054                                  ;       CompareMemory
  4055                                  ;       CopyMemory
  4056                                  ;       UpperCaseString
  4057                                  ;
  4058                                  ;=======================================================================================================================
  4059                                  ;-----------------------------------------------------------------------------------------------------------------------
  4060                                  ;
  4061                                  ;       Routine:        CompareMemory
  4062                                  ;
  4063                                  ;       Description:    This routine compares two byte arrays.
  4064                                  ;
  4065                                  ;       In:             DS:EDX  first source address
  4066                                  ;                       DS:EBX  second source address
  4067                                  ;                       ECX     comparison length
  4068                                  ;
  4069                                  ;       Out:            EDX     first source address
  4070                                  ;                       EBX     second source address
  4071                                  ;                       ECX     0       array 1 = array 2
  4072                                  ;                               <0      array 1 < array 2
  4073                                  ;                               >0      array 1 > array 2
  4074                                  ;
  4075                                  ;-----------------------------------------------------------------------------------------------------------------------
  4076 00000E87 56                      CompareMemory           push    esi                                             ;save non-volatile regs
  4077 00000E88 57                                              push    edi                                             ;
  4078 00000E89 06                                              push    es                                              ;
  4079 00000E8A 1E                                              push    ds                                              ;copy DS
  4080 00000E8B 07                                              pop     es                                              ;... to ES
  4081 00000E8C 89D6                                            mov     esi,edx                                         ;first source address
  4082 00000E8E 89DF                                            mov     edi,ebx                                         ;second source address
  4083 00000E90 FC                                              cld                                                     ;forward strings
  4084 00000E91 F3A6                                            rep     cmpsb                                           ;compare bytes
  4085 00000E93 B000                                            mov     al,0                                            ;default result
  4086 00000E95 7406                                            jz      .10                                             ;branch if arrays equal
  4087 00000E97 B001                                            mov     al,1                                            ;positive result
  4088 00000E99 7302                                            jnc     .10                                             ;branch if target > source
  4089 00000E9B B0FF                                            mov     al,-1                                           ;negative result
  4090 00000E9D 0FBEC8                  .10                     movsx   ecx,al                                          ;extend sign
  4091 00000EA0 07                                              pop     es                                              ;restore non-volatile regs
  4092 00000EA1 5F                                              pop     edi                                             ;
  4093 00000EA2 5E                                              pop     esi                                             ;
  4094 00000EA3 C3                                              ret                                                     ;return
  4095                                  ;-----------------------------------------------------------------------------------------------------------------------
  4096                                  ;
  4097                                  ;       Routine:        CopyMemory
  4098                                  ;
  4099                                  ;       Description:    This routine copies a byte array.
  4100                                  ;
  4101                                  ;       In:             DS:EDX  first source address
  4102                                  ;                       DS:EBX  second source address
  4103                                  ;                       ECX     copy length
  4104                                  ;
  4105                                  ;-----------------------------------------------------------------------------------------------------------------------
  4106 00000EA4 51                      CopyMemory              push    ecx                                             ;save non-volatile regs
  4107 00000EA5 56                                              push    esi                                             ;
  4108 00000EA6 57                                              push    edi                                             ;
  4109 00000EA7 06                                              push    es                                              ;
  4110                                  ;
  4111                                  ;       Compare byte array
  4112                                  ;
  4113 00000EA8 1E                                              push    ds                                              ;load data selector
  4114 00000EA9 07                                              pop     es                                              ;... into ES register
  4115 00000EAA 89D6                                            mov     esi,edx                                         ;first source address
  4116 00000EAC 89DF                                            mov     edi,ebx                                         ;second source address
  4117 00000EAE FC                                              cld                                                     ;forward strings
  4118 00000EAF F3A4                                            rep     movsb                                           ;copy bytes
  4119                                  ;
  4120                                  ;       Restore and return
  4121                                  ;
  4122 00000EB1 07                                              pop     es                                              ;restore non-volatile regs
  4123 00000EB2 5F                                              pop     edi                                             ;
  4124 00000EB3 5E                                              pop     esi                                             ;
  4125 00000EB4 59                                              pop     ecx                                             ;
  4126 00000EB5 C3                                              ret                                                     ;return
  4127                                  ;-----------------------------------------------------------------------------------------------------------------------
  4128                                  ;
  4129                                  ;       Routine:        UpperCaseString
  4130                                  ;
  4131                                  ;       Description:    This routine places all characters in the given string to upper case.
  4132                                  ;
  4133                                  ;       In:             DS:EDX  string address
  4134                                  ;
  4135                                  ;       Out:            EDX     string address
  4136                                  ;
  4137                                  ;-----------------------------------------------------------------------------------------------------------------------
  4138 00000EB6 56                      UpperCaseString         push    esi                                             ;save non-volatile regs
  4139 00000EB7 89D6                                            mov     esi,edx                                         ;string address
  4140 00000EB9 FC                                              cld                                                     ;forward strings
  4141 00000EBA AC                      .10                     lodsb                                                   ;string character
  4142 00000EBB 84C0                                            test    al,al                                           ;null?
  4143 00000EBD 740F                                            jz      .20                                             ;yes, skip ahead
  4144 00000EBF 3C61                                            cmp     al,EASCIILOWERA                                 ;lower-case? (lower bounds)
  4145 00000EC1 72F7                                            jb      .10                                             ;no, continue
  4146 00000EC3 3C7A                                            cmp     al,EASCIILOWERZ                                 ;lower-case? (upper bounds)
  4147 00000EC5 77F3                                            ja      .10                                             ;no, continue
  4148 00000EC7 24DF                                            and     al,EASCIICASEMASK                               ;mask for upper case
  4149 00000EC9 8846FF                                          mov     [esi-1],al                                      ;upper character
  4150 00000ECC EBEC                                            jmp     .10                                             ;continue
  4151 00000ECE 5E                      .20                     pop     esi                                             ;restore non-volatile regs
  4152 00000ECF C3                                              ret                                                     ;return
  4153                                  ;=======================================================================================================================
  4154                                  ;
  4155                                  ;       Console Helper Routines
  4156                                  ;
  4157                                  ;       FirstConsoleColumn
  4158                                  ;       GetConsoleChar
  4159                                  ;       GetConsoleString
  4160                                  ;       NextConsoleColumn
  4161                                  ;       NextConsoleRow
  4162                                  ;       PreviousConsoleColumn
  4163                                  ;       PutConsoleChar
  4164                                  ;       PutConsoleHexByte
  4165                                  ;       PutConsoleHexDword
  4166                                  ;       PutConsoleHexWord
  4167                                  ;       PutConsoleOIAChar
  4168                                  ;       PutConsoleOIAShift
  4169                                  ;       PutConsoleString
  4170                                  ;       Yield
  4171                                  ;
  4172                                  ;=======================================================================================================================
  4173                                  ;-----------------------------------------------------------------------------------------------------------------------
  4174                                  ;
  4175                                  ;       Routine:        FirstConsoleColumn
  4176                                  ;
  4177                                  ;       Description:    This routine resets the console column to start of the row.
  4178                                  ;
  4179                                  ;       In:             DS      OS data selector
  4180                                  ;
  4181                                  ;-----------------------------------------------------------------------------------------------------------------------
  4182 00000ED0 30C0                    FirstConsoleColumn      xor     al,al                                           ;zero column
  4183 00000ED2 A23C0A0000                                      mov     [wbConsoleColumn],al                            ;save column
  4184 00000ED7 C3                                              ret                                                     ;return
  4185                                  ;-----------------------------------------------------------------------------------------------------------------------
  4186                                  ;
  4187                                  ;       Routine:        GetConsoleChar
  4188                                  ;
  4189                                  ;       Description:    This routine waits for EMSGKEYCHAR message and return character code.
  4190                                  ;
  4191                                  ;       Out:            AL      ASCII character code
  4192                                  ;                       AH      keyboard scan code
  4193                                  ;
  4194                                  ;-----------------------------------------------------------------------------------------------------------------------
  4195 00000ED8 E868020000              GetConsoleChar.10       call    Yield                                           ;pass control or halt
  4196 00000EDD E87B030000              GetConsoleChar          call    GetMessage                                      ;get the next message
  4197 00000EE2 09C0                                            or      eax,eax                                         ;do we have a message?
  4198 00000EE4 74F2                                            jz      GetConsoleChar.10                               ;no, skip ahead
  4199 00000EE6 50                                              push    eax                                             ;save key codes
  4200 00000EE7 250000FFFF                                      and     eax,0FFFF0000h                                  ;mask for message type
  4201 00000EEC 3D00000241                                      cmp     eax,EMSGKEYCHAR                                 ;key-char message?
  4202 00000EF1 58                                              pop     eax                                             ;restore key codes
  4203 00000EF2 75E9                                            jne     GetConsoleChar                                  ;no, try again
  4204 00000EF4 25FFFF0000                                      and     eax,0000ffffh                                   ;mask for key codes
  4205 00000EF9 C3                                              ret                                                     ;return
  4206                                  ;-----------------------------------------------------------------------------------------------------------------------
  4207                                  ;
  4208                                  ;       Routine:        GetConsoleString
  4209                                  ;
  4210                                  ;       Description:    This routine accepts keyboard input into a buffer.
  4211                                  ;
  4212                                  ;       In:             DS:EDX  target buffer address
  4213                                  ;                       ECX     maximum number of characters to accept
  4214                                  ;                       BH      echo to terminal
  4215                                  ;                       BL      terminating character
  4216                                  ;
  4217                                  ;-----------------------------------------------------------------------------------------------------------------------
  4218 00000EFA 51                      GetConsoleString        push    ecx                                             ;save non-volatile regs
  4219 00000EFB 56                                              push    esi                                             ;
  4220 00000EFC 57                                              push    edi                                             ;
  4221 00000EFD 06                                              push    es                                              ;
  4222 00000EFE 1E                                              push    ds                                              ;load data segment selector ...
  4223 00000EFF 07                                              pop     es                                              ;... into extra segment register
  4224 00000F00 89D7                                            mov     edi,edx                                         ;edi = target buffer
  4225 00000F02 51                                              push    ecx                                             ;save maximum characters
  4226 00000F03 30C0                                            xor     al,al                                           ;zero register
  4227 00000F05 FC                                              cld                                                     ;forward strings
  4228 00000F06 F3AA                                            rep     stosb                                           ;zero fill buffer
  4229 00000F08 59                                              pop     ecx                                             ;maximum characters
  4230 00000F09 89D7                                            mov     edi,edx                                         ;edi = target buffer
  4231 00000F0B 89D6                                            mov     esi,edx                                         ;esi = target buffer
  4232 00000F0D E34E                    .10                     jecxz   .50                                             ;exit if max-length is zero
  4233 00000F0F E8C9FFFFFF              .20                     call    GetConsoleChar                                  ;al = next input char
  4234 00000F14 38D8                                            cmp     al,bl                                           ;is this the terminator?
  4235 00000F16 7445                                            je      .50                                             ;yes, exit
  4236 00000F18 3C08                                            cmp     al,EASCIIBACKSPACE                              ;is this a backspace?
  4237 00000F1A 7521                                            jne     .30                                             ;no, skip ahead
  4238 00000F1C 39FE                                            cmp     esi,edi                                         ;at start of buffer?
  4239 00000F1E 74EF                                            je      .20                                             ;yes, get next character
  4240 00000F20 4F                                              dec     edi                                             ;backup target pointer
  4241 00000F21 C60700                                          mov     byte [edi],0                                    ;zero previous character
  4242 00000F24 41                                              inc     ecx                                             ;increment remaining chars
  4243 00000F25 F6C701                                          test    bh,1                                            ;echo to console?
  4244 00000F28 74E5                                            jz      .20                                             ;no, get next character
  4245 00000F2A E873000000                                      call    PreviousConsoleColumn                           ;backup console position
  4246 00000F2F B020                                            mov     al,EASCIISPACE                                  ;ASCII space
  4247 00000F31 E891000000                                      call    PutConsoleChar                                  ;write space to console
  4248 00000F36 E837040000                                      call    PlaceCursor                                     ;position the cursor
  4249 00000F3B EBD2                                            jmp     .20                                             ;get next character
  4250 00000F3D 3C20                    .30                     cmp     al,EASCIISPACE                                  ;printable? (lower bounds)
  4251 00000F3F 72CE                                            jb      .20                                             ;no, get another character
  4252 00000F41 3C7E                                            cmp     al,EASCIITILDE                                  ;printable? (upper bounds)
  4253 00000F43 77CA                                            ja      .20                                             ;no, get another character
  4254 00000F45 AA                                              stosb                                                   ;store character in buffer
  4255 00000F46 F6C701                                          test    bh,1                                            ;echo to console?
  4256 00000F49 740F                                            jz      .40                                             ;no, skip ahead
  4257 00000F4B E877000000                                      call    PutConsoleChar                                  ;write character to console
  4258 00000F50 E810000000                                      call    NextConsoleColumn                               ;advance console position
  4259 00000F55 E818040000                                      call    PlaceCursor                                     ;position the cursor
  4260 00000F5A 49                      .40                     dec     ecx                                             ;decrement remaining chars
  4261 00000F5B EBB0                                            jmp     .10                                             ;next
  4262 00000F5D 30C0                    .50                     xor     al,al                                           ;null
  4263 00000F5F AA                                              stosb                                                   ;terminate buffer
  4264 00000F60 07                                              pop     es                                              ;restore non-volatile regs
  4265 00000F61 5F                                              pop     edi                                             ;
  4266 00000F62 5E                                              pop     esi                                             ;
  4267 00000F63 59                                              pop     ecx                                             ;
  4268 00000F64 C3                                              ret                                                     ;return
  4269                                  ;-----------------------------------------------------------------------------------------------------------------------
  4270                                  ;
  4271                                  ;       Routine:        NextConsoleColumn
  4272                                  ;
  4273                                  ;       Description:    This routine advances the console position one column. The columnn is reset to zero and the row
  4274                                  ;                       incremented if the end of the current row is reached.
  4275                                  ;
  4276                                  ;       In:             DS      OS data selector
  4277                                  ;
  4278                                  ;-----------------------------------------------------------------------------------------------------------------------
  4279 00000F65 A03C0A0000              NextConsoleColumn       mov     al,[wbConsoleColumn]                            ;current column
  4280 00000F6A FEC0                                            inc     al                                              ;increment column
  4281 00000F6C A23C0A0000                                      mov     [wbConsoleColumn],al                            ;save column
  4282 00000F71 3C50                                            cmp     al,ECONCOLS                                     ;end of row?
  4283 00000F73 720A                                            jb      .10                                             ;no, skip ahead
  4284 00000F75 E856FFFFFF                                      call    FirstConsoleColumn                              ;reset column to start of row
  4285 00000F7A E801000000                                      call    NextConsoleRow                                  ;line feed to next row
  4286 00000F7F C3                      .10                     ret                                                     ;return
  4287                                  ;-----------------------------------------------------------------------------------------------------------------------
  4288                                  ;
  4289                                  ;       Routine:        NextConsoleRow
  4290                                  ;
  4291                                  ;       Description:    This routine advances the console position one line. Scroll the screen one row if needed.
  4292                                  ;
  4293                                  ;       In:             DS      OS data selector
  4294                                  ;
  4295                                  ;-----------------------------------------------------------------------------------------------------------------------
  4296 00000F80 A03D0A0000              NextConsoleRow          mov     al,[wbConsoleRow]                               ;current row
  4297 00000F85 FEC0                                            inc     al                                              ;increment row
  4298 00000F87 A23D0A0000                                      mov     [wbConsoleRow],al                               ;save row
  4299 00000F8C 3C18                                            cmp     al,ECONROWS                                     ;end of screen?
  4300 00000F8E 7211                                            jb      .10                                             ;no, skip ahead
  4301 00000F90 E860030000                                      call    ScrollConsoleRow                                ;scroll up one row
  4302 00000F95 A03D0A0000                                      mov     al,[wbConsoleRow]                               ;row
  4303 00000F9A FEC8                                            dec     al                                              ;decrement row
  4304 00000F9C A23D0A0000                                      mov     [wbConsoleRow],al                               ;save row
  4305 00000FA1 C3                      .10                     ret                                                     ;return
  4306                                  ;-----------------------------------------------------------------------------------------------------------------------
  4307                                  ;
  4308                                  ;       Routine:        PreviousConsoleColumn
  4309                                  ;
  4310                                  ;       Description:    This routine retreats the cursor one logical column. If the cursor was at the start of a row,
  4311                                  ;                       the column is set to the last position in the row and the row is decremented.
  4312                                  ;
  4313                                  ;       In:             DS      OS data selector
  4314                                  ;
  4315                                  ;-----------------------------------------------------------------------------------------------------------------------
  4316 00000FA2 A03C0A0000              PreviousConsoleColumn   mov     al,[wbConsoleColumn]                            ;current column
  4317 00000FA7 08C0                                            or      al,al                                           ;start of row?
  4318 00000FA9 7514                                            jnz     .10                                             ;no, skip ahead
  4319 00000FAB 8A253D0A0000                                    mov     ah,[wbConsoleRow]                               ;current row
  4320 00000FB1 08E4                                            or      ah,ah                                           ;top of screen?
  4321 00000FB3 7411                                            jz      .20                                             ;yes, exit with no change
  4322 00000FB5 FECC                                            dec     ah                                              ;decrement row
  4323 00000FB7 88253D0A0000                                    mov     [wbConsoleRow],ah                               ;save row
  4324 00000FBD B050                                            mov     al,ECONCOLS                                     ;set maximum column
  4325 00000FBF FEC8                    .10                     dec     al                                              ;decrement column
  4326 00000FC1 A23C0A0000                                      mov     [wbConsoleColumn],al                            ;save column
  4327 00000FC6 C3                      .20                     ret                                                     ;return
  4328                                  ;-----------------------------------------------------------------------------------------------------------------------
  4329                                  ;
  4330                                  ;       Routine:        PutConsoleChar
  4331                                  ;
  4332                                  ;       Description:    This routine writes one ASCII character to the console screen.
  4333                                  ;
  4334                                  ;       In:             AL      ASCII character
  4335                                  ;                       DS      OS data selector
  4336                                  ;
  4337                                  ;-----------------------------------------------------------------------------------------------------------------------
  4338 00000FC7 51                      PutConsoleChar          push    ecx                                             ;save non-volatile regs
  4339 00000FC8 06                                              push    es                                              ;
  4340 00000FC9 6A20                                            push    EGDTCGA                                         ;load CGA selector ...
  4341 00000FCB 07                                              pop     es                                              ;... into extra segment reg
  4342 00000FCC 8A0D3C0A0000                                    mov     cl,[wbConsoleColumn]                            ;column
  4343 00000FD2 8A2D3D0A0000                                    mov     ch,[wbConsoleRow]                               ;row
  4344 00000FD8 E844030000                                      call    SetConsoleChar                                  ;put character at row, column
  4345 00000FDD 07                                              pop     es                                              ;restore non-volatile regs
  4346 00000FDE 59                                              pop     ecx                                             ;
  4347 00000FDF C3                                              ret                                                     ;return
  4348                                  ;-----------------------------------------------------------------------------------------------------------------------
  4349                                  ;
  4350                                  ;       Routine:        PutConsoleHexByte
  4351                                  ;
  4352                                  ;       Description:    This routine writes two ASCII characters to the console representing a byte value.
  4353                                  ;
  4354                                  ;       In:             AL      byte value
  4355                                  ;                       CL      column
  4356                                  ;                       CH      row
  4357                                  ;                       DS      OS data selector
  4358                                  ;                       ES      CGA selector
  4359                                  ;
  4360                                  ;-----------------------------------------------------------------------------------------------------------------------
  4361 00000FE0 53                      PutConsoleHexByte       push    ebx                                             ;save non-volatile regs
  4362 00000FE1 88C3                                            mov     bl,al                                           ;save byte value
  4363 00000FE3 C0E804                                          shr     al,4                                            ;hi-order nybble
  4364 00000FE6 0C30                                            or      al,030h                                         ;apply ASCII zone
  4365 00000FE8 3C3A                                            cmp     al,03ah                                         ;numeric?
  4366 00000FEA 7202                                            jb      .10                                             ;yes, skip ahead
  4367 00000FEC 0407                                            add     al,7                                            ;add ASCII offset for alpha
  4368 00000FEE E82E030000              .10                     call    SetConsoleChar                                  ;display ASCII character
  4369 00000FF3 88D8                                            mov     al,bl                                           ;byte value
  4370 00000FF5 240F                                            and     al,0fh                                          ;lo-order nybble
  4371 00000FF7 0C30                                            or      al,30h                                          ;apply ASCII zone
  4372 00000FF9 3C3A                                            cmp     al,03ah                                         ;numeric?
  4373 00000FFB 7202                                            jb      .20                                             ;yes, skip ahead
  4374 00000FFD 0407                                            add     al,7                                            ;add ASCII offset for alpha
  4375 00000FFF E81D030000              .20                     call    SetConsoleChar                                  ;display ASCII character
  4376 00001004 5B                                              pop     ebx                                             ;restore non-volatile regs
  4377 00001005 C3                                              ret                                                     ;return
  4378                                  ;-----------------------------------------------------------------------------------------------------------------------
  4379                                  ;
  4380                                  ;       Routine:        PutConsoleHexDword
  4381                                  ;
  4382                                  ;       Description:    This routine writes eight ASCII characters to the console representing a doubleword value.
  4383                                  ;
  4384                                  ;       In:             EAX     value
  4385                                  ;                       CL      column
  4386                                  ;                       CH      row
  4387                                  ;                       DS      OS data selector
  4388                                  ;                       ES      CGA selector
  4389                                  ;
  4390                                  ;-----------------------------------------------------------------------------------------------------------------------
  4391 00001006 50                      PutConsoleHexDword      push    eax
  4392 00001007 C1E810                                          shr     eax,16
  4393 0000100A E807000000                                      call    PutConsoleHexWord
  4394 0000100F 58                                              pop     eax
  4395 00001010 E801000000                                      call    PutConsoleHexWord
  4396 00001015 C3                                              ret
  4397                                  ;-----------------------------------------------------------------------------------------------------------------------
  4398                                  ;
  4399                                  ;       Routine:        PutConsoleHexWord
  4400                                  ;
  4401                                  ;       Description:    This routine writes four ASCII characters to the console representing a word value.
  4402                                  ;
  4403                                  ;       In:             EAX     value
  4404                                  ;                       CL      column
  4405                                  ;                       CH      row
  4406                                  ;                       DS      OS data selector
  4407                                  ;                       ES      CGA selector
  4408                                  ;
  4409                                  ;-----------------------------------------------------------------------------------------------------------------------
  4410 00001016 50                      PutConsoleHexWord       push    eax
  4411 00001017 C1E808                                          shr     eax,8
  4412 0000101A E8C1FFFFFF                                      call    PutConsoleHexByte
  4413 0000101F 58                                              pop     eax
  4414 00001020 E8BBFFFFFF                                      call    PutConsoleHexByte
  4415 00001025 C3                                              ret
  4416                                  ;-----------------------------------------------------------------------------------------------------------------------
  4417                                  ;
  4418                                  ;       Routine:        PutConsoleOIAChar
  4419                                  ;
  4420                                  ;       Description:    This routine updates the Operator Information Area (OIA).
  4421                                  ;
  4422                                  ;       In:             DS      OS data selector
  4423                                  ;
  4424                                  ;-----------------------------------------------------------------------------------------------------------------------
  4425 00001026 53                      PutConsoleOIAChar       push    ebx                                             ;save non-volatile regs
  4426 00001027 51                                              push    ecx                                             ;
  4427 00001028 56                                              push    esi                                             ;
  4428 00001029 1E                                              push    ds                                              ;
  4429 0000102A 06                                              push    es                                              ;
  4430 0000102B 6A18                                            push    EGDTOSDATA                                      ;load OS data selector ...
  4431 0000102D 1F                                              pop     ds                                              ;... into data segment register
  4432 0000102E 6A20                                            push    EGDTCGA                                         ;load CGA selector ...
  4433 00001030 07                                              pop     es                                              ;... into extra segment register
  4434 00001031 BE410A0000                                      mov     esi,wbConsoleScan0                              ;scan codes address
  4435 00001036 B718                                            mov     bh,ECONOIAROW                                   ;OIA row
  4436 00001038 B300                                            mov     bl,0                                            ;starting column
  4437 0000103A B906000000                                      mov     ecx,6                                           ;maximum scan codes
  4438 0000103F 51                      .10                     push    ecx                                             ;save remaining count
  4439 00001040 89D9                                            mov     ecx,ebx                                         ;row, column
  4440 00001042 AC                                              lodsb                                                   ;read scan code
  4441 00001043 08C0                                            or      al,al                                           ;scan code present?
  4442 00001045 7407                                            jz      .20                                             ;no, skip ahead
  4443 00001047 E894FFFFFF                                      call    PutConsoleHexByte                               ;display scan code
  4444 0000104C EB0E                                            jmp     .30                                             ;continue
  4445 0000104E B020                    .20                     mov     al,' '                                          ;ASCII space
  4446 00001050 E8CC020000                                      call    SetConsoleChar                                  ;display space
  4447 00001055 B020                                            mov     al,' '                                          ;ASCII space
  4448 00001057 E8C5020000                                      call    SetConsoleChar                                  ;display space
  4449 0000105C 80C302                  .30                     add     bl,2                                            ;next column (+2)
  4450 0000105F 59                                              pop     ecx                                             ;restore remaining
  4451 00001060 E2DD                                            loop    .10                                             ;next code
  4452 00001062 A0470A0000                                      mov     al,[wbConsoleChar]                              ;console ASCII character
  4453 00001067 3C20                                            cmp     al,32                                           ;printable? (lower-bounds)
  4454 00001069 720D                                            jb      .40                                             ;no, skip ahead
  4455 0000106B 3C7E                                            cmp     al,126                                          ;printable? (upper-bounds)
  4456 0000106D 7709                                            ja      .40                                             ;no, skip ahead
  4457 0000106F 88FD                                            mov     ch,bh                                           ;OIA row
  4458 00001071 B128                                            mov     cl,40                                           ;character display column
  4459 00001073 E8A9020000                                      call    SetConsoleChar                                  ;display ASCII character
  4460 00001078 07                      .40                     pop     es                                              ;restore non-volatile regs
  4461 00001079 1F                                              pop     ds                                              ;
  4462 0000107A 5E                                              pop     esi                                             ;
  4463 0000107B 59                                              pop     ecx                                             ;
  4464 0000107C 5B                                              pop     ebx                                             ;
  4465 0000107D C3                                              ret                                                     ;return
  4466                                  ;-----------------------------------------------------------------------------------------------------------------------
  4467                                  ;
  4468                                  ;       Routine:        PutConsoleOIAShift
  4469                                  ;
  4470                                  ;       Description:    This routine updates the shift/ctrl/alt/lock indicators in the operator information area (OIA).
  4471                                  ;
  4472                                  ;       In:             BL      shift flags
  4473                                  ;                       BH      lock flags
  4474                                  ;                       DS      OS data selector
  4475                                  ;
  4476                                  ;-----------------------------------------------------------------------------------------------------------------------
  4477 0000107E 51                      PutConsoleOIAShift      push    ecx                                             ;save non-volatile regs
  4478 0000107F 06                                              push    es                                              ;
  4479 00001080 6A20                                            push    EGDTCGA                                         ;load CGA selector ...
  4480 00001082 07                                              pop     es                                              ;... into ES register
  4481 00001083 B518                                            mov     ch,ECONOIAROW                                   ;OIA row
  4482 00001085 B020                                            mov     al,EASCIISPACE                                  ;space is default character
  4483 00001087 F6C302                                          test    bl,EKEYFSHIFTLEFT                               ;left-shift indicated?
  4484 0000108A 7402                                            jz      .10                                             ;no, skip ahead
  4485 0000108C B053                                            mov     al,'S'                                          ;yes, indicate with 'S'
  4486 0000108E B10E                    .10                     mov     cl,14                                           ;indicator column
  4487 00001090 E88C020000                                      call    SetConsoleChar                                  ;display ASCII character
  4488 00001095 B020                                            mov     al,EASCIISPACE                                  ;ASCII space
  4489 00001097 F6C310                                          test    bl,EKEYFSHIFTRIGHT                              ;right-shift indicated?
  4490 0000109A 7402                                            jz      .20                                             ;no, skip ahead
  4491 0000109C B053                                            mov     al,'S'                                          ;yes, indicate with 'S'
  4492 0000109E B140                    .20                     mov     cl,64                                           ;indicator column
  4493 000010A0 E87C020000                                      call    SetConsoleChar                                  ;display ASCII character
  4494 000010A5 B020                                            mov     al,EASCIISPACE                                  ;ASCII space
  4495 000010A7 F6C301                                          test    bl,EKEYFCTRLLEFT                                ;left-ctrl indicated?
  4496 000010AA 7402                                            jz      .30                                             ;no, skip ahead
  4497 000010AC B043                                            mov     al,'C'                                          ;yes, indicate with 'C'
  4498 000010AE B10F                    .30                     mov     cl,15                                           ;indicator column
  4499 000010B0 E86C020000                                      call    SetConsoleChar                                  ;display ASCII character
  4500 000010B5 B020                                            mov     al,EASCIISPACE                                  ;ASCII space
  4501 000010B7 F6C308                                          test    bl,EKEYFCTRLRIGHT                               ;right-ctrl indicated?
  4502 000010BA 7402                                            jz      .40                                             ;no, skip ahead
  4503 000010BC B043                                            mov     al,'C'                                          ;yes, indicate with 'C'
  4504 000010BE B13F                    .40                     mov     cl,63                                           ;indicator column
  4505 000010C0 E85C020000                                      call    SetConsoleChar                                  ;display ASCII character
  4506 000010C5 B020                                            mov     al,EASCIISPACE                                  ;ASCII space
  4507 000010C7 F6C304                                          test    bl,EKEYFALTLEFT                                 ;left-alt indicated?
  4508 000010CA 7402                                            jz      .50                                             ;no, skip ahead
  4509 000010CC B041                                            mov     al,'A'                                          ;yes, indicate with 'A'
  4510 000010CE B110                    .50                     mov     cl,16                                           ;indicator column
  4511 000010D0 E84C020000                                      call    SetConsoleChar                                  ;display ASCII character
  4512 000010D5 B020                                            mov     al,EASCIISPACE                                  ;ASCII space
  4513 000010D7 F6C320                                          test    bl,EKEYFALTRIGHT                                ;right-alt indicated?
  4514 000010DA 7402                                            jz      .60                                             ;no, skip ahead
  4515 000010DC B041                                            mov     al,'A'                                          ;yes, indicate with 'A'
  4516 000010DE B13E                    .60                     mov     cl,62                                           ;indicator column
  4517 000010E0 E83C020000                                      call    SetConsoleChar                                  ;display ASCII character
  4518 000010E5 B020                                            mov     al,EASCIISPACE                                  ;ASCII space
  4519 000010E7 F6C704                                          test    bh,EKEYFLOCKCAPS                                ;caps-lock indicated?
  4520 000010EA 7402                                            jz      .70                                             ;no, skip ahead
  4521 000010EC B043                                            mov     al,'C'                                          ;yes, indicate with 'C'
  4522 000010EE B14E                    .70                     mov     cl,78                                           ;indicator column
  4523 000010F0 E82C020000                                      call    SetConsoleChar                                  ;display ASCII character
  4524 000010F5 B020                                            mov     al,EASCIISPACE                                  ;ASCII space
  4525 000010F7 F6C702                                          test    bh,EKEYFLOCKNUM                                 ;num-lock indicated?
  4526 000010FA 7402                                            jz      .80                                             ;no, skip ahead
  4527 000010FC B04E                                            mov     al,'N'                                          ;yes, indicate with 'N'
  4528 000010FE B14D                    .80                     mov     cl,77                                           ;indicator column
  4529 00001100 E81C020000                                      call    SetConsoleChar                                  ;display ASCII character
  4530 00001105 B020                                            mov     al,EASCIISPACE                                  ;ASCII space
  4531 00001107 F6C701                                          test    bh,EKEYFLOCKSCROLL                              ;scroll-lock indicated?
  4532 0000110A 7402                                            jz      .90                                             ;no, skip ahead
  4533 0000110C B053                                            mov     al,'S'                                          ;yes, indicate with 'S'
  4534 0000110E B14C                    .90                     mov     cl,76                                           ;indicator column
  4535 00001110 E80C020000                                      call    SetConsoleChar                                  ;display ASCII character
  4536 00001115 07                                              pop     es                                              ;restore non-volatile regs
  4537 00001116 59                                              pop     ecx                                             ;
  4538 00001117 C3                                              ret                                                     ;return
  4539                                  ;-----------------------------------------------------------------------------------------------------------------------
  4540                                  ;
  4541                                  ;       Routine:        PutConsoleString
  4542                                  ;
  4543                                  ;       Description:    This routine writes a sequence of ASCII characters to the console until null and updates the
  4544                                  ;                       console position as needed.
  4545                                  ;
  4546                                  ;       In:             EDX     source address
  4547                                  ;                       DS      OS data selector
  4548                                  ;
  4549                                  ;-----------------------------------------------------------------------------------------------------------------------
  4550 00001118 56                      PutConsoleString        push    esi                                             ;save non-volatile regs
  4551 00001119 89D6                                            mov     esi,edx                                         ;source address
  4552 0000111B FC                                              cld                                                     ;forward strings
  4553 0000111C AC                      .10                     lodsb                                                   ;ASCII character
  4554 0000111D 08C0                                            or      al,al                                           ;end of string?
  4555 0000111F 7422                                            jz      .40                                             ;yes, skip ahead
  4556 00001121 3C0D                                            cmp     al,EASCIIRETURN                                 ;carriage return?
  4557 00001123 7507                                            jne     .20                                             ;no, skip ahead
  4558 00001125 E8A6FDFFFF                                      call    FirstConsoleColumn                              ;move to start of row
  4559 0000112A EBF0                                            jmp     .10                                             ;next character
  4560 0000112C 3C0A                    .20                     cmp     al,EASCIILINEFEED                               ;line feed?
  4561 0000112E 7507                                            jne     .30                                             ;no, skip ahead
  4562 00001130 E84BFEFFFF                                      call    NextConsoleRow                                  ;move to next row
  4563 00001135 EBE5                                            jmp     .10                                             ;next character
  4564 00001137 E88BFEFFFF              .30                     call    PutConsoleChar                                  ;output character to console
  4565 0000113C E824FEFFFF                                      call    NextConsoleColumn                               ;advance to next column
  4566 00001141 EBD9                                            jmp     .10                                             ;next character
  4567 00001143 5E                      .40                     pop     esi                                             ;restore non-volatile regs
  4568 00001144 C3                                              ret                                                     ;return
  4569                                  ;-----------------------------------------------------------------------------------------------------------------------
  4570                                  ;
  4571                                  ;       Routine:        Yield
  4572                                  ;
  4573                                  ;       Description:    This routine passes control to the next ready task or enter halt.
  4574                                  ;
  4575                                  ;-----------------------------------------------------------------------------------------------------------------------
  4576 00001145 FB                      Yield                   sti                                                     ;enable maskagle interrupts
  4577 00001146 F4                                              hlt                                                     ;halt until external interrupt
  4578 00001147 C3                                              ret                                                     ;return
  4579                                  ;=======================================================================================================================
  4580                                  ;
  4581                                  ;       Data-Type Conversion Helper Routines
  4582                                  ;
  4583                                  ;       DecimalToUnsigned
  4584                                  ;       HexadecimalToUnsigned
  4585                                  ;       UnsignedToDecimalString
  4586                                  ;       UnsignedToHexadecimal
  4587                                  ;
  4588                                  ;=======================================================================================================================
  4589                                  ;-----------------------------------------------------------------------------------------------------------------------
  4590                                  ;
  4591                                  ;       Routine:        DecimalToUnsigned
  4592                                  ;
  4593                                  ;       Description:    This routine returns an unsigned integer of the value of the input ASCIIZ decimal string.
  4594                                  ;
  4595                                  ;       Input:          DS:EDX  null-terminated decimal string address
  4596                                  ;
  4597                                  ;       Output:         EAX     unsigned integer value
  4598                                  ;
  4599                                  ;-----------------------------------------------------------------------------------------------------------------------
  4600 00001148 56                      DecimalToUnsigned       push    esi                                             ;save non-volatile regs
  4601 00001149 89D6                                            mov     esi,edx                                         ;source address
  4602 0000114B 31D2                                            xor     edx,edx                                         ;zero total
  4603 0000114D AC                      .10                     lodsb                                                   ;source byte
  4604 0000114E 3C2C                                            cmp     al,','                                          ;comma?
  4605 00001150 74FB                                            je      .10                                             ;yes, ignore
  4606 00001152 84C0                                            test    al,al                                           ;end of string?
  4607 00001154 7421                                            jz      .30                                             ;yes, done
  4608 00001156 3C2E                                            cmp     al,'.'                                          ;decimal point?
  4609 00001158 741D                                            je      .30                                             ;yes, done
  4610 0000115A 3C30                                            cmp     al,'0'                                          ;numeral?
  4611 0000115C 7217                                            jb      .20                                             ;no, invalid string
  4612 0000115E 3C39                                            cmp     al,'9'                                          ;numeral?
  4613 00001160 7713                                            ja      .20                                             ;no, invalid string
  4614 00001162 240F                                            and     al,00Fh                                         ;mask ASCII zone
  4615 00001164 50                                              push    eax                                             ;save numeral
  4616 00001165 D1E2                                            shl     edx,1                                           ;total * 2
  4617 00001167 89D0                                            mov     eax,edx                                         ;total * 2
  4618 00001169 C1E202                                          shl     edx,2                                           ;total * 8
  4619 0000116C 01C2                                            add     edx,eax                                         ;total * 10
  4620 0000116E 58                                              pop     eax                                             ;restore numeral
  4621 0000116F 01C2                                            add     edx,eax                                         ;accumulate decimal digit
  4622 00001171 31C0                                            xor     eax,eax                                         ;zero register
  4623 00001173 EBD8                                            jmp     .10                                             ;next
  4624 00001175 31D2                    .20                     xor     edx,edx                                         ;zero result on error
  4625 00001177 89D0                    .30                     mov     eax,edx                                         ;result
  4626 00001179 5E                                              pop     esi                                             ;restore non-volatile regs
  4627 0000117A C3                                              ret                                                     ;return
  4628                                  ;-----------------------------------------------------------------------------------------------------------------------
  4629                                  ;
  4630                                  ;       Routine:        HexadecimalToUnsigned
  4631                                  ;
  4632                                  ;       Description:    This routine returns an unsigned integer of the value of the input ASCIIZ hexadecimal string.
  4633                                  ;
  4634                                  ;       Input:          DS:EDX  null-terminated hexadecimal string address
  4635                                  ;
  4636                                  ;       Output:         EAX     unsigned integer value
  4637                                  ;
  4638                                  ;-----------------------------------------------------------------------------------------------------------------------
  4639 0000117B 56                      HexadecimalToUnsigned   push    esi                                             ;save non-volatile regs
  4640 0000117C 89D6                                            mov     esi,edx                                         ;source address
  4641 0000117E 31D2                                            xor     edx,edx                                         ;zero register
  4642 00001180 AC                      .10                     lodsb                                                   ;source byte
  4643 00001181 84C0                                            test    al,al                                           ;end of string?
  4644 00001183 7410                                            jz      .30                                             ;yes, branch
  4645 00001185 3C39                                            cmp     al,'9'                                          ;hexadecimal?
  4646 00001187 7602                                            jna     .20                                             ;no, skip ahead
  4647 00001189 2C37                                            sub     al,37h                                          ;'A' = 41h, less 37h = 0Ah
  4648 0000118B 83E00F                  .20                     and     eax,0fh                                         ;remove ascii zone
  4649 0000118E C1E204                                          shl     edx,4                                           ;previous total x 16
  4650 00001191 01C2                                            add     edx,eax                                         ;add prior value x 16
  4651 00001193 EBEB                                            jmp     .10                                             ;next
  4652 00001195 89D0                    .30                     mov     eax,edx                                         ;result
  4653 00001197 5E                                              pop     esi                                             ;restore non-volatile regs
  4654 00001198 C3                                              ret                                                     ;return
  4655                                  ;-----------------------------------------------------------------------------------------------------------------------
  4656                                  ;
  4657                                  ;       Routine:        UnsignedToDecimalString
  4658                                  ;
  4659                                  ;       Description:    This routine creates an ASCIIZ string representing the decimal value of 32-bit binary input.
  4660                                  ;
  4661                                  ;       Input:          BH      flags           bit 0: 1 = trim leading zeros
  4662                                  ;                                               bit 1: 1 = include comma grouping delimiters
  4663                                  ;                                               bit 4: 1 = non-zero digit found (internal)
  4664                                  ;                       ECX     32-bit binary
  4665                                  ;                       DS:EDX  output buffer address
  4666                                  ;
  4667                                  ;-----------------------------------------------------------------------------------------------------------------------
  4668 00001199 53                      UnsignedToDecimalString push    ebx                                             ;save non-volatile regs
  4669 0000119A 51                                              push    ecx                                             ;
  4670 0000119B 57                                              push    edi                                             ;
  4671 0000119C 06                                              push    es                                              ;
  4672 0000119D 1E                                              push    ds                                              ;load data selector
  4673 0000119E 07                                              pop     es                                              ;... into extra segment reg
  4674 0000119F 89D7                                            mov     edi,edx                                         ;output buffer address
  4675 000011A1 80E70F                                          and     bh,00001111b                                    ;zero internal flags
  4676 000011A4 89CA                                            mov     edx,ecx                                         ;binary
  4677 000011A6 B900CA9A3B                                      mov     ecx,1000000000                                  ;10^9 divisor
  4678 000011AB E871000000                                      call    .30                                             ;divide and store
  4679 000011B0 B900E1F505                                      mov     ecx,100000000                                   ;10^8 divisor
  4680 000011B5 E855000000                                      call    .10                                             ;divide and store
  4681 000011BA B980969800                                      mov     ecx,10000000                                    ;10^7 divisor
  4682 000011BF E85D000000                                      call    .30                                             ;divide and store
  4683 000011C4 B940420F00                                      mov     ecx,1000000                                     ;10^6 divisor
  4684 000011C9 E853000000                                      call    .30                                             ;divide and store
  4685 000011CE B9A0860100                                      mov     ecx,100000                                      ;10^5 divisor
  4686 000011D3 E837000000                                      call    .10                                             ;divide and store
  4687 000011D8 B910270000                                      mov     ecx,10000                                       ;10^4 divisor
  4688 000011DD E83F000000                                      call    .30                                             ;divide and store
  4689 000011E2 B9E8030000                                      mov     ecx,1000                                        ;10^3 divisor
  4690 000011E7 E835000000                                      call    .30                                             ;divide and store
  4691 000011EC B964000000                                      mov     ecx,100                                         ;10^2 divisor
  4692 000011F1 E819000000                                      call    .10                                             ;divide and store
  4693 000011F6 B90A000000                                      mov     ecx,10                                          ;10^2 divisor
  4694 000011FB E821000000                                      call    .30                                             ;divide and store
  4695 00001200 89D0                                            mov     eax,edx                                         ;10^1 remainder
  4696 00001202 E827000000                                      call    .40                                             ;store
  4697 00001207 30C0                                            xor     al,al                                           ;null terminator
  4698 00001209 AA                                              stosb
  4699 0000120A 07                                              pop     es                                              ;restore non-volatile regs
  4700 0000120B 5F                                              pop     edi                                             ;
  4701 0000120C 59                                              pop     ecx                                             ;
  4702 0000120D 5B                                              pop     ebx                                             ;
  4703 0000120E C3                                              ret                                                     ;return
  4704 0000120F F6C702                  .10                     test    bh,00000010b                                    ;comma group delims?
  4705 00001212 740D                                            jz      .30                                             ;no, branch
  4706 00001214 F6C701                                          test    bh,00000001b                                    ;trim leading zeros?
  4707 00001217 7405                                            jz      .20                                             ;no, store delim
  4708 00001219 F6C710                                          test    bh,00010000b                                    ;non-zero found?
  4709 0000121C 7403                                            jz      .30                                             ;no, branch
  4710 0000121E B02C                    .20                     mov     al,','                                          ;delimiter
  4711 00001220 AA                                              stosb                                                   ;store delimiter
  4712 00001221 89D0                    .30                     mov     eax,edx                                         ;lo-orer dividend
  4713 00001223 31D2                                            xor     edx,edx                                         ;zero hi-order
  4714 00001225 F7F1                                            div     ecx                                             ;divide by power of 10
  4715 00001227 84C0                                            test    al,al                                           ;zero?
  4716 00001229 7407                                            jz      .50                                             ;yes, branch
  4717 0000122B 80CF10                                          or      bh,00010000b                                    ;non-zero found
  4718 0000122E 0C30                    .40                     or      al,30h                                          ;ASCII zone
  4719 00001230 AA                                              stosb                                                   ;store digit
  4720 00001231 C3                                              ret                                                     ;return
  4721 00001232 F6C701                  .50                     test    bh,00000001b                                    ;trim leading zeros?
  4722 00001235 74F7                                            jz      .40                                             ;no, store and continue
  4723 00001237 F6C710                                          test    bh,00010000b                                    ;non-zero found?
  4724 0000123A 75F2                                            jnz     .40                                             ;yes, store and continue
  4725 0000123C C3                                              ret                                                     ;return
  4726                                  ;-----------------------------------------------------------------------------------------------------------------------
  4727                                  ;
  4728                                  ;       Routine:        UnsignedToHexadecimal
  4729                                  ;
  4730                                  ;       Description:    This routine creates an ASCIIZ string representing the hexadecimal value of binary input
  4731                                  ;
  4732                                  ;       Input:          DS:EDX  output buffer address
  4733                                  ;                       ECX     32-bit binary
  4734                                  ;
  4735                                  ;-----------------------------------------------------------------------------------------------------------------------
  4736 0000123D 57                      UnsignedToHexadecimal   push    edi                                             ;store non-volatile regs
  4737 0000123E 89D7                                            mov     edi,edx                                         ;output buffer address
  4738 00001240 89CA                                            mov     edx,ecx                                         ;32-bit unsigned
  4739 00001242 31C9                                            xor     ecx,ecx                                         ;zero register
  4740 00001244 B108                                            mov     cl,8                                            ;nybble count
  4741 00001246 C1C204                  .10                     rol     edx,4                                           ;next hi-order nybble in bits 0-3
  4742 00001249 88D0                                            mov     al,dl                                           ;????bbbb
  4743 0000124B 240F                                            and     al,0fh                                          ;mask out bits 4-7
  4744 0000124D 0C30                                            or      al,30h                                          ;mask in ascii zone
  4745 0000124F 3C3A                                            cmp     al,3ah                                          ;A through F?
  4746 00001251 7202                                            jb      .20                                             ;no, skip ahead
  4747 00001253 0407                                            add     al,7                                            ;41h through 46h
  4748 00001255 AA                      .20                     stosb                                                   ;store hexnum
  4749 00001256 E2EE                                            loop    .10                                             ;next nybble
  4750 00001258 30C0                                            xor     al,al                                           ;zero reg
  4751 0000125A AA                                              stosb                                                   ;null terminate
  4752 0000125B 5F                                              pop     edi                                             ;restore non-volatile regs
  4753 0000125C C3                                              ret                                                     ;return
  4754                                  ;=======================================================================================================================
  4755                                  ;
  4756                                  ;       Message Queue Helper Routines
  4757                                  ;
  4758                                  ;       GetMessage
  4759                                  ;       PutMessage
  4760                                  ;
  4761                                  ;=======================================================================================================================
  4762                                  ;-----------------------------------------------------------------------------------------------------------------------
  4763                                  ;
  4764                                  ;       Routine:        GetMessage
  4765                                  ;
  4766                                  ;       Description:    This routine reads and removes a message from the message queue.
  4767                                  ;
  4768                                  ;       Out:            EAX     lo-order message data
  4769                                  ;                       EDX     hi-order message data
  4770                                  ;
  4771                                  ;                       CY      0 = message read
  4772                                  ;                               1 = no message to read
  4773                                  ;
  4774                                  ;-----------------------------------------------------------------------------------------------------------------------
  4775 0000125D 53                      GetMessage              push    ebx                                             ;save non-volatile regs
  4776 0000125E 51                                              push    ecx                                             ;
  4777 0000125F 1E                                              push    ds                                              ;
  4778 00001260 6A2C                                            push    ELDTMQ                                          ;load message queue selector ...
  4779 00001262 1F                                              pop     ds                                              ;... into data segment register
  4780 00001263 8B1D00000000                                    mov     ebx,[MQHead]                                    ;head ptr
  4781 00001269 8B03                                            mov     eax,[ebx]                                       ;lo-order 32 bits
  4782 0000126B 8B5304                                          mov     edx,[ebx+4]                                     ;hi-order 32 bits
  4783 0000126E 09D0                                            or      eax,edx                                         ;is queue empty?
  4784 00001270 F9                                              stc                                                     ;assume queue is emtpy
  4785 00001271 741B                                            jz      .20                                             ;yes, skip ahead
  4786 00001273 31C9                                            xor     ecx,ecx                                         ;store zero
  4787 00001275 890B                                            mov     [ebx],ecx                                       ;... in lo-order dword
  4788 00001277 894B04                                          mov     [ebx+4],ecx                                     ;... in hi-order dword
  4789 0000127A 83C308                                          add     ebx,8                                           ;next queue element
  4790 0000127D 81E3FC030000                                    and     ebx,03fch                                       ;at end of queue?
  4791 00001283 7502                                            jnz     .10                                             ;no, skip ahead
  4792 00001285 B308                                            mov     bl,8                                            ;reset to 1st entry
  4793 00001287 891D00000000            .10                     mov     [MQHead],ebx                                    ;save new head ptr
  4794 0000128D F8                                              clc                                                     ;indicate message read
  4795 0000128E 1F                      .20                     pop     ds                                              ;restore non-volatile regs
  4796 0000128F 59                                              pop     ecx                                             ;
  4797 00001290 5B                                              pop     ebx                                             ;
  4798 00001291 C3                                              ret                                                     ;return
  4799                                  ;-----------------------------------------------------------------------------------------------------------------------
  4800                                  ;
  4801                                  ;       Routine:        PutMessage
  4802                                  ;
  4803                                  ;       Description:    This routine adda a message to the message queue.
  4804                                  ;
  4805                                  ;       In:             ECX     hi-order data word
  4806                                  ;                       EDX     lo-order data word
  4807                                  ;
  4808                                  ;       Out:            CY      0 = success
  4809                                  ;                               1 = fail: queue is full
  4810                                  ;
  4811                                  ;-----------------------------------------------------------------------------------------------------------------------
  4812 00001292 1E                      PutMessage              push    ds                                              ;save non-volatile regs
  4813 00001293 6A2C                                            push    ELDTMQ                                          ;load task message queue selector ...
  4814 00001295 1F                                              pop     ds                                              ;... into data segment register
  4815 00001296 A104000000                                      mov     eax,[MQTail]                                    ;tail ptr
  4816 0000129B 833800                                          cmp     dword [eax],0                                   ;is queue full?
  4817 0000129E F9                                              stc                                                     ;assume failure
  4818 0000129F 7517                                            jne     .20                                             ;yes, cannot store
  4819 000012A1 8910                                            mov     [eax],edx                                       ;store lo-order data
  4820 000012A3 894804                                          mov     [eax+4],ecx                                     ;store hi-order data
  4821 000012A6 83C008                                          add     eax,8                                           ;next queue element adr
  4822 000012A9 25FC030000                                      and     eax,03fch                                       ;at end of queue?
  4823 000012AE 7502                                            jnz     .10                                             ;no, skip ahead
  4824 000012B0 B008                                            mov     al,8                                            ;reset to top of queue
  4825 000012B2 A304000000              .10                     mov     [MQTail],eax                                    ;save new tail ptr
  4826 000012B7 F8                                              clc                                                     ;indicate success
  4827 000012B8 1F                      .20                     pop     ds                                              ;restore non-volatile regs
  4828 000012B9 C3                                              ret                                                     ;return
  4829                                  ;=======================================================================================================================
  4830                                  ;
  4831                                  ;       Memory-Mapped Video Routines
  4832                                  ;
  4833                                  ;       These routines read and/or write directly to CGA video memory (B800:0)
  4834                                  ;
  4835                                  ;       ClearConsoleScreen
  4836                                  ;       ScrollConsoleRow
  4837                                  ;       SetConsoleChar
  4838                                  ;       SetConsoleString
  4839                                  ;
  4840                                  ;=======================================================================================================================
  4841                                  ;-----------------------------------------------------------------------------------------------------------------------
  4842                                  ;
  4843                                  ;       Routine:        ClearConsoleScreen
  4844                                  ;
  4845                                  ;       Description:    This routine clears the console (CGA) screen.
  4846                                  ;
  4847                                  ;-----------------------------------------------------------------------------------------------------------------------
  4848 000012BA 51                      ClearConsoleScreen      push    ecx                                             ;save non-volatile regs
  4849 000012BB 57                                              push    edi                                             ;
  4850 000012BC 1E                                              push    ds                                              ;
  4851 000012BD 06                                              push    es                                              ;
  4852 000012BE 6A18                                            push    EGDTOSDATA                                      ;load OS Data selector ...
  4853 000012C0 1F                                              pop     ds                                              ;... into DS register
  4854 000012C1 6A20                                            push    EGDTCGA                                         ;load CGA selector ...
  4855 000012C3 07                                              pop     es                                              ;... into ES register
  4856 000012C4 B820072007                                      mov     eax,ECONCLEARDWORD                              ;initializtion value
  4857 000012C9 B9C0030000                                      mov     ecx,ECONROWDWORDS*(ECONROWS)                    ;double-words to clear
  4858 000012CE 31FF                                            xor     edi,edi                                         ;target offset
  4859 000012D0 FC                                              cld                                                     ;forward strings
  4860 000012D1 F3AB                                            rep     stosd                                           ;reset screen body
  4861 000012D3 B820702070                                      mov     eax,ECONOIADWORD                                ;OIA attribute and space
  4862 000012D8 B928000000                                      mov     ecx,ECONROWDWORDS                               ;double-words per row
  4863 000012DD F3AB                                            rep     stosd                                           ;reset OIA line
  4864 000012DF 30C0                                            xor     al,al                                           ;zero register
  4865 000012E1 A23D0A0000                                      mov     [wbConsoleRow],al                               ;reset console row
  4866 000012E6 A23C0A0000                                      mov     [wbConsoleColumn],al                            ;reset console column
  4867 000012EB E882000000                                      call    PlaceCursor                                     ;place cursor at current position
  4868 000012F0 07                                              pop     es                                              ;restore non-volatile regs
  4869 000012F1 1F                                              pop     ds                                              ;
  4870 000012F2 5F                                              pop     edi                                             ;
  4871 000012F3 59                                              pop     ecx                                             ;
  4872 000012F4 C3                                              ret                                                     ;return
  4873                                  ;-----------------------------------------------------------------------------------------------------------------------
  4874                                  ;
  4875                                  ;       Routine:        ScrollConsoleRow
  4876                                  ;
  4877                                  ;       Description:    This routine scrolls the console (text) screen up one row.
  4878                                  ;
  4879                                  ;-----------------------------------------------------------------------------------------------------------------------
  4880 000012F5 51                      ScrollConsoleRow        push    ecx                                             ;save non-volatile regs
  4881 000012F6 56                                              push    esi                                             ;
  4882 000012F7 57                                              push    edi                                             ;
  4883 000012F8 1E                                              push    ds                                              ;
  4884 000012F9 06                                              push    es                                              ;
  4885 000012FA 6A20                                            push    EGDTCGA                                         ;load CGA video selector ...
  4886 000012FC 1F                                              pop     ds                                              ;... into DS
  4887 000012FD 6A20                                            push    EGDTCGA                                         ;load CGA video selector ...
  4888 000012FF 07                                              pop     es                                              ;... into ES
  4889 00001300 B998030000                                      mov     ecx,ECONROWDWORDS*(ECONROWS-1)                  ;double-words to move
  4890 00001305 BEA0000000                                      mov     esi,ECONROWBYTES                                ;ESI = source (line 2)
  4891 0000130A 31FF                                            xor     edi,edi                                         ;EDI = target (line 1)
  4892 0000130C FC                                              cld                                                     ;forward strings
  4893 0000130D F3A5                                            rep     movsd                                           ;move 24 lines up
  4894 0000130F B820072007                                      mov     eax,ECONCLEARDWORD                              ;attribute and ASCII space
  4895 00001314 B928000000                                      mov     ecx,ECONROWDWORDS                               ;double-words per row
  4896 00001319 F3AB                                            rep     stosd                                           ;clear bottom row
  4897 0000131B 07                                              pop     es                                              ;restore non-volatile regs
  4898 0000131C 1F                                              pop     ds                                              ;
  4899 0000131D 5F                                              pop     edi                                             ;
  4900 0000131E 5E                                              pop     esi                                             ;
  4901 0000131F 59                                              pop     ecx                                             ;
  4902 00001320 C3                                              ret                                                     ;return
  4903                                  ;-----------------------------------------------------------------------------------------------------------------------
  4904                                  ;
  4905                                  ;       Routine:        SetConsoleChar
  4906                                  ;
  4907                                  ;       Description:    This routine outputs an ASCII character at the given row and column.
  4908                                  ;
  4909                                  ;       In:             AL      ASCII character
  4910                                  ;                       CL      column
  4911                                  ;                       CH      row
  4912                                  ;                       ES      CGA selector
  4913                                  ;
  4914                                  ;       Out:            EAX     last target address written (ES:)
  4915                                  ;                       CL      column + 1
  4916                                  ;
  4917                                  ;-----------------------------------------------------------------------------------------------------------------------
  4918 00001321 88C2                    SetConsoleChar          mov     dl,al                                           ;ASCII character
  4919 00001323 0FB6C5                                          movzx   eax,ch                                          ;row
  4920 00001326 B450                                            mov     ah,ECONCOLS                                     ;cols/row
  4921 00001328 F6E4                                            mul     ah                                              ;row * cols/row
  4922 0000132A 00C8                                            add     al,cl                                           ;add column
  4923 0000132C 80D400                                          adc     ah,0                                            ;handle carry
  4924 0000132F D1E0                                            shl     eax,1                                           ;screen offset
  4925 00001331 268810                                          mov     [es:eax],dl                                     ;store character
  4926 00001334 FEC1                                            inc     cl                                              ;next column
  4927 00001336 C3                                              ret                                                     ;return
  4928                                  ;-----------------------------------------------------------------------------------------------------------------------
  4929                                  ;
  4930                                  ;       Routine:        SetConsoleString
  4931                                  ;
  4932                                  ;       Description:    This routine outputs a sequence of ASCII character at the given row and column.
  4933                                  ;
  4934                                  ;       In:             ESI     source offset (DS:)
  4935                                  ;                       CL      column
  4936                                  ;                       CH      row
  4937                                  ;                       ES      CGA selector
  4938                                  ;
  4939                                  ;-----------------------------------------------------------------------------------------------------------------------
  4940 00001337 56                      SetConsoleString        push    esi                                             ;save non-volatile regs
  4941 00001338 FC                                              cld                                                     ;forward strings
  4942 00001339 AC                      .10                     lodsb                                                   ;next ASCII character
  4943 0000133A 84C0                                            test    al,al                                           ;end of string?
  4944 0000133C 7407                                            jz      .20                                             ;yes, branch
  4945 0000133E E8DEFFFFFF                                      call    SetConsoleChar                                  ;store character
  4946 00001343 EBF4                                            jmp     .10                                             ;continue
  4947 00001345 5E                      .20                     pop     esi                                             ;restore non-volatile regs
  4948 00001346 C3                                              ret                                                     ;return
  4949                                  ;=======================================================================================================================
  4950                                  ;
  4951                                  ;       Input/Output Routines
  4952                                  ;
  4953                                  ;       These routines read and/or write directly to ports.
  4954                                  ;
  4955                                  ;       GetBaseMemSize
  4956                                  ;       GetExtendedMemSize
  4957                                  ;       GetROMMemSize
  4958                                  ;       PlaceCursor
  4959                                  ;       PutPrimaryEndOfInt
  4960                                  ;       PutSecondaryEndOfInt
  4961                                  ;       ReadRealTimeClock
  4962                                  ;       ResetSystem
  4963                                  ;       SetKeyboardLamps
  4964                                  ;       WaitForKeyInBuffer
  4965                                  ;       WaitForKeyOutBuffer
  4966                                  ;
  4967                                  ;=======================================================================================================================
  4968                                  ;-----------------------------------------------------------------------------------------------------------------------
  4969                                  ;
  4970                                  ;       Routine:        GetBaseMemSize
  4971                                  ;
  4972                                  ;       Description:    Return the amount of base RAM as reported by the CMOS.
  4973                                  ;
  4974                                  ;       Output:         EAX     base RAM size in bytes
  4975                                  ;
  4976                                  ;-----------------------------------------------------------------------------------------------------------------------
  4977 00001347 31C0                    GetBaseMemSize          xor     eax,eax                                         ;zero register
  4978 00001349 B016                                            mov     al,ERTCBASERAMHI                                ;base RAM high register
  4979 0000134B E670                                            out     ERTCREGPORT,al                                  ;select base RAM high register
  4980 0000134D E471                                            in      al,ERTCDATAPORT                                 ;read base RAM high (KB)
  4981 0000134F 88C4                                            mov     ah,al                                           ;save base RAM high
  4982 00001351 B015                                            mov     al,ERTCBASERAMLO                                ;base RAM low register
  4983 00001353 E670                                            out     ERTCREGPORT,al                                  ;select base RAM low register
  4984 00001355 E471                                            in      al,ERTCDATAPORT                                 ;read base RAM low (KB)
  4985 00001357 C3                                              ret                                                     ;return to caller
  4986                                  ;-----------------------------------------------------------------------------------------------------------------------
  4987                                  ;
  4988                                  ;       Routine:        GetExtendedMemSize
  4989                                  ;
  4990                                  ;       Description:    Return the amount of extended RAM as reported by the CMOS.
  4991                                  ;
  4992                                  ;       Output:         EAX     extended RAM size in bytes
  4993                                  ;
  4994                                  ;-----------------------------------------------------------------------------------------------------------------------
  4995 00001358 31C0                    GetExtendedMemSize      xor     eax,eax                                         ;zero register
  4996 0000135A B018                                            mov     al,ERTCEXTRAMHI                                 ;extended RAM high register
  4997 0000135C E670                                            out     ERTCREGPORT,al                                  ;select extended RAM high register
  4998 0000135E E471                                            in      al,ERTCDATAPORT                                 ;read extended RAM high (KB)
  4999 00001360 88C4                                            mov     ah,al                                           ;save extended RAM high
  5000 00001362 B017                                            mov     al,ERTCEXTRAMLO                                 ;extended RAM low register
  5001 00001364 E670                                            out     ERTCREGPORT,al                                  ;select extended RAM low register
  5002 00001366 E471                                            in      al,ERTCDATAPORT                                 ;read extended RAM low (KB)
  5003 00001368 C3                                              ret                                                     ;return to caller
  5004                                  ;-----------------------------------------------------------------------------------------------------------------------
  5005                                  ;
  5006                                  ;       Routine:        GetROMMemSize
  5007                                  ;
  5008                                  ;       Description:    Return the amount of RAM as reported by the BIOS during power-up.
  5009                                  ;
  5010                                  ;       Output:         EAX     RAM size in bytes
  5011                                  ;
  5012                                  ;-----------------------------------------------------------------------------------------------------------------------
  5013 00001369 31C0                    GetROMMemSize           xor     eax,eax                                         ;zero register
  5014 0000136B 66A113040000                                    mov     ax,[wwROMMemSize]                               ;memory size (KB) as returned by INT 12h
  5015 00001371 C3                                              ret                                                     ;return
  5016                                  ;-----------------------------------------------------------------------------------------------------------------------
  5017                                  ;
  5018                                  ;       Routine:        PlaceCursor
  5019                                  ;
  5020                                  ;       Description:    This routine positions the cursor on the console.
  5021                                  ;
  5022                                  ;       In:             DS      OS data selector
  5023                                  ;
  5024                                  ;-----------------------------------------------------------------------------------------------------------------------
  5025 00001372 51                      PlaceCursor             push    ecx                                             ;save non-volatile regs
  5026 00001373 A03D0A0000                                      mov     al,[wbConsoleRow]                               ;AL = row
  5027 00001378 B450                                            mov     ah,ECONCOLS                                     ;AH = cols/row
  5028 0000137A F6E4                                            mul     ah                                              ;row offset
  5029 0000137C 02053C0A0000                                    add     al,[wbConsoleColumn]                            ;add column
  5030 00001382 80D400                                          adc     ah,0                                            ;add overflow
  5031 00001385 89C1                                            mov     ecx,eax                                         ;screen offset
  5032 00001387 B2D4                                            mov     dl,ECRTPORTLO                                   ;crt controller port lo
  5033 00001389 B603                                            mov     dh,ECRTPORTHI                                   ;crt controller port hi
  5034 0000138B B00E                                            mov     al,ECRTCURLOCHI                                 ;crt cursor loc reg hi
  5035 0000138D EE                                              out     dx,al                                           ;select register
  5036 0000138E 42                                              inc     edx                                             ;data port
  5037 0000138F 88E8                                            mov     al,ch                                           ;hi-order cursor loc
  5038 00001391 EE                                              out     dx,al                                           ;store hi-order loc
  5039 00001392 4A                                              dec     edx                                             ;register select port
  5040 00001393 B00F                                            mov     al,ECRTCURLOCLO                                 ;crt cursor loc reg lo
  5041 00001395 EE                                              out     dx,al                                           ;select register
  5042 00001396 42                                              inc     edx                                             ;data port
  5043 00001397 88C8                                            mov     al,cl                                           ;lo-order cursor loc
  5044 00001399 EE                                              out     dx,al                                           ;store lo-order loc
  5045 0000139A 59                                              pop     ecx                                             ;restore non-volatile regs
  5046 0000139B C3                                              ret                                                     ;return
  5047                                  ;-----------------------------------------------------------------------------------------------------------------------
  5048                                  ;
  5049                                  ;       Routine:        PutPrimaryEndOfInt
  5050                                  ;
  5051                                  ;       Description:    This routine sends a non-specific end-of-interrupt signal to the primary PIC.
  5052                                  ;
  5053                                  ;-----------------------------------------------------------------------------------------------------------------------
  5054 0000139C FB                      PutPrimaryEndOfInt      sti                                                     ;enable maskable interrupts
  5055 0000139D B020                                            mov     al,EPICEOI                                      ;non-specific end-of-interrupt
  5056 0000139F E620                                            out     EPICPORTPRI,al                                  ;send EOI to primary PIC
  5057 000013A1 C3                                              ret                                                     ;return
  5058                                  ;-----------------------------------------------------------------------------------------------------------------------
  5059                                  ;
  5060                                  ;       Routine:        PutSecondaryEndOfInt
  5061                                  ;
  5062                                  ;       Description:    This routine sends a non-specific end-of-interrupt signal to the secondary PIC.
  5063                                  ;
  5064                                  ;-----------------------------------------------------------------------------------------------------------------------
  5065 000013A2 FB                      PutSecondaryEndOfInt    sti                                                     ;enable maskable interrupts
  5066 000013A3 B020                                            mov     al,EPICEOI                                      ;non-specific end-of-interrupt
  5067 000013A5 E6A0                                            out     EPICPORTSEC,al                                  ;send EOI to secondary PIC
  5068 000013A7 C3                                              ret                                                     ;return
  5069                                  ;-----------------------------------------------------------------------------------------------------------------------
  5070                                  ;
  5071                                  ;       Routine:        ReadRealTimeClock
  5072                                  ;
  5073                                  ;       Description:    This routine gets current date time from the real-time clock.
  5074                                  ;
  5075                                  ;       In:             DS:EBX  DATETIME structure
  5076                                  ;
  5077                                  ;-----------------------------------------------------------------------------------------------------------------------
  5078 000013A8 56                      ReadRealTimeClock       push    esi                                             ;save non-volatile regs
  5079 000013A9 57                                              push    edi                                             ;
  5080 000013AA 06                                              push    es                                              ;
  5081 000013AB 1E                                              push    ds                                              ;store data selector ...
  5082 000013AC 07                                              pop     es                                              ;... in es register
  5083 000013AD 89DF                                            mov     edi,ebx                                         ;date-time structure
  5084 000013AF B000                                            mov     al,ERTCSECONDREG                                ;second register
  5085 000013B1 E670                                            out     ERTCREGPORT,al                                  ;select second register
  5086 000013B3 E471                                            in      al,ERTCDATAPORT                                 ;read second register
  5087 000013B5 FC                                              cld                                                     ;forward strings
  5088 000013B6 AA                                              stosb                                                   ;store second value
  5089 000013B7 B002                                            mov     al,ERTCMINUTEREG                                ;minute register
  5090 000013B9 E670                                            out     ERTCREGPORT,al                                  ;select minute register
  5091 000013BB E471                                            in      al,ERTCDATAPORT                                 ;read minute register
  5092 000013BD AA                                              stosb                                                   ;store minute value
  5093 000013BE B004                                            mov     al,ERTCHOURREG                                  ;hour register
  5094 000013C0 E670                                            out     ERTCREGPORT,al                                  ;select hour register
  5095 000013C2 E471                                            in      al,ERTCDATAPORT                                 ;read hour register
  5096 000013C4 AA                                              stosb                                                   ;store hour value
  5097 000013C5 B006                                            mov     al,ERTCWEEKDAYREG                               ;weekday register
  5098 000013C7 E670                                            out     ERTCREGPORT,al                                  ;select weekday register
  5099 000013C9 E471                                            in      al,ERTCDATAPORT                                 ;read weekday register
  5100 000013CB AA                                              stosb                                                   ;store weekday value
  5101 000013CC B007                                            mov     al,ERTCDAYREG                                   ;day register
  5102 000013CE E670                                            out     ERTCREGPORT,al                                  ;select day register
  5103 000013D0 E471                                            in      al,ERTCDATAPORT                                 ;read day register
  5104 000013D2 AA                                              stosb                                                   ;store day value
  5105 000013D3 B008                                            mov     al,ERTCMONTHREG                                 ;month register
  5106 000013D5 E670                                            out     ERTCREGPORT,al                                  ;select month register
  5107 000013D7 E471                                            in      al,ERTCDATAPORT                                 ;read month register
  5108 000013D9 AA                                              stosb                                                   ;store month value
  5109 000013DA B009                                            mov     al,ERTCYEARREG                                  ;year register
  5110 000013DC E670                                            out     ERTCREGPORT,al                                  ;select year register
  5111 000013DE E471                                            in      al,ERTCDATAPORT                                 ;read year register
  5112 000013E0 AA                                              stosb                                                   ;store year value
  5113 000013E1 B032                                            mov     al,ERTCCENTURYREG                               ;century register
  5114 000013E3 E670                                            out     ERTCREGPORT,al                                  ;select century register
  5115 000013E5 E471                                            in      al,ERTCDATAPORT                                 ;read century register
  5116 000013E7 AA                                              stosb                                                   ;store century value
  5117 000013E8 B00B                                            mov     al,ERTCSTATUSREG                                ;status register
  5118 000013EA E670                                            out     ERTCREGPORT,al                                  ;select status register
  5119 000013EC E471                                            in      al,ERTCDATAPORT                                 ;read status register
  5120 000013EE A804                                            test    al,ERTCBINARYVALS                               ;test if values are binary
  5121 000013F0 751D                                            jnz     .20                                             ;skip ahead if binary values
  5122 000013F2 89DE                                            mov     esi,ebx                                         ;date-time structure address
  5123 000013F4 89DF                                            mov     edi,ebx                                         ;date-time structure address
  5124 000013F6 B908000000                                      mov     ecx,8                                           ;loop counter
  5125 000013FB AC                      .10                     lodsb                                                   ;BCD value
  5126 000013FC 88C4                                            mov     ah,al                                           ;BCD value
  5127 000013FE 240F                                            and     al,00001111b                                    ;low-order decimal zone
  5128 00001400 80E4F0                                          and     ah,11110000b                                    ;hi-order decimal zone
  5129 00001403 D0EC                                            shr     ah,1                                            ;hi-order decimal * 8
  5130 00001405 00E0                                            add     al,ah                                           ;low-order + hi-order * 8
  5131 00001407 C0EC02                                          shr     ah,2                                            ;hi-order decimal * 2
  5132 0000140A 00E0                                            add     al,ah                                           ;low-order + hi-order * 10
  5133 0000140C AA                                              stosb                                                   ;replace BCD with binary
  5134 0000140D E2EC                                            loop    .10                                             ;next value
  5135 0000140F 07                      .20                     pop     es                                              ;restore non-volatile regs
  5136 00001410 5F                                              pop     edi                                             ;
  5137 00001411 5E                                              pop     esi                                             ;
  5138 00001412 C3                                              ret                                                     ;return
  5139                                  ;-----------------------------------------------------------------------------------------------------------------------
  5140                                  ;
  5141                                  ;       Routine:        ResetSystem
  5142                                  ;
  5143                                  ;       Description:    This routine restarts the system using the 8042 controller.
  5144                                  ;
  5145                                  ;       Out:            N/A     This routine does not return.
  5146                                  ;
  5147                                  ;-----------------------------------------------------------------------------------------------------------------------
  5148 00001413 B9FFFF1F00              ResetSystem             mov     ecx,001fffffh                                   ;delay to clear ints
  5149 00001418 E2FE                                            loop    $                                               ;clear interrupts
  5150 0000141A B0FE                                            mov     al,EKEYBCMDRESET                                ;mask out bit zero
  5151 0000141C E664                                            out     EKEYBPORTSTAT,al                                ;drive bit zero low
  5152 0000141E FB                      .10                     sti                                                     ;enable maskable interrupts
  5153 0000141F F4                                              hlt                                                     ;halt until interrupt
  5154 00001420 EBFC                                            jmp     .10                                             ;repeat until reset kicks in
  5155                                  ;-----------------------------------------------------------------------------------------------------------------------
  5156                                  ;
  5157                                  ;       Routine:        SetKeyboardLamps
  5158                                  ;
  5159                                  ;       Description:    This routine sends the set/reset mode indicators command to the keyboard device.
  5160                                  ;
  5161                                  ;       In:             BH      00000CNS (C:Caps Lock,N:Num Lock,S:Scroll Lock)
  5162                                  ;
  5163                                  ;-----------------------------------------------------------------------------------------------------------------------
  5164 00001422 E81C000000              SetKeyboardLamps        call    WaitForKeyInBuffer                              ;wait for input buffer ready
  5165 00001427 B0ED                                            mov     al,EKEYBCMDLAMPS                                ;set/reset lamps command
  5166 00001429 E660                                            out     EKEYBPORTDATA,al                                ;send command to 8042
  5167 0000142B E821000000                                      call    WaitForKeyOutBuffer                             ;wait for 8042 result
  5168 00001430 E460                                            in      al,EKEYBPORTDATA                                ;read 8042 'ACK' (0fah)
  5169 00001432 E80C000000                                      call    WaitForKeyInBuffer                              ;wait for input buffer ready
  5170 00001437 88F8                                            mov     al,bh                                           ;set/reset lamps value
  5171 00001439 E660                                            out     EKEYBPORTDATA,al                                ;send lamps value
  5172 0000143B E811000000                                      call    WaitForKeyOutBuffer                             ;wait for 8042 result
  5173 00001440 E460                                            in      al,EKEYBPORTDATA                                ;read 8042 'ACK' (0fah)
  5174 00001442 C3                                              ret                                                     ;return
  5175                                  ;-----------------------------------------------------------------------------------------------------------------------
  5176                                  ;
  5177                                  ;       Routine:        WaitForKeyInBuffer
  5178                                  ;
  5179                                  ;       Description:    This routine waits for keyboard input buffer to be ready for input.
  5180                                  ;
  5181                                  ;       Out:            ZF      1 = Input buffer ready
  5182                                  ;                               0 = Input buffer not ready after timeout
  5183                                  ;
  5184                                  ;-----------------------------------------------------------------------------------------------------------------------
  5185 00001443 51                      WaitForKeyInBuffer      push    ecx                                             ;save non-volatile regs
  5186 00001444 B900000100                                      mov     ecx,EKEYBWAITLOOP                               ;keyboard controller timeout
  5187 00001449 E464                    .10                     in      al,EKEYBPORTSTAT                                ;keyboard status byte
  5188 0000144B A802                                            test    al,EKEYBBITIN                                   ;is input buffer still full?
  5189 0000144D E0FA                                            loopnz  .10                                             ;yes, repeat till timeout
  5190 0000144F 59                                              pop     ecx                                             ;restore non-volatile regs
  5191 00001450 C3                                              ret                                                     ;return
  5192                                  ;-----------------------------------------------------------------------------------------------------------------------
  5193                                  ;
  5194                                  ;       Routine:        WaitForKeyOutBuffer
  5195                                  ;
  5196                                  ;       Description:    This routine waits for keyboard output buffer to have data to read.
  5197                                  ;
  5198                                  ;       Out:            ZF      1 = Output buffer has data from controller
  5199                                  ;                               0 = Output buffer empty after timeout
  5200                                  ;
  5201                                  ;-----------------------------------------------------------------------------------------------------------------------
  5202 00001451 51                      WaitForKeyOutBuffer     push    ecx                                             ;save non-volatile regs
  5203 00001452 B900000100                                      mov     ecx,EKEYBWAITLOOP                               ;keyboard controller timeout
  5204 00001457 E464                    .10                     in      al,EKEYBPORTSTAT                                ;keyboard status byte
  5205 00001459 A801                                            test    al,EKEYBBITOUT                                  ;output buffer status bit
  5206 0000145B E1FA                                            loopz   .10                                             ;loop until output buffer bit
  5207 0000145D 59                                              pop     ecx                                             ;restore non-volatile regs
  5208 0000145E C3                                              ret                                                     ;return
  5209                                  ;-----------------------------------------------------------------------------------------------------------------------
  5210                                  ;
  5211                                  ;       End of the Kernel Function Library
  5212                                  ;
  5213                                  ;-----------------------------------------------------------------------------------------------------------------------
  5214 0000145F 00<rept>                                        times   8192-($-$$) db 0h                               ;zero fill to end of section
  5215                                  ;=======================================================================================================================
  5216                                  ;
  5217                                  ;       Console Task
  5218                                  ;
  5219                                  ;       The only task defined in the kernel is the console task. This task consists of code, data, stack, and task state
  5220                                  ;       segments and a local descriptor table. The console task accepts and echos user keyboard input to the console
  5221                                  ;       screen and responds to user commands.
  5222                                  ;
  5223                                  ;=======================================================================================================================
  5224                                  ;-----------------------------------------------------------------------------------------------------------------------
  5225                                  ;
  5226                                  ;       Console Stack                                                           @disk: 007600   @mem:  004000
  5227                                  ;
  5228                                  ;       This is the stack for the console task. It supports 448 nested calls.
  5229                                  ;
  5230                                  ;-----------------------------------------------------------------------------------------------------------------------
  5231                                  section                 constack                                                ;console task stack
  5232 00000000 00<rept>                                        times   1792-($-$$) db 0h                               ;zero fill to end of section
  5233                                  ;-----------------------------------------------------------------------------------------------------------------------
  5234                                  ;
  5235                                  ;       Console Local Descriptor Table                                          @disk: 007d00   @mem:  004700
  5236                                  ;
  5237                                  ;       This is the LDT for the console task. It defines the stack, code, data and queue segments as well as data
  5238                                  ;       aliases for the TSS LDT. Data aliases allow inspection and altering of the TSS and LDT. This LDT can hold up to
  5239                                  ;       16 descriptors. Six are initially defined.
  5240                                  ;
  5241                                  ;-----------------------------------------------------------------------------------------------------------------------
  5242                                  section                 conldt                                                  ;console local descriptors
  5243 00000000 7F00804700934000                                dq      004093004780007Fh                               ;04 TSS alias
  5244 00000008 7F00004700934000                                dq      004093004700007Fh                               ;0c LDT alias
  5245 00000010 FF06004000934000                                dq      00409300400006FFh                               ;14 stack
  5246 00000018 FFFF00000093CF00                                dq      00CF93000000FFFFh                               ;1c data
  5247 00000020 FF0F0050009B4000                                dq      00409B0050000FFFh                               ;24 code
  5248 00000028 FF07004800934000                                dq      00409300480007FFh                               ;2c message queue
  5249 00000030 00<rept>                                        times   128-($-$$) db 0h                                ;zero fill to end of section
  5250                                  ;-----------------------------------------------------------------------------------------------------------------------
  5251                                  ;
  5252                                  ;       Console Task State Segment                                              @disk: 007d80   @mem:  004780
  5253                                  ;
  5254                                  ;       This is the TSS for the console task. All rings share the same stack. DS and ES are set to the console data
  5255                                  ;       segment. CS to console code.
  5256                                  ;
  5257                                  ;-----------------------------------------------------------------------------------------------------------------------
  5258                                  section                 contss                                                  ;console task state segment
  5259 00000000 00000000                                        dd      0                                               ;00 back-link tss
  5260 00000004 00070000                                        dd      0700h                                           ;04 esp ring 0
  5261 00000008 14000000                                        dd      0014h                                           ;08 ss ring 0
  5262 0000000C 00070000                                        dd      0700h                                           ;0c esp ring 1
  5263 00000010 14000000                                        dd      0014h                                           ;10 es ring 1
  5264 00000014 00070000                                        dd      0700h                                           ;14 esp ring 2
  5265 00000018 14000000                                        dd      0014h                                           ;18 ss ring 2
  5266 0000001C 00000000                                        dd      0                                               ;1c cr ring 3
  5267 00000020 00000000                                        dd      0                                               ;20 eip
  5268 00000024 00020000                                        dd      0200h                                           ;24 eflags
  5269 00000028 00000000                                        dd      0                                               ;28 eax
  5270 0000002C 00000000                                        dd      0                                               ;2c ecx
  5271 00000030 00000000                                        dd      0                                               ;30 edx
  5272 00000034 00000000                                        dd      0                                               ;34 ebx
  5273 00000038 00070000                                        dd      0700h                                           ;38 esp ring 3
  5274 0000003C 00000000                                        dd      0                                               ;3c ebp
  5275 00000040 00000000                                        dd      0                                               ;40 esi
  5276 00000044 00000000                                        dd      0                                               ;44 edi
  5277 00000048 1C000000                                        dd      001Ch                                           ;48 es
  5278 0000004C 24000000                                        dd      0024h                                           ;4c cs
  5279 00000050 14000000                                        dd      0014h                                           ;50 ss ring 3
  5280 00000054 1C000000                                        dd      001Ch                                           ;54 ds
  5281 00000058 00000000                                        dd      0                                               ;58 fs
  5282 0000005C 00000000                                        dd      0                                               ;5c gs
  5283 00000060 60000000                                        dd      EGDTCONSOLELDT                                  ;60 ldt selector in gdt
  5284 00000064 00<rept>                                        times   128-($-$$) db 0h                                ;zero fill to end of section
  5285                                  ;-----------------------------------------------------------------------------------------------------------------------
  5286                                  ;
  5287                                  ;       Console Message Queue                                                   @disk: 007e00   @mem: 004800
  5288                                  ;
  5289                                  ;       The console message queue is 2048 bytes of memory organized as a queue of 510 double words (4 bytes each) and
  5290                                  ;       two double word values that act as indices. The queue is a FIFO that is fed by the keyboard hardware interrupt
  5291                                  ;       handler and consumed by a service routine called from a task. Each queue entry defines an input (keystroke)
  5292                                  ;       event.
  5293                                  ;
  5294                                  ;-----------------------------------------------------------------------------------------------------------------------
  5295                                  section                 conmque                                                 ;console message queue
  5296 00000000 08000000                                        dd      8                                               ;head pointer
  5297 00000004 08000000                                        dd      8                                               ;tail pointer
  5298 00000008 00000000<rept>                                  times   510 dd 0                                        ;queue elements
  5299                                  ;-----------------------------------------------------------------------------------------------------------------------
  5300                                  ;
  5301                                  ;       Console Code                                                            @disk: 008600   @mem: 005000
  5302                                  ;
  5303                                  ;       This is the code for the console task. The task is defined in the GDT in two descriptors, the Local Descriptor
  5304                                  ;       Table (LDT) at 0050h and the Task State Segment (TSS) at 0058h. Jumping to or calling a TSS selector causes a
  5305                                  ;       task switch, giving control to the code for the task at the CS:IP defined in the TSS for the current ring level.
  5306                                  ;       The initial CS:IP in the Console TSS is 24h:0, where 24h is a selector in the LDT. This selector points to the
  5307                                  ;       concode section, loaded into memory 5000h by the Loader. The console task is dedicated to accepting user key-
  5308                                  ;       board input, echoing to the console screen and responding to user commands.
  5309                                  ;
  5310                                  ;       When control reaches this section, our addressability is set up according to the following diagram.
  5311                                  ;
  5312                                  ;       DS,ES --------> 000000  +-----------------------------------------------+ DS,ES:0000
  5313                                  ;                               |  Real Mode Interrupt Vectors                  |
  5314                                  ;                       000400  +-----------------------------------------------+ DS,ES:0400
  5315                                  ;                               |  Reserved BIOS Memory Area                    |
  5316                                  ;                       000800  +-----------------------------------------------+ DS,ES:0800
  5317                                  ;                               |  Shared Kernel Memory Area                    |
  5318                                  ;                       001000  +-----------------------------------------------+               <-- GDTR
  5319                                  ;                               |  Global Descriptor Table (GDT)                |
  5320                                  ;                       001800  +-----------------------------------------------+               <-- IDTR
  5321                                  ;                               |  Interrupt Descriptor Table (IDT)             |
  5322                                  ;                       002000  +-----------------------------------------------+
  5323                                  ;                               |  Interrupt Handlers                           |
  5324                                  ;                               |  Kernel Function Library                      |
  5325                                  ;       SS -----------> 004000  +===============================================+ SS:0000
  5326                                  ;                               |  Console Task Stack Area                      |
  5327                                  ;       SS:SP --------> 004700  +-----------------------------------------------+ SS:0700       <-- LDTR = GDT.SEL 0050h
  5328                                  ;                               |  Console Task Local Descriptor Table (LDT)    |
  5329                                  ;                       004780  +-----------------------------------------------+               <-- TR  = GDT.SEL 0058h
  5330                                  ;                               |  Console Task Task State Segment (TSS)        |
  5331                                  ;                       004800  +-----------------------------------------------+
  5332                                  ;                               |  Console Task Message Queue                   |
  5333                                  ;       CS,CS:IP -----> 005000  +-----------------------------------------------+ CS:0000
  5334                                  ;                               |  Console Task Code                            |
  5335                                  ;                               |  Console Task Constants                       |
  5336                                  ;                       006000  +===============================================+
  5337                                  ;
  5338                                  ;-----------------------------------------------------------------------------------------------------------------------
  5339                                  section                 concode vstart=05000h                                   ;labels relative to 5000h
  5340 00000000 E8D9000000              ConCode                 call    ConInitializeData                               ;initialize console variables
  5341                                  
  5342                                                          clearConsoleScreen                                      ;clear the console screen
  5342 00000005 B001                <1>  mov al,eClearConsoleScreen
  5342 00000007 CD30                <1>  int _svc
  5343                                                          putConsoleString czTitle                                ;display startup message
  5343 00000009 BA[3B0A0000]        <1>  mov edx,%1
  5343 0000000E B00D                <1>  mov al,ePutConsoleString
  5343 00000010 CD30                <1>  int _svc
  5344                                                          putConsoleString czROMMem                               ;ROM memory label
  5344 00000012 BA[160A0000]        <1>  mov edx,%1
  5344 00000017 B00D                <1>  mov al,ePutConsoleString
  5344 00000019 CD30                <1>  int _svc
  5345                                                          putConsoleString wzROMMemSize                           ;ROM memory amount
  5345 0000001B BA470B0000          <1>  mov edx,%1
  5345 00000020 B00D                <1>  mov al,ePutConsoleString
  5345 00000022 CD30                <1>  int _svc
  5346                                                          putConsoleString czKB                                   ;Kilobytes
  5346 00000024 BA[90090000]        <1>  mov edx,%1
  5346 00000029 B00D                <1>  mov al,ePutConsoleString
  5346 0000002B CD30                <1>  int _svc
  5347                                                          putConsoleString czNewLine                              ;new line
  5347 0000002D BA[93090000]        <1>  mov edx,%1
  5347 00000032 B00D                <1>  mov al,ePutConsoleString
  5347 00000034 CD30                <1>  int _svc
  5348                                                          putConsoleString czBaseMem                              ;base memory label
  5348 00000036 BA[51090000]        <1>  mov edx,%1
  5348 0000003B B00D                <1>  mov al,ePutConsoleString
  5348 0000003D CD30                <1>  int _svc
  5349                                                          putConsoleString wzBaseMemSize                          ;base memory size
  5349 0000003F BA3C0B0000          <1>  mov edx,%1
  5349 00000044 B00D                <1>  mov al,ePutConsoleString
  5349 00000046 CD30                <1>  int _svc
  5350                                                          putConsoleString czKB                                   ;Kilobytes
  5350 00000048 BA[90090000]        <1>  mov edx,%1
  5350 0000004D B00D                <1>  mov al,ePutConsoleString
  5350 0000004F CD30                <1>  int _svc
  5351                                                          putConsoleString czNewLine                              ;new line
  5351 00000051 BA[93090000]        <1>  mov edx,%1
  5351 00000056 B00D                <1>  mov al,ePutConsoleString
  5351 00000058 CD30                <1>  int _svc
  5352                                                          putConsoleString czExtendedMem                          ;extended memory label
  5352 0000005A BA[78090000]        <1>  mov edx,%1
  5352 0000005F B00D                <1>  mov al,ePutConsoleString
  5352 00000061 CD30                <1>  int _svc
  5353                                                          putConsoleString wzExtendedMemSize                      ;extended memory size
  5353 00000063 BA520B0000          <1>  mov edx,%1
  5353 00000068 B00D                <1>  mov al,ePutConsoleString
  5353 0000006A CD30                <1>  int _svc
  5354                                                          putConsoleString czKB                                   ;Kilobytes
  5354 0000006C BA[90090000]        <1>  mov edx,%1
  5354 00000071 B00D                <1>  mov al,ePutConsoleString
  5354 00000073 CD30                <1>  int _svc
  5355                                                          putConsoleString czNewLine                              ;new line
  5355 00000075 BA[93090000]        <1>  mov edx,%1
  5355 0000007A B00D                <1>  mov al,ePutConsoleString
  5355 0000007C CD30                <1>  int _svc
  5356                                  .10                     putConsoleString czPrompt                               ;display input prompt
  5356                              <1> .10 :
  5356 0000007E BA[F7090000]        <1>  mov edx,%1
  5356 00000083 B00D                <1>  mov al,ePutConsoleString
  5356 00000085 CD30                <1>  int _svc
  5357                                                          placeCursor                                             ;set CRT cursor location
  5357 00000087 B00C                <1>  mov al,ePlaceCursor
  5357 00000089 CD30                <1>  int _svc
  5358                                                          getConsoleString wzConsoleInBuffer,79,1,13              ;accept keyboard input
  5358 0000008B BA4C0A0000          <1>  mov edx,%1
  5358 00000090 B94F000000          <1>  mov ecx,%2
  5358 00000095 B701                <1>  mov bh,%3
  5358 00000097 B30D                <1>  mov bl,%4
  5358 00000099 B007                <1>  mov al,eGetConsoleString
  5358 0000009B CD30                <1>  int _svc
  5359                                                          putConsoleString czNewLine                              ;newline
  5359 0000009D BA[93090000]        <1>  mov edx,%1
  5359 000000A2 B00D                <1>  mov al,ePutConsoleString
  5359 000000A4 CD30                <1>  int _svc
  5360                                  
  5361 000000A6 BA4C0A0000                                      mov     edx,wzConsoleInBuffer                           ;console input buffer
  5362 000000AB BB9C0A0000                                      mov     ebx,wzConsoleToken                              ;token buffer
  5363 000000B0 E8BB000000                                      call    ConTakeToken                                    ;handle console input
  5364 000000B5 BA9C0A0000                                      mov     edx,wzConsoleToken                              ;token buffer
  5365 000000BA E8E6000000                                      call    ConDetermineCommand                             ;determine command number
  5366 000000BF 83F81A                                          cmp     eax,ECONJMPTBLCNT                               ;valid command number?
  5367 000000C2 720B                                            jb      .20                                             ;yes, branch
  5368                                  
  5369                                                          putConsoleString czUnknownCommand                       ;display error message
  5369 000000C4 BA[590A0000]        <1>  mov edx,%1
  5369 000000C9 B00D                <1>  mov al,ePutConsoleString
  5369 000000CB CD30                <1>  int _svc
  5370                                  
  5371 000000CD EBAF                                            jmp     .10                                             ;next command
  5372 000000CF C1E002                  .20                     shl     eax,2                                           ;index into jump table
  5373 000000D2 BA[05080000]                                    mov     edx,tConJmpTbl                                  ;jump table base address
  5374 000000D7 8B0402                                          mov     eax,[edx+eax]                                   ;command handler routine address
  5375 000000DA FFD0                                            call    eax                                             ;call command handler
  5376 000000DC EBA0                                            jmp     .10                                             ;next command
  5377                                  ;-----------------------------------------------------------------------------------------------------------------------
  5378                                  ;
  5379                                  ;       Routine:        ConInitializeData
  5380                                  ;
  5381                                  ;       Description:    This routine initializes console task variables.
  5382                                  ;
  5383                                  ;-----------------------------------------------------------------------------------------------------------------------
  5384 000000DE 51                      ConInitializeData       push    ecx                                             ;save non-volatile regs
  5385 000000DF 57                                              push    edi                                             ;
  5386 000000E0 06                                              push    es                                              ;
  5387                                  ;
  5388                                  ;       Initialize console work areas.
  5389                                  ;
  5390 000000E1 6A18                                            push    EGDTOSDATA                                      ;load OS data selector ...
  5391 000000E3 07                                              pop     es                                              ;... into extra segment register
  5392 000000E4 BF080A0000                                      mov     edi,ECONDATA                                    ;OS console data address
  5393 000000E9 30C0                                            xor     al,al                                           ;initialization value
  5394 000000EB B975010000                                      mov     ecx,ECONDATALEN                                 ;size of OS console data
  5395 000000F0 FC                                              cld                                                     ;forward strings
  5396 000000F1 F3AA                                            rep     stosb                                           ;initialize data
  5397                                  ;
  5398                                  ;       Initialize heap size
  5399                                  ;
  5400 000000F3 B800000080                                      mov     eax,EKRNHEAPSIZE                                ;heap size
  5401 000000F8 A30C0A0000                                      mov     [wdConsoleHeapSize],eax                         ;set heap size
  5402                                  ;
  5403                                  ;       Initialize MEMROOT structure
  5404                                  ;
  5405 000000FD BF5D0B0000                                      mov     edi,wsConsoleMemRoot                            ;memory root structure address
  5406 00000102 B800000100                                      mov     eax,EKRNHEAPBASE                                ;base address of heap storage
  5407 00000107 31C9                                            xor     ecx,ecx                                         ;zero register
  5408 00000109 B104                                            mov     cl,4                                            ;count
  5409 0000010B F3AB                                            rep     stosd                                           ;store first/last contig and free addrs
  5410 0000010D 31C0                                            xor     eax,eax                                         ;zero register
  5411 0000010F AB                                              stosd                                                   ;zero first task block
  5412 00000110 AB                                              stosd                                                   ;zero last task block
  5413                                  ;
  5414                                  ;       Initialize MEMBLOCK structure at EMEMBASE
  5415                                  ;
  5416 00000111 BF00000100                                      mov     edi,EKRNHEAPBASE                                ;memory block structure address
  5417 00000116 B846524545                                      mov     eax,EMEMFREECODE                                ;free memory signature
  5418 0000011B AB                                              stosd                                                   ;store signature
  5419 0000011C B800000080                                      mov     eax,EKRNHEAPSIZE                                ;heap size
  5420 00000121 AB                                              stosd                                                   ;store block size
  5421 00000122 31C9                                            xor     ecx,ecx                                         ;zero register
  5422 00000124 B106                                            mov     cl,6                                            ;count
  5423 00000126 31C0                                            xor     eax,eax                                         ;zero register
  5424 00000128 F3AB                                            rep     stosd                                           ;zero owner, reserved, pointers
  5425                                  ;
  5426                                  ;       Read memory sizes from ROM
  5427                                  ;
  5428                                                          getROMMemSize                                           ;get ROM memory size
  5428 0000012A B009                <1>  mov al,eGetROMMemSize
  5428 0000012C CD30                <1>  int _svc
  5429 0000012E A3180A0000                                      mov     [wdROMMemSize],eax                              ;bytes reported by ROM
  5430 00000133 89C1                                            mov     ecx,eax                                         ;integer param
  5431 00000135 BA470B0000                                      mov     edx,wzROMMemSize                                ;output buffer param
  5432 0000013A B703                                            mov     bh,3                                            ;no leading zeros; thousands grouping
  5433                                                          unsignedToDecimalString                                 ;build ASCIIZ decimal string
  5433 0000013C B01C                <1>  mov al,eUnsignedToDecimalString
  5433 0000013E CD30                <1>  int _svc
  5434                                                          getBaseMemSize                                          ;get base RAM count from CMOS
  5434 00000140 B006                <1>  mov al,eGetBaseMemSize
  5434 00000142 CD30                <1>  int _svc
  5435 00000144 A3100A0000                                      mov     [wdBaseMemSize],eax                             ;save base RAM count
  5436 00000149 89C1                                            mov     ecx,eax                                         ;integer param
  5437 0000014B BA3C0B0000                                      mov     edx,wzBaseMemSize                               ;output buffer param
  5438 00000150 B703                                            mov     bh,3                                            ;no leading zeros; thousands grouping
  5439                                                          unsignedToDecimalString                                 ;build ASCIIZ decimal string
  5439 00000152 B01C                <1>  mov al,eUnsignedToDecimalString
  5439 00000154 CD30                <1>  int _svc
  5440                                                          getExtendedMemSize                                      ;get extended RAM count from CMOS
  5440 00000156 B008                <1>  mov al,eGetExtendedMemSize
  5440 00000158 CD30                <1>  int _svc
  5441 0000015A A3140A0000                                      mov     [wdExtendedMemSize],eax                         ;save base RAM count
  5442 0000015F 89C1                                            mov     ecx,eax                                         ;integer param
  5443 00000161 BA520B0000                                      mov     edx,wzExtendedMemSize                           ;output buffer param
  5444 00000166 B703                                            mov     bh,3                                            ;no leading zeros; thousands grouping
  5445                                                          unsignedToDecimalString                                 ;build ASCIIZ decimal string
  5445 00000168 B01C                <1>  mov al,eUnsignedToDecimalString
  5445 0000016A CD30                <1>  int _svc
  5446                                  ;
  5447                                  ;       Restore and return.
  5448                                  ;
  5449 0000016C 07                                              pop     es                                              ;restore non-volatile regs
  5450 0000016D 5F                                              pop     edi                                             ;
  5451 0000016E 59                                              pop     ecx                                             ;
  5452 0000016F C3                                              ret                                                     ;return
  5453                                  ;-----------------------------------------------------------------------------------------------------------------------
  5454                                  ;
  5455                                  ;       Routine:        ConTakeToken
  5456                                  ;
  5457                                  ;       Description:    This routine extracts the next token from the given source buffer.
  5458                                  ;
  5459                                  ;       In:             DS:EDX  source buffer address
  5460                                  ;                       DS:EBX  target buffer address
  5461                                  ;
  5462                                  ;       Out:            DS:EDX  source buffer address
  5463                                  ;                       DS:EBX  target buffer address
  5464                                  ;
  5465                                  ;       Command Form:   Line    = *3( *SP 1*ALNUM )
  5466                                  ;
  5467                                  ;-----------------------------------------------------------------------------------------------------------------------
  5468 00000170 56                      ConTakeToken            push    esi                                             ;save non-volatile regs
  5469 00000171 57                                              push    edi                                             ;
  5470 00000172 06                                              push    es                                              ;
  5471 00000173 1E                                              push    ds                                              ;load data segment selector ...
  5472 00000174 07                                              pop     es                                              ;... into extra segment reg
  5473 00000175 89D6                                            mov     esi,edx                                         ;source buffer address
  5474 00000177 89DF                                            mov     edi,ebx                                         ;target buffer address
  5475 00000179 C60700                                          mov     byte [edi],0                                    ;null-terminate target buffer
  5476 0000017C FC                                              cld                                                     ;forward strings
  5477 0000017D AC                      .10                     lodsb                                                   ;load byte
  5478 0000017E 3C20                                            cmp     al,EASCIISPACE                                  ;space?
  5479 00000180 74FB                                            je      .10                                             ;yes, continue
  5480 00000182 84C0                                            test    al,al                                           ;end of line?
  5481 00000184 7410                                            jz      .40                                             ;yes, branch
  5482 00000186 AA                      .20                     stosb                                                   ;store byte
  5483 00000187 AC                                              lodsb                                                   ;load byte
  5484 00000188 84C0                                            test    al,al                                           ;end of line?
  5485 0000018A 740A                                            jz      .40                                             ;no, continue
  5486 0000018C 3C20                                            cmp     al,EASCIISPACE                                  ;space?
  5487 0000018E 75F6                                            jne     .20                                             ;no, continue
  5488 00000190 AC                      .30                     lodsb                                                   ;load byte
  5489 00000191 3C20                                            cmp     al,EASCIISPACE                                  ;space?
  5490 00000193 74FB                                            je      .30                                             ;yes, continue
  5491 00000195 4E                                              dec     esi                                             ;pre-position
  5492 00000196 C60700                  .40                     mov     byte [edi],0                                    ;terminate buffer
  5493 00000199 89D7                                            mov     edi,edx                                         ;source buffer address
  5494 0000019B AC                      .50                     lodsb                                                   ;remaining byte
  5495 0000019C AA                                              stosb                                                   ;move to front of buffer
  5496 0000019D 84C0                                            test    al,al                                           ;end of line?
  5497 0000019F 75FA                                            jnz     .50                                             ;no, continue
  5498 000001A1 07                                              pop     es                                              ;restore non-volatile regs
  5499 000001A2 5F                                              pop     edi                                             ;
  5500 000001A3 5E                                              pop     esi                                             ;
  5501 000001A4 C3                                              ret                                                     ;return
  5502                                  ;-----------------------------------------------------------------------------------------------------------------------
  5503                                  ;
  5504                                  ;       Routine:        ConDetermineCommand
  5505                                  ;
  5506                                  ;       Description:    This routine determines the command number for the command at DS:EDX.
  5507                                  ;
  5508                                  ;       input:          DS:EDX  command address
  5509                                  ;
  5510                                  ;       output:         EAX     >=0     = command nbr
  5511                                  ;                               0       = unknown command
  5512                                  ;
  5513                                  ;-----------------------------------------------------------------------------------------------------------------------
  5514 000001A5 53                      ConDetermineCommand     push    ebx                                             ;save non-volatile regs
  5515 000001A6 51                                              push    ecx                                             ;
  5516 000001A7 56                                              push    esi                                             ;
  5517 000001A8 57                                              push    edi                                             ;
  5518                                  
  5519                                                          upperCaseString                                         ;upper-case string at EDX
  5519 000001A9 B01E                <1>  mov al,eUpperCaseString
  5519 000001AB CD30                <1>  int _svc
  5520                                  
  5521 000001AD BE[6D080000]                                    mov     esi,tConCmdTbl                                  ;commands table
  5522 000001B2 31FF                                            xor     edi,edi                                         ;intialize command number
  5523 000001B4 FC                                              cld                                                     ;forward strings
  5524 000001B5 AC                      .10                     lodsb                                                   ;command length
  5525 000001B6 0FB6C8                                          movzx   ecx,al                                          ;command length
  5526 000001B9 E30D                                            jecxz   .20                                             ;branch if end of table
  5527 000001BB 89F3                                            mov     ebx,esi                                         ;table entry address
  5528 000001BD 01CE                                            add     esi,ecx                                         ;next table entry address
  5529                                  
  5530                                                          compareMemory                                           ;compare byte arrays at EDX, EBX
  5530 000001BF B002                <1>  mov al,eCompareMemory
  5530 000001C1 CD30                <1>  int _svc
  5531                                  
  5532 000001C3 E303                                            jecxz   .20                                             ;branch if equal
  5533 000001C5 47                                              inc     edi                                             ;increment command nbr
  5534 000001C6 EBED                                            jmp     .10                                             ;repeat
  5535 000001C8 89F8                    .20                     mov     eax,edi                                         ;command number
  5536 000001CA 5F                                              pop     edi                                             ;restore non-volatile regs
  5537 000001CB 5E                                              pop     esi                                             ;
  5538 000001CC 59                                              pop     ecx                                             ;
  5539 000001CD 5B                                              pop     ebx                                             ;
  5540 000001CE C3                                              ret                                                     ;return
  5541                                  ;-----------------------------------------------------------------------------------------------------------------------
  5542                                  ;
  5543                                  ;       Routine:        ConClear
  5544                                  ;
  5545                                  ;       Description:    This routine handles the CLEAR command and its CLS alias.
  5546                                  ;
  5547                                  ;-----------------------------------------------------------------------------------------------------------------------
  5548                                  ConClear                clearConsoleScreen                                      ;clear console screen
  5548                              <1> ConClear :
  5548 000001CF B001                <1>  mov al,eClearConsoleScreen
  5548 000001D1 CD30                <1>  int _svc
  5549 000001D3 C3                                              ret                                                     ;return
  5550                                  ;-----------------------------------------------------------------------------------------------------------------------
  5551                                  ;
  5552                                  ;       Routine:        ConDate
  5553                                  ;
  5554                                  ;       Description:    This routine handles the DATE command.
  5555                                  ;
  5556                                  ;-----------------------------------------------------------------------------------------------------------------------
  5557                                  ConDate                 readRealTimeClock wsConsoleDateTime                     ;read RTC data into structure
  5557                              <1> ConDate :
  5557 000001D4 BB750B0000          <1>  mov ebx,%1
  5557 000001D9 B019                <1>  mov al,eReadRealTimeClock
  5557 000001DB CD30                <1>  int _svc
  5558                                                          putDateString     wsConsoleDateTime,wzConsoleOutBuffer  ;format date string
  5558 000001DD BB750B0000          <1>  mov ebx,%1
  5558 000001E2 BAEC0A0000          <1>  mov edx,%2
  5558 000001E7 B00E                <1>  mov al,ePutDateString
  5558 000001E9 CD30                <1>  int _svc
  5559                                                          putConsoleString  wzConsoleOutBuffer                    ;write string to console
  5559 000001EB BAEC0A0000          <1>  mov edx,%1
  5559 000001F0 B00D                <1>  mov al,ePutConsoleString
  5559 000001F2 CD30                <1>  int _svc
  5560                                                          putConsoleString  czNewLine                             ;write newline to console
  5560 000001F4 BA[93090000]        <1>  mov edx,%1
  5560 000001F9 B00D                <1>  mov al,ePutConsoleString
  5560 000001FB CD30                <1>  int _svc
  5561 000001FD C3                                              ret                                                     ;return
  5562                                  ;-----------------------------------------------------------------------------------------------------------------------
  5563                                  ;
  5564                                  ;       Routine:        ConDay
  5565                                  ;
  5566                                  ;       Description:    This routine handles the DAY command.
  5567                                  ;
  5568                                  ;-----------------------------------------------------------------------------------------------------------------------
  5569                                  ConDay                  readRealTimeClock wsConsoleDateTime                     ;read RTC data into structure
  5569                              <1> ConDay :
  5569 000001FE BB750B0000          <1>  mov ebx,%1
  5569 00000203 B019                <1>  mov al,eReadRealTimeClock
  5569 00000205 CD30                <1>  int _svc
  5570                                                          putDayString      wsConsoleDateTime,wzConsoleOutBuffer  ;format day string
  5570 00000207 BB750B0000          <1>  mov ebx,%1
  5570 0000020C BAEC0A0000          <1>  mov edx,%2
  5570 00000211 B00F                <1>  mov al,ePutDayString
  5570 00000213 CD30                <1>  int _svc
  5571                                                          putConsoleString  wzConsoleOutBuffer                    ;write string to console
  5571 00000215 BAEC0A0000          <1>  mov edx,%1
  5571 0000021A B00D                <1>  mov al,ePutConsoleString
  5571 0000021C CD30                <1>  int _svc
  5572                                                          putConsoleString  czNewLine                             ;write newline to console
  5572 0000021E BA[93090000]        <1>  mov edx,%1
  5572 00000223 B00D                <1>  mov al,ePutConsoleString
  5572 00000225 CD30                <1>  int _svc
  5573 00000227 C3                                              ret                                                     ;return
  5574                                  ;-----------------------------------------------------------------------------------------------------------------------
  5575                                  ;
  5576                                  ;       Routine:        ConExit
  5577                                  ;
  5578                                  ;       Description:    This routine handles the EXIT command and its SHUTDOWN and QUIT aliases.
  5579                                  ;
  5580                                  ;-----------------------------------------------------------------------------------------------------------------------
  5581                                  ConExit                 resetSystem                                             ;issue system reset
  5581                              <1> ConExit :
  5581 00000228 B01A                <1>  mov al,eResetSystem
  5581 0000022A CD30                <1>  int _svc
  5582 0000022C C3                                              ret                                                     ;return
  5583                                  ;-----------------------------------------------------------------------------------------------------------------------
  5584                                  ;
  5585                                  ;       Routine:        ConFree
  5586                                  ;
  5587                                  ;       Description:    This routine handles the FREE command.
  5588                                  ;
  5589                                  ;       Input:          wzConsoleInBuffer contains parameter(s)
  5590                                  ;
  5591                                  ;-----------------------------------------------------------------------------------------------------------------------
  5592 0000022D 53                      ConFree                 push    ebx                                             ;save non-volatile regs
  5593 0000022E 51                                              push    ecx                                             ;
  5594 0000022F 56                                              push    esi                                             ;
  5595 00000230 57                                              push    edi                                             ;
  5596                                  ;
  5597                                  ;       Get address parameter
  5598                                  ;
  5599 00000231 BA4C0A0000                                      mov     edx,wzConsoleInBuffer                           ;console input buffer address (param)
  5600 00000236 BB9C0A0000                                      mov     ebx,wzConsoleToken                              ;console command token address
  5601 0000023B E830FFFFFF                                      call    ConTakeToken                                    ;take first param as token
  5602                                  ;
  5603                                  ;       Convert input parameter from hexadecimal string to binary
  5604                                  ;
  5605 00000240 803D9C0A000000                                  cmp     byte [wzConsoleToken],0                         ;token found?
  5606 00000247 7421                                            je      .10                                             ;no, branch
  5607 00000249 BA9C0A0000                                      mov     edx,wzConsoleToken                              ;first param as token address
  5608                                  
  5609                                                          hexadecimalToUnsigned                                   ;convert string token to unsigned
  5609 0000024E B00A                <1>  mov al,eHexadecimalToUnsigned
  5609 00000250 CD30                <1>  int _svc
  5610                                  
  5611 00000252 85C0                                            test    eax,eax                                         ;valid parameter?
  5612 00000254 7414                                            jz      .10                                             ;no, branch
  5613                                  ;
  5614                                  ;       Free memory block
  5615                                  ;
  5616                                                          freeMemory eax                                          ;free memory
  5616 00000256 89C2                <1>  mov edx,%1
  5616 00000258 B005                <1>  mov al,eFreeMemory
  5616 0000025A CD30                <1>  int _svc
  5617                                  
  5618 0000025C 83F8FF                                          cmp     eax,-1                                          ;memory freed?
  5619 0000025F 7409                                            je      .10                                             ;no, branch
  5620                                  ;
  5621                                  ;       Indicate memory freed
  5622                                  ;
  5623                                                          putConsoleString czOK                                   ;indicate success
  5623 00000261 BA[96090000]        <1>  mov edx,%1
  5623 00000266 B00D                <1>  mov al,ePutConsoleString
  5623 00000268 CD30                <1>  int _svc
  5624                                  ;
  5625                                  ;       Restore and return
  5626                                  ;
  5627 0000026A 5F                      .10                     pop     edi                                             ;restore non-volatile regs
  5628 0000026B 5E                                              pop     esi                                             ;
  5629 0000026C 59                                              pop     ecx                                             ;
  5630 0000026D 5B                                              pop     ebx                                             ;
  5631 0000026E C3                                              ret                                                     ;return
  5632                                  ;-----------------------------------------------------------------------------------------------------------------------
  5633                                  ;
  5634                                  ;       Routine:        ConHour
  5635                                  ;
  5636                                  ;       Description:    This routine Handles the HOUR command.
  5637                                  ;
  5638                                  ;-----------------------------------------------------------------------------------------------------------------------
  5639                                  ConHour                 readRealTimeClock wsConsoleDateTime                     ;read RTC data into structure
  5639                              <1> ConHour :
  5639 0000026F BB750B0000          <1>  mov ebx,%1
  5639 00000274 B019                <1>  mov al,eReadRealTimeClock
  5639 00000276 CD30                <1>  int _svc
  5640                                                          putHourString     wsConsoleDateTime,wzConsoleOutBuffer  ;format hour string
  5640 00000278 BB750B0000          <1>  mov ebx,%1
  5640 0000027D BAEC0A0000          <1>  mov edx,%2
  5640 00000282 B010                <1>  mov al,ePutHourString
  5640 00000284 CD30                <1>  int _svc
  5641                                                          putConsoleString  wzConsoleOutBuffer                    ;write string to console
  5641 00000286 BAEC0A0000          <1>  mov edx,%1
  5641 0000028B B00D                <1>  mov al,ePutConsoleString
  5641 0000028D CD30                <1>  int _svc
  5642                                                          putConsoleString  czNewLine                             ;write newline to console
  5642 0000028F BA[93090000]        <1>  mov edx,%1
  5642 00000294 B00D                <1>  mov al,ePutConsoleString
  5642 00000296 CD30                <1>  int _svc
  5643 00000298 C3                                              ret                                                     ;return
  5644                                  ;-----------------------------------------------------------------------------------------------------------------------
  5645                                  ;
  5646                                  ;       Routine:        ConInt6
  5647                                  ;
  5648                                  ;       Description:    This routine issues an interrupt 6 to exercise the interrupt handler.
  5649                                  ;
  5650                                  ;-----------------------------------------------------------------------------------------------------------------------
  5651 00000299 0F0B                    ConInt6                 ud2                                                     ;raise bad opcode exception
  5652 0000029B C3                                              ret                                                     ;return (not executed)
  5653                                  ;-----------------------------------------------------------------------------------------------------------------------
  5654                                  ;
  5655                                  ;       Routine:        ConMalloc
  5656                                  ;
  5657                                  ;       Description:    This routine handles the MALLOC command.
  5658                                  ;
  5659                                  ;       Input:          wzConsoleInBuffer contains parameter(s)
  5660                                  ;
  5661                                  ;-----------------------------------------------------------------------------------------------------------------------
  5662 0000029C 53                      ConMalloc               push    ebx                                             ;save non-volatile regs
  5663 0000029D 51                                              push    ecx                                             ;
  5664 0000029E 56                                              push    esi                                             ;
  5665 0000029F 57                                              push    edi                                             ;
  5666                                  ;
  5667                                  ;       Get size parameter
  5668                                  ;
  5669 000002A0 BA4C0A0000                                      mov     edx,wzConsoleInBuffer                           ;console input buffer address (params)
  5670 000002A5 BB9C0A0000                                      mov     ebx,wzConsoleToken                              ;console command token address
  5671 000002AA E8C1FEFFFF                                      call    ConTakeToken                                    ;take first param as token
  5672                                  ;
  5673                                  ;       Convert input parameter from decimal string to binary
  5674                                  ;
  5675 000002AF 803D9C0A000000                                  cmp     byte [wzConsoleToken],0                         ;token found?
  5676 000002B6 7434                                            je      .10                                             ;no, branch
  5677 000002B8 BA9C0A0000                                      mov     edx,wzConsoleToken                              ;first param as token address
  5678                                  
  5679                                                          decimalToUnsigned                                       ;convert string token to unsigned
  5679 000002BD B004                <1>  mov al,eDecimalToUnsigned
  5679 000002BF CD30                <1>  int _svc
  5680                                  
  5681 000002C1 85C0                                            test    eax,eax                                         ;valid parameter?
  5682 000002C3 7427                                            jz      .10                                             ;no, branch
  5683                                  ;
  5684                                  ;       Allocate memory block
  5685                                  ;
  5686                                                          allocateMemory eax                                      ;allocate memory
  5686 000002C5 89C1                <1>  mov ecx,%1
  5686 000002C7 B000                <1>  mov al,eAllocateMemory
  5686 000002C9 CD30                <1>  int _svc
  5687                                  
  5688 000002CB 85C0                                            test    eax,eax                                         ;memory allocated?
  5689 000002CD 741D                                            jz      .10                                             ;no, branch
  5690                                  ;
  5691                                  ;       Report allocated memory block address
  5692                                  ;
  5693 000002CF BAEC0A0000                                      mov     edx,wzConsoleOutBuffer                          ;output buffer address
  5694 000002D4 89C1                                            mov     ecx,eax                                         ;memory address
  5695                                  
  5696                                                          unsignedToHexadecimal                                   ;convert memory address to hex
  5696 000002D6 B01D                <1>  mov al,eUnsignedToHexadecimal
  5696 000002D8 CD30                <1>  int _svc
  5697                                                          putConsoleString wzConsoleOutBuffer                     ;display memory address
  5697 000002DA BAEC0A0000          <1>  mov edx,%1
  5697 000002DF B00D                <1>  mov al,ePutConsoleString
  5697 000002E1 CD30                <1>  int _svc
  5698                                                          putConsoleString czNewLine                              ;display new line
  5698 000002E3 BA[93090000]        <1>  mov edx,%1
  5698 000002E8 B00D                <1>  mov al,ePutConsoleString
  5698 000002EA CD30                <1>  int _svc
  5699                                  
  5700 000002EC 5F                      .10                     pop     edi                                             ;restore non-volatile regs
  5701 000002ED 5E                                              pop     esi                                             ;
  5702 000002EE 59                                              pop     ecx                                             ;
  5703 000002EF 5B                                              pop     ebx                                             ;
  5704 000002F0 C3                                              ret                                                     ;return
  5705                                  ;-----------------------------------------------------------------------------------------------------------------------
  5706                                  ;
  5707                                  ;       Routine:        ConMem
  5708                                  ;
  5709                                  ;       Description:    This routine handles the MEMORY command and its MEM alias.
  5710                                  ;
  5711                                  ;       Input:          wzConsoleInBuffer contains parameter(s)
  5712                                  ;
  5713                                  ;-----------------------------------------------------------------------------------------------------------------------
  5714 000002F1 53                      ConMem                  push    ebx                                             ;save non-volatile regs
  5715 000002F2 56                                              push    esi                                             ;
  5716 000002F3 57                                              push    edi                                             ;
  5717                                  ;
  5718                                  ;                       update the source address if a parameter is given
  5719                                  ;
  5720 000002F4 BA4C0A0000                                      mov     edx,wzConsoleInBuffer                           ;console input buffer address (params)
  5721 000002F9 BB9C0A0000                                      mov     ebx,wzConsoleToken                              ;console command token address
  5722 000002FE E86DFEFFFF                                      call    ConTakeToken                                    ;take first param as token
  5723 00000303 803D9C0A000000                                  cmp     byte [wzConsoleToken],0                         ;token found?
  5724 0000030A 740E                                            je      .10                                             ;no, branch
  5725 0000030C BA9C0A0000                                      mov     edx,wzConsoleToken                              ;first param as token address
  5726                                  
  5727                                                          hexadecimalToUnsigned                                   ;convert string token to unsigned
  5727 00000311 B00A                <1>  mov al,eHexadecimalToUnsigned
  5727 00000313 CD30                <1>  int _svc
  5728                                  
  5729 00000315 A3080A0000                                      mov     [wdConsoleMemBase],eax                          ;save console memory address
  5730                                  ;
  5731                                  ;                       setup source address and row count
  5732                                  ;
  5733 0000031A 8B35080A0000            .10                     mov     esi,[wdConsoleMemBase]                          ;source memory address
  5734 00000320 31C9                                            xor     ecx,ecx                                         ;zero register
  5735 00000322 B110                                            mov     cl,16                                           ;row count
  5736                                  ;
  5737                                  ;                       start the row with the source address in hexadecimal
  5738                                  ;
  5739 00000324 51                      .20                     push    ecx                                             ;save remaining rows
  5740 00000325 BFEC0A0000                                      mov     edi,wzConsoleOutBuffer                          ;output buffer address
  5741 0000032A 89FA                                            mov     edx,edi                                         ;output buffer address
  5742 0000032C 89F1                                            mov     ecx,esi                                         ;console memory address
  5743                                  
  5744                                                          unsignedToHexadecimal                                   ;convert unsigned address to hex string
  5744 0000032E B01D                <1>  mov al,eUnsignedToHexadecimal
  5744 00000330 CD30                <1>  int _svc
  5745                                  
  5746 00000332 83C708                                          add     edi,8                                           ;end of memory addr hexnum
  5747 00000335 B020                                            mov     al,' '                                          ;ascii space
  5748 00000337 AA                                              stosb                                                   ;store delimiter
  5749                                  ;
  5750                                  ;                       output 16 ASCII hexadecimal byte values for the row
  5751                                  ;
  5752 00000338 31C9                                            xor     ecx,ecx                                         ;zero register
  5753 0000033A B110                                            mov     cl,16                                           ;loop count
  5754 0000033C 51                      .30                     push    ecx                                             ;save loop count
  5755 0000033D AC                                              lodsb                                                   ;memory byte
  5756 0000033E 88C4                                            mov     ah,al                                           ;memory byte
  5757 00000340 C0E804                                          shr     al,4                                            ;high-order in bits 3-0
  5758 00000343 0C30                                            or      al,30h                                          ;apply ascii numeric zone
  5759 00000345 3C3A                                            cmp     al,3ah                                          ;numeric range?
  5760 00000347 7202                                            jb      .40                                             ;yes, skip ahead
  5761 00000349 0407                                            add     al,7                                            ;adjust ascii for 'A'-'F'
  5762 0000034B AA                      .40                     stosb                                                   ;store ascii hexadecimal of high-order
  5763 0000034C 88E0                                            mov     al,ah                                           ;low-order in bits 3-0
  5764 0000034E 240F                                            and     al,0fh                                          ;mask out high-order bits
  5765 00000350 0C30                                            or      al,30h                                          ;apply ascii numeric zone
  5766 00000352 3C3A                                            cmp     al,3ah                                          ;numeric range?
  5767 00000354 7202                                            jb      .50                                             ;yes, skip ahead
  5768 00000356 0407                                            add     al,7                                            ;adjust ascii for 'A'-'F'
  5769 00000358 AA                      .50                     stosb                                                   ;store ascii hexadecimal of low-order
  5770 00000359 B020                                            mov     al,' '                                          ;ascii space
  5771 0000035B AA                                              stosb                                                   ;store ascii space delimiter
  5772 0000035C 59                                              pop     ecx                                             ;loop count
  5773 0000035D E2DD                                            loop    .30                                             ;next
  5774                                  ;
  5775                                  ;                       output printable ASCII character section for the row
  5776                                  ;
  5777 0000035F 83EE10                                          sub     esi,16                                          ;reset source pointer
  5778 00000362 B110                                            mov     cl,16                                           ;loop count
  5779 00000364 AC                      .60                     lodsb                                                   ;source byte
  5780 00000365 3C20                                            cmp     al,32                                           ;printable? (low-range test)
  5781 00000367 7204                                            jb      .70                                             ;no, skip ahead
  5782 00000369 3C80                                            cmp     al,128                                          ;printable? (high-range test)
  5783 0000036B 7202                                            jb      .80                                             ;yes, skip ahead
  5784 0000036D B020                    .70                     mov     al,' '                                          ;display space instead of printable
  5785 0000036F AA                      .80                     stosb                                                   ;store printable ascii byte
  5786 00000370 E2F2                                            loop    .60                                             ;next source byte
  5787 00000372 30C0                                            xor     al,al                                           ;nul-terminator
  5788 00000374 AA                                              stosb                                                   ;terminate output line
  5789                                  ;
  5790                                  ;                       display constructed output buffer and newline
  5791                                  ;
  5792                                                          putConsoleString wzConsoleOutBuffer                     ;display constructed output
  5792 00000375 BAEC0A0000          <1>  mov edx,%1
  5792 0000037A B00D                <1>  mov al,ePutConsoleString
  5792 0000037C CD30                <1>  int _svc
  5793                                                          putConsoleString czNewLine                              ;display new line
  5793 0000037E BA[93090000]        <1>  mov edx,%1
  5793 00000383 B00D                <1>  mov al,ePutConsoleString
  5793 00000385 CD30                <1>  int _svc
  5794                                  ;
  5795                                  ;                       repeat until all lines displayed and preserve source address
  5796                                  ;
  5797 00000387 59                                              pop     ecx                                             ;remaining rows
  5798 00000388 E29A                                            loop    .20                                             ;next row
  5799 0000038A 8935080A0000                                    mov     [wdConsoleMemBase],esi                          ;update console memory address
  5800 00000390 5F                                              pop     edi                                             ;restore regs
  5801 00000391 5E                                              pop     esi                                             ;
  5802 00000392 5B                                              pop     ebx                                             ;
  5803 00000393 C3                                              ret                                                     ;return
  5804                                  ;-----------------------------------------------------------------------------------------------------------------------
  5805                                  ;
  5806                                  ;       Routine:        ConMinute
  5807                                  ;
  5808                                  ;       Description:    This routine Handles the MINUTE command.
  5809                                  ;
  5810                                  ;-----------------------------------------------------------------------------------------------------------------------
  5811                                  ConMinute               readRealTimeClock wsConsoleDateTime                     ;read RTC data into structure
  5811                              <1> ConMinute :
  5811 00000394 BB750B0000          <1>  mov ebx,%1
  5811 00000399 B019                <1>  mov al,eReadRealTimeClock
  5811 0000039B CD30                <1>  int _svc
  5812                                                          putMinuteString   wsConsoleDateTime,wzConsoleOutBuffer  ;format minute string
  5812 0000039D BB750B0000          <1>  mov ebx,%1
  5812 000003A2 BAEC0A0000          <1>  mov edx,%2
  5812 000003A7 B011                <1>  mov al,ePutMinuteString
  5812 000003A9 CD30                <1>  int _svc
  5813                                                          putConsoleString  wzConsoleOutBuffer                    ;write string to console
  5813 000003AB BAEC0A0000          <1>  mov edx,%1
  5813 000003B0 B00D                <1>  mov al,ePutConsoleString
  5813 000003B2 CD30                <1>  int _svc
  5814                                                          putConsoleString  czNewLine                             ;write newline to console
  5814 000003B4 BA[93090000]        <1>  mov edx,%1
  5814 000003B9 B00D                <1>  mov al,ePutConsoleString
  5814 000003BB CD30                <1>  int _svc
  5815 000003BD C3                                              ret                                                     ;return
  5816                                  ;-----------------------------------------------------------------------------------------------------------------------
  5817                                  ;
  5818                                  ;       Routine:        ConMonth
  5819                                  ;
  5820                                  ;       Description:    This routine Handles the MONTH command.
  5821                                  ;
  5822                                  ;-----------------------------------------------------------------------------------------------------------------------
  5823                                  ConMonth                readRealTimeClock wsConsoleDateTime                     ;read RTC data into structure
  5823                              <1> ConMonth :
  5823 000003BE BB750B0000          <1>  mov ebx,%1
  5823 000003C3 B019                <1>  mov al,eReadRealTimeClock
  5823 000003C5 CD30                <1>  int _svc
  5824                                                          putMonthString    wsConsoleDateTime,wzConsoleOutBuffer  ;format month string
  5824 000003C7 BB750B0000          <1>  mov ebx,%1
  5824 000003CC BAEC0A0000          <1>  mov edx,%2
  5824 000003D1 B012                <1>  mov al,ePutMonthString
  5824 000003D3 CD30                <1>  int _svc
  5825                                                          putConsoleString  wzConsoleOutBuffer                    ;write string to console
  5825 000003D5 BAEC0A0000          <1>  mov edx,%1
  5825 000003DA B00D                <1>  mov al,ePutConsoleString
  5825 000003DC CD30                <1>  int _svc
  5826                                                          putConsoleString  czNewLine                             ;write newline to console
  5826 000003DE BA[93090000]        <1>  mov edx,%1
  5826 000003E3 B00D                <1>  mov al,ePutConsoleString
  5826 000003E5 CD30                <1>  int _svc
  5827 000003E7 C3                                              ret                                                     ;return
  5828                                  ;-----------------------------------------------------------------------------------------------------------------------
  5829                                  ;
  5830                                  ;       Routine:        ConMonthName
  5831                                  ;
  5832                                  ;       Description:    This routine Handles the MONTH.NAME command.
  5833                                  ;
  5834                                  ;-----------------------------------------------------------------------------------------------------------------------
  5835                                  ConMonthName            readRealTimeClock  wsConsoleDateTime                    ;read RTC data into structure
  5835                              <1> ConMonthName :
  5835 000003E8 BB750B0000          <1>  mov ebx,%1
  5835 000003ED B019                <1>  mov al,eReadRealTimeClock
  5835 000003EF CD30                <1>  int _svc
  5836                                                          putMonthNameString wsConsoleDateTime,wzConsoleOutBuffer ;format month name string
  5836 000003F1 BB750B0000          <1>  mov ebx,%1
  5836 000003F6 BAEC0A0000          <1>  mov edx,%2
  5836 000003FB B013                <1>  mov al,ePutMonthNameString
  5836 000003FD CD30                <1>  int _svc
  5837                                                          putConsoleString   wzConsoleOutBuffer                   ;write string to console
  5837 000003FF BAEC0A0000          <1>  mov edx,%1
  5837 00000404 B00D                <1>  mov al,ePutConsoleString
  5837 00000406 CD30                <1>  int _svc
  5838                                                          putConsoleString   czNewLine                            ;write newline to console
  5838 00000408 BA[93090000]        <1>  mov edx,%1
  5838 0000040D B00D                <1>  mov al,ePutConsoleString
  5838 0000040F CD30                <1>  int _svc
  5839 00000411 C3                                              ret                                                     ;return
  5840                                  ;-----------------------------------------------------------------------------------------------------------------------
  5841                                  ;
  5842                                  ;       Routine:        ConPCIProbe
  5843                                  ;
  5844                                  ;       Description:    This routine handles the PCIProbe command.
  5845                                  ;
  5846                                  ;-----------------------------------------------------------------------------------------------------------------------
  5847 00000412 53                      ConPCIProbe             push    ebx                                             ;save non-volatile regs
  5848                                  ;
  5849                                  ;                       initialize variables
  5850                                  ;
  5851 00000413 30C0                                            xor     al,al                                           ;zero register
  5852 00000415 A2480A0000                                      mov     [wbConsolePCIBus],al                            ;initialize bus
  5853 0000041A A2490A0000                                      mov     [wbConsolePCIDevice],al                         ;initialize device
  5854 0000041F A24A0A0000                                      mov     [wbConsolePCIFunction],al                       ;initialize function
  5855                                  ;
  5856                                  ;                       construct PCI selector
  5857                                  ;
  5858 00000424 8A25480A0000            .10                     mov     ah,[wbConsolePCIBus]                            ;AH = bbbb bbbb
  5859 0000042A 8A15490A0000                                    mov     dl,[wbConsolePCIDevice]                         ;DL = ???d dddd
  5860 00000430 C0E203                                          shl     dl,3                                            ;DL = dddd d000
  5861 00000433 A04A0A0000                                      mov     al,[wbConsolePCIFunction]                       ;AL = ???? ?fff
  5862 00000438 2407                                            and     al,007h                                         ;AL = 0000 0fff
  5863 0000043A 08D0                                            or      al,dl                                           ;AL = dddd dfff
  5864 0000043C 0FB7C0                                          movzx   eax,ax                                          ;0000 0000 0000 0000 bbbb bbbb dddd dfff
  5865 0000043F C1E008                                          shl     eax,8                                           ;0000 0000 bbbb bbbb dddd dfff 0000 0000
  5866 00000442 0D00000080                                      or      eax,80000000h                                   ;1000 0000 bbbb bbbb dddd dfff 0000 0000
  5867 00000447 A31C0A0000                                      mov     [wdConsolePCISelector],eax                      ;save selector
  5868                                  ;
  5869                                  ;                       read PCI data register
  5870                                  ;
  5871 0000044C 66BAF80C                                        mov     dx,0cf8h                                        ;register port
  5872 00000450 EF                                              out     dx,eax                                          ;select device
  5873 00000451 66BAFC0C                                        mov     dx,0cfch                                        ;data port
  5874 00000455 ED                                              in      eax,dx                                          ;read register data
  5875 00000456 A3200A0000                                      mov     [wdConsolePCIData],eax                          ;save data
  5876                                  ;
  5877                                  ;                       interpret PCI data value and display finding
  5878                                  ;
  5879 0000045B 83F8FF                                          cmp     eax,0ffffffffh                                  ;not defined?
  5880 0000045E 7447                                            je      .20                                             ;yes, branch
  5881 00000460 BA9C0A0000                                      mov     edx,wzConsoleToken                              ;output buffer
  5882 00000465 E83D010000                                      call    ConBuildPCIIdent                                ;build PCI bus, device, function ident
  5883                                  
  5884                                                          putConsoleString wzConsoleToken                         ;display bus as decimal
  5884 0000046A BA9C0A0000          <1>  mov edx,%1
  5884 0000046F B00D                <1>  mov al,ePutConsoleString
  5884 00000471 CD30                <1>  int _svc
  5885                                  
  5886 00000473 E873010000                                      call    ConInterpretPCIData                             ;update flags based on data
  5887                                  
  5888                                                          putConsoleString czSpace
  5888 00000478 BA[390A0000]        <1>  mov edx,%1
  5888 0000047D B00D                <1>  mov al,ePutConsoleString
  5888 0000047F CD30                <1>  int _svc
  5889                                                          putConsoleString [wdConsolePCIVendorStr]
  5889 00000481 8B15240A0000        <1>  mov edx,%1
  5889 00000487 B00D                <1>  mov al,ePutConsoleString
  5889 00000489 CD30                <1>  int _svc
  5890                                                          putConsoleString czSpace
  5890 0000048B BA[390A0000]        <1>  mov edx,%1
  5890 00000490 B00D                <1>  mov al,ePutConsoleString
  5890 00000492 CD30                <1>  int _svc
  5891                                                          putConsoleString [wdConsolePCIChipStr]
  5891 00000494 8B15280A0000        <1>  mov edx,%1
  5891 0000049A B00D                <1>  mov al,ePutConsoleString
  5891 0000049C CD30                <1>  int _svc
  5892                                                          putConsoleString czNewLine                              ;display new line
  5892 0000049E BA[93090000]        <1>  mov edx,%1
  5892 000004A3 B00D                <1>  mov al,ePutConsoleString
  5892 000004A5 CD30                <1>  int _svc
  5893                                  ;
  5894                                  ;                       step to next function, device, bus
  5895                                  ;
  5896 000004A7 FE054A0A0000            .20                     inc     byte [wbConsolePCIFunction]                     ;next function
  5897 000004AD 803D4A0A000008                                  cmp     byte [wbConsolePCIFunction],8                   ;at limit?
  5898 000004B4 0F826AFFFFFF                                    jb      .10                                             ;no, continue
  5899 000004BA C6054A0A000000                                  mov     byte [wbConsolePCIFunction],0                   ;zero function
  5900 000004C1 FE05490A0000                                    inc     byte [wbConsolePCIDevice]                       ;next device
  5901 000004C7 803D490A000020                                  cmp     byte [wbConsolePCIDevice],32                    ;at limit?
  5902 000004CE 0F8250FFFFFF                                    jb      .10                                             ;no, continue
  5903 000004D4 C605490A000000                                  mov     byte [wbConsolePCIDevice],0                     ;zero device
  5904 000004DB FE05480A0000                                    inc     byte [wbConsolePCIBus]                          ;next bus
  5905 000004E1 803D480A000000                                  cmp     byte [wbConsolePCIBus],0                        ;at limit?
  5906 000004E8 0F8236FFFFFF                                    jb      .10                                             ;no, continue
  5907                                  
  5908 000004EE E9B2000000                                      jmp     .30
  5909                                  
  5910                                  ;
  5911                                  ;                       report if ethernet adapter found
  5912                                  ;
  5913 000004F3 F6054B0A000080                                  test    byte [wbConsoleHWFlags],EHWETHERNET             ;ethernet h/w switch set?
  5914 000004FA 0F84A5000000                                    jz      .30                                             ;branch if no
  5915                                  
  5916                                                          putConsoleString czEthernetAdapterFound                 ;report adapter found
  5916 00000500 BA[5F090000]        <1>  mov edx,%1
  5916 00000505 B00D                <1>  mov al,ePutConsoleString
  5916 00000507 CD30                <1>  int _svc
  5917                                  ;
  5918                                  ;                       read base address register 0 at offset 10h
  5919                                  ;
  5920 00000509 A12C0A0000                                      mov     eax,[wdConsoleEthernetDevice]                   ;adapter PCI selector
  5921 0000050E 83C810                                          or      eax,10h                                         ;set function bits
  5922 00000511 66BAF80C                                        mov     dx,0cf8h                                        ;register port
  5923 00000515 EF                                              out     dx,eax                                          ;select register
  5924 00000516 66BAFC0C                                        mov     dx,0cfch                                        ;data port
  5925 0000051A ED                                              in      eax,dx                                          ;register data
  5926 0000051B A3300A0000                                      mov     [wdConsoleEthernetMem],eax                      ;save ethernet memory mapped i/o addr
  5927                                  ;
  5928                                  ;                       report base address register 0 value
  5929                                  ;
  5930 00000520 89C1                                            mov     ecx,eax                                         ;unsigned integer param
  5931 00000522 BA9C0A0000                                      mov     edx,wzConsoleToken                              ;target buffer address
  5932                                  
  5933                                                          unsignedToHexadecimal                                   ;convert unsigned to ASCII hex string
  5933 00000527 B01D                <1>  mov al,eUnsignedToHexadecimal
  5933 00000529 CD30                <1>  int _svc
  5934                                                          putConsoleString wzConsoleToken                         ;output string to console
  5934 0000052B BA9C0A0000          <1>  mov edx,%1
  5934 00000530 B00D                <1>  mov al,ePutConsoleString
  5934 00000532 CD30                <1>  int _svc
  5935                                                          putConsoleString czNewLine                              ;output newline to console
  5935 00000534 BA[93090000]        <1>  mov edx,%1
  5935 00000539 B00D                <1>  mov al,ePutConsoleString
  5935 0000053B CD30                <1>  int _svc
  5936                                  ;
  5937                                  ;                       read base address register 2 at offset 18h
  5938                                  ;
  5939 0000053D A12C0A0000                                      mov     eax,[wdConsoleEthernetDevice]                   ;adapter PCI selector
  5940 00000542 83C818                                          or      eax,18h                                         ;set function bits
  5941 00000545 66BAF80C                                        mov     dx,0cf8h                                        ;register port
  5942 00000549 EF                                              out     dx,eax                                          ;select register
  5943 0000054A 66BAFC0C                                        mov     dx,0cfch                                        ;data port
  5944 0000054E ED                                              in      eax,dx                                          ;register data
  5945 0000054F 24FE                                            and     al,0feh                                         ;clear bit zero
  5946 00000551 A3340A0000                                      mov     [wdConsoleEthernetPort],eax                     ;save ethernet i/o port
  5947                                  ;
  5948                                  ;                       report base address register 2 value
  5949                                  ;
  5950 00000556 89C1                                            mov     ecx,eax                                         ;unsigned integer param
  5951 00000558 BA9C0A0000                                      mov     edx,wzConsoleToken                              ;target buffer address
  5952                                  
  5953                                                          unsignedToHexadecimal                                   ;convert unsigned to ASCII hex string
  5953 0000055D B01D                <1>  mov al,eUnsignedToHexadecimal
  5953 0000055F CD30                <1>  int _svc
  5954                                                          putConsoleString wzConsoleToken                         ;output string to console
  5954 00000561 BA9C0A0000          <1>  mov edx,%1
  5954 00000566 B00D                <1>  mov al,ePutConsoleString
  5954 00000568 CD30                <1>  int _svc
  5955                                                          putConsoleString czNewLine                              ;output newline to console
  5955 0000056A BA[93090000]        <1>  mov edx,%1
  5955 0000056F B00D                <1>  mov al,ePutConsoleString
  5955 00000571 CD30                <1>  int _svc
  5956                                  ;
  5957                                  ;                       read ethernet control register using port i/o
  5958                                  ;
  5959 00000573 A1340A0000                                      mov     eax,[wdConsoleEthernetPort]                     ;ethernet i/o port
  5960 00000578 6689C2                                          mov     dx,ax                                           ;ethernet i/o port
  5961 0000057B 31C0                                            xor     eax,eax                                         ;control register (zero)
  5962 0000057D EF                                              out     dx,eax                                          ;select register
  5963 0000057E 6683C204                                        add     dx,4                                            ;data register
  5964 00000582 ED                                              in      eax,dx                                          ;read register data
  5965 00000583 A3380A0000                                      mov     [wdConsoleEthernetCtrl],eax                     ;save ethernet control register value
  5966                                  ;
  5967                                  ;                       report adapter control register value
  5968                                  ;
  5969 00000588 89C1                                            mov     ecx,eax                                         ;unsigned integer param
  5970 0000058A BA9C0A0000                                      mov     edx,wzConsoleToken                              ;target buffer address
  5971                                  
  5972                                                          unsignedToHexadecimal                                   ;convert unsigned to ASCII hex string
  5972 0000058F B01D                <1>  mov al,eUnsignedToHexadecimal
  5972 00000591 CD30                <1>  int _svc
  5973                                                          putConsoleString wzConsoleToken                         ;output string to console
  5973 00000593 BA9C0A0000          <1>  mov edx,%1
  5973 00000598 B00D                <1>  mov al,ePutConsoleString
  5973 0000059A CD30                <1>  int _svc
  5974                                                          putConsoleString czNewLine                              ;output newline to console
  5974 0000059C BA[93090000]        <1>  mov edx,%1
  5974 000005A1 B00D                <1>  mov al,ePutConsoleString
  5974 000005A3 CD30                <1>  int _svc
  5975                                  
  5976 000005A5 5B                      .30                     pop     ebx                                             ;restore non-volatile regs
  5977 000005A6 C3                                              ret                                                     ;return
  5978                                  ;-----------------------------------------------------------------------------------------------------------------------
  5979                                  ;
  5980                                  ;       Routine:        ConBuildPCIIdent
  5981                                  ;
  5982                                  ;       Description:    This routine constructs a PCI identification string from the current PCI Bus, Device, and
  5983                                  ;                       Function code values.
  5984                                  ;
  5985                                  ;       In:             DS:EDX  output buffer address
  5986                                  ;
  5987                                  ;-----------------------------------------------------------------------------------------------------------------------
  5988 000005A7 57                      ConBuildPCIIdent        push    edi                                             ;save non-volatile regs
  5989 000005A8 89D7                                            mov     edi,edx                                         ;output buffer address
  5990 000005AA A0480A0000                                      mov     al,[wbConsolePCIBus]                            ;current PCI bus (0-255)
  5991 000005AF 30E4                                            xor     ah,ah                                           ;zero high-order dividend
  5992 000005B1 B164                                            mov     cl,100                                          ;divisor (10^2)
  5993 000005B3 F6F1                                            div     cl                                              ;AL=100's, AH=bus MOD 100
  5994 000005B5 0C30                                            or      al,30h                                          ;apply ASCII zone
  5995 000005B7 FC                                              cld                                                     ;forward strings
  5996 000005B8 AA                                              stosb                                                   ;store 100's digit
  5997 000005B9 88E0                                            mov     al,ah                                           ;bus MOD 100
  5998 000005BB 30E4                                            xor     ah,ah                                           ;zero high-order dividend
  5999 000005BD B10A                                            mov     cl,10                                           ;divisor (10^1)
  6000 000005BF F6F1                                            div     cl                                              ;AL=10's, AH=1's
  6001 000005C1 660D3030                                        or      ax,3030h                                        ;apply ASCII zone
  6002 000005C5 66AB                                            stosw                                                   ;store 10's and 1's
  6003 000005C7 B02E                                            mov     al,EASCIIPERIOD                                 ;ASCII period delimiter
  6004 000005C9 AA                                              stosb                                                   ;store delimiter
  6005 000005CA A0490A0000                                      mov     al,[wbConsolePCIDevice]                         ;current PCI device (0-15)
  6006 000005CF 30E4                                            xor     ah,ah                                           ;zero high order dividend
  6007 000005D1 B10A                                            mov     cl,10                                           ;divisor (10^1)
  6008 000005D3 F6F1                                            div     cl                                              ;AL=10's, AH=1's
  6009 000005D5 660D3030                                        or      ax,3030h                                        ;apply ASCII zone
  6010 000005D9 66AB                                            stosw                                                   ;store 10's and 1's
  6011 000005DB B02E                                            mov     al,EASCIIPERIOD                                 ;ASCII period delimiter
  6012 000005DD AA                                              stosb                                                   ;store delimiter
  6013 000005DE A04A0A0000                                      mov     al,[wbConsolePCIFunction]                       ;current PCI function (0-7)
  6014 000005E3 0C30                                            or      al,30h                                          ;apply ASCII zone
  6015 000005E5 AA                                              stosb                                                   ;store 1's
  6016 000005E6 30C0                                            xor     al,al                                           ;null terminator
  6017 000005E8 AA                                              stosb                                                   ;store terminator
  6018 000005E9 5F                                              pop     edi                                             ;restore non-volatile regs
  6019 000005EA C3                                              ret                                                     ;return
  6020                                  ;-----------------------------------------------------------------------------------------------------------------------
  6021                                  ;
  6022                                  ;       Routine:        ConInterpretPCIData
  6023                                  ;
  6024                                  ;       Description:    This routine interprets the PCI vendor and device IDs.
  6025                                  ;
  6026                                  ;-----------------------------------------------------------------------------------------------------------------------
  6027 000005EB B8[34090000]            ConInterpretPCIData     mov     eax,czApple
  6028 000005F0 66813D200A00006B10                              cmp     word [wwConsolePCIVendor],EPCIVENDORAPPLE       ;Apple?
  6029 000005F9 751D                                            jne     .10                                             ;no, branch
  6030 000005FB BA[6B0A0000]                                    mov     edx,czUSBController
  6031 00000600 66833D220A00003F                                cmp     word [wwConsolePCIChip],EPCIAPPLEUSB            ;USB?
  6032 00000608 0F84CA000000                                    je      .80                                             ;yes, branch
  6033 0000060E BA[A2090000]                                    mov     edx,czOther                                     ;other
  6034 00000613 E9C0000000                                      jmp     .80                                             ;continue
  6035 00000618 B8[8A090000]            .10                     mov     eax,czIntel                                     ;Intel
  6036 0000061D 66813D200A00008680                              cmp     word [wwConsolePCIVendor],EPCIVENDORINTEL       ;Intel?
  6037 00000626 756F                                            jne     .20                                             ;no, branch
  6038 00000628 BA[F9090000]                                    mov     edx,czPro1000MT                                 ;Pro/1000 MT
  6039 0000062D 66813D220A00000F10                              cmp     word [wwConsolePCIChip],EPCIINTELPRO1000MT      ;Pro/1000 MT?
  6040 00000636 0F849C000000                                    je      .80                                             ;yes, branch
  6041 0000063C BA[A8090000]                                    mov     edx,czPCIAndMem                                 ;PCI and Memory
  6042 00000641 66813D220A00003712                              cmp     word [wwConsolePCIChip],EPCIINTELPCIMEM         ;PCI and Memory?
  6043 0000064A 0F8488000000                                    je      .80                                             ;yes, branch
  6044 00000650 BA[3A090000]                                    mov     edx,czAurealAD1881                              ;Aureal 1881 SOUNDMAX
  6045 00000655 66813D220A00001524                              cmp     word [wwConsolePCIChip],EPCIINTELAD1881         ;Aureal 1881 SOUNDMAX?
  6046 0000065E 7478                                            je      .80                                             ;yes, branch
  6047 00000660 BA[B7090000]                                    mov     edx,czPIIX3PCItoIDEBridge                       ;PIIX3 PCI-to-IDE Bridge
  6048 00000665 66813D220A00000070                              cmp     word [wwConsolePCIChip],EPCIINTELPIIX3          ;PIIX3 PCI-to-IDE Bridge?
  6049 0000066E 7468                                            je      .80                                             ;yes, branch
  6050 00000670 BA[E20A0000]                                    mov     edx,cz82371ABBusMaster                          ;82371AB Bus Master
  6051 00000675 66813D220A00001171                              cmp     word [wwConsolePCIChip],EPCIINTEL82371AB        ;82371AB Bus Master?
  6052 0000067E 7458                                            je      .80                                             ;yes, branch
  6053 00000680 BA[CF090000]                                    mov     edx,czPIIX4PowerMgmt                            ;PIIX4/4E/4M Power Mgmt Controller
  6054 00000685 66813D220A00001371                              cmp     word [wwConsolePCIChip],EPCIINTELPIIX4          ;PIIX4/4E/4M Power Mgmt Controller?
  6055 0000068E 7448                                            je      .80                                             ;yes, branch
  6056 00000690 BA[A2090000]                                    mov     edx,czOther                                     ;other
  6057 00000695 EB41                                            jmp     .80                                             ;continue
  6058 00000697 B8[9B090000]            .20                     mov     eax,czOracle                                    ;Oracle
  6059 0000069C 66813D200A0000EE80                              cmp     word [wwConsolePCIVendor],EPCIVENDORORACLE      ;Oracle?
  6060 000006A5 7527                                            jne     .30                                             ;no, branch
  6061 000006A7 BA[8C0A0000]                                    mov     edx,czVirtualBoxGA                              ;VirtulaBox Graphics Adapter
  6062 000006AC 66813D220A0000EFBE                              cmp     word [wwConsolePCIChip],EPCIORACLEVBOXGA        ;VirtualBox Graphics Adapter?
  6063 000006B5 7421                                            je      .80                                             ;yes, branch
  6064 000006B7 BA[7A0A0000]                                    mov     edx,czVirtualBoxDevice                          ;VirtualBox Device
  6065 000006BC 66813D220A0000FECA                              cmp     word [wwConsolePCIChip],EPCIORACLEVBOXDEVICE    ;VirtualBox Device?
  6066 000006C5 7411                                            je      .80                                             ;yes, branch
  6067 000006C7 BA[A2090000]                                    mov     edx,czOther                                     ;other
  6068 000006CC EB0A                                            jmp     .80                                             ;continue
  6069 000006CE B8[A2090000]            .30                     mov     eax,czOther                                     ;other
  6070 000006D3 BA[A2090000]                                    mov     edx,czOther                                     ;other
  6071 000006D8 A3240A0000              .80                     mov     [wdConsolePCIVendorStr],eax                     ;save vendor string
  6072 000006DD 8915280A0000                                    mov     [wdConsolePCIChipStr],edx                       ;save chip string
  6073 000006E3 66813D220A00000F10                              cmp     word [wwConsolePCIChip],EPCIINTELPRO1000MT      ;Pro/1000 MT Ethernet Adapter
  6074 000006EC 7511                                            jne     .90                                             ;no, branch
  6075 000006EE 800D4B0A000080                                  or      byte [wbConsoleHWFlags],EHWETHERNET             ;ethernet adapter found
  6076 000006F5 A11C0A0000                                      mov     eax,[wdConsolePCISelector]                      ;PCI selector
  6077 000006FA A32C0A0000                                      mov     [wdConsoleEthernetDevice],eax                   ;save as ethernet device selector
  6078 000006FF C3                      .90                     ret                                                     ;return
  6079                                  ;-----------------------------------------------------------------------------------------------------------------------
  6080                                  ;
  6081                                  ;       Routine:        ConSecond
  6082                                  ;
  6083                                  ;       Description:    This routine Handles the SECOND command.
  6084                                  ;
  6085                                  ;-----------------------------------------------------------------------------------------------------------------------
  6086                                  ConSecond               readRealTimeClock wsConsoleDateTime                     ;read RTC data into structure
  6086                              <1> ConSecond :
  6086 00000700 BB750B0000          <1>  mov ebx,%1
  6086 00000705 B019                <1>  mov al,eReadRealTimeClock
  6086 00000707 CD30                <1>  int _svc
  6087                                                          putSecondString   wsConsoleDateTime,wzConsoleOutBuffer  ;format second string
  6087 00000709 BB750B0000          <1>  mov ebx,%1
  6087 0000070E BAEC0A0000          <1>  mov edx,%2
  6087 00000713 B014                <1>  mov al,ePutSecondString
  6087 00000715 CD30                <1>  int _svc
  6088                                                          putConsoleString  wzConsoleOutBuffer                    ;write string to console
  6088 00000717 BAEC0A0000          <1>  mov edx,%1
  6088 0000071C B00D                <1>  mov al,ePutConsoleString
  6088 0000071E CD30                <1>  int _svc
  6089                                                          putConsoleString  czNewLine                             ;write newline to console
  6089 00000720 BA[93090000]        <1>  mov edx,%1
  6089 00000725 B00D                <1>  mov al,ePutConsoleString
  6089 00000727 CD30                <1>  int _svc
  6090 00000729 C3                                              ret                                                     ;return
  6091                                  ;-----------------------------------------------------------------------------------------------------------------------
  6092                                  ;
  6093                                  ;       Routine:        ConTime
  6094                                  ;
  6095                                  ;       Description:    This routine Handles the TIME command.
  6096                                  ;
  6097                                  ;-----------------------------------------------------------------------------------------------------------------------
  6098                                  ConTime                 readRealTimeClock wsConsoleDateTime                     ;read RTC data into structure
  6098                              <1> ConTime :
  6098 0000072A BB750B0000          <1>  mov ebx,%1
  6098 0000072F B019                <1>  mov al,eReadRealTimeClock
  6098 00000731 CD30                <1>  int _svc
  6099                                                          putTimeString     wsConsoleDateTime,wzConsoleOutBuffer  ;format time string
  6099 00000733 BB750B0000          <1>  mov ebx,%1
  6099 00000738 BAEC0A0000          <1>  mov edx,%2
  6099 0000073D B015                <1>  mov al,ePutTimeString
  6099 0000073F CD30                <1>  int _svc
  6100                                                          putConsoleString  wzConsoleOutBuffer                    ;write string to console
  6100 00000741 BAEC0A0000          <1>  mov edx,%1
  6100 00000746 B00D                <1>  mov al,ePutConsoleString
  6100 00000748 CD30                <1>  int _svc
  6101                                                          putConsoleString  czNewLine                             ;write newline to console
  6101 0000074A BA[93090000]        <1>  mov edx,%1
  6101 0000074F B00D                <1>  mov al,ePutConsoleString
  6101 00000751 CD30                <1>  int _svc
  6102 00000753 C3                                              ret                                                     ;return
  6103                                  ;-----------------------------------------------------------------------------------------------------------------------
  6104                                  ;
  6105                                  ;       Routine:        ConVersion
  6106                                  ;
  6107                                  ;       Description:    This routine handles the VERSION command and its alias, VER.
  6108                                  ;
  6109                                  ;-----------------------------------------------------------------------------------------------------------------------
  6110                                  ConVersion              putConsoleString czTitle                                ;display version message
  6110                              <1> ConVersion :
  6110 00000754 BA[3B0A0000]        <1>  mov edx,%1
  6110 00000759 B00D                <1>  mov al,ePutConsoleString
  6110 0000075B CD30                <1>  int _svc
  6111 0000075D C3                                              ret                                                     ;return
  6112                                  ;-----------------------------------------------------------------------------------------------------------------------
  6113                                  ;
  6114                                  ;       Routine:        ConWeekday
  6115                                  ;
  6116                                  ;       Description:    This routine handles the WEEKDAY command.
  6117                                  ;
  6118                                  ;-----------------------------------------------------------------------------------------------------------------------
  6119                                  ConWeekday              readRealTimeClock wsConsoleDateTime                     ;read RTC data into structure
  6119                              <1> ConWeekday :
  6119 0000075E BB750B0000          <1>  mov ebx,%1
  6119 00000763 B019                <1>  mov al,eReadRealTimeClock
  6119 00000765 CD30                <1>  int _svc
  6120                                                          putWeekdayString  wsConsoleDateTime,wzConsoleOutBuffer  ;format weekday string
  6120 00000767 BB750B0000          <1>  mov ebx,%1
  6120 0000076C BAEC0A0000          <1>  mov edx,%2
  6120 00000771 B016                <1>  mov al,ePutWeekdayString
  6120 00000773 CD30                <1>  int _svc
  6121                                                          putConsoleString  wzConsoleOutBuffer                    ;write string to console
  6121 00000775 BAEC0A0000          <1>  mov edx,%1
  6121 0000077A B00D                <1>  mov al,ePutConsoleString
  6121 0000077C CD30                <1>  int _svc
  6122                                                          putConsoleString  czNewLine                             ;write newline to console
  6122 0000077E BA[93090000]        <1>  mov edx,%1
  6122 00000783 B00D                <1>  mov al,ePutConsoleString
  6122 00000785 CD30                <1>  int _svc
  6123 00000787 C3                                              ret                                                     ;return
  6124                                  ;-----------------------------------------------------------------------------------------------------------------------
  6125                                  ;
  6126                                  ;       Routine:        ConWeekdayName
  6127                                  ;
  6128                                  ;       Description:    This routine Handles the WEEKDAY.NAME command.
  6129                                  ;
  6130                                  ;-----------------------------------------------------------------------------------------------------------------------
  6131                                  ConWeekdayName          readRealTimeClock    wsConsoleDateTime                          ;read RTC data into structure
  6131                              <1> ConWeekdayName :
  6131 00000788 BB750B0000          <1>  mov ebx,%1
  6131 0000078D B019                <1>  mov al,eReadRealTimeClock
  6131 0000078F CD30                <1>  int _svc
  6132                                                          putWeekdayNameString wsConsoleDateTime,wzConsoleOutBuffer       ;format day name string
  6132 00000791 BB750B0000          <1>  mov ebx,%1
  6132 00000796 BAEC0A0000          <1>  mov edx,%2
  6132 0000079B B017                <1>  mov al,ePutWeekdayNameString
  6132 0000079D CD30                <1>  int _svc
  6133                                                          putConsoleString     wzConsoleOutBuffer                         ;write string to console
  6133 0000079F BAEC0A0000          <1>  mov edx,%1
  6133 000007A4 B00D                <1>  mov al,ePutConsoleString
  6133 000007A6 CD30                <1>  int _svc
  6134                                                          putConsoleString     czNewLine                                  ;write newline to console
  6134 000007A8 BA[93090000]        <1>  mov edx,%1
  6134 000007AD B00D                <1>  mov al,ePutConsoleString
  6134 000007AF CD30                <1>  int _svc
  6135 000007B1 C3                                              ret                                                             ;return
  6136                                  ;-----------------------------------------------------------------------------------------------------------------------
  6137                                  ;
  6138                                  ;       Routine:        ConYear
  6139                                  ;
  6140                                  ;       Description:    This routine Handles the YEAR command.
  6141                                  ;
  6142                                  ;-----------------------------------------------------------------------------------------------------------------------
  6143                                  ConYear                 readRealTimeClock wsConsoleDateTime                     ;read RTC data into structure
  6143                              <1> ConYear :
  6143 000007B2 BB750B0000          <1>  mov ebx,%1
  6143 000007B7 B019                <1>  mov al,eReadRealTimeClock
  6143 000007B9 CD30                <1>  int _svc
  6144                                                          putYearString     wsConsoleDateTime,wzConsoleOutBuffer  ;format year string
  6144 000007BB BB750B0000          <1>  mov ebx,%1
  6144 000007C0 BAEC0A0000          <1>  mov edx,%2
  6144 000007C5 B018                <1>  mov al,ePutYearString
  6144 000007C7 CD30                <1>  int _svc
  6145                                                          putConsoleString  wzConsoleOutBuffer                    ;write string to console
  6145 000007C9 BAEC0A0000          <1>  mov edx,%1
  6145 000007CE B00D                <1>  mov al,ePutConsoleString
  6145 000007D0 CD30                <1>  int _svc
  6146                                                          putConsoleString  czNewLine                             ;write newline to console
  6146 000007D2 BA[93090000]        <1>  mov edx,%1
  6146 000007D7 B00D                <1>  mov al,ePutConsoleString
  6146 000007D9 CD30                <1>  int _svc
  6147 000007DB C3                                              ret                                                     ;return
  6148                                  ;-----------------------------------------------------------------------------------------------------------------------
  6149                                  ;
  6150                                  ;       Routine:        ConYearIsLeap
  6151                                  ;
  6152                                  ;       Description:    This routine handles the YEAR.ISLEAP command
  6153                                  ;
  6154                                  ;-----------------------------------------------------------------------------------------------------------------------
  6155                                  ConYearIsLeap           readRealTimeClock wsConsoleDateTime                     ;read RTC data into structure
  6155                              <1> ConYearIsLeap :
  6155 000007DC BB750B0000          <1>  mov ebx,%1
  6155 000007E1 B019                <1>  mov al,eReadRealTimeClock
  6155 000007E3 CD30                <1>  int _svc
  6156                                                          isLeapYear        wsConsoleDateTime                     ;indicate if year is leap year
  6156 000007E5 BB750B0000          <1>  mov ebx,%1
  6156 000007EA B00B                <1>  mov al,eIsLeapYear
  6156 000007EC CD30                <1>  int _svc
  6157                                  
  6158 000007EE E30B                                            jecxz   .10                                             ;branch if not leap
  6159                                  
  6160                                                          putConsoleString  czYearIsLeap                          ;display year is leap message
  6160 000007F0 BA[A80A0000]        <1>  mov edx,%1
  6160 000007F5 B00D                <1>  mov al,ePutConsoleString
  6160 000007F7 CD30                <1>  int _svc
  6161                                  
  6162 000007F9 EB09                                            jmp     .20                                             ;continue
  6163                                  
  6164                                  .10                     putConsoleString  czYearIsNotLeap                       ;display year is not leap mesage
  6164                              <1> .10 :
  6164 000007FB BA[C30A0000]        <1>  mov edx,%1
  6164 00000800 B00D                <1>  mov al,ePutConsoleString
  6164 00000802 CD30                <1>  int _svc
  6165 00000804 C3                      .20                     ret                                                     ;return
  6166                                  ;-----------------------------------------------------------------------------------------------------------------------
  6167                                  ;
  6168                                  ;       Tables
  6169                                  ;
  6170                                  ;-----------------------------------------------------------------------------------------------------------------------
  6171                                                                                                                  ;---------------------------------------
  6172                                                                                                                  ;  Command Jump Table
  6173                                                                                                                  ;---------------------------------------
  6174                                  tConJmpTbl              equ     $                                               ;command jump table
  6175 00000805 88070000                                        dd      ConWeekdayName  - ConCode                       ;weekday.name command routine offset
  6176 00000809 DC070000                                        dd      ConYearIsLeap   - ConCode                       ;year.isleap command routine offset
  6177 0000080D E8030000                                        dd      ConMonthName    - ConCode                       ;month.name command routine offset
  6178 00000811 12040000                                        dd      ConPCIProbe     - ConCode                       ;pciprobe command routine offset
  6179 00000815 28020000                                        dd      ConExit         - ConCode                       ;shutdown command routine offset
  6180 00000819 54070000                                        dd      ConVersion      - ConCode                       ;version command routine offset
  6181 0000081D 5E070000                                        dd      ConWeekday      - ConCode                       ;weekday command routine offset
  6182 00000821 9C020000                                        dd      ConMalloc       - ConCode                       ;malloc command routine offset
  6183 00000825 F1020000                                        dd      ConMem          - ConCode                       ;memory command routine offset
  6184 00000829 94030000                                        dd      ConMinute       - ConCode                       ;minute command routine offset
  6185 0000082D 00070000                                        dd      ConSecond       - ConCode                       ;second command routine offset
  6186 00000831 CF010000                                        dd      ConClear        - ConCode                       ;clear command routine offset
  6187 00000835 12040000                                        dd      ConPCIProbe     - ConCode                       ;lspci command routine offset
  6188 00000839 BE030000                                        dd      ConMonth        - ConCode                       ;month command routine offset
  6189 0000083D D4010000                                        dd      ConDate         - ConCode                       ;date command routine offset
  6190 00000841 28020000                                        dd      ConExit         - ConCode                       ;exit command routine offset
  6191 00000845 2D020000                                        dd      ConFree         - ConCode                       ;free command routine offset
  6192 00000849 6F020000                                        dd      ConHour         - ConCode                       ;hour command routine offset
  6193 0000084D 99020000                                        dd      ConInt6         - ConCode                       ;int6 command routine offset
  6194 00000851 28020000                                        dd      ConExit         - ConCode                       ;quit command routine offset
  6195 00000855 2A070000                                        dd      ConTime         - ConCode                       ;time command routine offset
  6196 00000859 B2070000                                        dd      ConYear         - ConCode                       ;year command routine offset
  6197 0000085D CF010000                                        dd      ConClear        - ConCode                       ;cls command routine offset
  6198 00000861 FE010000                                        dd      ConDay          - ConCode                       ;day command routine offset
  6199 00000865 F1020000                                        dd      ConMem          - ConCode                       ;mem command routine offset
  6200 00000869 54070000                                        dd      ConVersion      - ConCode                       ;ver command routine offset
  6201                                  ECONJMPTBLL             equ     ($-tConJmpTbl)                                  ;table length
  6202                                  ECONJMPTBLCNT           equ     ECONJMPTBLL/4                                   ;table entries
  6203                                                                                                                  ;---------------------------------------
  6204                                                                                                                  ;  Command Name Table
  6205                                                                                                                  ;---------------------------------------
  6206                                  tConCmdTbl              equ     $                                               ;command name table
  6207 0000086D 0D5745454B4441592E-                             db      13,"WEEKDAY.NAME",0                             ;weekday.name command
  6207 00000876 4E414D4500         
  6208 0000087B 0C594541522E49534C-                             db      12,"YEAR.ISLEAP",0                              ;year.isleap command
  6208 00000884 45415000           
  6209 00000888 0B4D4F4E54482E4E41-                             db      11,"MONTH.NAME",0                               ;month.name command
  6209 00000891 4D4500             
  6210 00000894 0950434950524F4245-                             db      9,"PCIPROBE",0                                  ;pciprobe command
  6210 0000089D 00                 
  6211 0000089E 0953485554444F574E-                             db      9,"SHUTDOWN",0                                  ;shutdown command
  6211 000008A7 00                 
  6212 000008A8 0856455253494F4E00                              db      8,"VERSION",0                                   ;version command
  6213 000008B1 085745454B44415900                              db      8,"WEEKDAY",0                                   ;weekday command
  6214 000008BA 074D414C4C4F4300                                db      7,"MALLOC",0                                    ;malloc command
  6215 000008C2 074D454D4F525900                                db      7,"MEMORY",0                                    ;memory command
  6216 000008CA 074D494E55544500                                db      7,"MINUTE",0                                    ;minute command
  6217 000008D2 075345434F4E4400                                db      7,"SECOND",0                                    ;second command
  6218 000008DA 06434C45415200                                  db      6,"CLEAR",0                                     ;clear command
  6219 000008E1 064C5350434900                                  db      6,"LSPCI",0                                     ;lspci command (pciprobe alias)
  6220 000008E8 064D4F4E544800                                  db      6,"MONTH",0                                     ;month command
  6221 000008EF 054441544500                                    db      5,"DATE",0                                      ;date command
  6222 000008F5 054558495400                                    db      5,"EXIT",0                                      ;exit command
  6223 000008FB 054652454500                                    db      5,"FREE",0                                      ;free command
  6224 00000901 05484F555200                                    db      5,"HOUR",0                                      ;hour command
  6225 00000907 05494E543600                                    db      5,"INT6",0                                      ;int6 command
  6226 0000090D 055155495400                                    db      5,"QUIT",0                                      ;quit command
  6227 00000913 0554494D4500                                    db      5,"TIME",0                                      ;time command
  6228 00000919 055945415200                                    db      5,"YEAR",0                                      ;year command
  6229 0000091F 04434C5300                                      db      4,"CLS",0                                       ;cls command
  6230 00000924 0444415900                                      db      4,"DAY",0                                       ;day command
  6231 00000929 044D454D00                                      db      4,"MEM",0                                       ;mem command
  6232 0000092E 0456455200                                      db      4,"VER",0                                       ;ver command
  6233 00000933 00                                              db      0                                               ;end of table
  6234                                  ;-----------------------------------------------------------------------------------------------------------------------
  6235                                  ;
  6236                                  ;       Constants
  6237                                  ;
  6238                                  ;-----------------------------------------------------------------------------------------------------------------------
  6239 00000934 4170706C6500            czApple                 db      "Apple",0                                       ;vendor name string
  6240 0000093A 41757265616C204144-     czAurealAD1881          db      "Aureal AD1881 SOUNDMAX",0                      ;soundmax string
  6240 00000943 3138383120534F554E-
  6240 0000094C 444D415800         
  6241 00000951 42617365206D656D6F-     czBaseMem               db      "Base memory: ",0                               ;base memory from BIOS
  6241 0000095A 72793A2000         
  6242 0000095F 45746865726E657420-     czEthernetAdapterFound  db      "Ethernet adapter found",13,10,0                ;adapter found message
  6242 00000968 616461707465722066-
  6242 00000971 6F756E640D0A00     
  6243 00000978 457874656E64656420-     czExtendedMem           db      "Extended memory: ",0                           ;extended memory from BIOS
  6243 00000981 6D656D6F72793A2000 
  6244 0000098A 496E74656C00            czIntel                 db      "Intel",0                                       ;vendor name string
  6245 00000990 4B4200                  czKB                    db      "KB",0                                          ;Kilobytes
  6246 00000993 0D0A00                  czNewLine               db      13,10,0                                         ;new line string
  6247 00000996 6F6B0D0A00              czOK                    db      "ok",13,10,0                                    ;ok string
  6248 0000099B 4F7261636C6500          czOracle                db      "Oracle",0                                      ;vendor name string
  6249 000009A2 4F7468657200            czOther                 db      "Other",0                                       ;default name string
  6250 000009A8 5043492026204D656D-     czPCIAndMem             db      "PCI & Memory",0                                ;PCI and Memory string
  6250 000009B1 6F727900           
  6251 000009B5 2E00                    czPeriod                db      ".",0                                           ;period delimiter
  6252 000009B7 504949583320504349-     czPIIX3PCItoIDEBridge   db      "PIIX3 PCI-to-ISA Bridge",0                     ;pci-to-isa bridge string
  6252 000009C0 2D746F2D4953412042-
  6252 000009C9 726964676500       
  6253 000009CF 50494958342F34452F-     czPIIX4PowerMgmt        db      "PIIX4/4E/4M Power Management Controller",0     ;power management controller string
  6253 000009D8 344D20506F77657220-
  6253 000009E1 4D616E6167656D656E-
  6253 000009EA 7420436F6E74726F6C-
  6253 000009F3 6C657200           
  6254 000009F7 3A00                    czPrompt                db      ":",0                                           ;prompt string
  6255 000009F9 50726F2F3130303020-     czPro1000MT             db      "Pro/1000 MT Ethernet Adapter",0                ;Intel Pro/1000 MT Ethernet adapter strg
  6255 00000A02 4D542045746865726E-
  6255 00000A0B 657420416461707465-
  6255 00000A14 7200               
  6256 00000A16 42617365206D656D6F-     czROMMem                db      "Base memory below EBDA (Int 12h): ",0          ;memory reported by ROM
  6256 00000A1F 72792062656C6F7720-
  6256 00000A28 454244412028496E74-
  6256 00000A31 20313268293A2000   
  6257 00000A39 2000                    czSpace                 db      " ",0                                           ;space delimiter
  6258 00000A3B 437573746F6D204F70-     czTitle                 db      "Custom Operating System 1.0",13,10,0           ;version string
  6258 00000A44 65726174696E672053-
  6258 00000A4D 797374656D20312E30-
  6258 00000A56 0D0A00             
  6259 00000A59 556E6B6E6F776E2063-     czUnknownCommand        db      "Unknown command",13,10,0                       ;unknown command response string
  6259 00000A62 6F6D6D616E640D0A00 
  6260 00000A6B 55534220436F6E7472-     czUSBController         db      "USB Controller",0                              ;USB controller string
  6260 00000A74 6F6C6C657200       
  6261 00000A7A 5669727475616C426F-     czVirtualBoxDevice      db      "VirtualBox Device",0                           ;Virtual Box device string
  6261 00000A83 782044657669636500 
  6262 00000A8C 5669727475616C426F-     czVirtualBoxGA          db      "VirtualBox Graphics Adapter",0                 ;Virtual Box graphics adapter string
  6262 00000A95 782047726170686963-
  6262 00000A9E 732041646170746572-
  6262 00000AA7 00                 
  6263 00000AA8 546865207965617220-     czYearIsLeap            db      "The year is a leap year.",13,10,0              ;leap year message
  6263 00000AB1 69732061206C656170-
  6263 00000ABA 20796561722E0D0A00 
  6264 00000AC3 546865207965617220-     czYearIsNotLeap         db      "The year is not a leap year.",13,10,0          ;not leap year message
  6264 00000ACC 6973206E6F74206120-
  6264 00000AD5 6C6561702079656172-
  6264 00000ADE 2E0D0A00           
  6265 00000AE2 383233373141422F45-     cz82371ABBusMaster      db      "82371AB/EB PCI Bus Master IDE Controller",0    ;bus-master strin
  6265 00000AEB 422050434920427573-
  6265 00000AF4 204D61737465722049-
  6265 00000AFD 444520436F6E74726F-
  6265 00000B06 6C6C657200         
  6266 00000B0B 00<rept>                                        times   4096-($-$$) db 0h                               ;zero fill to end of section
  6267                                  ;=======================================================================================================================
  6268                                  ;
  6269                                  ;       Background Task                                                         @disk: 009600   @mem: 006000
  6270                                  ;
  6271                                  ;       This task executes monitoring and self-correcting functions.
  6272                                  ;
  6273                                  ;                       000000  +-----------------------------------------------+
  6274                                  ;                               |  Real Mode Interrupt Vectors                  |
  6275                                  ;                       000400  +-----------------------------------------------+ DS,ES:0400
  6276                                  ;                               |  Reserved BIOS Memory Area                    |
  6277                                  ;                       000800  +-----------------------------------------------+ DS,ES:0800
  6278                                  ;                               |  Shared Kernel Memory Area                    |
  6279                                  ;                       001000  +-----------------------------------------------+               <-- GDTR
  6280                                  ;                               |  Global Descriptor Table (GDT)                |
  6281                                  ;                       001800  +-----------------------------------------------+               <-- IDTR
  6282                                  ;                               |  Interrupt Descriptor Table (IDT)             |
  6283                                  ;                       002000  +-----------------------------------------------+
  6284                                  ;                               |  Interrupt Handlers                           |
  6285                                  ;                               |  Kernel Function Library                      |
  6286                                  ;                       004000  +===============================================+
  6287                                  ;                               |  Console Task Stack Area                      |
  6288                                  ;                       004700  +-----------------------------------------------+
  6289                                  ;                               |  Console Task Local Descriptor Table (LDT)    |
  6290                                  ;                       004780  +-----------------------------------------------+
  6291                                  ;                               |  Console Task Task State Segment (TSS)        |
  6292                                  ;                       004800  +-----------------------------------------------+
  6293                                  ;                               |  Console Task Message Queue                   |
  6294                                  ;                       005000  +-----------------------------------------------+
  6295                                  ;                               |  Console Task Code                            |
  6296                                  ;                               |  Console Task Constants                       |
  6297                                  ;                       006000  +===============================================+
  6298                                  ;                               |  Background Task Stack Area                   |
  6299                                  ;       SS:SP --------> 006700  +-----------------------------------------------+ SS:0700       <-- LDTR = GDT.SEL 0060h
  6300                                  ;                               |  Background Task Local Descriptor Table (LDT) |
  6301                                  ;                       006780  +-----------------------------------------------+               <-- TR = GDT.SEL 0068h
  6302                                  ;                               |  Background Task Task State Segment (TSS)     |
  6303                                  ;                       006800  +-----------------------------------------------+
  6304                                  ;                               |  Background Task Message Queue                |
  6305                                  ;       CS,CS:IP -----> 007000  +-----------------------------------------------+ CS:0000
  6306                                  ;                               |  Background Task Code                         |
  6307                                  ;                               |  Background Task Constants                    |
  6308                                  ;                       008000  +===============================================+
  6309                                  ;
  6310                                  ;=======================================================================================================================
  6311                                  ;-----------------------------------------------------------------------------------------------------------------------
  6312                                  ;
  6313                                  ;       Background Task Stack                                                   @disk: 009600   @mem:  006000
  6314                                  ;
  6315                                  ;       This is the stack for the background task. It supports 448 nested calls.
  6316                                  ;
  6317                                  ;-----------------------------------------------------------------------------------------------------------------------
  6318                                  section                 bgstack                                                 ;background task stack
  6319 00000000 00<rept>                                        times   1792-($-$$) db 0h                               ;zero fill to end of section
  6320                                  ;-----------------------------------------------------------------------------------------------------------------------
  6321                                  ;
  6322                                  ;       Background Task Local Descriptor Table                                  @disk: 009D00   @mem:  006700
  6323                                  ;
  6324                                  ;       This is the LDT for the background task. It defines the stack, code, data and queue segments as well as data
  6325                                  ;       aliases for the TSS LDT. Data aliases allow inspection and altering of the TSS and LDT. This LDT can hold up to
  6326                                  ;       16 descriptors. Six are initially defined.
  6327                                  ;
  6328                                  ;-----------------------------------------------------------------------------------------------------------------------
  6329                                  section                 bgldt                                                   ;background task local descriptors
  6330 00000000 7F00806700934000                                dq      004093006780007Fh                               ;04 TSS alias           128B  @ 6780
  6331 00000008 7F00006700934000                                dq      004093006700007Fh                               ;0C LDT alias           128B  @ 6700
  6332 00000010 FF06006000934000                                dq      00409300600006FFh                               ;14 stack               1792B @ 6600
  6333 00000018 FFFF00000093CF00                                dq      00CF93000000FFFFh                               ;1C data                4GB   @ 0000
  6334 00000020 FF0F0070009B4000                                dq      00409B0070000FFFh                               ;24 code                4KB   @ 7000
  6335 00000028 FF07006800934000                                dq      00409300680007FFh                               ;2C message queue       2KB   @ 6800
  6336 00000030 00<rept>                                        times   128-($-$$) db 0h                                ;zero fill to end of section
  6337                                  ;-----------------------------------------------------------------------------------------------------------------------
  6338                                  ;
  6339                                  ;       Background Task State Segment                                           @disk: 009D80   @mem:  006780
  6340                                  ;
  6341                                  ;       This is the TSS for the console task. All rings share the same stack. DS and ES are set to the console data
  6342                                  ;       segment. CS to console code.
  6343                                  ;
  6344                                  ;-----------------------------------------------------------------------------------------------------------------------
  6345                                  section                 bgtss                                                   ;background task state segment
  6346 00000000 00000000                                        dd      0                                               ;00 back-link tss
  6347 00000004 00070000                                        dd      0700h                                           ;04 esp ring 0
  6348 00000008 14000000                                        dd      0014h                                           ;08 ss ring 0
  6349 0000000C 00070000                                        dd      0700h                                           ;0C esp ring 1
  6350 00000010 14000000                                        dd      0014h                                           ;10 es ring 1
  6351 00000014 00070000                                        dd      0700h                                           ;14 esp ring 2
  6352 00000018 14000000                                        dd      0014h                                           ;18 ss ring 2
  6353 0000001C 00000000                                        dd      0                                               ;1C cr ring 3
  6354 00000020 00000000                                        dd      0                                               ;20 eip
  6355 00000024 00020000                                        dd      0200h                                           ;24 eflags
  6356 00000028 00000000                                        dd      0                                               ;28 eax
  6357 0000002C 00000000                                        dd      0                                               ;2C ecx
  6358 00000030 00000000                                        dd      0                                               ;30 edx
  6359 00000034 00000000                                        dd      0                                               ;34 ebx
  6360 00000038 00070000                                        dd      0700h                                           ;38 esp ring 3
  6361 0000003C 00000000                                        dd      0                                               ;3C ebp
  6362 00000040 00000000                                        dd      0                                               ;40 esi
  6363 00000044 00000000                                        dd      0                                               ;44 edi
  6364 00000048 1C000000                                        dd      001Ch                                           ;48 es
  6365 0000004C 24000000                                        dd      0024h                                           ;4C cs
  6366 00000050 14000000                                        dd      0014h                                           ;50 ss ring 3
  6367 00000054 1C000000                                        dd      001Ch                                           ;54 ds
  6368 00000058 00000000                                        dd      0                                               ;58 fs
  6369 0000005C 00000000                                        dd      0                                               ;5c gs
  6370 00000060 70000000                                        dd      ESELBACKGROUNDLDT                               ;60 ldt selector in gdt
  6371 00000064 00<rept>                                        times   128-($-$$) db 0h                                ;zero fill to end of section
  6372                                  ;-----------------------------------------------------------------------------------------------------------------------
  6373                                  ;
  6374                                  ;       Background Task Message Queue                                           @disk: 009E00   @mem: 006800
  6375                                  ;
  6376                                  ;       The console message queue is 2048 bytes of memory organized as a queue of 510 double words (4 bytes each) and
  6377                                  ;       two double word values that act as indices. The queue is a FIFO that is fed by the keyboard hardware interrupt
  6378                                  ;       handler and consumed by a service routine called from a task. Each queue entry defines an input (keystroke)
  6379                                  ;       event.
  6380                                  ;
  6381                                  ;-----------------------------------------------------------------------------------------------------------------------
  6382                                  section                 bgmque                                                  ;console message queue
  6383 00000000 08000000                                        dd      8                                               ;head pointer
  6384 00000004 08000000                                        dd      8                                               ;tail pointer
  6385 00000008 00000000<rept>                                  times   510 dd 0                                        ;queue elements
  6386                                  ;-----------------------------------------------------------------------------------------------------------------------
  6387                                  ;
  6388                                  ;       Background Task Code                                                    @disk: 00A600   @mem: 007000
  6389                                  ;
  6390                                  ;-----------------------------------------------------------------------------------------------------------------------
  6391                                  section                 bgcode  vstart=07000h                                   ;labels relative to 7000h
  6392 00000000 E857000000              BackgroundCode          call    BgInitializeData                                ;initialize the background variables
  6393                                  
  6394                                  .10                     readRealTimeClock wsBgDateTime                          ;read real-time clock data
  6394                              <1> .10 :
  6394 00000005 BB800B0000          <1>  mov ebx,%1
  6394 0000000A B019                <1>  mov al,eReadRealTimeClock
  6394 0000000C CD30                <1>  int _svc
  6395                                                          putTimeString     wsBgDateTime,wzBgTime                 ;create ASCII time string
  6395 0000000E BB800B0000          <1>  mov ebx,%1
  6395 00000013 BA880B0000          <1>  mov edx,%2
  6395 00000018 B015                <1>  mov al,ePutTimeString
  6395 0000001A CD30                <1>  int _svc
  6396                                                          compareMemory     wzBgTime,wzBgTimeCmpr,EBGTIMELEN      ;compare to previous time string
  6396 0000001C BA880B0000          <1>  mov edx,%1
  6396 00000021 BB910B0000          <1>  mov ebx,%2
  6396 00000026 B909000000          <1>  mov ecx,%3
  6396 0000002B B002                <1>  mov al,eCompareMemory
  6396 0000002D CD30                <1>  int _svc
  6397                                  
  6398 0000002F E3D4                                            jecxz   .10                                             ;repeat if equal
  6399 00000031 06                                              push    es                                              ;save non-volatile reg
  6400 00000032 6A20                                            push    EGDTCGA                                         ;load CGA selector ...
  6401 00000034 07                                              pop     es                                              ;... into extra segment reg
  6402 00000035 BE880B0000                                      mov     esi,wzBgTime                                    ;string address
  6403 0000003A B518                                            mov     ch,24                                           ;OIA row
  6404 0000003C B143                                            mov     cl,67                                           ;OIA column
  6405                                  
  6406                                                          setConsoleString                                        ;display string
  6406 0000003E B01B                <1>  mov al,eSetConsoleString
  6406 00000040 CD30                <1>  int _svc
  6407                                  
  6408 00000042 07                                              pop     es                                              ;restore non-volatile reg
  6409                                  
  6410                                                          copyMemory        wzBgTime,wzBgTimeCmpr,EBGTIMELEN      ;copy to comparison string
  6410 00000043 BA880B0000          <1>  mov edx,%1
  6410 00000048 BB910B0000          <1>  mov ebx,%2
  6410 0000004D B909000000          <1>  mov ecx,%3
  6410 00000052 B003                <1>  mov al,eCopyMemory
  6410 00000054 CD30                <1>  int _svc
  6411                                                          yield                                                   ;halt until interrupt
  6411 00000056 B01F                <1>  mov al,eYield
  6411 00000058 CD30                <1>  int _svc
  6412                                  
  6413 0000005A EBA9                                            jmp     .10                                             ;continue
  6414                                  ;-----------------------------------------------------------------------------------------------------------------------
  6415                                  ;
  6416                                  ;       Routine:        BgInitializeData
  6417                                  ;
  6418                                  ;       Description:    This routine initializes background task variables.
  6419                                  ;
  6420                                  ;-----------------------------------------------------------------------------------------------------------------------
  6421 0000005C 51                      BgInitializeData        push    ecx                                             ;save non-volatile regs
  6422 0000005D 57                                              push    edi                                             ;
  6423 0000005E 06                                              push    es                                              ;
  6424                                  ;
  6425                                  ;       Initialize console work areas
  6426                                  ;
  6427 0000005F 6A18                                            push    EGDTOSDATA                                      ;load OS data selector ...
  6428 00000061 07                                              pop     es                                              ;... into extra segment register
  6429 00000062 BF800B0000                                      mov     edi,EBGDATA                                     ;OS console data address
  6430 00000067 30C0                                            xor     al,al                                           ;initialization value
  6431 00000069 B91A000000                                      mov     ecx,EBGDATALEN                                  ;size of OS console data
  6432 0000006E FC                                              cld                                                     ;forward strings
  6433 0000006F F3AA                                            rep     stosb                                           ;initialize data
  6434                                  ;
  6435                                  ;       Restore and return
  6436                                  ;
  6437 00000071 07                                              pop     es                                              ;restore non-volatile regs
  6438 00000072 5F                                              pop     edi                                             ;
  6439 00000073 59                                              pop     ecx                                             ;
  6440 00000074 C3                                              ret                                                     ;return
  6441                                  ;-----------------------------------------------------------------------------------------------------------------------
  6442                                  ;
  6443                                  ;       Background Task Constants
  6444                                  ;
  6445                                  ;-----------------------------------------------------------------------------------------------------------------------
  6446 00000075 00<rept>                                        times   4096-($-$$) db 0h                               ;zero fill to end of section
  6447                                  %endif
  6448                                  %ifdef BUILDDISK
  6449                                  ;-----------------------------------------------------------------------------------------------------------------------
  6450                                  ;
  6451                                  ;       Free Disk Space                                                         @disk: 00B600   @mem:  n/a
  6452                                  ;
  6453                                  ;       Following the convention introduced by DOS, we use the value 'F6' to indicate unused floppy disk storage.
  6454                                  ;
  6455                                  ;-----------------------------------------------------------------------------------------------------------------------
  6456                                  section                 unused                                                  ;unused disk space
  6457                                                          times   EBOOTDISKBYTES-0B600h db 0F6h                   ;fill to end of disk image
  6458                                  %endif
  6459                                  ;=======================================================================================================================
  6460                                  ;
  6461                                  ;       End of Program Code
  6462                                  ;
  6463                                  ;=======================================================================================================================
