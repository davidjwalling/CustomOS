     1                                  ;=======================================================================================================================
     2                                  ;
     3                                  ;       File:           os.asm
     4                                  ;
     5                                  ;       Project:        os.003
     6                                  ;
     7                                  ;       Description:    This sample program adds code to create osprep.com, a program to update the boot sector on a
     8                                  ;                       floppy disk. This utility can be useful in creating floppy boot diskettes from native DOS or
     9                                  ;                       within a DOS VM.
    10                                  ;
    11                                  ;       Revised:        July 4, 2018
    12                                  ;
    13                                  ;       Assembly:       nasm os.asm -f bin -o os.dat     -l os.dat.lst     -DBUILDBOOT
    14                                  ;                       nasm os.asm -f bin -o os.dsk     -l os.dsk.lst     -DBUILDDISK
    15                                  ;                       nasm os.asm -f bin -o os.com     -l os.com.lst     -DBUILDCOM
    16                                  ;                       nasm os.asm -f bin -o osprep.com -l osprep.com.lst -DBUILDPREP
    17                                  ;
    18                                  ;       Assembler:      Netwide Assembler (NASM) 2.13.03, Feb 7 2018
    19                                  ;
    20                                  ;       Notice:         Copyright (C) 2010-2018 David J. Walling. All Rights Reserved.
    21                                  ;
    22                                  ;=======================================================================================================================
    23                                  ;-----------------------------------------------------------------------------------------------------------------------
    24                                  ;
    25                                  ;       Assembly Directives
    26                                  ;
    27                                  ;       Use one of the following as an assembly directive (-D) with NASM.
    28                                  ;
    29                                  ;       BUILDBOOT       Creates os.dat, a 512-byte boot sector as a standalone file.
    30                                  ;       BUILDDISK       Creates os.dsk, a 1.44MB (3.5") floppy disk image file.
    31                                  ;       BUILDCOM        Creates os.com, the OS loader and kernel as a standalone DOS program.
    32                                  ;       BUILDPREP       Creates osprep.com, a DOS program that prepares a floppy disk to boot the OS
    33                                  ;
    34                                  ;-----------------------------------------------------------------------------------------------------------------------
    35                                  %ifdef BUILDDISK                                                                ;if we are building a disk image ...
    36                                  %define BUILDBOOT                                                               ;... build the boot sector
    37                                  %define BUILDCOM                                                                ;... and the OS kernel
    38                                  %endif
    39                                  %ifdef BUILDPREP                                                                ;if creating the disk prep program ...
    40                                  %define BUILDBOOT                                                               ;... also build the boot sector
    41                                  %endif
    42                                  ;-----------------------------------------------------------------------------------------------------------------------
    43                                  ;
    44                                  ;       Conventions
    45                                  ;
    46                                  ;       Alignment:      In this document, columns are numbered beginning with 1.
    47                                  ;                       Assembly instructions (mnemonics) begin in column 25.
    48                                  ;                       Assembly operands begin in column 33.
    49                                  ;                       Inline comments begin in column 81.
    50                                  ;                       Lines should not extend beyond column 120.
    51                                  ;
    52                                  ;       Arguments:      Arguments are passed as registers and generally follow this order: EAX, ECX, EDX, EBX.
    53                                  ;                       However, ECX may be used as the first parameter if a test for zero is required. EBX and EBP
    54                                  ;                       may be used as parameters if the routine is considered a "method" of an "object". In this
    55                                  ;                       case, EBX or EBP will address the object storage. If the routine is general-purpose string
    56                                  ;                       or character-array manipulator, ESI and EDI may be used as parameters to address input and/or
    57                                  ;                       ouput buffers, respectively.
    58                                  ;
    59                                  ;       Code Order:     Routines should appear in the order of their first likely use.
    60                                  ;                       Negative relative call or jump addresses indicate reuse.
    61                                  ;
    62                                  ;       Comments:       A comment that spans the entire line begins with a semicolon in column 1.
    63                                  ;                       A comment that accompanies code on a line begins with a semicolon in column 81.
    64                                  ;                       Register names in comments are in upper case (EAX, EDI).
    65                                  ;                       Hexadecimal values in comments are in lower case (01fh, 0dah).
    66                                  ;                       Routines are preceded with a comment box that includes the routine name, description, and
    67                                  ;                       register contents on entry and exit.
    68                                  ;
    69                                  ;       Constants:      Symbolic constants (equates) are named in all-caps beginning with 'E' (EDATAPORT).
    70                                  ;                       Constant stored values are named in camel case, starting with 'c' (cbMaxLines).
    71                                  ;                       The 2nd letter of the constant label indicates the storage type.
    72                                  ;
    73                                  ;                       cq......        constant quad-word (dq)
    74                                  ;                       cd......        constant double-word (dd)
    75                                  ;                       cw......        constant word (dw)
    76                                  ;                       cb......        constant byte (db)
    77                                  ;                       cz......        constant ASCIIZ (null-terminated) string
    78                                  ;
    79                                  ;       Instructions:   32-bit instructions are generally favored.
    80                                  ;                       8-bit instructions and data are preferred for flags and status fields, etc.
    81                                  ;                       16-bit instructions are avoided wherever possible to avoid prefix bytes.
    82                                  ;
    83                                  ;       Labels:         Labels within a routine are numeric and begin with a period (.10, .20).
    84                                  ;                       Labels within a routine begin at ".10" and increment by 10.
    85                                  ;
    86                                  ;       Literals:       Literal values defined by external standards should be defined as symbolic constants (equates).
    87                                  ;                       Hexadecimal literals in code are in upper case with a leading '0' and trailing 'h' (01Fh).
    88                                  ;                       Binary literal values in source code are encoded with a final 'b' (1010b).
    89                                  ;                       Decimal literal values in source code are strictly numerals (2048).
    90                                  ;                       Octal literal values are avoided.
    91                                  ;                       String literals are enclosed in double quotes, e.g. "Loading OS".
    92                                  ;                       Single character literals are enclosed in single quotes, e.g. 'A'.
    93                                  ;
    94                                  ;       Macros:         Macro names are in camel case, beginning with a lower-case letter (getDateString).
    95                                  ;                       Macro names describe an action and so DO begin with a verb.
    96                                  ;
    97                                  ;       Memory Use:     Operating system memory allocation is avoided wherever possible.
    98                                  ;                       Buffers are kept to as small a size as practicable.
    99                                  ;                       Data and code intermingling is avoided wherever possible.
   100                                  ;
   101                                  ;       Registers:      Register names in comments are in upper case (EAX, EDX).
   102                                  ;                       Register names in source code are in lower case (eax, edx).
   103                                  ;
   104                                  ;       Return Values:  Routines return result values in EAX or ECX or both. Routines should indicate failure by
   105                                  ;                       setting the carry flag to 1. Routines may prefer the use of ECX as a return value if the
   106                                  ;                       value is to be tested for null upon return (using the jecxz instruction).
   107                                  ;
   108                                  ;       Routines:       Routine names are in mixed case, capitalized (GetYear, ReadRealTimeClock).
   109                                  ;                       Routine names begin with a verb (Get, Read, Load).
   110                                  ;                       Routines should have a single entry address and a single exit instruction (ret, iretd, etc.).
   111                                  ;                       Routines that serve as wrappers for library functions carry the same name as the library
   112                                  ;                       function but begin with a leading underscore (_) character.
   113                                  ;
   114                                  ;       Structures:     Structure names are in all-caps (DATETIME).
   115                                  ;                       Structure names describe a "thing" and so do NOT begin with a verb.
   116                                  ;
   117                                  ;       Usage:          Registers EBX, ECX, EBP, SS, CS, DS and ES are preserved by routines.
   118                                  ;                       Registers ESI and EDI are preserved unless they are input parameters.
   119                                  ;                       Registers EAX and ECX are preferred for returning response/result values.
   120                                  ;                       Registers EBX and EBP are preferred for context (structure) address parameters.
   121                                  ;                       Registers EAX, ECX, EDX and EBX are preferred for integral parameters.
   122                                  ;
   123                                  ;       Variables:      Variables are named in camel case, starting with 'w'.
   124                                  ;                       The 2nd letter of the variable label indicates the storage type.
   125                                  ;
   126                                  ;                       wq......        variable quad-word (resq)
   127                                  ;                       wd......        variable double-word (resd)
   128                                  ;                       ww......        variable word (resw)
   129                                  ;                       wb......        variable byte (resb)
   130                                  ;                       ws......        writable structure
   131                                  ;
   132                                  ;-----------------------------------------------------------------------------------------------------------------------
   133                                  ;=======================================================================================================================
   134                                  ;
   135                                  ;       Equates
   136                                  ;
   137                                  ;       The equate (equ) statement defines a symbolic name for a fixed value so that such a value can be defined and
   138                                  ;       verified once and then used throughout the code. Using symbolic names simplifies searching for where logical
   139                                  ;       values are used. Equate names are in all-caps and begin with the letter 'E'. Equates are grouped into related
   140                                  ;       sets. Equates here are defined in the following groupings:
   141                                  ;
   142                                  ;       Hardware-Defined Values
   143                                  ;
   144                                  ;       EKEYB...        8042 or "PS/2 Controller" (Keyboard Controller) values
   145                                  ;
   146                                  ;       Firmware-Defined Values
   147                                  ;
   148                                  ;       EBIOS...        Basic Input/Output System (BIOS) values
   149                                  ;
   150                                  ;       Standards-Based Values
   151                                  ;
   152                                  ;       EASCII...       American Standard Code for Information Interchange (ASCII) values
   153                                  ;
   154                                  ;       Operating System Values
   155                                  ;
   156                                  ;       EBOOT...        Boot sector and loader values
   157                                  ;
   158                                  ;=======================================================================================================================
   159                                  ;-----------------------------------------------------------------------------------------------------------------------
   160                                  ;
   161                                  ;       Hardware-Defined Values
   162                                  ;
   163                                  ;-----------------------------------------------------------------------------------------------------------------------
   164                                  ;-----------------------------------------------------------------------------------------------------------------------
   165                                  ;
   166                                  ;       8042 Keyboard Controller                                                EKEYB...
   167                                  ;
   168                                  ;       The 8042 Keyboard Controller (8042) is a programmable controller that accepts input signals from the keyboard
   169                                  ;       device. It also signals a hardware interrupt to the CPU when the low-order bit of I/O port 64h is set to zero.
   170                                  ;
   171                                  ;-----------------------------------------------------------------------------------------------------------------------
   172                                  EKEYBPORTSTAT           equ     064h                                            ;status port
   173                                  EKEYBCMDRESET           equ     0FEh                                            ;reset bit 0 to restart system
   174                                  ;-----------------------------------------------------------------------------------------------------------------------
   175                                  ;
   176                                  ;       Firmware-Defined Values
   177                                  ;
   178                                  ;-----------------------------------------------------------------------------------------------------------------------
   179                                  ;-----------------------------------------------------------------------------------------------------------------------
   180                                  ;
   181                                  ;       BIOS Interrupts and Functions                                           EBIOS...
   182                                  ;
   183                                  ;       Basic Input/Output System (BIOS) functions are grouped and accessed by issuing an interrupt call. Each
   184                                  ;       BIOS interrupt supports several funtions. The function code is typically passed in the AH register.
   185                                  ;
   186                                  ;-----------------------------------------------------------------------------------------------------------------------
   187                                  EBIOSINTVIDEO           equ     010h                                            ;video services interrupt
   188                                  EBIOSFNSETVMODE         equ     000h                                            ;video set mode function
   189                                  EBIOSMODETEXT80         equ     003h                                            ;video mode 80x25 text
   190                                  EBIOSFNTTYOUTPUT        equ     00Eh                                            ;video TTY output function
   191                                  EBIOSINTDISKETTE        equ     013h                                            ;diskette services interrupt
   192                                  EBIOSFNREADSECTOR       equ     002h                                            ;diskette read sector function
   193                                  EBIOSFNWRITESECTOR      equ     003h                                            ;diskette write sector function
   194                                  EBIOSINTKEYBOARD        equ     016h                                            ;keyboard services interrupt
   195                                  EBIOSFNKEYSTATUS        equ     001h                                            ;keyboard status function
   196                                  ;-----------------------------------------------------------------------------------------------------------------------
   197                                  ;
   198                                  ;       Standards-Based Values
   199                                  ;
   200                                  ;-----------------------------------------------------------------------------------------------------------------------
   201                                  ;-----------------------------------------------------------------------------------------------------------------------
   202                                  ;
   203                                  ;       ASCII                                                                   EASCII...
   204                                  ;
   205                                  ;-----------------------------------------------------------------------------------------------------------------------
   206                                  EASCIIRETURN            equ     00Dh                                            ;carriage return
   207                                  EASCIIESCAPE            equ     01Bh                                            ;escape
   208                                  ;-----------------------------------------------------------------------------------------------------------------------
   209                                  ;
   210                                  ;       Operating System Values
   211                                  ;
   212                                  ;-----------------------------------------------------------------------------------------------------------------------
   213                                  ;-----------------------------------------------------------------------------------------------------------------------
   214                                  ;
   215                                  ;       Boot Sector and Loader Constants                                        EBOOT...
   216                                  ;
   217                                  ;       Equates in this section support the boot sector and the 16-bit operating system loader, which will be
   218                                  ;       responsible for placing the CPU into protected mode and calling the initial operating system task.
   219                                  ;
   220                                  ;-----------------------------------------------------------------------------------------------------------------------
   221                                  EBOOTSTACKTOP           equ     0100h                                           ;boot sector stack top relative to DS
   222                                  EBOOTSECTORBYTES        equ     512                                             ;bytes per sector
   223                                  EBOOTDIRENTRIES         equ     224                                             ;directory entries
   224                                  EBOOTDISKSECTORS        equ     2880                                            ;sectors per disk
   225                                  EBOOTDISKBYTES          equ     (EBOOTSECTORBYTES*EBOOTDISKSECTORS)             ;bytes per disk
   226                                  EBOOTFATBASE            equ     (EBOOTSTACKTOP+EBOOTSECTORBYTES)                ;offset of FAT I/O buffer rel to DS
   227                                  EBOOTMAXTRIES           equ     5                                               ;max read retries
   228                                  %ifdef BUILDBOOT
   229                                  ;=======================================================================================================================
   230                                  ;
   231                                  ;       Boot Sector                                                             @disk: 000000   @mem: 007c00
   232                                  ;
   233                                  ;       The first sector of the disk is the boot sector. The BIOS will load the boot sector into memory and pass
   234                                  ;       control to the code at the start of the sector. The boot sector code is responsible for loading the operating
   235                                  ;       system into memory. The boot sector contains a disk parameter table describing the geometry and allocation
   236                                  ;       of the disk. Following the disk parameter table is code to load the operating system kernel into memory.
   237                                  ;
   238                                  ;       The "cpu" directive limits emitted code to those instructions supported by the most primitive processor
   239                                  ;       we expect to ever execute our code. The "vstart" parameter indicates addressability of symbols so as to
   240                                  ;       emulate the DOS .COM program model. Although the BIOS is expected to load the boot sector at address 7c00,
   241                                  ;       we do not make that assumption. The CPU starts in 16-bit addressing mode. A three-byte jump instruction is
   242                                  ;       immediately followed by a disk parameter table.
   243                                  ;
   244                                  ;=======================================================================================================================
   245                                                          cpu     8086                                            ;assume minimal CPU
   246                                  section                 boot    vstart=0100h                                    ;emulate .COM (CS,DS,ES=PSP) addressing
   247                                                          bits    16                                              ;16-bit code at power-up
   248                                  %ifdef BUILDPREP
   249                                  Boot                    jmp     word Prep                                       ;jump to preparation code
   250                                  %else
   251 00000000 E91B00                  Boot                    jmp     word Boot.10                                    ;jump over parameter table
   252                                  %endif
   253                                  ;-----------------------------------------------------------------------------------------------------------------------
   254                                  ;
   255                                  ;       Disk Parameter Table
   256                                  ;
   257                                  ;       The disk parameter table informs the BIOS of the floppy disk architecture. Here, we use parameters for the
   258                                  ;       3.5" 1.44MB floppy disk since this format is widely supported by virtual machine hypervisors.
   259                                  ;
   260                                  ;-----------------------------------------------------------------------------------------------------------------------
   261 00000003 437573746F6D4F53                                db      "CustomOS"                                      ;eight-byte label
   262 0000000B 0002                    cwSectorBytes           dw      EBOOTSECTORBYTES                                ;bytes per sector
   263 0000000D 01                      cbClusterSectors        db      1                                               ;sectors per cluster
   264 0000000E 0100                    cwReservedSectors       dw      1                                               ;reserved sectors
   265 00000010 02                      cbFatCount              db      2                                               ;file allocation table copies
   266 00000011 E000                    cwDirEntries            dw      EBOOTDIRENTRIES                                 ;max directory entries
   267 00000013 400B                    cwDiskSectors           dw      EBOOTDISKSECTORS                                ;sectors per disk
   268 00000015 F0                      cbDiskType              db      0F0h                                            ;1.44MB
   269 00000016 0900                    cwFatSectors            dw      9                                               ;sectors per FAT copy
   270                                  cbTrackSectors          equ     $                                               ;sectors per track (as byte)
   271 00000018 1200                    cwTrackSectors          dw      18                                              ;sectors per track (as word)
   272 0000001A 0200                    cwDiskSides             dw      2                                               ;sides per disk
   273 0000001C 0000                    cwSpecialSectors        dw      0                                               ;special sectors
   274                                  ;
   275                                  ;       BIOS typically loads the boot sector at absolute address 7c00 and sets the stack pointer at 512 bytes past the
   276                                  ;       end of the boot sector. But, since BIOS code varies, we don't make any assumptions as to where our boot sector
   277                                  ;       is loaded. For example, the initial CS:IP could be 0:7c00, 700:c00, 7c0:0, etc. So, to avoid assumptions, we
   278                                  ;       first normalize CS:IP to get the absolute segment address in BX. The comments below show the effect of this code
   279                                  ;       given several possible starting values for CS:IP.
   280                                  ;
   281                                                                                                                  ;CS:IP   0:7c00 700:c00 7c0:0
   282 0000001E E80000                  Boot.10                 call    word .20                                        ;[ESP] =   7c21     c21    21
   283                                  .@20                    equ     $-$$                                            ;.@20 = 021h
   284 00000021 58                      .20                     pop     ax                                              ;AX =      7c21     c21    21
   285 00000022 83E821                                          sub     ax,.@20                                         ;AX =      7c00     c00     0
   286 00000025 B104                                            mov     cl,4                                            ;shift count
   287 00000027 D3E8                                            shr     ax,cl                                           ;AX =       7c0      c0     0
   288 00000029 8CCB                                            mov     bx,cs                                           ;BX =         0     700   7c0
   289 0000002B 01C3                                            add     bx,ax                                           ;BX =       7c0     7c0   7c0
   290                                  ;
   291                                  ;       Now, since we are assembling our boot code to emulate the addressing of a .COM file, we want the DS and ES
   292                                  ;       registers to be set to where a Program Segment Prefix (PSP) would be, exactly 100h (256) bytes prior to
   293                                  ;       the start of our code. This will correspond to our assembled data address offsets. Note that we instructed
   294                                  ;       the assembler to produce addresses for our symbols that are offset from our code by 100h. See the "vstart"
   295                                  ;       parameter for the "section" directive above. We also set SS to the PSP and SP to the address of our i/o
   296                                  ;       buffer. This leaves 256 bytes of usable stack from 7b0:0 to 7b0:100.
   297                                  ;
   298 0000002D 83EB10                                          sub     bx,16                                           ;BX = 07b0
   299 00000030 8EDB                                            mov     ds,bx                                           ;DS = 07b0 = psp
   300 00000032 8EC3                                            mov     es,bx                                           ;ES = 07b0 = psp
   301 00000034 8ED3                                            mov     ss,bx                                           ;SS = 07b0 = psp (ints disabled)
   302 00000036 BC0001                                          mov     sp,EBOOTSTACKTOP                                ;SP = 0100       (ints enabled)
   303                                  ;
   304                                  ;       Our boot addressability is now set up according to the following diagram.
   305                                  ;
   306                                  ;       DS,ES,SS -----> 007b00  +-----------------------------------------------+ DS:0000
   307                                  ;                               |  Boot Stack & Boot PSP (Unused)               |
   308                                  ;                               |  256 = 100h bytes                             |
   309                                  ;       SS:SP --------> 007c00  +-----------------------------------------------+ DS:0100  07b0:0100
   310                                  ;                               |  Boot Sector (vstart=0100h)                   |
   311                                  ;                               |  1 sector = 512 = 200h bytes                  |
   312                                  ;                       007e00  +-----------------------------------------------+ DS:0300
   313                                  ;                               |  File Allocation Table (FAT) I/O Buffer       |
   314                                  ;                               |  9x512-byte sectors = 4,608 = 1200h bytes     |
   315                                  ;                       009000  +-----------------------------------------------+ DS:1500  08f0:0100
   316                                  ;                               |  Directory Sector Buffer & Kernel Load Area   |
   317                                  ;                               |  2 sectors = 1024 = 400h bytes
   318                                  ;                       009400  +-----------------------------------------------+ DS:1900
   319                                  ;
   320                                  ;       On entry, DL indicates the drive being booted from.
   321                                  ;
   322 00000039 8816[F801]                                      mov     [wbDrive],dl                                    ;[wbDrive] = drive being booted from
   323                                  ;
   324                                  ;       Compute directory i/o buffer address.
   325                                  ;
   326 0000003D A1[1600]                                        mov     ax,[cwFatSectors]                               ;AX = 0009 = FAT sectors
   327 00000040 F726[0B00]                                      mul     word [cwSectorBytes]                            ;DX:AX = 0000:1200 = FAT bytes
   328 00000044 050003                                          add     ax,EBOOTFATBASE                                 ;AX = 1500 = end of FAT buffer
   329 00000047 A3[EC01]                                        mov     [wwDirBuffer],ax                                ;[wwDirBuffer] = 1500
   330                                  ;
   331                                  ;       Compute segment where os.com will be loaded.
   332                                  ;
   333 0000004A D3E8                                            shr     ax,cl                                           ;AX = 0150
   334 0000004C 01D8                                            add     ax,bx                                           ;AX = 0150 + 07b0 = 0900
   335 0000004E 83E810                                          sub     ax,16                                           ;AX = 08f0
   336 00000051 A3[3F01]                                        mov     [wwLoadSegment],ax                              ;[wwLoadSegment] = 08f0
   337                                  ;
   338                                  ;       Set the video mode to 80 column, 25 row, text.
   339                                  ;
   340 00000054 B80300                                          mov     ax,EBIOSFNSETVMODE<<8|EBIOSMODETEXT80           ;set mode function, 80x25 text mode
   341 00000057 CD10                                            int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
   342                                  ;
   343                                  ;       Write a message to the console so we know we have our addressability established.
   344                                  ;
   345 00000059 BE[C501]                                        mov     si,czLoadMsg                                    ;loading message
   346 0000005C E84B01                                          call    BootPrint                                       ;display loader message
   347                                  ;
   348                                  ;       Initialize the number of directory sectors to search.
   349                                  ;
   350 0000005F A1[1100]                                        mov     ax,[cwDirEntries]                               ;AX = 224 = max dir entries
   351 00000062 A3[EE01]                                        mov     [wwEntriesLeft],ax                              ;[wwEntriesLeft] = 224
   352                                  ;
   353                                  ;       Compute number of directory sectors and initialize overhead count.
   354                                  ;
   355 00000065 89C1                                            mov     cx,ax                                           ;CX = 00e0 = 224 entries
   356 00000067 F726[B801]                                      mul     word [cwEntryLen]                               ;DX:AX = 224 * 32 = 7168
   357 0000006B F736[0B00]                                      div     word [cwSectorBytes]                            ;AX = 7168 / 512 = 14 = dir sectors
   358 0000006F A3[F001]                                        mov     [wwOverhead],ax                                 ;[wwOverhead] = 000e
   359                                  ;
   360                                  ;       Compute directory entries per sector.
   361                                  ;
   362 00000072 91                                              xchg    ax,cx                                           ;DX:AX = 0:00e0, CX = 0000e
   363 00000073 F7F1                                            div     cx                                              ;AX = 0010 = entries per dir sector
   364 00000075 A3[F201]                                        mov     [wwSectorEntries],ax                            ;[wwSectorEntries] = 0010
   365                                  ;
   366                                  ;       Compute first logical directory sector and update overhead count.
   367                                  ;
   368 00000078 A1[1600]                                        mov     ax,[cwFatSectors]                               ;AX = 0009 = FAT sectors per copy
   369 0000007B F626[1000]                                      mul     byte [cbFatCount]                               ;AX = 0012 = FAT sectors
   370 0000007F 0306[0E00]                                      add     ax,[cwReservedSectors]                          ;AX = 0013 = FAT plus reserved
   371 00000083 0306[1C00]                                      add     ax,[cwSpecialSectors]                           ;AX = 0013 = FAT + reserved + special
   372 00000087 A3[F401]                                        mov     [wwLogicalSector],ax                            ;[wwLogicalSector] = 0013
   373 0000008A 0106[F001]                                      add     [wwOverhead],ax                                 ;[wwOverhead] = 0021 = res+spec+FAT+dir
   374                                  ;
   375                                  ;       Read directory sector.
   376                                  ;
   377 0000008E B001                    .30                     mov     al,1                                            ;sector count
   378 00000090 A2[F601]                                        mov     [wbReadCount],al                                ;[wbReadCount] = 01
   379 00000093 8B1E[EC01]                                      mov     bx,[wwDirBuffer]                                ;BX = 1500
   380 00000097 E8A700                                          call    ReadSector                                      ;read sector into es:bx
   381                                  ;
   382                                  ;       Setup variables to search this directory sector.
   383                                  ;
   384 0000009A A1[EE01]                                        mov     ax,[wwEntriesLeft]                              ;directory entries to search
   385 0000009D 3B06[F201]                                      cmp     ax,[wwSectorEntries]                            ;need to search more sectors?
   386 000000A1 7603                                            jna     .40                                             ;no, continue
   387 000000A3 A1[F201]                                        mov     ax,[wwSectorEntries]                            ;yes, limit search to sector
   388 000000A6 2906[EE01]              .40                     sub     [wwEntriesLeft],ax                              ;update entries left to searh
   389 000000AA BE[BA01]                                        mov     si,cbKernelProgram                              ;program name
   390 000000AD 8B3E[EC01]                                      mov     di,[wwDirBuffer]                                ;DI = 1500
   391                                  ;
   392                                  ;       Loop through directory sectors searching for kernel program.
   393                                  ;
   394 000000B1 56                      .50                     push    si                                              ;save kernel name address
   395 000000B2 57                                              push    di                                              ;save dir i/o buffer address
   396 000000B3 B90B00                                          mov     cx,11                                           ;length of 8+3 name
   397 000000B6 FC                                              cld                                                     ;forward strings
   398 000000B7 F3A6                                            repe    cmpsb                                           ;compare entry name
   399 000000B9 5F                                              pop     di                                              ;restore dir i/o buffer address
   400 000000BA 5E                                              pop     si                                              ;restore kernel name address
   401 000000BB 7418                                            je      .60                                             ;exit loop if found
   402 000000BD 033E[B801]                                      add     di,[cwEntryLen]                                 ;point to next dir entry
   403 000000C1 48                                              dec     ax                                              ;decrement remaining entries
   404 000000C2 75ED                                            jnz     .50                                             ;next entry
   405                                  ;
   406                                  ;       Repeat search if we are not at the end of the directory.
   407                                  ;
   408 000000C4 FF06[F401]                                      inc     word [wwLogicalSector]                          ;increment logical sector
   409 000000C8 833E[EE01]00                                    cmp     word [wwEntriesLeft],0                          ;done with directory?
   410 000000CD 75BF                                            jne     .30                                             ;no, get next sector
   411 000000CF BE[E001]                                        mov     si,czNoKernel                                   ;missing kernel message
   412 000000D2 E9C000                                          jmp     BootExit                                        ;display message and exit
   413                                  ;
   414                                  ;       If we find the kernel program in the directory, read the FAT.
   415                                  ;
   416 000000D5 A1[0E00]                .60                     mov     ax,[cwReservedSectors]                          ;AX = 0001
   417 000000D8 A3[F401]                                        mov     [wwLogicalSector],ax                            ;start past boot sector
   418 000000DB A1[1600]                                        mov     ax,[cwFatSectors]                               ;AX = 0009
   419 000000DE A2[F601]                                        mov     [wbReadCount],al                                ;[wbReadCount] = 09
   420 000000E1 BB0003                                          mov     bx,EBOOTFATBASE                                 ;BX = 0300
   421 000000E4 E85A00                                          call    ReadSector                                      ;read FAT into buffer
   422                                  ;
   423                                  ;       Get the starting cluster of the kernel program and target address.
   424                                  ;
   425 000000E7 8B451A                                          mov     ax,[di+26]                                      ;AX = starting cluster of file
   426 000000EA C41E[3D01]                                      les     bx,[wwLoadOffset]                               ;ES:BX = kernel load add (08f0:0100)
   427                                  ;
   428                                  ;       Read each program cluster into RAM.
   429                                  ;
   430 000000EE 50                      .70                     push    ax                                              ;save cluster nbr
   431 000000EF 83E802                                          sub     ax,2                                            ;AX = cluster nbr base 0
   432 000000F2 8A0E[0D00]                                      mov     cl,[cbClusterSectors]                           ;CL = sectors per cluster
   433 000000F6 880E[F601]                                      mov     [wbReadCount],cl                                ;save sectors to read
   434 000000FA 30ED                                            xor     ch,ch                                           ;CX = sectors per cluster
   435 000000FC F7E1                                            mul     cx                                              ;DX:AX = logical cluster sector
   436 000000FE 0306[F001]                                      add     ax,[wwOverhead]                                 ;AX = kernel sector nbr
   437 00000102 A3[F401]                                        mov     [wwLogicalSector],ax                            ;save logical sector nbr
   438 00000105 E83900                                          call    ReadSector                                      ;read sectors into ES:BX
   439                                  ;
   440                                  ;       Update buffer pointer for next cluster.
   441                                  ;
   442 00000108 A0[0D00]                                        mov     al,[cbClusterSectors]                           ;AL = sectors per cluster
   443 0000010B 30E4                                            xor     ah,ah                                           ;AX = sectors per cluster
   444 0000010D F726[0B00]                                      mul     word [cwSectorBytes]                            ;DX:AX = cluster bytes
   445 00000111 01C3                                            add     bx,ax                                           ;BX = next cluster target address
   446 00000113 58                                              pop     ax                                              ;AX = restore cluster nbr
   447                                  ;
   448                                  ;       Compute next cluster number.
   449                                  ;
   450 00000114 89C1                                            mov     cx,ax                                           ;CX = cluster nbr
   451 00000116 89C7                                            mov     di,ax                                           ;DI = cluster nbr
   452 00000118 D1E8                                            shr     ax,1                                            ;AX = cluster/2
   453 0000011A 89C2                                            mov     dx,ax                                           ;DX = cluster/2
   454 0000011C 01D0                                            add     ax,dx                                           ;AX = 2*(cluster/2)
   455 0000011E 01D0                                            add     ax,dx                                           ;AX = 3*(cluster/2)
   456 00000120 83E701                                          and     di,1                                            ;get low bit
   457 00000123 01C7                                            add     di,ax                                           ;add one if cluster is odd
   458 00000125 81C70003                                        add     di,EBOOTFATBASE                                 ;add FAT buffer address
   459 00000129 8B05                                            mov     ax,[di]                                         ;get cluster bytes
   460                                  ;
   461                                  ;       Adjust cluster nbr by 4 bits if cluster is odd; test for end of chain.
   462                                  ;
   463 0000012B F6C101                                          test    cl,1                                            ;is cluster odd?
   464 0000012E 7404                                            jz      .80                                             ;no, skip ahead
   465 00000130 B104                                            mov     cl,4                                            ;shift count
   466 00000132 D3E8                                            shr     ax,cl                                           ;shift nybble low
   467 00000134 25FF0F                  .80                     and     ax,0FFFh                                        ;mask for 24 bits; next cluster nbr
   468 00000137 3DFF0F                                          cmp     ax,0FFFh                                        ;end of chain?
   469 0000013A 75B2                                            jne     .70                                             ;no, continue
   470                                  ;
   471                                  ;       Transfer control to the operating system program.
   472                                  ;
   473 0000013C EA                                              db      0EAh                                            ;jmp seg:offset
   474 0000013D 0001                    wwLoadOffset            dw      0100h                                           ;kernel entry offset
   475 0000013F F008                    wwLoadSegment           dw      08F0h                                           ;kernel entry segment (computed)
   476                                  ;
   477                                  ;       Read [wbReadCount] disk sectors from [wwLogicalSector] into ES:BX.
   478                                  ;
   479 00000141 A1[1800]                ReadSector              mov     ax,[cwTrackSectors]                             ;AX = sectors per track
   480 00000144 F726[1A00]                                      mul     word [cwDiskSides]                              ;DX:AX = sectors per cylinder
   481 00000148 89C1                                            mov     cx,ax                                           ;CX = sectors per cylinder
   482 0000014A A1[F401]                                        mov     ax,[wwLogicalSector]                            ;DX:AX = logical sector
   483 0000014D F7F1                                            div     cx                                              ;AX = cylinder; DX = cyl sector
   484 0000014F A2[FB01]                                        mov     [wbTrack],al                                    ;[wbTrack] = cylinder
   485 00000152 89D0                                            mov     ax,dx                                           ;AX = cyl sector
   486 00000154 F636[1800]                                      div     byte [cbTrackSectors]                           ;AH = sector, AL = head
   487 00000158 FEC4                                            inc     ah                                              ;AH = sector (1,2,3,...)
   488 0000015A A3[F901]                                        mov     [wbHead],ax                                     ;[wbHead]= head, [wwSectorTrack]= sector
   489                                  ;
   490                                  ;       Try maxtries times to read sector.
   491                                  ;
   492 0000015D B90500                                          mov     cx,EBOOTMAXTRIES                                ;CX = 0005
   493 00000160 53                      .10                     push    bx                                              ;save buffer address
   494 00000161 51                                              push    cx                                              ;save retry count
   495 00000162 8B16[F801]                                      mov     dx,[wwDriveHead]                                ;DH = head, DL = drive
   496 00000166 8B0E[FA01]                                      mov     cx,[wwSectorTrack]                              ;CH = track, CL = sector
   497 0000016A A1[F601]                                        mov     ax,[wwReadCountCommand]                         ;AH = fn., AL = sector count
   498 0000016D CD13                                            int     EBIOSINTDISKETTE                                ;read sector
   499 0000016F 59                                              pop     cx                                              ;restore retry count
   500 00000170 5B                                              pop     bx                                              ;restore buffer address
   501 00000171 7343                                            jnc     BootReturn                                      ;skip ahead if done
   502 00000173 E2EB                                            loop    .10                                             ;retry
   503                                  ;
   504                                  ;       Handle disk error: convert to ASCII and store in error string.
   505                                  ;
   506 00000175 88E0                                            mov     al,ah                                           ;AL = bios error code
   507 00000177 30E4                                            xor     ah,ah                                           ;AX = bios error code
   508 00000179 B210                                            mov     dl,16                                           ;divisor for base 16
   509 0000017B F6F2                                            div     dl                                              ;AL = hi order, AH = lo order
   510 0000017D 0D3030                                          or      ax,03030h                                       ;apply ASCII zone bits
   511 00000180 80FC3A                                          cmp     ah,03Ah                                         ;range test ASCII numeral
   512 00000183 7203                                            jb      .20                                             ;continue if numeral
   513 00000185 80C407                                          add     ah,7                                            ;adjust for ASCII 'A'-'F'
   514 00000188 3C3A                    .20                     cmp     al,03Ah                                         ;range test ASCII numeral
   515 0000018A 7203                                            jb      .30                                             ;continue if numeral
   516 0000018C 80C407                                          add     ah,7                                            ;adjust for ASCII 'A'-'F'
   517 0000018F A3[DD01]                .30                     mov     [wzErrorCode],ax                                ;store ASCII error code
   518 00000192 BE[D201]                                        mov     si,czErrorMsg                                   ;error message address
   519 00000195 E81200                  BootExit                call    BootPrint                                       ;display messge to console
   520                                  ;
   521                                  ;       Wait for a key press.
   522                                  ;
   523 00000198 B401                    .10                     mov     ah,EBIOSFNKEYSTATUS                             ;BIOS keyboard status function
   524 0000019A CD16                                            int     EBIOSINTKEYBOARD                                ;get keyboard status
   525 0000019C 7504                                            jnz     .20                                             ;continue if key pressed
   526 0000019E FB                                              sti                                                     ;enable maskable interrupts
   527 0000019F F4                                              hlt                                                     ;wait for interrupt
   528 000001A0 EBF6                                            jmp     .10                                             ;repeat
   529                                  ;
   530                                  ;       Reset the system.
   531                                  ;
   532 000001A2 B0FE                    .20                     mov     al,EKEYBCMDRESET                                ;8042 pulse output port pin
   533 000001A4 E664                                            out     EKEYBPORTSTAT,al                                ;drive B0 low to restart
   534 000001A6 FB                      .30                     sti                                                     ;enable maskable interrupts
   535 000001A7 F4                                              hlt                                                     ;stop until reset, int, nmi
   536 000001A8 EBFC                                            jmp     .30                                             ;loop until restart kicks in
   537                                  ;
   538                                  ;       Display text message.
   539                                  ;
   540 000001AA FC                      BootPrint               cld                                                     ;forward strings
   541 000001AB AC                      .10                     lodsb                                                   ;load next byte at DS:SI in AL
   542 000001AC 84C0                                            test    al,al                                           ;end of string?
   543 000001AE 7406                                            jz      BootReturn                                      ;... yes, exit our loop
   544 000001B0 B40E                                            mov     ah,EBIOSFNTTYOUTPUT                             ;BIOS teletype function
   545 000001B2 CD10                                            int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
   546 000001B4 EBF5                                            jmp     .10                                             ;repeat until done
   547 000001B6 C3                      BootReturn              ret                                                     ;return
   548                                  ;-----------------------------------------------------------------------------------------------------------------------
   549                                  ;
   550                                  ;       Constants
   551                                  ;
   552                                  ;-----------------------------------------------------------------------------------------------------------------------
   553 000001B7 90                                              align   2
   554 000001B8 2000                    cwEntryLen              dw      32                                              ;length of directory entry
   555 000001BA 4F5320202020202043-     cbKernelProgram         db      "OS      COM"                                   ;kernel program name
   555 000001C3 4F4D               
   556 000001C5 4C6F6164696E67204F-     czLoadMsg               db      "Loading OS",13,10,0                            ;loading message
   556 000001CE 530D0A00           
   557 000001D2 4469736B206572726F-     czErrorMsg              db      "Disk error "                                   ;error message
   557 000001DB 7220               
   558 000001DD 202000                  wzErrorCode             db      020h,020h,0                                     ;error code and null terminator
   559 000001E0 4F53206D697373696E-     czNoKernel              db      "OS missing",0                                  ;missing kernel message
   559 000001E9 6700               
   560                                  ;-----------------------------------------------------------------------------------------------------------------------
   561                                  ;
   562                                  ;       Work Areas
   563                                  ;
   564                                  ;-----------------------------------------------------------------------------------------------------------------------
   565 000001EB 90                                              align   2
   566 000001EC 0000                    wwDirBuffer             dw      0                                               ;directory i/o buffer address
   567 000001EE 0000                    wwEntriesLeft           dw      0                                               ;directory entries to search
   568 000001F0 0000                    wwOverhead              dw      0                                               ;overhead sectors
   569 000001F2 0000                    wwSectorEntries         dw      0                                               ;directory entries per sector
   570 000001F4 0000                    wwLogicalSector         dw      0                                               ;current logical sector
   571                                  wwReadCountCommand      equ     $                                               ;read count and command
   572 000001F6 00                      wbReadCount             db      0                                               ;sectors to read
   573 000001F7 02                      cbReadCommand           db      EBIOSFNREADSECTOR                               ;BIOS read disk fn code
   574                                  wwDriveHead             equ     $                                               ;drive, head (word)
   575 000001F8 00                      wbDrive                 db      0                                               ;drive
   576 000001F9 00                      wbHead                  db      0                                               ;head
   577                                  wwSectorTrack           equ     $                                               ;sector, track (word)
   578 000001FA 00                                              db      0                                               ;sector
   579 000001FB 00                      wbTrack                 db      0                                               ;track
   580 000001FC 00<rept>                                        times   510-($-$$) db 0h                                ;zero fill to end of sector
   581 000001FE 55AA                                            db      055h,0AAh                                       ;end of sector signature
   582                                  %endif
   583                                  %ifdef BUILDPREP
   584                                  ;=======================================================================================================================
   585                                  ;
   586                                  ;       Diskette Preparation Code
   587                                  ;
   588                                  ;       This routine writes the OS boot sector code to a formatted floppy diskette. The diskette parameter table,
   589                                  ;       which is located in the first 30 bytes of the boot sector is first read from the diskette and overlayed onto
   590                                  ;       the OS bootstrap code so that the diskette format parameters are preserved.
   591                                  ;
   592                                  ;=======================================================================================================================
   593                                  ;
   594                                  ;       Query the user to insert a flopppy diskette and press enter or cancel.
   595                                  ;
   596                                  Prep                    mov     si,czPrepMsg10                                  ;starting message address
   597                                                          call    BootPrint                                       ;display message
   598                                  ;
   599                                  ;       Exit if the Escape key is pressed or loop until Enter is pressed.
   600                                  ;
   601                                  .10                     mov     ah,EBIOSFNKEYSTATUS                             ;BIOS keyboard status function
   602                                                          int     EBIOSINTKEYBOARD                                ;get keyboard status
   603                                                          jnz     .20                                             ;continue if key pressed
   604                                                          sti                                                     ;enable interrupts
   605                                                          hlt                                                     ;wait for interrupt
   606                                                          jmp     .10                                             ;repeat
   607                                  .20                     cmp     al,EASCIIRETURN                                 ;Enter key pressed?
   608                                                          je      .30                                             ;yes, branch
   609                                                          cmp     al,EASCIIESCAPE                                 ;Escape key pressed?
   610                                                          jne     .10                                             ;no, repeat
   611                                                          jmp     .120                                            ;yes, exit program
   612                                  ;
   613                                  ;       Display writing-sector message and patch the JMP instruction.
   614                                  ;
   615                                  .30                     mov     si,czPrepMsg12                                  ;writing-sector message address
   616                                                          call    BootPrint                                       ;display message
   617                                                          mov     bx,Boot+1                                       ;address of JMP instruction operand
   618                                                          mov     ax,01Bh                                         ;address past disk parameter table
   619                                                          mov     [bx],ax                                         ;update the JMP instruction
   620                                  ;
   621                                  ;       Try to read the boot sector.
   622                                  ;
   623                                                          mov     cx,EBOOTMAXTRIES                                ;try up to five times
   624                                  .40                     push    cx                                              ;save remaining tries
   625                                                          mov     bx,wcPrepInBuf                                  ;input buffer address
   626                                                          mov     dx,0                                            ;head zero, drive zero
   627                                                          mov     cx,1                                            ;track zero, sector one
   628                                                          mov     al,1                                            ;one sector
   629                                                          mov     ah,EBIOSFNREADSECTOR                            ;read function
   630                                                          int     EBIOSINTDISKETTE                                ;attempt the read
   631                                                          pop     cx                                              ;restore remaining retries
   632                                                          jnc     .50                                             ;skip ahead if successful
   633                                                          loop    .40                                             ;try again
   634                                                          mov     si,czPrepMsg20                                  ;read-error message address
   635                                                          jmp     .70                                             ;branch to error routine
   636                                  ;
   637                                  ;       Copy diskette parms from input buffer to output buffer.
   638                                  ;
   639                                  .50                     mov     si,wcPrepInBuf                                  ;input buffer address
   640                                                          add     si,11                                           ;skip over JMP and system ID
   641                                                          mov     di,Boot                                         ;output buffer address
   642                                                          add     di,11                                           ;skip over JMP and system ID
   643                                                          mov     cx,19                                           ;length of diskette parameters
   644                                                          cld                                                     ;forward string copies
   645                                                          rep     movsb                                           ;copy diskette parameters
   646                                  ;
   647                                  ;       Try to write boot sector to diskette.
   648                                  ;
   649                                                          mov     cx,EBOOTMAXTRIES                                ;try up to five times
   650                                  .60                     push    cx                                              ;save remaining tries
   651                                                          mov     bx,Boot                                         ;output buffer address
   652                                                          mov     dx,0                                            ;head zero, drive zero
   653                                                          mov     cx,1                                            ;track zero, sector one
   654                                                          mov     al,1                                            ;one sector
   655                                                          mov     ah,EBIOSFNWRITESECTOR                           ;write function
   656                                                          int     EBIOSINTDISKETTE                                ;attempt the write
   657                                                          pop     cx                                              ;restore remaining retries
   658                                                          jnc     .100                                            ;skip ahead if successful
   659                                                          loop    .60                                             ;try again
   660                                                          mov     si,czPrepMsg30                                  ;write-error message address
   661                                  ;
   662                                  ;       Convert the error code to ASCII and display the error message.
   663                                  ;
   664                                  .70                     push    ax                                              ;save error code
   665                                                          mov     al,ah                                           ;copy error code
   666                                                          mov     ah,0                                            ;AX = error code
   667                                                          mov     dl,10h                                          ;hexadecimal divisor
   668                                                          idiv    dl                                              ;AL = hi-order, AH = lo-order
   669                                                          or      ax,03030h                                       ;add ASCII zone digits
   670                                                          cmp     ah,03Ah                                         ;AH ASCII numeral?
   671                                                          jb      .80                                             ;yes, continue
   672                                                          add     ah,7                                            ;no, make ASCII 'A'-'F'
   673                                  .80                     cmp     al,03Ah                                         ;ASCII numeral?
   674                                                          jb      .90                                             ;yes, continue
   675                                                          add     al,7                                            ;no, make ASCII
   676                                  .90                     mov     [si+17],ax                                      ;put ASCII error code in message
   677                                                          call    BootPrint                                       ;write error message
   678                                                          pop     ax                                              ;restore error code
   679                                  ;
   680                                  ;       Display the completion message.
   681                                  ;
   682                                  .100                    mov     si,czPrepMsgOK                                  ;assume successful completion
   683                                                          mov     al,ah                                           ;BIOS return code
   684                                                          cmp     al,0                                            ;success?
   685                                                          je      .110                                            ;yes, continue
   686                                                          mov     si,czPrepMsgErr1                                ;disk parameter error message
   687                                                          cmp     al,1                                            ;disk parameter error?
   688                                                          je      .110                                            ;yes, continue
   689                                                          mov     si,czPrepMsgErr2                                ;address mark not found message
   690                                                          cmp     al,2                                            ;address mark not found?
   691                                                          je      .110                                            ;yes, continue
   692                                                          mov     si,czPrepMsgErr3                                ;protected disk message
   693                                                          cmp     al,3                                            ;protected disk?
   694                                                          je      .110                                            ;yes, continue
   695                                                          mov     si,czPrepMsgErr6                                ;diskette removed message
   696                                                          cmp     al,6                                            ;diskette removed?
   697                                                          je      .110                                            ;yes, continue
   698                                                          mov     si,czPrepMsgErr80                               ;drive timed out message
   699                                                          cmp     al,80H                                          ;drive timed out?
   700                                                          je      .110                                            ;yes, continue
   701                                                          mov     si,czPrepMsgErrXX                               ;unknown error message
   702                                  .110                    call    BootPrint                                       ;display result message
   703                                  .120                    mov     ax,04C00H                                       ;terminate with zero result code
   704                                                          int     021h                                            ;terminate DOS program
   705                                                          ret                                                     ;return (should not execute)
   706                                  ;-----------------------------------------------------------------------------------------------------------------------
   707                                  ;
   708                                  ;       Diskette Preparation Messages
   709                                  ;
   710                                  ;-----------------------------------------------------------------------------------------------------------------------
   711                                  czPrepMsg10             db      13,10,"CustomOS Boot-Diskette Preparation Program"
   712                                                          db      13,10,"Copyright (C) 2010-2018 David J. Walling. All rights reserved."
   713                                                          db      13,10
   714                                                          db      13,10,"This program overwrites the boot sector of a diskette with startup code that"
   715                                                          db      13,10,"will load the operating system into memory when the computer is restarted."
   716                                                          db      13,10,"To proceed, place a formatted diskette into drive A: and press the Enter key."
   717                                                          db      13,10,"To exit this program without preparing a diskette, press the Escape key."
   718                                                          db      13,10,0
   719                                  czPrepMsg12             db      13,10,"Writing the boot sector to the diskette ..."
   720                                                          db      13,10,0
   721                                  czPrepMsg20             db      13,10,"The error-code .. was returned from the BIOS while reading from the disk."
   722                                                          db      13,10,0
   723                                  czPrepMsg30             db      13,10,"The error-code .. was returned from the BIOS while writing to the disk."
   724                                                          db      13,10,0
   725                                  czPrepMsgOK             db      13,10,"The boot-sector was written to the diskette. Before booting your computer with"
   726                                                          db      13,10,"this diskette, make sure that the file OS.COM is copied onto the diskette."
   727                                                          db      13,10,0
   728                                  czPrepMsgErr1           db      13,10,"(01) Invalid Disk Parameter"
   729                                                          db      13,10,"This is an internal error caused by an invalid value being passed to a system"
   730                                                          db      13,10,"function. The OSBOOT.COM file may be corrupt. Copy or download the file again"
   731                                                          db      13,10,"and retry."
   732                                                          db      13,10,0
   733                                  czPrepMsgErr2           db      13,10,"(02) Address Mark Not Found"
   734                                                          db      13,10,"This error indicates a physical problem with the floppy diskette. Please retry"
   735                                                          db      13,10,"using another diskette."
   736                                                          db      13,10,0
   737                                  czPrepMsgErr3           db      13,10,"(03) Protected Disk"
   738                                                          db      13,10,"This error is usually caused by attempting to write to a write-protected disk."
   739                                                          db      13,10,"Check the 'write-protect' setting on the disk or retry using using another disk."
   740                                                          db      13,10,0
   741                                  czPrepMsgErr6           db      13,10,"(06) Diskette Removed"
   742                                                          db      13,10,"This error may indicate that the floppy diskette has been removed from the"
   743                                                          db      13,10,"diskette drive. On some systems, this code may also occur if the diskette is"
   744                                                          db      13,10,"'write protected.' Please verify that the diskette is not write-protected and"
   745                                                          db      13,10,"is properly inserted in the diskette drive."
   746                                                          db      13,10,0
   747                                  czPrepMsgErr80          db      13,10,"(80) Drive Timed Out"
   748                                                          db      13,10,"This error usually indicates that no diskette is in the diskette drive. Please"
   749                                                          db      13,10,"make sure that the diskette is properly seated in the drive and retry."
   750                                                          db      13,10,0
   751                                  czPrepMsgErrXX          db      13,10,"(??) Unknown Error"
   752                                                          db      13,10,"The error-code returned by the BIOS is not a recognized error. Please consult"
   753                                                          db      13,10,"your computer's technical reference for a description of this error code."
   754                                                          db      13,10,0
   755                                  wcPrepInBuf             equ     $
   756                                  %endif
   757                                  %ifdef BUILDDISK
   758                                  ;=======================================================================================================================
   759                                  ;
   760                                  ;       File Allocation Tables
   761                                  ;
   762                                  ;       The disk contains two copies of the File Allocation Table (FAT). On our disk, each FAT copy is 1200h bytes in
   763                                  ;       length. Each FAT entry contains the logical number of the next cluster. The first two entries are reserved. Our
   764                                  ;       OS.COM file here is 400h bytes in length. These 400h bytes contain familiar code that displays a message to the
   765                                  ;       screen. Our disk parameter table defines a cluster as containing one sector and each sector having 200h bytes.
   766                                  ;       Therefore, our FAT table must reserve only two clusters for OS.COM. The clusters used by OS.COM, then, will be
   767                                  ;       clusters 2 and 3. The entry value for cluster 3 is set to "0fffh" to indicate that it is the last cluster in the
   768                                  ;       chain.
   769                                  ;
   770                                  ;       Every three bytes encode two FAT entries as follows:
   771                                  ;
   772                                  ;       db      0abh,0cdh,0efh  ;even cluster: 0dabh, odd cluster: 0efch
   773                                  ;
   774                                  ;=======================================================================================================================
   775                                  ;-----------------------------------------------------------------------------------------------------------------------
   776                                  ;
   777                                  ;       FAT copy 1                                                              @disk: 000200   @mem: n/a
   778                                  ;
   779                                  ;-----------------------------------------------------------------------------------------------------------------------
   780                                  section                 fat1                                                    ;first copy of FAT
   781                                                          db      0F0h,0FFh,0FFh, 003h,0F0h,0FFh
   782                                                          times   (9*512)-($-$$) db 0                             ;zero fill to end of section
   783                                  ;-----------------------------------------------------------------------------------------------------------------------
   784                                  ;
   785                                  ;       FAT copy 2                                                              @disk: 001400   @mem: n/a
   786                                  ;
   787                                  ;-----------------------------------------------------------------------------------------------------------------------
   788                                  section                 fat2                                                    ;second copy of FAT
   789                                                          db      0F0h,0FFh,0FFh, 003h,0F0h,0FFh
   790                                                          times   (9*512)-($-$$) db 0                             ;zero fill to end of section
   791                                  ;-----------------------------------------------------------------------------------------------------------------------
   792                                  ;
   793                                  ;       Diskette Directory                                                      @disk: 002600   @mem: n/a
   794                                  ;
   795                                  ;       The disk contains one copy of the diskette directory. Each directory entry is 32 bytes long. Our directory
   796                                  ;       contains only one entry. Unused entries are set to all nulls. The directory immediately follows the second FAT
   797                                  ;       copy.
   798                                  ;
   799                                  ;-----------------------------------------------------------------------------------------------------------------------
   800                                  section                 dir                                                     ;diskette directory
   801                                                          db      "OS      COM"                                   ;file name (must contain spaces)
   802                                                          db      020h                                            ;attribute (archive bit set)
   803                                                          times   10 db 0                                         ;unused
   804                                                          dw      0h                                              ;time
   805                                                          db      01000001b                                       ;mmm = 10 MOD 8 = 2; ddddd = 1
   806                                                          db      01001001b                                       ;yyyyyyy = 2016-1980 = 36 = 24h; m/8 = 1
   807                                                          dw      2                                               ;first cluster
   808                                                          dd      400h                                            ;file size
   809                                                          times   (EBOOTDIRENTRIES*32)-($-$$) db 0h               ;zero fill to end of section
   810                                  %endif
   811                                  %ifdef BUILDCOM
   812                                  ;=======================================================================================================================
   813                                  ;
   814                                  ;       OS.COM
   815                                  ;
   816                                  ;       The operating system file is assembled at the start of the data area of the floppy disk image, which
   817                                  ;       immediately follows the directory. This corresponds to logical cluster 2, even though the physical address of
   818                                  ;       this sector on the disk varies depending on the disk type. The os.com file consists of two parts, the OS loader
   819                                  ;       and the OS kernel. The Loader is 16-bit code that receives control directly from the boot sector code after the
   820                                  ;       OS.COM file is loaded into memory. The kernel is 32-bit code that receives control after the Loader has
   821                                  ;       initialized protected-mode tables and 32-bit interrupt handlers and switched the CPU into protected mode.
   822                                  ;
   823                                  ;       Our loader addressability is set up according to the following diagram.
   824                                  ;
   825                                  ;       SS -----------> 007b00  +-----------------------------------------------+ SS:0000
   826                                  ;                               |  Boot Stack & Boot PSP (Unused)               |
   827                                  ;                               |  256 = 100h bytes                             |
   828                                  ;       SS:SP --------> 007c00  +-----------------------------------------------+ SS:0100  07b0:0100
   829                                  ;                               |  Boot Sector (vstart=0100h)                   |
   830                                  ;                               |  1 sector = 512 = 200h bytes                  |
   831                                  ;                       007e00  +-----------------------------------------------+
   832                                  ;                               |  File Allocation Table (FAT) I/O Buffer       |
   833                                  ;                               |  9 x 512-byte sectors = 4,608 = 1200h bytes   |
   834                                  ;                               |                                               |
   835                                  ;       CS,DS,ES -----> 008f00  |  Loader PSP (Unused)                          | DS:0000
   836                                  ;                               |                                               |
   837                                  ;       CS:IP --------> 009000  +-----------------------------------------------+ DS:0100  08f0:0100
   838                                  ;                               |  Loader Code                                  |
   839                                  ;                               |  2 sectors = 1024 = 400h bytes                |
   840                                  ;                       009400  +-----------------------------------------------+ DS:0500
   841                                  ;
   842                                  ;=======================================================================================================================
   843                                  ;-----------------------------------------------------------------------------------------------------------------------
   844                                  ;
   845                                  ;       OS Loader                                                               @disk: 004200   @mem: 009000
   846                                  ;
   847                                  ;       This code is the operating system loader. It resides on the boot disk at the start of the data area, following
   848                                  ;       the directory. The loader occupies several clusters that are mapped in the file allocation tables above.
   849                                  ;       The loader executes 16-bit instructions in real mode. It performs several initialization functions such as
   850                                  ;       determining whether the CPU and other resources are sufficient to run the operating system. If all minimum
   851                                  ;       resources are present, the loader initializes protected mode tables, places the CPU into protected mode and
   852                                  ;       starts the console task. Since the loader was called either from the bootstrap or as a .com file on the boot
   853                                  ;       disk, we can assume that the initial IP is 0x100 and not perform any absolute address fix-ups on our segment
   854                                  ;       registers.
   855                                  ;
   856                                  ;-----------------------------------------------------------------------------------------------------------------------
   857                                                          cpu     8086                                            ;assume minimal CPU
   858                                  section                 loader  vstart=0100h                                    ;use .COM compatible addressing
   859                                                          bits    16                                              ;this is 16-bit code
   860                                  Loader                  push    cs                                              ;use the code segment
   861                                                          pop     ds                                              ;...as our data segment
   862                                                          push    cs                                              ;use the code segment
   863                                                          pop     es                                              ;...as our extra segment
   864                                  ;
   865                                  ;       Write a message to the console so we know we have our addressability established.
   866                                  ;
   867                                                          mov     si,czStartingMsg                                ;starting message
   868                                                          call    PutTTYString                                    ;display loader message
   869                                  ;
   870                                  ;       Now we want to wait for a keypress. We can use a keyboard interrupt function for this (INT 16h, AH=0).
   871                                  ;       However, some hypervisor BIOS implementations have been seen to implement the "wait" as simply a fast
   872                                  ;       iteration of the keyboard status function call (INT 16h, AH=1), causing a max CPU condition. So, instead,
   873                                  ;       we will use the keyboard status call and iterate over a halt (HLT) instruction until a key is pressed.
   874                                  ;       By convention, we enable maskable interrupts with STI before issuing HLT, so as not to catch fire.
   875                                  ;
   876                                  .30                     mov     ah,EBIOSFNKEYSTATUS                             ;keyboard status function
   877                                                          int     EBIOSINTKEYBOARD                                ;call BIOS keyboard interrupt
   878                                                          jnz     .40                                             ;exit if key pressed
   879                                                          sti                                                     ;enable maskable interrupts
   880                                                          hlt                                                     ;wait for interrupt
   881                                                          jmp     .30                                             ;repeat until keypress
   882                                  ;
   883                                  ;       Now that a key has been pressed, we signal the system to restart by driving the B0 line on the 8042
   884                                  ;       keyboard controller low (OUT 64h,0feh). The restart may take some microseconds to kick in, so we issue
   885                                  ;       HLT until the system resets.
   886                                  ;
   887                                  .40                     mov     al,EKEYBCMDRESET                                ;8042 pulse output port pin
   888                                                          out     EKEYBPORTSTAT,al                                ;drive B0 low to restart
   889                                  .50                     sti                                                     ;enable maskable interrupts
   890                                                          hlt                                                     ;stop until reset, int, nmi
   891                                                          jmp     .50                                             ;loop until restart kicks in
   892                                  ;-----------------------------------------------------------------------------------------------------------------------
   893                                  ;
   894                                  ;       Routine:        PutTTYString
   895                                  ;
   896                                  ;       Description:    This routine sends a NUL-terminated string of characters to the TTY output device. We use the
   897                                  ;                       TTY output function of the BIOS video interrupt, passing the address of the string in DS:SI
   898                                  ;                       and the BIOS teletype function code in AH. After a return from the BIOS interrupt, we repeat
   899                                  ;                       for the next string character until a NUL is found. Note that we clear the direction flag (DF)
   900                                  ;                       with CLD before the first LODSB. The direction flag is not guaranteed to be preseved between
   901                                  ;                       calls within the OS. However, the "int" instruction does store the EFLAGS register on the
   902                                  ;                       stack and restores it on return. Therefore, clearing the direction flag before subsequent calls
   903                                  ;                       to LODSB is not needed.
   904                                  ;
   905                                  ;       In:             DS:SI   address of string
   906                                  ;
   907                                  ;       Out:            DF      0
   908                                  ;                       ZF      1
   909                                  ;                       AL      0
   910                                  ;
   911                                  ;-----------------------------------------------------------------------------------------------------------------------
   912                                  PutTTYString            cld                                                     ;forward strings
   913                                  .10                     lodsb                                                   ;load next byte at DS:SI in AL
   914                                                          test    al,al                                           ;end of string?
   915                                                          jz      .20                                             ;... yes, exit our loop
   916                                                          mov     ah,EBIOSFNTTYOUTPUT                             ;BIOS teletype function
   917                                                          int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
   918                                                          jmp     .10                                             ;repeat until done
   919                                  .20                     ret                                                     ;return
   920                                  ;-----------------------------------------------------------------------------------------------------------------------
   921                                  ;
   922                                  ;       Loader Data
   923                                  ;
   924                                  ;       Our only "data" is the string displayed when system starts. It ends with ASCII carriage-return (13) and line-
   925                                  ;       feed (10) values. The remainder of the boot sector is filled with NUL. The boot sector finally ends with the
   926                                  ;       required two-byte signature checked by the BIOS. Note that recent versions of NASM will issue a warning if
   927                                  ;       the calculated address for the end-of-sector signature produces a negative value for "1024-($-$$)". This will
   928                                  ;       indicate if we have added too much data and exceeded the length of the sector. Note also that since we are at
   929                                  ;       the end of a "file" (os.com) and not the boot sector, there is no end-of-sector marker (0x55 0xaa) here.
   930                                  ;
   931                                  ;-----------------------------------------------------------------------------------------------------------------------
   932                                  czStartingMsg           db      "Starting OS",13,10,0                           ;starting message
   933                                                          times   1024-($-$$) db 0h                               ;zero fill to end of sector
   934                                  %endif
   935                                  %ifdef BUILDDISK
   936                                  ;-----------------------------------------------------------------------------------------------------------------------
   937                                  ;
   938                                  ;       Free Disk Space                                                         @disk: 004600   @mem:  n/a
   939                                  ;
   940                                  ;       Following the convention introduced by DOS, we use the value 'F6' to indicate unused floppy disk storage.
   941                                  ;
   942                                  ;-----------------------------------------------------------------------------------------------------------------------
   943                                  section                 unused                                                  ;unused disk space
   944                                                          times   EBOOTDISKBYTES-04600h db 0F6h                   ;fill to end of disk image
   945                                  %endif
   946                                  ;=======================================================================================================================
   947                                  ;
   948                                  ;       End of Program Code
   949                                  ;
   950                                  ;=======================================================================================================================
