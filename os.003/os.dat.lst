     1                                  ;=======================================================================================================================
     2                                  ;
     3                                  ;       File:           os.asm
     4                                  ;
     5                                  ;       Project:        os.003
     6                                  ;
     7                                  ;       Description:    This sample program adds code to create osprep.com, a program to update the boot sector on a
     8                                  ;                       floppy disk. This utility can be useful in creating floppy boot diskettes from native DOS or
     9                                  ;                       within a DOS VM.
    10                                  ;
    11                                  ;       Revised:        July 4, 2018
    12                                  ;
    13                                  ;       Assembly:       nasm os.asm -f bin -o os.dat     -l os.dat.lst     -DBUILDBOOT
    14                                  ;                       nasm os.asm -f bin -o os.dsk     -l os.dsk.lst     -DBUILDDISK
    15                                  ;                       nasm os.asm -f bin -o os.com     -l os.com.lst     -DBUILDCOM
    16                                  ;                       nasm os.asm -f bin -o osprep.com -l osprep.com.lst -DBUILDPREP
    17                                  ;
    18                                  ;       Assembler:      Netwide Assembler (NASM) 2.13.03, Feb 7 2018
    19                                  ;
    20                                  ;       Notice:         Copyright (C) 2010-2018 David J. Walling. All Rights Reserved.
    21                                  ;
    22                                  ;=======================================================================================================================
    23                                  ;-----------------------------------------------------------------------------------------------------------------------
    24                                  ;
    25                                  ;       Assembly Directives
    26                                  ;
    27                                  ;       Use one of the following as an assembly directive (-D) with NASM.
    28                                  ;
    29                                  ;       BUILDBOOT       Creates os.dat, a 512-byte boot sector as a standalone file.
    30                                  ;       BUILDDISK       Creates os.dsk, a 1.44MB (3.5") floppy disk image file.
    31                                  ;       BUILDCOM        Creates os.com, the OS loader and kernel as a standalone DOS program.
    32                                  ;       BUILDPREP       Creates osprep.com, a DOS program that prepares a floppy disk to boot the OS
    33                                  ;
    34                                  ;-----------------------------------------------------------------------------------------------------------------------
    35                                  %ifdef BUILDDISK                                                                ;if we are building a disk image ...
    36                                  %define BUILDBOOT                                                               ;... build the boot sector
    37                                  %define BUILDCOM                                                                ;... and the OS kernel
    38                                  %endif
    39                                  %ifdef BUILDPREP                                                                ;if creating the disk prep program ...
    40                                  %define BUILDBOOT                                                               ;... also build the boot sector
    41                                  %endif
    42                                  ;-----------------------------------------------------------------------------------------------------------------------
    43                                  ;
    44                                  ;       Conventions
    45                                  ;
    46                                  ;       Alignment:      In this document, columns are numbered beginning with 1.
    47                                  ;                       Logical tabs are set after each eight columns.
    48                                  ;                       Tabs are simulated using SPACE characters.
    49                                  ;                       For comments that span an entire line, comment text begins in column 9.
    50                                  ;                       Assembly instructions (mnemonics) begin in column 25.
    51                                  ;                       Assembly operands begin in column 33.
    52                                  ;                       Inline comments begin in column 81.
    53                                  ;                       Lines should not extend beyond column 120.
    54                                  ;
    55                                  ;       Arguments:      Arguments are passed as registers and generally follow this order: EAX, ECX, EDX, EBX.
    56                                  ;                       However, ECX may be used as the sole parameter if a test for zero is required. EBX and EBP
    57                                  ;                       may be used as parameters if the routine is considered a "method" of an "object". In this
    58                                  ;                       case, EBX or EBP will address the object storage. If the routine is general-purpose string
    59                                  ;                       or character-array manipulator, ESI and EDI may be used as parameters to address input and/or
    60                                  ;                       ouput buffers, respectively.
    61                                  ;
    62                                  ;       Code Order:     Routines should appear in the order of their first likely use.
    63                                  ;                       Negative relative call or jump addresses usually, therefore, indicate reuse.
    64                                  ;
    65                                  ;       Comments:       A comment that spans the entire line begins with a semicolon in column 1.
    66                                  ;                       A comment that accompanies code on a line begins with a semicolon in column 81.
    67                                  ;                       Register names in comments are in upper case (EAX, EDI).
    68                                  ;                       Hexadecimal values in comments are in lower case (01fh, 0dah).
    69                                  ;                       Routines are preceded with a comment box that includes the routine name, description, and
    70                                  ;                       register contents on entry and exit.
    71                                  ;
    72                                  ;       Constants:      Symbolic constants (equates) are named in all-caps beginning with 'E' (EDATAPORT).
    73                                  ;                       Constant stored values are named in camel case, starting with 'c' (cbMaxLines).
    74                                  ;                       The 2nd letter of the constant label indicates the storage type.
    75                                  ;
    76                                  ;                       cq......        constant quad-word (dq)
    77                                  ;                       cd......        constant double-word (dd)
    78                                  ;                       cw......        constant word (dw)
    79                                  ;                       cb......        constant byte (db)
    80                                  ;                       cz......        constant ASCIIZ (null-terminated) string
    81                                  ;
    82                                  ;       Instructions:   32-bit instructions are generally favored.
    83                                  ;                       8-bit instructions and data are preferred for flags and status fields, etc.
    84                                  ;                       16-bit instructions are avoided wherever possible to avoid prefix bytes.
    85                                  ;
    86                                  ;       Labels:         Labels within a routine are numeric and begin with a period (.10, .20).
    87                                  ;                       Labels within a routine begin at ".10" and increment by 10.
    88                                  ;
    89                                  ;       Literals:       Literal values defined by external standards should be defined as symbolic constants (equates).
    90                                  ;                       Hexadecimal literals in code are in upper case with a leading '0' and trailing 'h' (01Fh).
    91                                  ;                       Binary literal values in source code are encoded with a final 'b' (1010b).
    92                                  ;                       Decimal literal values in source code are strictly numerals (2048).
    93                                  ;                       Octal literal values are avoided.
    94                                  ;                       String literals are enclosed in double quotes, e.g. "Loading OS".
    95                                  ;                       Single character literals are enclosed in single quotes, e.g. 'A'.
    96                                  ;
    97                                  ;       Macros:         Macro names are in camel case, beginning with a lower-case letter (getDateString).
    98                                  ;                       Macro names describe an action and so DO begin with a verb.
    99                                  ;
   100                                  ;       Memory Use:     Operating system memory allocation is minimized.
   101                                  ;                       Buffers are kept to as small a size as practicable.
   102                                  ;                       Data and code intermingling is avoided wherever possible.
   103                                  ;
   104                                  ;       Registers:      Register names in comments are in upper case (EAX, EDX).
   105                                  ;                       Register names in source code are in lower case (eax, edx).
   106                                  ;
   107                                  ;       Return Values:  Routines return result values in EAX or ECX or both. Routines should indicate failure by
   108                                  ;                       setting the carry flag to 1. Routines may prefer the use of ECX as a return value if the
   109                                  ;                       value is to be tested for null upon return (using the jecxz instruction).
   110                                  ;
   111                                  ;       Routines:       Routine names are in mixed case and capitalized (GetYear, ReadRealTimeClock).
   112                                  ;                       Routine names begin with a verb (Get, Read, Load).
   113                                  ;                       Routines should have a single entry address and a single exit instruction (ret, iretd, etc.).
   114                                  ;                       Routines that serve as wrappers for library functions carry the same name as the library
   115                                  ;                       function but begin with a leading underscore (_) character.
   116                                  ;
   117                                  ;       Structures:     Structure names are in all-caps (DATETIME).
   118                                  ;                       Structure names describe a "thing" and so do NOT begin with a verb.
   119                                  ;
   120                                  ;       Usage:          Registers EBX, ECX, EBP, SS, CS, DS and ES are preserved by routines.
   121                                  ;                       Registers ESI and EDI are preserved unless they are input parameters.
   122                                  ;                       Registers EAX and ECX are preferred for returning response/result values.
   123                                  ;                       Registers EBX and EBP are preferred for context (structure) address parameters.
   124                                  ;                       Registers EAX, ECX, EDX and EBX are preferred for integral parameters.
   125                                  ;
   126                                  ;       Variables:      Variables are named in camel case, starting with 'w'.
   127                                  ;                       The 2nd letter of the variable label indicates the storage type.
   128                                  ;
   129                                  ;                       wq......        variable quad-word (resq)
   130                                  ;                       wd......        variable double-word (resd)
   131                                  ;                       ww......        variable word (resw)
   132                                  ;                       wb......        variable byte (resb)
   133                                  ;                       ws......        writable structure
   134                                  ;
   135                                  ;-----------------------------------------------------------------------------------------------------------------------
   136                                  ;=======================================================================================================================
   137                                  ;
   138                                  ;       Equates
   139                                  ;
   140                                  ;       The equate (equ) statement defines a symbolic name for a fixed value so that such a value can be defined and
   141                                  ;       verified once and then used throughout the code. Using symbolic names simplifies searching for where logical
   142                                  ;       values are used. Equate names are in all-caps and begin with the letter 'E'. Equates are grouped into related
   143                                  ;       sets. Equates here are defined in the following groupings:
   144                                  ;
   145                                  ;       Hardware-Defined Values
   146                                  ;
   147                                  ;       EKEYB...        8042 or "PS/2 Controller" (Keyboard Controller) values
   148                                  ;
   149                                  ;       Firmware-Defined Values
   150                                  ;
   151                                  ;       EBIOS...        Basic Input/Output System (BIOS) values
   152                                  ;
   153                                  ;       Standards-Based Values
   154                                  ;
   155                                  ;       EASCII...       American Standard Code for Information Interchange (ASCII) values
   156                                  ;
   157                                  ;       Operating System Values
   158                                  ;
   159                                  ;       EBOOT...        Boot sector and loader values
   160                                  ;
   161                                  ;=======================================================================================================================
   162                                  ;-----------------------------------------------------------------------------------------------------------------------
   163                                  ;
   164                                  ;       Hardware-Defined Values
   165                                  ;
   166                                  ;-----------------------------------------------------------------------------------------------------------------------
   167                                  ;-----------------------------------------------------------------------------------------------------------------------
   168                                  ;
   169                                  ;       8042 Keyboard Controller                                                EKEYB...
   170                                  ;
   171                                  ;       The 8042 Keyboard Controller (8042) is a programmable controller that accepts input signals from the keyboard
   172                                  ;       device. It also signals a hardware interrupt to the CPU when the low-order bit of I/O port 64h is set to zero.
   173                                  ;
   174                                  ;-----------------------------------------------------------------------------------------------------------------------
   175                                  EKEYBPORTSTAT           equ     064h                                            ;status port
   176                                  EKEYBCMDRESET           equ     0FEh                                            ;reset bit 0 to restart system
   177                                  ;-----------------------------------------------------------------------------------------------------------------------
   178                                  ;
   179                                  ;       Firmware-Defined Values
   180                                  ;
   181                                  ;-----------------------------------------------------------------------------------------------------------------------
   182                                  ;-----------------------------------------------------------------------------------------------------------------------
   183                                  ;
   184                                  ;       BIOS Interrupts and Functions                                           EBIOS...
   185                                  ;
   186                                  ;       Basic Input/Output System (BIOS) functions are grouped and accessed by issuing an interrupt call. Each
   187                                  ;       BIOS interrupt supports several funtions. The function code is typically passed in the AH register.
   188                                  ;
   189                                  ;-----------------------------------------------------------------------------------------------------------------------
   190                                  EBIOSINTVIDEO           equ     010h                                            ;video services interrupt
   191                                  EBIOSFNSETVMODE         equ     000h                                            ;video set mode function
   192                                  EBIOSMODETEXT80         equ     003h                                            ;video mode 80x25 text
   193                                  EBIOSFNTTYOUTPUT        equ     00Eh                                            ;video TTY output function
   194                                  EBIOSINTDISKETTE        equ     013h                                            ;diskette services interrupt
   195                                  EBIOSFNREADSECTOR       equ     002h                                            ;diskette read sector function
   196                                  EBIOSFNWRITESECTOR      equ     003h                                            ;diskette write sector function
   197                                  EBIOSINTKEYBOARD        equ     016h                                            ;keyboard services interrupt
   198                                  EBIOSFNKEYSTATUS        equ     001h                                            ;keyboard status function
   199                                  ;-----------------------------------------------------------------------------------------------------------------------
   200                                  ;
   201                                  ;       Standards-Based Values
   202                                  ;
   203                                  ;-----------------------------------------------------------------------------------------------------------------------
   204                                  ;-----------------------------------------------------------------------------------------------------------------------
   205                                  ;
   206                                  ;       ASCII                                                                   EASCII...
   207                                  ;
   208                                  ;-----------------------------------------------------------------------------------------------------------------------
   209                                  EASCIIRETURN            equ     00Dh                                            ;carriage return
   210                                  EASCIIESCAPE            equ     01Bh                                            ;escape
   211                                  ;-----------------------------------------------------------------------------------------------------------------------
   212                                  ;
   213                                  ;       Operating System Values
   214                                  ;
   215                                  ;-----------------------------------------------------------------------------------------------------------------------
   216                                  ;-----------------------------------------------------------------------------------------------------------------------
   217                                  ;
   218                                  ;       Boot Sector and Loader Constants                                        EBOOT...
   219                                  ;
   220                                  ;       Equates in this section support the boot sector and the 16-bit operating system loader, which will be
   221                                  ;       responsible for placing the CPU into protected mode and calling the initial operating system task.
   222                                  ;
   223                                  ;-----------------------------------------------------------------------------------------------------------------------
   224                                  EBOOTSTACKTOP           equ     0100h                                           ;boot sector stack top relative to DS
   225                                  EBOOTSECTORBYTES        equ     512                                             ;bytes per sector
   226                                  EBOOTDIRENTRIES         equ     224                                             ;directory entries
   227                                  EBOOTDISKSECTORS        equ     2880                                            ;sectors per disk
   228                                  EBOOTDISKBYTES          equ     (EBOOTSECTORBYTES*EBOOTDISKSECTORS)             ;bytes per disk
   229                                  EBOOTFATBASE            equ     (EBOOTSTACKTOP+EBOOTSECTORBYTES)                ;offset of FAT I/O buffer rel to DS
   230                                  EBOOTMAXTRIES           equ     5                                               ;max read retries
   231                                  %ifdef BUILDBOOT
   232                                  ;=======================================================================================================================
   233                                  ;
   234                                  ;       Boot Sector                                                             @disk: 000000   @mem: 007c00
   235                                  ;
   236                                  ;       The first sector of the disk is the boot sector. The BIOS will load the boot sector into memory and pass
   237                                  ;       control to the code at the start of the sector. The boot sector code is responsible for loading the operating
   238                                  ;       system into memory. The boot sector contains a disk parameter table describing the geometry and allocation
   239                                  ;       of the disk. Following the disk parameter table is code to load the operating system kernel into memory.
   240                                  ;
   241                                  ;       The "cpu" directive limits emitted code to those instructions supported by the most primitive processor
   242                                  ;       we expect to ever execute our code. The "vstart" parameter indicates addressability of symbols so as to
   243                                  ;       emulate the DOS .COM program model. Although the BIOS is expected to load the boot sector at address 7c00,
   244                                  ;       we do not make that assumption. The CPU starts in 16-bit addressing mode. A three-byte jump instruction is
   245                                  ;       immediately followed by a disk parameter table.
   246                                  ;
   247                                  ;=======================================================================================================================
   248                                                          cpu     8086                                            ;assume minimal CPU
   249                                  section                 boot    vstart=0100h                                    ;emulate .COM (CS,DS,ES=PSP) addressing
   250                                                          bits    16                                              ;16-bit code at power-up
   251                                  %ifdef BUILDPREP
   252                                  Boot                    jmp     word Prep                                       ;jump to preparation code
   253                                  %else
   254 00000000 E91B00                  Boot                    jmp     word Boot.10                                    ;jump over parameter table
   255                                  %endif
   256                                  ;-----------------------------------------------------------------------------------------------------------------------
   257                                  ;
   258                                  ;       Disk Parameter Table
   259                                  ;
   260                                  ;       The disk parameter table informs the BIOS of the floppy disk architecture. Here, we use parameters for the
   261                                  ;       3.5" 1.44MB floppy disk since this format is widely supported by virtual machine hypervisors.
   262                                  ;
   263                                  ;-----------------------------------------------------------------------------------------------------------------------
   264 00000003 437573746F6D4F53                                db      "CustomOS"                                      ;eight-byte label
   265 0000000B 0002                    cwSectorBytes           dw      EBOOTSECTORBYTES                                ;bytes per sector
   266 0000000D 01                      cbClusterSectors        db      1                                               ;sectors per cluster
   267 0000000E 0100                    cwReservedSectors       dw      1                                               ;reserved sectors
   268 00000010 02                      cbFatCount              db      2                                               ;file allocation table copies
   269 00000011 E000                    cwDirEntries            dw      EBOOTDIRENTRIES                                 ;max directory entries
   270 00000013 400B                    cwDiskSectors           dw      EBOOTDISKSECTORS                                ;sectors per disk
   271 00000015 F0                      cbDiskType              db      0F0h                                            ;1.44MB
   272 00000016 0900                    cwFatSectors            dw      9                                               ;sectors per FAT copy
   273                                  cbTrackSectors          equ     $                                               ;sectors per track (as byte)
   274 00000018 1200                    cwTrackSectors          dw      18                                              ;sectors per track (as word)
   275 0000001A 0200                    cwDiskSides             dw      2                                               ;sides per disk
   276 0000001C 0000                    cwSpecialSectors        dw      0                                               ;special sectors
   277                                  ;
   278                                  ;       BIOS typically loads the boot sector at absolute address 7c00 and sets the stack pointer at 512 bytes past the
   279                                  ;       end of the boot sector. But, since BIOS code varies, we don't make any assumptions as to where our boot sector
   280                                  ;       is loaded. For example, the initial CS:IP could be 0:7c00, 700:c00, 7c0:0, etc. So, to avoid assumptions, we
   281                                  ;       first normalize CS:IP to get the absolute segment address in BX. The comments below show the effect of this code
   282                                  ;       given several possible starting values for CS:IP.
   283                                  ;
   284                                                                                                                  ;CS:IP   0:7c00 700:c00 7c0:0
   285 0000001E E80000                  Boot.10                 call    word .20                                        ;[ESP] =   7c21     c21    21
   286                                  .@20                    equ     $-$$                                            ;.@20 = 021h
   287 00000021 58                      .20                     pop     ax                                              ;AX =      7c21     c21    21
   288 00000022 83E821                                          sub     ax,.@20                                         ;AX =      7c00     c00     0
   289 00000025 B104                                            mov     cl,4                                            ;shift count
   290 00000027 D3E8                                            shr     ax,cl                                           ;AX =       7c0      c0     0
   291 00000029 8CCB                                            mov     bx,cs                                           ;BX =         0     700   7c0
   292 0000002B 01C3                                            add     bx,ax                                           ;BX =       7c0     7c0   7c0
   293                                  ;
   294                                  ;       Now, since we are assembling our boot code to emulate the addressing of a .COM file, we want the DS and ES
   295                                  ;       registers to be set to where a Program Segment Prefix (PSP) would be, exactly 100h (256) bytes prior to
   296                                  ;       the start of our code. This will correspond to our assembled data address offsets. Note that we instructed
   297                                  ;       the assembler to produce addresses for our symbols that are offset from our code by 100h. See the "vstart"
   298                                  ;       parameter for the "section" directive above. We also set SS to the PSP and SP to the address of our i/o
   299                                  ;       buffer. This leaves 256 bytes of usable stack from 7b0:0 to 7b0:100.
   300                                  ;
   301 0000002D 83EB10                                          sub     bx,16                                           ;BX = 07b0
   302 00000030 8EDB                                            mov     ds,bx                                           ;DS = 07b0 = psp
   303 00000032 8EC3                                            mov     es,bx                                           ;ES = 07b0 = psp
   304 00000034 8ED3                                            mov     ss,bx                                           ;SS = 07b0 = psp (ints disabled)
   305 00000036 BC0001                                          mov     sp,EBOOTSTACKTOP                                ;SP = 0100       (ints enabled)
   306                                  ;
   307                                  ;       Our boot addressability is now set up according to the following diagram.
   308                                  ;
   309                                  ;       DS,ES,SS -----> 007b00  +-----------------------------------------------+ DS:0000
   310                                  ;                               |  Boot Stack & Boot PSP (Unused)               |
   311                                  ;                               |  256 = 100h bytes                             |
   312                                  ;       SS:SP --------> 007c00  +-----------------------------------------------+ DS:0100  07b0:0100
   313                                  ;                               |  Boot Sector (vstart=0100h)                   |
   314                                  ;                               |  1 sector = 512 = 200h bytes                  |
   315                                  ;                       007e00  +-----------------------------------------------+ DS:0300
   316                                  ;                               |  File Allocation Table (FAT) I/O Buffer       |
   317                                  ;                               |  9x512-byte sectors = 4,608 = 1200h bytes     |
   318                                  ;                       009000  +-----------------------------------------------+ DS:1500  08f0:0100
   319                                  ;                               |  Directory Sector Buffer & Kernel Load Area   |
   320                                  ;                               |  2 sectors = 1024 = 400h bytes
   321                                  ;                       009400  +-----------------------------------------------+ DS:1900
   322                                  ;
   323                                  ;       On entry, DL indicates the drive being booted from.
   324                                  ;
   325 00000039 8816[F801]                                      mov     [wbDrive],dl                                    ;[wbDrive] = drive being booted from
   326                                  ;
   327                                  ;       Compute directory i/o buffer address.
   328                                  ;
   329 0000003D A1[1600]                                        mov     ax,[cwFatSectors]                               ;AX = 0009 = FAT sectors
   330 00000040 F726[0B00]                                      mul     word [cwSectorBytes]                            ;DX:AX = 0000:1200 = FAT bytes
   331 00000044 050003                                          add     ax,EBOOTFATBASE                                 ;AX = 1500 = end of FAT buffer
   332 00000047 A3[EC01]                                        mov     [wwDirBuffer],ax                                ;[wwDirBuffer] = 1500
   333                                  ;
   334                                  ;       Compute segment where os.com will be loaded.
   335                                  ;
   336 0000004A D3E8                                            shr     ax,cl                                           ;AX = 0150
   337 0000004C 01D8                                            add     ax,bx                                           ;AX = 0150 + 07b0 = 0900
   338 0000004E 83E810                                          sub     ax,16                                           ;AX = 08f0
   339 00000051 A3[3F01]                                        mov     [wwLoadSegment],ax                              ;[wwLoadSegment] = 08f0
   340                                  ;
   341                                  ;       Set the video mode to 80 column, 25 row, text.
   342                                  ;
   343 00000054 B80300                                          mov     ax,EBIOSFNSETVMODE<<8|EBIOSMODETEXT80           ;set mode function, 80x25 text mode
   344 00000057 CD10                                            int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
   345                                  ;
   346                                  ;       Write a message to the console so we know we have our addressability established.
   347                                  ;
   348 00000059 BE[C501]                                        mov     si,czLoadMsg                                    ;loading message
   349 0000005C E84B01                                          call    BootPrint                                       ;display loader message
   350                                  ;
   351                                  ;       Initialize the number of directory sectors to search.
   352                                  ;
   353 0000005F A1[1100]                                        mov     ax,[cwDirEntries]                               ;AX = 224 = max dir entries
   354 00000062 A3[EE01]                                        mov     [wwEntriesLeft],ax                              ;[wwEntriesLeft] = 224
   355                                  ;
   356                                  ;       Compute number of directory sectors and initialize overhead count.
   357                                  ;
   358 00000065 89C1                                            mov     cx,ax                                           ;CX = 00e0 = 224 entries
   359 00000067 F726[B801]                                      mul     word [cwEntryLen]                               ;DX:AX = 224 * 32 = 7168
   360 0000006B F736[0B00]                                      div     word [cwSectorBytes]                            ;AX = 7168 / 512 = 14 = dir sectors
   361 0000006F A3[F001]                                        mov     [wwOverhead],ax                                 ;[wwOverhead] = 000e
   362                                  ;
   363                                  ;       Compute directory entries per sector.
   364                                  ;
   365 00000072 91                                              xchg    ax,cx                                           ;DX:AX = 0:00e0, CX = 0000e
   366 00000073 F7F1                                            div     cx                                              ;AX = 0010 = entries per dir sector
   367 00000075 A3[F201]                                        mov     [wwSectorEntries],ax                            ;[wwSectorEntries] = 0010
   368                                  ;
   369                                  ;       Compute first logical directory sector and update overhead count.
   370                                  ;
   371 00000078 A1[1600]                                        mov     ax,[cwFatSectors]                               ;AX = 0009 = FAT sectors per copy
   372 0000007B F626[1000]                                      mul     byte [cbFatCount]                               ;AX = 0012 = FAT sectors
   373 0000007F 0306[0E00]                                      add     ax,[cwReservedSectors]                          ;AX = 0013 = FAT plus reserved
   374 00000083 0306[1C00]                                      add     ax,[cwSpecialSectors]                           ;AX = 0013 = FAT + reserved + special
   375 00000087 A3[F401]                                        mov     [wwLogicalSector],ax                            ;[wwLogicalSector] = 0013
   376 0000008A 0106[F001]                                      add     [wwOverhead],ax                                 ;[wwOverhead] = 0021 = res+spec+FAT+dir
   377                                  ;
   378                                  ;       Read directory sector.
   379                                  ;
   380 0000008E B001                    .30                     mov     al,1                                            ;sector count
   381 00000090 A2[F601]                                        mov     [wbReadCount],al                                ;[wbReadCount] = 01
   382 00000093 8B1E[EC01]                                      mov     bx,[wwDirBuffer]                                ;BX = 1500
   383 00000097 E8A700                                          call    ReadSector                                      ;read sector into es:bx
   384                                  ;
   385                                  ;       Setup variables to search this directory sector.
   386                                  ;
   387 0000009A A1[EE01]                                        mov     ax,[wwEntriesLeft]                              ;directory entries to search
   388 0000009D 3B06[F201]                                      cmp     ax,[wwSectorEntries]                            ;need to search more sectors?
   389 000000A1 7603                                            jna     .40                                             ;no, continue
   390 000000A3 A1[F201]                                        mov     ax,[wwSectorEntries]                            ;yes, limit search to sector
   391 000000A6 2906[EE01]              .40                     sub     [wwEntriesLeft],ax                              ;update entries left to searh
   392 000000AA BE[BA01]                                        mov     si,cbKernelProgram                              ;program name
   393 000000AD 8B3E[EC01]                                      mov     di,[wwDirBuffer]                                ;DI = 1500
   394                                  ;
   395                                  ;       Loop through directory sectors searching for kernel program.
   396                                  ;
   397 000000B1 56                      .50                     push    si                                              ;save kernel name address
   398 000000B2 57                                              push    di                                              ;save dir i/o buffer address
   399 000000B3 B90B00                                          mov     cx,11                                           ;length of 8+3 name
   400 000000B6 FC                                              cld                                                     ;forward strings
   401 000000B7 F3A6                                            repe    cmpsb                                           ;compare entry name
   402 000000B9 5F                                              pop     di                                              ;restore dir i/o buffer address
   403 000000BA 5E                                              pop     si                                              ;restore kernel name address
   404 000000BB 7418                                            je      .60                                             ;exit loop if found
   405 000000BD 033E[B801]                                      add     di,[cwEntryLen]                                 ;point to next dir entry
   406 000000C1 48                                              dec     ax                                              ;decrement remaining entries
   407 000000C2 75ED                                            jnz     .50                                             ;next entry
   408                                  ;
   409                                  ;       Repeat search if we are not at the end of the directory.
   410                                  ;
   411 000000C4 FF06[F401]                                      inc     word [wwLogicalSector]                          ;increment logical sector
   412 000000C8 833E[EE01]00                                    cmp     word [wwEntriesLeft],0                          ;done with directory?
   413 000000CD 75BF                                            jne     .30                                             ;no, get next sector
   414 000000CF BE[E001]                                        mov     si,czNoKernel                                   ;missing kernel message
   415 000000D2 E9C000                                          jmp     BootExit                                        ;display message and exit
   416                                  ;
   417                                  ;       If we find the kernel program in the directory, read the FAT.
   418                                  ;
   419 000000D5 A1[0E00]                .60                     mov     ax,[cwReservedSectors]                          ;AX = 0001
   420 000000D8 A3[F401]                                        mov     [wwLogicalSector],ax                            ;start past boot sector
   421 000000DB A1[1600]                                        mov     ax,[cwFatSectors]                               ;AX = 0009
   422 000000DE A2[F601]                                        mov     [wbReadCount],al                                ;[wbReadCount] = 09
   423 000000E1 BB0003                                          mov     bx,EBOOTFATBASE                                 ;BX = 0300
   424 000000E4 E85A00                                          call    ReadSector                                      ;read FAT into buffer
   425                                  ;
   426                                  ;       Get the starting cluster of the kernel program and target address.
   427                                  ;
   428 000000E7 8B451A                                          mov     ax,[di+26]                                      ;AX = starting cluster of file
   429 000000EA C41E[3D01]                                      les     bx,[wwLoadOffset]                               ;ES:BX = kernel load add (08f0:0100)
   430                                  ;
   431                                  ;       Read each program cluster into RAM.
   432                                  ;
   433 000000EE 50                      .70                     push    ax                                              ;save cluster nbr
   434 000000EF 83E802                                          sub     ax,2                                            ;AX = cluster nbr base 0
   435 000000F2 8A0E[0D00]                                      mov     cl,[cbClusterSectors]                           ;CL = sectors per cluster
   436 000000F6 880E[F601]                                      mov     [wbReadCount],cl                                ;save sectors to read
   437 000000FA 30ED                                            xor     ch,ch                                           ;CX = sectors per cluster
   438 000000FC F7E1                                            mul     cx                                              ;DX:AX = logical cluster sector
   439 000000FE 0306[F001]                                      add     ax,[wwOverhead]                                 ;AX = kernel sector nbr
   440 00000102 A3[F401]                                        mov     [wwLogicalSector],ax                            ;save logical sector nbr
   441 00000105 E83900                                          call    ReadSector                                      ;read sectors into ES:BX
   442                                  ;
   443                                  ;       Update buffer pointer for next cluster.
   444                                  ;
   445 00000108 A0[0D00]                                        mov     al,[cbClusterSectors]                           ;AL = sectors per cluster
   446 0000010B 30E4                                            xor     ah,ah                                           ;AX = sectors per cluster
   447 0000010D F726[0B00]                                      mul     word [cwSectorBytes]                            ;DX:AX = cluster bytes
   448 00000111 01C3                                            add     bx,ax                                           ;BX = next cluster target address
   449 00000113 58                                              pop     ax                                              ;AX = restore cluster nbr
   450                                  ;
   451                                  ;       Compute next cluster number.
   452                                  ;
   453 00000114 89C1                                            mov     cx,ax                                           ;CX = cluster nbr
   454 00000116 89C7                                            mov     di,ax                                           ;DI = cluster nbr
   455 00000118 D1E8                                            shr     ax,1                                            ;AX = cluster/2
   456 0000011A 89C2                                            mov     dx,ax                                           ;DX = cluster/2
   457 0000011C 01D0                                            add     ax,dx                                           ;AX = 2*(cluster/2)
   458 0000011E 01D0                                            add     ax,dx                                           ;AX = 3*(cluster/2)
   459 00000120 83E701                                          and     di,1                                            ;get low bit
   460 00000123 01C7                                            add     di,ax                                           ;add one if cluster is odd
   461 00000125 81C70003                                        add     di,EBOOTFATBASE                                 ;add FAT buffer address
   462 00000129 8B05                                            mov     ax,[di]                                         ;get cluster bytes
   463                                  ;
   464                                  ;       Adjust cluster nbr by 4 bits if cluster is odd; test for end of chain.
   465                                  ;
   466 0000012B F6C101                                          test    cl,1                                            ;is cluster odd?
   467 0000012E 7404                                            jz      .80                                             ;no, skip ahead
   468 00000130 B104                                            mov     cl,4                                            ;shift count
   469 00000132 D3E8                                            shr     ax,cl                                           ;shift nybble low
   470 00000134 25FF0F                  .80                     and     ax,0FFFh                                        ;mask for 24 bits; next cluster nbr
   471 00000137 3DFF0F                                          cmp     ax,0FFFh                                        ;end of chain?
   472 0000013A 75B2                                            jne     .70                                             ;no, continue
   473                                  ;
   474                                  ;       Transfer control to the operating system program.
   475                                  ;
   476 0000013C EA                                              db      0EAh                                            ;jmp seg:offset
   477 0000013D 0001                    wwLoadOffset            dw      0100h                                           ;kernel entry offset
   478 0000013F F008                    wwLoadSegment           dw      08F0h                                           ;kernel entry segment (computed)
   479                                  ;
   480                                  ;       Read [wbReadCount] disk sectors from [wwLogicalSector] into ES:BX.
   481                                  ;
   482 00000141 A1[1800]                ReadSector              mov     ax,[cwTrackSectors]                             ;AX = sectors per track
   483 00000144 F726[1A00]                                      mul     word [cwDiskSides]                              ;DX:AX = sectors per cylinder
   484 00000148 89C1                                            mov     cx,ax                                           ;CX = sectors per cylinder
   485 0000014A A1[F401]                                        mov     ax,[wwLogicalSector]                            ;DX:AX = logical sector
   486 0000014D F7F1                                            div     cx                                              ;AX = cylinder; DX = cyl sector
   487 0000014F A2[FB01]                                        mov     [wbTrack],al                                    ;[wbTrack] = cylinder
   488 00000152 89D0                                            mov     ax,dx                                           ;AX = cyl sector
   489 00000154 F636[1800]                                      div     byte [cbTrackSectors]                           ;AH = sector, AL = head
   490 00000158 FEC4                                            inc     ah                                              ;AH = sector (1,2,3,...)
   491 0000015A A3[F901]                                        mov     [wbHead],ax                                     ;[wbHead]= head, [wwSectorTrack]= sector
   492                                  ;
   493                                  ;       Try maxtries times to read sector.
   494                                  ;
   495 0000015D B90500                                          mov     cx,EBOOTMAXTRIES                                ;CX = 0005
   496 00000160 53                      .10                     push    bx                                              ;save buffer address
   497 00000161 51                                              push    cx                                              ;save retry count
   498 00000162 8B16[F801]                                      mov     dx,[wwDriveHead]                                ;DH = head, DL = drive
   499 00000166 8B0E[FA01]                                      mov     cx,[wwSectorTrack]                              ;CH = track, CL = sector
   500 0000016A A1[F601]                                        mov     ax,[wwReadCountCommand]                         ;AH = fn., AL = sector count
   501 0000016D CD13                                            int     EBIOSINTDISKETTE                                ;read sector
   502 0000016F 59                                              pop     cx                                              ;restore retry count
   503 00000170 5B                                              pop     bx                                              ;restore buffer address
   504 00000171 7343                                            jnc     BootReturn                                      ;skip ahead if done
   505 00000173 E2EB                                            loop    .10                                             ;retry
   506                                  ;
   507                                  ;       Handle disk error: convert to ASCII and store in error string.
   508                                  ;
   509 00000175 88E0                                            mov     al,ah                                           ;AL = bios error code
   510 00000177 30E4                                            xor     ah,ah                                           ;AX = bios error code
   511 00000179 B210                                            mov     dl,16                                           ;divisor for base 16
   512 0000017B F6F2                                            div     dl                                              ;AL = hi order, AH = lo order
   513 0000017D 0D3030                                          or      ax,03030h                                       ;apply ASCII zone bits
   514 00000180 80FC3A                                          cmp     ah,03Ah                                         ;range test ASCII numeral
   515 00000183 7203                                            jb      .20                                             ;continue if numeral
   516 00000185 80C407                                          add     ah,7                                            ;adjust for ASCII 'A'-'F'
   517 00000188 3C3A                    .20                     cmp     al,03Ah                                         ;range test ASCII numeral
   518 0000018A 7203                                            jb      .30                                             ;continue if numeral
   519 0000018C 80C407                                          add     ah,7                                            ;adjust for ASCII 'A'-'F'
   520 0000018F A3[DD01]                .30                     mov     [wzErrorCode],ax                                ;store ASCII error code
   521 00000192 BE[D201]                                        mov     si,czErrorMsg                                   ;error message address
   522 00000195 E81200                  BootExit                call    BootPrint                                       ;display messge to console
   523                                  ;
   524                                  ;       Wait for a key press.
   525                                  ;
   526 00000198 B401                    .10                     mov     ah,EBIOSFNKEYSTATUS                             ;BIOS keyboard status function
   527 0000019A CD16                                            int     EBIOSINTKEYBOARD                                ;get keyboard status
   528 0000019C 7504                                            jnz     .20                                             ;continue if key pressed
   529 0000019E FB                                              sti                                                     ;enable maskable interrupts
   530 0000019F F4                                              hlt                                                     ;wait for interrupt
   531 000001A0 EBF6                                            jmp     .10                                             ;repeat
   532                                  ;
   533                                  ;       Reset the system.
   534                                  ;
   535 000001A2 B0FE                    .20                     mov     al,EKEYBCMDRESET                                ;8042 pulse output port pin
   536 000001A4 E664                                            out     EKEYBPORTSTAT,al                                ;drive B0 low to restart
   537 000001A6 FB                      .30                     sti                                                     ;enable maskable interrupts
   538 000001A7 F4                                              hlt                                                     ;stop until reset, int, nmi
   539 000001A8 EBFC                                            jmp     .30                                             ;loop until restart kicks in
   540                                  ;
   541                                  ;       Display text message.
   542                                  ;
   543 000001AA FC                      BootPrint               cld                                                     ;forward strings
   544 000001AB AC                      .10                     lodsb                                                   ;load next byte at DS:SI in AL
   545 000001AC 84C0                                            test    al,al                                           ;end of string?
   546 000001AE 7406                                            jz      BootReturn                                      ;... yes, exit our loop
   547 000001B0 B40E                                            mov     ah,EBIOSFNTTYOUTPUT                             ;BIOS teletype function
   548 000001B2 CD10                                            int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
   549 000001B4 EBF5                                            jmp     .10                                             ;repeat until done
   550 000001B6 C3                      BootReturn              ret                                                     ;return
   551                                  ;-----------------------------------------------------------------------------------------------------------------------
   552                                  ;
   553                                  ;       Constants
   554                                  ;
   555                                  ;-----------------------------------------------------------------------------------------------------------------------
   556 000001B7 90                                              align   2
   557 000001B8 2000                    cwEntryLen              dw      32                                              ;length of directory entry
   558 000001BA 4F5320202020202043-     cbKernelProgram         db      "OS      COM"                                   ;kernel program name
   558 000001C3 4F4D               
   559 000001C5 4C6F6164696E67204F-     czLoadMsg               db      "Loading OS",13,10,0                            ;loading message
   559 000001CE 530D0A00           
   560 000001D2 4469736B206572726F-     czErrorMsg              db      "Disk error "                                   ;error message
   560 000001DB 7220               
   561 000001DD 202000                  wzErrorCode             db      020h,020h,0                                     ;error code and null terminator
   562 000001E0 4F53206D697373696E-     czNoKernel              db      "OS missing",0                                  ;missing kernel message
   562 000001E9 6700               
   563                                  ;-----------------------------------------------------------------------------------------------------------------------
   564                                  ;
   565                                  ;       Work Areas
   566                                  ;
   567                                  ;-----------------------------------------------------------------------------------------------------------------------
   568 000001EB 90                                              align   2
   569 000001EC 0000                    wwDirBuffer             dw      0                                               ;directory i/o buffer address
   570 000001EE 0000                    wwEntriesLeft           dw      0                                               ;directory entries to search
   571 000001F0 0000                    wwOverhead              dw      0                                               ;overhead sectors
   572 000001F2 0000                    wwSectorEntries         dw      0                                               ;directory entries per sector
   573 000001F4 0000                    wwLogicalSector         dw      0                                               ;current logical sector
   574                                  wwReadCountCommand      equ     $                                               ;read count and command
   575 000001F6 00                      wbReadCount             db      0                                               ;sectors to read
   576 000001F7 02                      cbReadCommand           db      EBIOSFNREADSECTOR                               ;BIOS read disk fn code
   577                                  wwDriveHead             equ     $                                               ;drive, head (word)
   578 000001F8 00                      wbDrive                 db      0                                               ;drive
   579 000001F9 00                      wbHead                  db      0                                               ;head
   580                                  wwSectorTrack           equ     $                                               ;sector, track (word)
   581 000001FA 00                                              db      0                                               ;sector
   582 000001FB 00                      wbTrack                 db      0                                               ;track
   583 000001FC 00<rept>                                        times   510-($-$$) db 0h                                ;zero fill to end of sector
   584 000001FE 55AA                                            db      055h,0AAh                                       ;end of sector signature
   585                                  %endif
   586                                  %ifdef BUILDPREP
   587                                  ;=======================================================================================================================
   588                                  ;
   589                                  ;       Diskette Preparation Code
   590                                  ;
   591                                  ;       This routine writes the OS boot sector code to a formatted floppy diskette. The diskette parameter table,
   592                                  ;       which is located in the first 30 bytes of the boot sector is first read from the diskette and overlayed onto
   593                                  ;       the OS bootstrap code so that the diskette format parameters are preserved.
   594                                  ;
   595                                  ;=======================================================================================================================
   596                                  ;
   597                                  ;       Query the user to insert a flopppy diskette and press enter or cancel.
   598                                  ;
   599                                  Prep                    mov     si,czPrepMsg10                                  ;starting message address
   600                                                          call    BootPrint                                       ;display message
   601                                  ;
   602                                  ;       Exit if the Escape key is pressed or loop until Enter is pressed.
   603                                  ;
   604                                  .10                     mov     ah,EBIOSFNKEYSTATUS                             ;BIOS keyboard status function
   605                                                          int     EBIOSINTKEYBOARD                                ;get keyboard status
   606                                                          jnz     .20                                             ;continue if key pressed
   607                                                          sti                                                     ;enable interrupts
   608                                                          hlt                                                     ;wait for interrupt
   609                                                          jmp     .10                                             ;repeat
   610                                  .20                     cmp     al,EASCIIRETURN                                 ;Enter key pressed?
   611                                                          je      .30                                             ;yes, branch
   612                                                          cmp     al,EASCIIESCAPE                                 ;Escape key pressed?
   613                                                          jne     .10                                             ;no, repeat
   614                                                          jmp     .120                                            ;yes, exit program
   615                                  ;
   616                                  ;       Display writing-sector message and patch the JMP instruction.
   617                                  ;
   618                                  .30                     mov     si,czPrepMsg12                                  ;writing-sector message address
   619                                                          call    BootPrint                                       ;display message
   620                                                          mov     bx,Boot+1                                       ;address of JMP instruction operand
   621                                                          mov     ax,01Bh                                         ;address past disk parameter table
   622                                                          mov     [bx],ax                                         ;update the JMP instruction
   623                                  ;
   624                                  ;       Try to read the boot sector.
   625                                  ;
   626                                                          mov     cx,EBOOTMAXTRIES                                ;try up to five times
   627                                  .40                     push    cx                                              ;save remaining tries
   628                                                          mov     bx,wcPrepInBuf                                  ;input buffer address
   629                                                          mov     dx,0                                            ;head zero, drive zero
   630                                                          mov     cx,1                                            ;track zero, sector one
   631                                                          mov     al,1                                            ;one sector
   632                                                          mov     ah,EBIOSFNREADSECTOR                            ;read function
   633                                                          int     EBIOSINTDISKETTE                                ;attempt the read
   634                                                          pop     cx                                              ;restore remaining retries
   635                                                          jnc     .50                                             ;skip ahead if successful
   636                                                          loop    .40                                             ;try again
   637                                                          mov     si,czPrepMsg20                                  ;read-error message address
   638                                                          jmp     .70                                             ;branch to error routine
   639                                  ;
   640                                  ;       Copy diskette parms from input buffer to output buffer.
   641                                  ;
   642                                  .50                     mov     si,wcPrepInBuf                                  ;input buffer address
   643                                                          add     si,11                                           ;skip over JMP and system ID
   644                                                          mov     di,Boot                                         ;output buffer address
   645                                                          add     di,11                                           ;skip over JMP and system ID
   646                                                          mov     cx,19                                           ;length of diskette parameters
   647                                                          cld                                                     ;forward string copies
   648                                                          rep     movsb                                           ;copy diskette parameters
   649                                  ;
   650                                  ;       Try to write boot sector to diskette.
   651                                  ;
   652                                                          mov     cx,EBOOTMAXTRIES                                ;try up to five times
   653                                  .60                     push    cx                                              ;save remaining tries
   654                                                          mov     bx,Boot                                         ;output buffer address
   655                                                          mov     dx,0                                            ;head zero, drive zero
   656                                                          mov     cx,1                                            ;track zero, sector one
   657                                                          mov     al,1                                            ;one sector
   658                                                          mov     ah,EBIOSFNWRITESECTOR                           ;write function
   659                                                          int     EBIOSINTDISKETTE                                ;attempt the write
   660                                                          pop     cx                                              ;restore remaining retries
   661                                                          jnc     .100                                            ;skip ahead if successful
   662                                                          loop    .60                                             ;try again
   663                                                          mov     si,czPrepMsg30                                  ;write-error message address
   664                                  ;
   665                                  ;       Convert the error code to ASCII and display the error message.
   666                                  ;
   667                                  .70                     push    ax                                              ;save error code
   668                                                          mov     al,ah                                           ;copy error code
   669                                                          mov     ah,0                                            ;AX = error code
   670                                                          mov     dl,10h                                          ;hexadecimal divisor
   671                                                          idiv    dl                                              ;AL = hi-order, AH = lo-order
   672                                                          or      ax,03030h                                       ;add ASCII zone digits
   673                                                          cmp     ah,03Ah                                         ;AH ASCII numeral?
   674                                                          jb      .80                                             ;yes, continue
   675                                                          add     ah,7                                            ;no, make ASCII 'A'-'F'
   676                                  .80                     cmp     al,03Ah                                         ;ASCII numeral?
   677                                                          jb      .90                                             ;yes, continue
   678                                                          add     al,7                                            ;no, make ASCII
   679                                  .90                     mov     [si+17],ax                                      ;put ASCII error code in message
   680                                                          call    BootPrint                                       ;write error message
   681                                                          pop     ax                                              ;restore error code
   682                                  ;
   683                                  ;       Display the completion message.
   684                                  ;
   685                                  .100                    mov     si,czPrepMsgOK                                  ;assume successful completion
   686                                                          mov     al,ah                                           ;BIOS return code
   687                                                          cmp     al,0                                            ;success?
   688                                                          je      .110                                            ;yes, continue
   689                                                          mov     si,czPrepMsgErr1                                ;disk parameter error message
   690                                                          cmp     al,1                                            ;disk parameter error?
   691                                                          je      .110                                            ;yes, continue
   692                                                          mov     si,czPrepMsgErr2                                ;address mark not found message
   693                                                          cmp     al,2                                            ;address mark not found?
   694                                                          je      .110                                            ;yes, continue
   695                                                          mov     si,czPrepMsgErr3                                ;protected disk message
   696                                                          cmp     al,3                                            ;protected disk?
   697                                                          je      .110                                            ;yes, continue
   698                                                          mov     si,czPrepMsgErr6                                ;diskette removed message
   699                                                          cmp     al,6                                            ;diskette removed?
   700                                                          je      .110                                            ;yes, continue
   701                                                          mov     si,czPrepMsgErr80                               ;drive timed out message
   702                                                          cmp     al,80H                                          ;drive timed out?
   703                                                          je      .110                                            ;yes, continue
   704                                                          mov     si,czPrepMsgErrXX                               ;unknown error message
   705                                  .110                    call    BootPrint                                       ;display result message
   706                                  .120                    mov     ax,04C00H                                       ;terminate with zero result code
   707                                                          int     021h                                            ;terminate DOS program
   708                                                          ret                                                     ;return (should not execute)
   709                                  ;-----------------------------------------------------------------------------------------------------------------------
   710                                  ;
   711                                  ;       Diskette Preparation Messages
   712                                  ;
   713                                  ;-----------------------------------------------------------------------------------------------------------------------
   714                                  czPrepMsg10             db      13,10,"CustomOS Boot-Diskette Preparation Program"
   715                                                          db      13,10,"Copyright (C) 2010-2018 David J. Walling. All rights reserved."
   716                                                          db      13,10
   717                                                          db      13,10,"This program overwrites the boot sector of a diskette with startup code that"
   718                                                          db      13,10,"will load the operating system into memory when the computer is restarted."
   719                                                          db      13,10,"To proceed, place a formatted diskette into drive A: and press the Enter key."
   720                                                          db      13,10,"To exit this program without preparing a diskette, press the Escape key."
   721                                                          db      13,10,0
   722                                  czPrepMsg12             db      13,10,"Writing the boot sector to the diskette ..."
   723                                                          db      13,10,0
   724                                  czPrepMsg20             db      13,10,"The error-code .. was returned from the BIOS while reading from the disk."
   725                                                          db      13,10,0
   726                                  czPrepMsg30             db      13,10,"The error-code .. was returned from the BIOS while writing to the disk."
   727                                                          db      13,10,0
   728                                  czPrepMsgOK             db      13,10,"The boot-sector was written to the diskette. Before booting your computer with"
   729                                                          db      13,10,"this diskette, make sure that the file OS.COM is copied onto the diskette."
   730                                                          db      13,10,0
   731                                  czPrepMsgErr1           db      13,10,"(01) Invalid Disk Parameter"
   732                                                          db      13,10,"This is an internal error caused by an invalid value being passed to a system"
   733                                                          db      13,10,"function. The OSBOOT.COM file may be corrupt. Copy or download the file again"
   734                                                          db      13,10,"and retry."
   735                                                          db      13,10,0
   736                                  czPrepMsgErr2           db      13,10,"(02) Address Mark Not Found"
   737                                                          db      13,10,"This error indicates a physical problem with the floppy diskette. Please retry"
   738                                                          db      13,10,"using another diskette."
   739                                                          db      13,10,0
   740                                  czPrepMsgErr3           db      13,10,"(03) Protected Disk"
   741                                                          db      13,10,"This error is usually caused by attempting to write to a write-protected disk."
   742                                                          db      13,10,"Check the 'write-protect' setting on the disk or retry using using another disk."
   743                                                          db      13,10,0
   744                                  czPrepMsgErr6           db      13,10,"(06) Diskette Removed"
   745                                                          db      13,10,"This error may indicate that the floppy diskette has been removed from the"
   746                                                          db      13,10,"diskette drive. On some systems, this code may also occur if the diskette is"
   747                                                          db      13,10,"'write protected.' Please verify that the diskette is not write-protected and"
   748                                                          db      13,10,"is properly inserted in the diskette drive."
   749                                                          db      13,10,0
   750                                  czPrepMsgErr80          db      13,10,"(80) Drive Timed Out"
   751                                                          db      13,10,"This error usually indicates that no diskette is in the diskette drive. Please"
   752                                                          db      13,10,"make sure that the diskette is properly seated in the drive and retry."
   753                                                          db      13,10,0
   754                                  czPrepMsgErrXX          db      13,10,"(??) Unknown Error"
   755                                                          db      13,10,"The error-code returned by the BIOS is not a recognized error. Please consult"
   756                                                          db      13,10,"your computer's technical reference for a description of this error code."
   757                                                          db      13,10,0
   758                                  wcPrepInBuf             equ     $
   759                                  %endif
   760                                  %ifdef BUILDDISK
   761                                  ;=======================================================================================================================
   762                                  ;
   763                                  ;       File Allocation Tables
   764                                  ;
   765                                  ;       The disk contains two copies of the File Allocation Table (FAT). On our disk, each FAT copy is 1200h bytes in
   766                                  ;       length. Each FAT entry contains the logical number of the next cluster. The first two entries are reserved. Our
   767                                  ;       OS.COM file here is 400h bytes in length. These 400h bytes contain familiar code that displays a message to the
   768                                  ;       screen. Our disk parameter table defines a cluster as containing one sector and each sector having 200h bytes.
   769                                  ;       Therefore, our FAT table must reserve only two clusters for OS.COM. The clusters used by OS.COM, then, will be
   770                                  ;       clusters 2 and 3. The entry value for cluster 3 is set to "0fffh" to indicate that it is the last cluster in the
   771                                  ;       chain.
   772                                  ;
   773                                  ;       Every three bytes encode two FAT entries as follows:
   774                                  ;
   775                                  ;       db      0abh,0cdh,0efh  ;even cluster: 0dabh, odd cluster: 0efch
   776                                  ;
   777                                  ;=======================================================================================================================
   778                                  ;-----------------------------------------------------------------------------------------------------------------------
   779                                  ;
   780                                  ;       FAT copy 1                                                              @disk: 000200   @mem: n/a
   781                                  ;
   782                                  ;-----------------------------------------------------------------------------------------------------------------------
   783                                  section                 fat1                                                    ;first copy of FAT
   784                                                          db      0F0h,0FFh,0FFh, 003h,0F0h,0FFh
   785                                                          times   (9*512)-($-$$) db 0                             ;zero fill to end of section
   786                                  ;-----------------------------------------------------------------------------------------------------------------------
   787                                  ;
   788                                  ;       FAT copy 2                                                              @disk: 001400   @mem: n/a
   789                                  ;
   790                                  ;-----------------------------------------------------------------------------------------------------------------------
   791                                  section                 fat2                                                    ;second copy of FAT
   792                                                          db      0F0h,0FFh,0FFh, 003h,0F0h,0FFh
   793                                                          times   (9*512)-($-$$) db 0                             ;zero fill to end of section
   794                                  ;-----------------------------------------------------------------------------------------------------------------------
   795                                  ;
   796                                  ;       Diskette Directory                                                      @disk: 002600   @mem: n/a
   797                                  ;
   798                                  ;       The disk contains one copy of the diskette directory. Each directory entry is 32 bytes long. Our directory
   799                                  ;       contains only one entry. Unused entries are set to all nulls. The directory immediately follows the second FAT
   800                                  ;       copy.
   801                                  ;
   802                                  ;-----------------------------------------------------------------------------------------------------------------------
   803                                  section                 dir                                                     ;diskette directory
   804                                                          db      "OS      COM"                                   ;file name (must contain spaces)
   805                                                          db      020h                                            ;attribute (archive bit set)
   806                                                          times   10 db 0                                         ;unused
   807                                                          dw      0h                                              ;time
   808                                                          db      01000001b                                       ;mmm = 10 MOD 8 = 2; ddddd = 1
   809                                                          db      01001001b                                       ;yyyyyyy = 2016-1980 = 36 = 24h; m/8 = 1
   810                                                          dw      2                                               ;first cluster
   811                                                          dd      400h                                            ;file size
   812                                                          times   (EBOOTDIRENTRIES*32)-($-$$) db 0h               ;zero fill to end of section
   813                                  %endif
   814                                  %ifdef BUILDCOM
   815                                  ;=======================================================================================================================
   816                                  ;
   817                                  ;       OS.COM
   818                                  ;
   819                                  ;       The operating system file is assembled at the start of the data area of the floppy disk image, which
   820                                  ;       immediately follows the directory. This corresponds to logical cluster 2, even though the physical address of
   821                                  ;       this sector on the disk varies depending on the disk type. The os.com file consists of two parts, the OS loader
   822                                  ;       and the OS kernel. The Loader is 16-bit code that receives control directly from the boot sector code after the
   823                                  ;       OS.COM file is loaded into memory. The kernel is 32-bit code that receives control after the Loader has
   824                                  ;       initialized protected-mode tables and 32-bit interrupt handlers and switched the CPU into protected mode.
   825                                  ;
   826                                  ;       Our loader addressability is set up according to the following diagram.
   827                                  ;
   828                                  ;       SS -----------> 007b00  +-----------------------------------------------+ SS:0000
   829                                  ;                               |  Boot Stack & Boot PSP (Unused)               |
   830                                  ;                               |  256 = 100h bytes                             |
   831                                  ;       SS:SP --------> 007c00  +-----------------------------------------------+ SS:0100  07b0:0100
   832                                  ;                               |  Boot Sector (vstart=0100h)                   |
   833                                  ;                               |  1 sector = 512 = 200h bytes                  |
   834                                  ;                       007e00  +-----------------------------------------------+
   835                                  ;                               |  File Allocation Table (FAT) I/O Buffer       |
   836                                  ;                               |  9 x 512-byte sectors = 4,608 = 1200h bytes   |
   837                                  ;                               |                                               |
   838                                  ;       CS,DS,ES -----> 008f00  |  Loader PSP (Unused)                          | DS:0000
   839                                  ;                               |                                               |
   840                                  ;       CS:IP --------> 009000  +-----------------------------------------------+ DS:0100  08f0:0100
   841                                  ;                               |  Loader Code                                  |
   842                                  ;                               |  2 sectors = 1024 = 400h bytes                |
   843                                  ;                       009400  +-----------------------------------------------+ DS:0500
   844                                  ;
   845                                  ;=======================================================================================================================
   846                                  ;-----------------------------------------------------------------------------------------------------------------------
   847                                  ;
   848                                  ;       OS Loader                                                               @disk: 004200   @mem: 009000
   849                                  ;
   850                                  ;       This code is the operating system loader. It resides on the boot disk at the start of the data area, following
   851                                  ;       the directory. The loader occupies several clusters that are mapped in the file allocation tables above.
   852                                  ;       The loader executes 16-bit instructions in real mode. It performs several initialization functions such as
   853                                  ;       determining whether the CPU and other resources are sufficient to run the operating system. If all minimum
   854                                  ;       resources are present, the loader initializes protected mode tables, places the CPU into protected mode and
   855                                  ;       starts the console task. Since the loader was called either from the bootstrap or as a .com file on the boot
   856                                  ;       disk, we can assume that the initial IP is 0x100 and not perform any absolute address fix-ups on our segment
   857                                  ;       registers.
   858                                  ;
   859                                  ;-----------------------------------------------------------------------------------------------------------------------
   860                                                          cpu     8086                                            ;assume minimal CPU
   861                                  section                 loader  vstart=0100h                                    ;use .COM compatible addressing
   862                                                          bits    16                                              ;this is 16-bit code
   863                                  Loader                  push    cs                                              ;use the code segment
   864                                                          pop     ds                                              ;...as our data segment
   865                                                          push    cs                                              ;use the code segment
   866                                                          pop     es                                              ;...as our extra segment
   867                                  ;
   868                                  ;       Write a message to the console so we know we have our addressability established.
   869                                  ;
   870                                                          mov     si,czStartingMsg                                ;starting message
   871                                                          call    PutTTYString                                    ;display loader message
   872                                  ;
   873                                  ;       Now we want to wait for a keypress. We can use a keyboard interrupt function for this (INT 16h, AH=0).
   874                                  ;       However, some hypervisor BIOS implementations have been seen to implement the "wait" as simply a fast
   875                                  ;       iteration of the keyboard status function call (INT 16h, AH=1), causing a max CPU condition. So, instead,
   876                                  ;       we will use the keyboard status call and iterate over a halt (HLT) instruction until a key is pressed.
   877                                  ;       By convention, we enable maskable interrupts with STI before issuing HLT, so as not to catch fire.
   878                                  ;
   879                                  .30                     mov     ah,EBIOSFNKEYSTATUS                             ;keyboard status function
   880                                                          int     EBIOSINTKEYBOARD                                ;call BIOS keyboard interrupt
   881                                                          jnz     .40                                             ;exit if key pressed
   882                                                          sti                                                     ;enable maskable interrupts
   883                                                          hlt                                                     ;wait for interrupt
   884                                                          jmp     .30                                             ;repeat until keypress
   885                                  ;
   886                                  ;       Now that a key has been pressed, we signal the system to restart by driving the B0 line on the 8042
   887                                  ;       keyboard controller low (OUT 64h,0feh). The restart may take some microseconds to kick in, so we issue
   888                                  ;       HLT until the system resets.
   889                                  ;
   890                                  .40                     mov     al,EKEYBCMDRESET                                ;8042 pulse output port pin
   891                                                          out     EKEYBPORTSTAT,al                                ;drive B0 low to restart
   892                                  .50                     sti                                                     ;enable maskable interrupts
   893                                                          hlt                                                     ;stop until reset, int, nmi
   894                                                          jmp     .50                                             ;loop until restart kicks in
   895                                  ;-----------------------------------------------------------------------------------------------------------------------
   896                                  ;
   897                                  ;       Routine:        PutTTYString
   898                                  ;
   899                                  ;       Description:    This routine sends a NUL-terminated string of characters to the TTY output device. We use the
   900                                  ;                       TTY output function of the BIOS video interrupt, passing the address of the string in DS:SI
   901                                  ;                       and the BIOS teletype function code in AH. After a return from the BIOS interrupt, we repeat
   902                                  ;                       for the next string character until a NUL is found. Note that we clear the direction flag (DF)
   903                                  ;                       with CLD before the first LODSB. The direction flag is not guaranteed to be preseved between
   904                                  ;                       calls within the OS. However, the "int" instruction does store the EFLAGS register on the
   905                                  ;                       stack and restores it on return. Therefore, clearing the direction flag before subsequent calls
   906                                  ;                       to LODSB is not needed.
   907                                  ;
   908                                  ;       In:             DS:SI   address of string
   909                                  ;
   910                                  ;       Out:            DF      0
   911                                  ;                       ZF      1
   912                                  ;                       AL      0
   913                                  ;
   914                                  ;-----------------------------------------------------------------------------------------------------------------------
   915                                  PutTTYString            cld                                                     ;forward strings
   916                                  .10                     lodsb                                                   ;load next byte at DS:SI in AL
   917                                                          test    al,al                                           ;end of string?
   918                                                          jz      .20                                             ;... yes, exit our loop
   919                                                          mov     ah,EBIOSFNTTYOUTPUT                             ;BIOS teletype function
   920                                                          int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
   921                                                          jmp     .10                                             ;repeat until done
   922                                  .20                     ret                                                     ;return
   923                                  ;-----------------------------------------------------------------------------------------------------------------------
   924                                  ;
   925                                  ;       Loader Data
   926                                  ;
   927                                  ;       Our only "data" is the string displayed when system starts. It ends with ASCII carriage-return (13) and line-
   928                                  ;       feed (10) values. The remainder of the boot sector is filled with NUL. The boot sector finally ends with the
   929                                  ;       required two-byte signature checked by the BIOS. Note that recent versions of NASM will issue a warning if
   930                                  ;       the calculated address for the end-of-sector signature produces a negative value for "1024-($-$$)". This will
   931                                  ;       indicate if we have added too much data and exceeded the length of the sector. Note also that since we are at
   932                                  ;       the end of a "file" (os.com) and not the boot sector, there is no end-of-sector marker (0x55 0xaa) here.
   933                                  ;
   934                                  ;-----------------------------------------------------------------------------------------------------------------------
   935                                  czStartingMsg           db      "Starting OS",13,10,0                           ;starting message
   936                                                          times   1024-($-$$) db 0h                               ;zero fill to end of sector
   937                                  %endif
   938                                  %ifdef BUILDDISK
   939                                  ;-----------------------------------------------------------------------------------------------------------------------
   940                                  ;
   941                                  ;       Free Disk Space                                                         @disk: 004600   @mem:  n/a
   942                                  ;
   943                                  ;       Following the convention introduced by DOS, we use the value 'F6' to indicate unused floppy disk storage.
   944                                  ;
   945                                  ;-----------------------------------------------------------------------------------------------------------------------
   946                                  section                 unused                                                  ;unused disk space
   947                                                          times   EBOOTDISKBYTES-04600h db 0F6h                   ;fill to end of disk image
   948                                  %endif
   949                                  ;=======================================================================================================================
   950                                  ;
   951                                  ;       End of Program Code
   952                                  ;
   953                                  ;=======================================================================================================================
