     1                                  ;=======================================================================================================================
     2                                  ;
     3                                  ;	File:		os.asm
     4                                  ;
     5                                  ;	Project:	os.003
     6                                  ;
     7                                  ;	Description:	This sample program adds code to create osprep.com, a program to update the boot sector on a
     8                                  ;			floppy disk.
     9                                  ;
    10                                  ;	Revised:	July 1, 2017
    11                                  ;
    12                                  ;	Assembly:	nasm os.asm -f bin -o os.dat     -l os.dat.lst     -DBUILDBOOT
    13                                  ;			nasm os.asm -f bin -o os.dsk     -l os.dsk.lst     -DBUILDDISK
    14                                  ;			nasm os.asm -f bin -o os.com     -l os.com.lst     -DBUILDCOM
    15                                  ;			nasm os.asm -f bin -o osprep.com -l osprep.com.lst -DBUILDPREP
    16                                  ;
    17                                  ;	Assembler:	Netwide Assembler (NASM) 2.13.01
    18                                  ;
    19                                  ;			Copyright (C) 2010-2017 by David J. Walling. All Rights Reserved.
    20                                  ;
    21                                  ;=======================================================================================================================
    22                                  ;-----------------------------------------------------------------------------------------------------------------------
    23                                  ;
    24                                  ;	Assembly Directives
    25                                  ;
    26                                  ;	Use one of the following as an assembly directive (-D) with NASM.
    27                                  ;
    28                                  ;	BUILDBOOT	Creates os.dat, a 512-byte boot sector as a standalone file.
    29                                  ;	BUILDDISK	Creates os.dsk, a 1.44MB (3.5") floppy disk image file.
    30                                  ;	BUILDCOM	Creates os.com, the OS loader and kernel as a standalone DOS program.
    31                                  ;	BUILDPREP	Creates osprep.com, a DOS program that prepares a floppy disk to boot the OS
    32                                  ;
    33                                  ;-----------------------------------------------------------------------------------------------------------------------
    34                                  %ifdef BUILDDISK
    35                                  %define BUILDBOOT
    36                                  %define BUILDCOM
    37                                  %endif
    38                                  %ifdef BUILDPREP
    39                                  %define BUILDBOOT
    40                                  %endif
    41                                  ;-----------------------------------------------------------------------------------------------------------------------
    42                                  ;
    43                                  ;	Conventions
    44                                  ;
    45                                  ;	Labels:		Labels within a routine are numeric and begin with a period (.10, .20).
    46                                  ;			Labels within a routine begin at ".10" and increment by 10.
    47                                  ;
    48                                  ;	Comments:	A comment that spans the entire line begins with a semicolon in column 1.
    49                                  ;			A comment that accompanies code on a line begins with a semicolon in column 81.
    50                                  ;			Register names in comments are in upper case.
    51                                  ;			Hexadecimal values in comments are in lower case.
    52                                  ;			Routines are preceded with a comment box that includes the routine name, description, and
    53                                  ;			register contents on entry and exit.
    54                                  ;
    55                                  ;	Alignment:	Assembly instructions (mnemonics) begin in column 25.
    56                                  ;			Assembly operands begin in column 33.
    57                                  ;			Lines should not extend beyond column 120.
    58                                  ;
    59                                  ;	Routines:	Routine names are in mixed case (GetYear, ReadRealTimeClock).
    60                                  ;			Routine names begin with a verb (Get, Read, etc.).
    61                                  ;			Routines should have a single entry address and a single exit instruction (ret, iretd, etc.).
    62                                  ;
    63                                  ;	Constants:	Symbolic constants (equates) are named in all-caps beginning with 'E' (EDATAPORT).
    64                                  ;			Constant stored values are named in camel case, starting with 'c'.
    65                                  ;			The 2nd letter of the constant label indicates the storage type.
    66                                  ;
    67                                  ;			cq......	constant quad-word (dq)
    68                                  ;			cd......	constant double-word (dd)
    69                                  ;			cw......	constant word (dw)
    70                                  ;			cb......	constant byte (db)
    71                                  ;			cz......	constant ASCIIZ (null-terminated) string
    72                                  ;
    73                                  ;	Variables:	Variables are named in camel case, starting with 'w'.
    74                                  ;			The 2nd letter of the variable label indicates the storage type.
    75                                  ;
    76                                  ;			wq......	variable quad-word (resq)
    77                                  ;			wd......	variable double-word (resd)
    78                                  ;			ww......	variable word (resw)
    79                                  ;			wb......	variable byte (resb)
    80                                  ;
    81                                  ;	Literals:	Literal values defined by external standards should be defined as symbolic constants (equates).
    82                                  ;			Hexadecimal literals in code are in upper case with a leading '0' and trailing 'h'. e.g. 01Fh.
    83                                  ;			Binary literal values in source code are encoded with a final 'b', e.g. 1010b.
    84                                  ;			Decimal literal values in source code are strictly numerals, e.g. 2048.
    85                                  ;			Octal literal values are avoided.
    86                                  ;			String literals are enclosed in double quotes, e.g. "Loading OS".
    87                                  ;			Single character literals are enclosed in single quotes, e.g. 'A'.
    88                                  ;
    89                                  ;	Structures:	Structure names are in all-caps (DATETIME).
    90                                  ;			Structure names do not begin with a verb.
    91                                  ;
    92                                  ;	Macros:		Macro names are in camel case (getDateString).
    93                                  ;			Macro names do begin with a verb.
    94                                  ;
    95                                  ;	Registers:	Register names in comments are in upper case.
    96                                  ;			Register names in source code are in lower case.
    97                                  ;
    98                                  ;	Usage:		Registers EBX, ECX, ESI, EDI, EBP, SS, CS, DS and ES are preserved by all OS routines.
    99                                  ;			Registers EAX and ECX are preferred for returning response/result values.
   100                                  ;			Register EBX is preferred for passing a context (structure) address parameter.
   101                                  ;			Registers EAX, EDX, ECX and EBX are preferred for passing integral parameters.
   102                                  ;
   103                                  ;-----------------------------------------------------------------------------------------------------------------------
   104                                  ;=======================================================================================================================
   105                                  ;
   106                                  ;	Equates
   107                                  ;
   108                                  ;	The equate (equ) statement defines a symbolic name for a fixed value so that such a value can be defined and
   109                                  ;	verified once and then used throughout the code. Using symbolic names simplifies searching for where logical
   110                                  ;	values are used. Equate names are in all-caps and begin with the letter 'E'. Equates are grouped into related
   111                                  ;	sets. Hardware-based values are listed first, followed by BIOS, protocol and application values.
   112                                  ;
   113                                  ;=======================================================================================================================
   114                                  ;-----------------------------------------------------------------------------------------------------------------------
   115                                  ;
   116                                  ;	8042 Keyboard Controller						EKEYB...
   117                                  ;
   118                                  ;	The 8042 Keyboard Controller (8042) is a programmable controller that accepts input signals from the keyboard
   119                                  ;	device. It also signals a hardware interrupt to the CPU when the low-order bit of I/O port 64h is set to zero.
   120                                  ;
   121                                  ;-----------------------------------------------------------------------------------------------------------------------
   122                                  EKEYBPORTSTAT		equ	064h						;status port
   123                                  EKEYBCMDRESET		equ	0FEh						;reset bit 0 to restart system
   124                                  ;-----------------------------------------------------------------------------------------------------------------------
   125                                  ;
   126                                  ;	BIOS Interrupts and Functions						EBIOS...
   127                                  ;
   128                                  ;	Basic Input/Output System (BIOS) functions are grouped and accessed by issuing an interrupt call. Each
   129                                  ;	BIOS interrupt supports several funtions. The function code is typically passed in the AH register.
   130                                  ;
   131                                  ;-----------------------------------------------------------------------------------------------------------------------
   132                                  EBIOSINTVIDEO		equ	010h						;video services interrupt
   133                                  EBIOSFNSETVMODE		equ	000h						;video set mode function
   134                                  EBIOSMODETEXT80		equ	003h						;video mode 80x25 text
   135                                  EBIOSFNTTYOUTPUT	equ	00Eh						;video TTY output function
   136                                  EBIOSINTDISKETTE	equ	013h						;diskette services interrupt
   137                                  EBIOSINTKEYBOARD	equ	016h						;keyboard services interrupt
   138                                  EBIOSFNKEYSTATUS	equ	001h						;keyboard status function
   139                                  ;-----------------------------------------------------------------------------------------------------------------------
   140                                  ;
   141                                  ;	ASCII									EASCII...
   142                                  ;
   143                                  ;-----------------------------------------------------------------------------------------------------------------------
   144                                  EASCIIRETURN		equ	00Dh						;carriage return
   145                                  EASCIIESCAPE		equ	01Bh						;escape
   146                                  ;-----------------------------------------------------------------------------------------------------------------------
   147                                  ;
   148                                  ;	Boot Sector and Loader Constants					EBOOT...
   149                                  ;
   150                                  ;	Equates in this section support the boot sector and the 16-bit operating system loader, which will be
   151                                  ;	responsible for placing the CPU into protected mode and calling the initial operating system task.
   152                                  ;
   153                                  ;-----------------------------------------------------------------------------------------------------------------------
   154                                  EBOOTSTACKTOP		equ	0100h						;boot sector stack top relative to DS
   155                                  EBOOTSECTORBYTES	equ	512						;bytes per sector
   156                                  EBOOTDISKSECTORS	equ	2880						;sectors per disk
   157                                  EBOOTDISKBYTES		equ	(EBOOTSECTORBYTES*EBOOTDISKSECTORS)		;bytes per disk
   158                                  EBOOTFATBASE		equ	(EBOOTSTACKTOP+EBOOTSECTORBYTES)		;offset of FAT I/O buffer rel to DS
   159                                  EBOOTMAXTRIES		equ	5						;max read retries
   160                                  %ifdef BUILDBOOT
   161                                  ;=======================================================================================================================
   162                                  ;
   163                                  ;	Boot Sector Code							@disk: 000000	@mem: 007c00
   164                                  ;
   165                                  ;	The first sector of the disk is the boot sector. The BIOS will load the boot sector into memory and pass
   166                                  ;	control to the code at the start of the sector. The boot sector code is responsible for loading the operating
   167                                  ;	system into memory. The boot sector contains a disk parameter table describing the geometry and allocation
   168                                  ;	of the disk. Following the disk parameter table is code to load the operating system kernel into memory.
   169                                  ;
   170                                  ;	The 'cpu' directive limits emitted code to those instructions supported by the most primitive processor
   171                                  ;	we expect to ever execute our code. The 'vstart' parameter indicates addressability of symbols so as to
   172                                  ;	emulating the DOS .COM program model. Although the BIOS is expected to load the boot sector at address 7c00,
   173                                  ;	we do not make that assumption. The CPU starts in 16-bit addressing mode. A three-byte jump instruction is
   174                                  ;	immediately followed by a disk parameter table.
   175                                  ;
   176                                  ;=======================================================================================================================
   177                                  			cpu	8086						;assume minimal CPU
   178                                  section			boot	vstart=0100h					;emulate .COM (CS,DS,ES=PSP) addressing
   179                                  			bits	16						;16-bit code at power-up
   180                                  %ifdef BUILDPREP
   181 00000000 E9FD01                  Boot			jmp	word Prep					;jump to preparation code
   182                                  %else
   183                                  Boot			jmp	word Boot.10					;jump over parameter table
   184                                  %endif
   185                                  ;-----------------------------------------------------------------------------------------------------------------------
   186                                  ;
   187                                  ;	Disk Parameter Table
   188                                  ;
   189                                  ;	The disk parameter table informs the BIOS of the floppy disk architecture. Here, we use parameters for the
   190                                  ;	3.5" 1.44MB floppy disk since this format is widely supported by virtual machine hypervisors.
   191                                  ;
   192                                  ;-----------------------------------------------------------------------------------------------------------------------
   193 00000003 437573746F6D4F53        			db	"CustomOS"					;eight-byte label
   194 0000000B 0002                    cwSectorBytes		dw	EBOOTSECTORBYTES				;bytes per sector
   195 0000000D 01                      cbClusterSectors	db	1						;sectors per cluster
   196 0000000E 0100                    cwReservedSectors	dw	1						;reserved sectors
   197 00000010 02                      cbFatCount		db	2						;file allocation table copies
   198 00000011 E000                    cwDirEntries		dw	224						;max directory entries
   199 00000013 400B                    cwDiskSectors		dw	EBOOTDISKSECTORS				;sectors per disk
   200 00000015 F0                      cbDiskType		db	0F0h						;1.44MB
   201 00000016 0900                    cwFatSectors		dw	9						;sectors per FAT copy
   202                                  cbTrackSectors		equ	$						;sectors per track (as byte)
   203 00000018 1200                    cwTrackSectors		dw	18						;sectors per track (as word)
   204 0000001A 0200                    cwDiskSides		dw	2						;sides per disk
   205 0000001C 0000                    cwSpecialSectors	dw	0						;special sectors
   206                                  ;
   207                                  ;	BIOS typically loads the boot sector at absolute address 7c00 and sets the stack pointer at 512 bytes past the
   208                                  ;	end of the boot sector. But, since BIOS code varies, we don't make any assumptions as to where our boot sector
   209                                  ;	is loaded. For example, the initial CS:IP could be 0:7c00, 700:c00, 7c0:0, etc. So, to avoid assumptions, we
   210                                  ;	first normalize CS:IP to get the absolute segment address in BX. The comments below show the effect of this code
   211                                  ;	given several possible starting values for CS:IP.
   212                                  ;
   213                                  										;CS:IP	 0:7c00 700:c00 7c0:0
   214 0000001E E80000                  Boot.10			call	word .20					;[ESP] =   7c21     c21    21
   215                                  .@20			equ	$-$$						;.@20 = 021h
   216 00000021 58                      .20			pop	ax						;AX =	   7c21     c21    21
   217 00000022 83E821                  			sub	ax,.@20						;BX =	   7c00     c00     0
   218 00000025 B104                    			mov	cl,4						;shift count
   219 00000027 D3E8                    			shr	ax,cl						;AX =	    7c0      c0     0
   220 00000029 8CCB                    			mov	bx,cs						;BX =	      0     700   7c0
   221 0000002B 01C3                    			add	bx,ax						;BX =	    7c0     7c0   7c0
   222                                  ;
   223                                  ;	Now, since we are assembling our boot code to emulate the addressing of a .COM file, we want the DS and ES
   224                                  ;	registers to be set to where a Program Segment Prefix (PSP) would be, exactly 100h (256) bytes prior to
   225                                  ;	the start of our code. This will correspond to our assembled data address offsets. Note that we instructed
   226                                  ;	the assembler to produce addresses for our symbols that are offset from our code by 100h. See the "vstart"
   227                                  ;	parameter for the "section" directive above. We also set SS to the PSP and SP to the address of our i/o
   228                                  ;	buffer. This leaves 256 bytes of usable stack from 7b0:300 to 7b0:400.
   229                                  ;
   230 0000002D 83EB10                  			sub	bx,16						;BX = 07b0
   231 00000030 8EDB                    			mov	ds,bx						;DS = 07b0 = psp
   232 00000032 8EC3                    			mov	es,bx						;ES = 07b0 = psp
   233 00000034 8ED3                    			mov	ss,bx						;SS = 07b0 = psp (ints disabled)
   234 00000036 BC0001                  			mov	sp,EBOOTSTACKTOP				;SP = 0100       (ints enabled)
   235                                  ;
   236                                  ;	Our boot addressability is now set up according to the following diagram.
   237                                  ;
   238                                  ;	DS,ES,SS ----->	007b00	+-----------------------------------------------+ DS:0000
   239                                  ;				|  Boot Stack & Boot PSP (Unused)		|
   240                                  ;				|  256 = 100h bytes				|
   241                                  ;	SS:SP -------->	007c00	+-----------------------------------------------+ DS:0100  07b0:0100
   242                                  ;				|  Boot Sector (vstart=0100h)			|
   243                                  ;				|  1 sector = 512 = 200h bytes			|
   244                                  ;			007e00	+-----------------------------------------------+ DS:0300
   245                                  ;				|  File Allocation Table (FAT) I/O Buffer	|
   246                                  ;				|  9x512-byte sectors = 4,608 = 1200h bytes	|
   247                                  ;			009000	+-----------------------------------------------+ DS:1500  08f0:0100
   248                                  ;				|  Directory Sector Buffer & Kernel Load Area	|
   249                                  ;			009200	+-----------------------------------------------+ DS:1700
   250                                  ;
   251                                  ;	On entry, DL indicates the drive being booted from.
   252                                  ;
   253 00000039 8816[F801]              			mov	[wbDrive],dl					;[drive] = drive being booted from
   254                                  ;
   255                                  ;	Compute directory i/o buffer address.
   256                                  ;
   257 0000003D A1[1600]                			mov	ax,[cwFatSectors]				;AX = 0009 = FAT sectors
   258 00000040 F726[0B00]              			mul	word [cwSectorBytes]				;DX:AX = 0000:1200 = FAT bytes
   259 00000044 050003                  			add	ax,EBOOTFATBASE					;AX = 1500 = end of FAT buffer
   260 00000047 A3[EC01]                			mov	[wwDirBuffer],ax				;[dirbuffer] = 1500
   261                                  ;
   262                                  ;	Compute segment where os.com will be loaded.
   263                                  ;
   264 0000004A D3E8                    			shr	ax,cl						;AX = 0150
   265 0000004C 01D8                    			add	ax,bx						;AX = 0150 + 07b0 = 0900
   266 0000004E 83E810                  			sub	ax,16						;AX = 08f0
   267 00000051 A3[3F01]                			mov	[wwLoadSegment],ax				;[loadsegment] = 08f0
   268                                  ;
   269                                  ;	Set the video mode to 80 column, 25 row, text.
   270                                  ;
   271 00000054 B80300                  			mov	ax,EBIOSFNSETVMODE<<8|EBIOSMODETEXT80		;set mode function, 80x25 text mode
   272 00000057 CD10                    			int	EBIOSINTVIDEO					;call BIOS display interrupt
   273                                  ;
   274                                  ;	Write a message to the console so we know we have our addressability established.
   275                                  ;
   276 00000059 BE[C501]                			mov	si,czLoadMsg					;loading message
   277 0000005C E84B01                  			call	BootPrint					;display loader message
   278                                  ;
   279                                  ;	Initialize the number of directory sectors to search.
   280                                  ;
   281 0000005F A1[1100]                			mov	ax,[cwDirEntries]				;AX = 224 = max dir entries
   282 00000062 A3[EE01]                			mov	[wwEntriesLeft],ax				;[entriesleft] = 224
   283                                  ;
   284                                  ;	Compute number of directory sectors and initialize overhead count.
   285                                  ;
   286 00000065 89C1                    			mov	cx,ax						;CX = 00e0 = 224 entries
   287 00000067 F726[B801]              			mul	word [cwEntryLen]				;DX:AX = 224 * 32 = 7168
   288 0000006B F736[0B00]              			div	word [cwSectorBytes]				;AX = 7168 / 512 = 14 = dir sectors
   289 0000006F A3[F001]                			mov	[wwOverhead],ax					;[overhead] = 000e
   290                                  ;
   291                                  ;	Compute directory entries per sector.
   292                                  ;
   293 00000072 91                      			xchg	ax,cx						;DX:AX = 0:00e0, DX = 0000e
   294 00000073 F7F1                    			div	cx						;AX = 0010 = entries per dir sector
   295 00000075 A3[F201]                			mov	[wwSectorEntries],ax				;[sectorentries] = 0010
   296                                  ;
   297                                  ;	Compute first logical directory sector and update overhead count.
   298                                  ;
   299 00000078 A1[1600]                			mov	ax,[cwFatSectors]				;AX = 0009 = FAT sectors per copy
   300 0000007B F626[1000]              			mul	byte [cbFatCount]				;AX = 0012 = FAT sectors
   301 0000007F 0306[0E00]              			add	ax,[cwReservedSectors]				;AX = 0013 = FAT plus reserved
   302 00000083 0306[1C00]              			add	ax,[cwSpecialSectors]				;AX = 0013 = FAT + reserved + special
   303 00000087 A3[F401]                			mov	[wwLogicalSector],ax				;[logicalsector] = 0013
   304 0000008A 0106[F001]              			add	[wwOverhead],ax					;[overhead] = 0021 = res+spec+FAT+dir
   305                                  ;
   306                                  ;	Read directory sector.
   307                                  ;
   308 0000008E B001                    .30			mov	al,1						;sector count
   309 00000090 A2[F601]                			mov	[wbReadCount],al				;[readcount] = 01
   310 00000093 8B1E[EC01]              			mov	bx,[wwDirBuffer]				;BX = 1500
   311 00000097 E8A700                  			call	ReadSector					;read sector into es:bx
   312                                  ;
   313                                  ;	Setup variables to search this directory sector.
   314                                  ;
   315 0000009A A1[EE01]                			mov	ax,[wwEntriesLeft]				;directory entries to search
   316 0000009D 3B06[F201]              			cmp	ax,[wwSectorEntries]				;need to search more sectors?
   317 000000A1 7603                    			jna	.40						;no, continue
   318 000000A3 A1[F201]                			mov	ax,[wwSectorEntries]				;yes, limit search to sector
   319 000000A6 2906[EE01]              .40			sub	[wwEntriesLeft],ax				;update entries left to searh
   320 000000AA BE[BA01]                			mov	si,cbKernelProgram				;program name
   321 000000AD 8B3E[EC01]              			mov	di,[wwDirBuffer]				;DI = 1500
   322                                  ;
   323                                  ;	Loop through directory sectors searching for kernel program.
   324                                  ;
   325 000000B1 56                      .50			push	si						;save kernel name address
   326 000000B2 57                      			push	di						;save dir i/o buffer address
   327 000000B3 B90B00                  			mov	cx,11						;length of 8+3 name
   328 000000B6 FC                      			cld							;forward strings
   329 000000B7 F3A6                    			repe	cmpsb						;compare entry name
   330 000000B9 5F                      			pop	di						;restore dir i/o buffer address
   331 000000BA 5E                      			pop	si						;restore kernel name address
   332 000000BB 7418                    			je	.60						;exit loop if found
   333 000000BD 033E[B801]              			add	di,[cwEntryLen]					;point to next dir entry
   334 000000C1 48                      			dec	ax						;decrement remaining entries
   335 000000C2 75ED                    			jnz	.50						;next entry
   336                                  ;
   337                                  ;	Repeat search if we are not at the end of the directory.
   338                                  ;
   339 000000C4 FF06[F401]              			inc	word [wwLogicalSector]				;increment logical sector
   340 000000C8 833E[EE01]00            			cmp	word [wwEntriesLeft],0				;done with directory?
   341 000000CD 75BF                    			jne	.30						;no, get next sector
   342 000000CF BE[E001]                			mov	si,czNoKernel					;missing kernel message
   343 000000D2 E9C000                  			jmp	BootExit					;display message and exit
   344                                  ;
   345                                  ;	If we find the kernel program in the directory, read the FAT.
   346                                  ;
   347 000000D5 A1[0E00]                .60			mov	ax,[cwReservedSectors]				;AX = 0001
   348 000000D8 A3[F401]                			mov	[wwLogicalSector],ax				;start past boot sector
   349 000000DB A1[1600]                			mov	ax,[cwFatSectors]				;AX = 0009
   350 000000DE A2[F601]                			mov	[wbReadCount],al				;[readcount] = 09
   351 000000E1 BB0003                  			mov	bx,EBOOTFATBASE					;BX = 0300
   352 000000E4 E85A00                  			call	ReadSector					;read FAT into buffer
   353                                  ;
   354                                  ;	Get the starting cluster of the kernel program and target address.
   355                                  ;
   356 000000E7 8B451A                  			mov	ax,[di+26]					;AX = starting cluster of file
   357 000000EA C41E[3D01]              			les	bx,[wwLoadOffset]				;ES:BX = kernel load add (08F0:0100)
   358                                  ;
   359                                  ;	Read each program cluster into RAM.
   360                                  ;
   361 000000EE 50                      .70			push	ax						;save cluster nbr
   362 000000EF 83E802                  			sub	ax,2						;AX = cluster nbr base 0
   363 000000F2 8A0E[0D00]              			mov	cl,[cbClusterSectors]				;CL = sectors per cluster
   364 000000F6 880E[F601]              			mov	[wbReadCount],cl				;save sectors to read
   365 000000FA 30ED                    			xor	ch,ch						;CX = sectors per cluster
   366 000000FC F7E1                    			mul	cx						;DX:AX = logical cluster sector
   367 000000FE 0306[F001]              			add	ax,[wwOverhead]					;AX = kernel sector nbr
   368 00000102 A3[F401]                			mov	[wwLogicalSector],ax				;save logical sector nbr
   369 00000105 E83900                  			call	ReadSector					;read sectors into ES:BX
   370                                  ;
   371                                  ;	Update buffer pointer for next cluster.
   372                                  ;
   373 00000108 A0[0D00]                			mov	al,[cbClusterSectors]				;AL = sectors per cluster
   374 0000010B 30E4                    			xor	ah,ah						;AX = sectors per cluster
   375 0000010D F726[0B00]              			mul	word [cwSectorBytes]				;DX:AX = cluster bytes
   376 00000111 01C3                    			add	bx,ax						;BX = next cluster target address
   377 00000113 58                      			pop	ax						;AX = restore cluster nbr
   378                                  ;
   379                                  ;	Compute next cluster number.
   380                                  ;
   381 00000114 89C1                    			mov	cx,ax						;CX = cluster nbr
   382 00000116 89C7                    			mov	di,ax						;DI = cluster nbr
   383 00000118 D1E8                    			shr	ax,1						;AX = cluster/2
   384 0000011A 89C2                    			mov	dx,ax						;DX = cluster/2
   385 0000011C 01D0                    			add	ax,dx						;AX = 2*(cluster/2)
   386 0000011E 01D0                    			add	ax,dx						;AX = 3*(cluster/2)
   387 00000120 83E701                  			and	di,1						;get low bit
   388 00000123 01C7                    			add	di,ax						;add one if cluster is odd
   389 00000125 81C70003                			add	di,EBOOTFATBASE					;add FAT buffer address
   390 00000129 8B05                    			mov	ax,[di]						;get cluster bytes
   391                                  ;
   392                                  ;	Adjust cluster nbr by 4 bits if cluster is odd; test for end of chain.
   393                                  ;
   394 0000012B F6C101                  			test	cl,1						;is cluster odd?
   395 0000012E 7404                    			jz	.80						;no, skip ahead
   396 00000130 B104                    			mov	cl,4						;shift count
   397 00000132 D3E8                    			shr	ax,cl						;shift nybble low
   398 00000134 25FF0F                  .80			and	ax,0FFFh					;mask for 24 bits; next cluster nbr
   399 00000137 3DFF0F                  			cmp	ax,0FFFh					;end of chain?
   400 0000013A 75B2                    			jne	.70						;no, continue
   401                                  ;
   402                                  ;	Transfer control to the operating system program.
   403                                  ;
   404 0000013C EA                      			db	0EAh						;jmp seg:offset
   405 0000013D 0001                    wwLoadOffset		dw	0100h						;kernel entry offset
   406 0000013F F008                    wwLoadSegment		dw	08F0h						;kernel entry segment (computed)
   407                                  ;
   408                                  ;	Read [readcount] disk sectors from [logicalsector] into ES:BX.
   409                                  ;
   410 00000141 A1[1800]                ReadSector		mov	ax,[cwTrackSectors]				;AX = sectors per track
   411 00000144 F726[1A00]              			mul	word [cwDiskSides]				;DX:AX = sectors per cylinder
   412 00000148 89C1                    			mov	cx,ax						;CX = sectors per cylinder
   413 0000014A A1[F401]                			mov	ax,[wwLogicalSector]				;DX:AX = logical sector
   414 0000014D F7F1                    			div	cx						;AX = cylinder; DX = cyl sector
   415 0000014F A2[FB01]                			mov	[wbTrack],al					;[track] = cylinder
   416 00000152 89D0                    			mov	ax,dx						;AX = cyl sector
   417 00000154 F636[1800]              			div	byte [cbTrackSectors]				;AH = sector, AL = head
   418 00000158 FEC4                    			inc	ah						;AH = sector (1,2,3,...)
   419 0000015A A3[F901]                			mov	[wbHead],ax					;[head]= head, [sector]= sector
   420                                  ;
   421                                  ;	Try maxtries times to read sector.
   422                                  ;
   423 0000015D B90500                  			mov	cx,EBOOTMAXTRIES				;CX = 0005
   424 00000160 53                      .10			push	bx						;save buffer address
   425 00000161 51                      			push	cx						;save retry count
   426 00000162 8B16[F801]              			mov	dx,[wwDriveHead]				;DH = head, DL = drive
   427 00000166 8B0E[FA01]              			mov	cx,[wwSectorTrack]				;CH = track, CL = sector
   428 0000016A A1[F601]                			mov	ax,[wwReadCountCommand]				;AH = fn., AL = sector count
   429 0000016D CD13                    			int	EBIOSINTDISKETTE				;read sector
   430 0000016F 59                      			pop	cx						;restore retry count
   431 00000170 5B                      			pop	bx						;restore buffer address
   432 00000171 7343                    			jnc	BootReturn					;skip ahead if done
   433 00000173 E2EB                    			loop	.10						;retry
   434                                  ;
   435                                  ;	Handle disk error: convert to ASCII and store in error string.
   436                                  ;
   437 00000175 88E0                    			mov	al,ah						;AL = bios error code
   438 00000177 30E4                    			xor	ah,ah						;AX = bios error code
   439 00000179 B210                    			mov	dl,16						;divisor for base 16
   440 0000017B F6F2                    			div	dl						;AL = hi order, AH = lo order
   441 0000017D 0D3030                  			or	ax,03030h					;apply ASCII zone bits
   442 00000180 80FC3A                  			cmp	ah,03Ah						;range test ASCII numeral
   443 00000183 7203                    			jb	.20						;continue if numeral
   444 00000185 80C407                  			add	ah,7						;adjust for ASCII 'A'-'F'
   445 00000188 3C3A                    .20			cmp	al,03Ah						;range test ASCII numeral
   446 0000018A 7203                    			jb	.30						;continue if numeral
   447 0000018C 80C407                  			add	ah,7						;adjust for ASCII 'A'-'F'
   448 0000018F A3[DD01]                .30			mov	[wzErrorCode],ax				;store ASCII error code
   449 00000192 BE[D201]                			mov	si,czErrorMsg					;error message address
   450 00000195 E81200                  BootExit		call	BootPrint					;display messge to console
   451 00000198 B401                    .10			mov	ah,EBIOSFNKEYSTATUS				;bios keyboard status function
   452 0000019A CD16                    			int	EBIOSINTKEYBOARD				;get keyboard status
   453 0000019C 7504                    			jnz	.20						;continue if key pressed
   454 0000019E FB                      			sti							;enable maskable interrupts
   455 0000019F F4                      			hlt							;wait for interrupt
   456 000001A0 EBF6                    			jmp	.10						;repeat
   457 000001A2 B0FE                    .20			mov	al,EKEYBCMDRESET				;8042 pulse output port pin
   458 000001A4 E664                    			out	EKEYBPORTSTAT,al				;drive B0 low to restart
   459 000001A6 FB                      .30			sti							;enable maskable interrupts
   460 000001A7 F4                      			hlt							;stop until reset, int, nmi
   461 000001A8 EBFC                    			jmp	.30						;loop until restart kicks in
   462                                  ;
   463                                  ;	Display text message.
   464                                  ;
   465 000001AA FC                      BootPrint		cld							;forward strings
   466 000001AB AC                      			lodsb							;load next byte at DS:SI in AL
   467 000001AC 84C0                    			test	al,al						;end of string?
   468 000001AE 7406                    			jz	BootReturn					;... yes, exit our loop
   469 000001B0 B40E                    			mov	ah,EBIOSFNTTYOUTPUT				;BIOS teletype function
   470 000001B2 CD10                    			int	EBIOSINTVIDEO					;call BIOS display interrupt
   471 000001B4 EBF4                    			jmp	BootPrint					;repeat until done
   472 000001B6 C3                      BootReturn		ret							;return
   473                                  ;-----------------------------------------------------------------------------------------------------------------------
   474                                  ;
   475                                  ;	Constants
   476                                  ;
   477                                  ;-----------------------------------------------------------------------------------------------------------------------
   478 000001B7 90                      			align	2
   479 000001B8 2000                    cwEntryLen		dw	32						;length of directory entry
   480 000001BA 4F5320202020202043-     cbKernelProgram		db	"OS      COM"					;kernel program name
   480 000001C3 4F4D               
   481 000001C5 4C6F6164696E67204F-     czLoadMsg		db	"Loading OS",13,10,0				;loading message
   481 000001CE 530D0A00           
   482 000001D2 4469736B206572726F-     czErrorMsg		db	"Disk error "					;error message
   482 000001DB 7220               
   483 000001DD 202000                  wzErrorCode		db	020h,020h,0					;error code and null terminator
   484 000001E0 4F53206D697373696E-     czNoKernel		db	"OS missing",0					;missing kernel message
   484 000001E9 6700               
   485                                  ;-----------------------------------------------------------------------------------------------------------------------
   486                                  ;
   487                                  ;	Work Areas
   488                                  ;
   489                                  ;-----------------------------------------------------------------------------------------------------------------------
   490 000001EB 90                      			align	2
   491 000001EC 0000                    wwDirBuffer		dw	0						;directory i/o buffer address
   492 000001EE 0000                    wwEntriesLeft		dw	0						;directory entries to search
   493 000001F0 0000                    wwOverhead		dw	0						;overhead sectors
   494 000001F2 0000                    wwSectorEntries		dw	0						;directory entries per sector
   495 000001F4 0000                    wwLogicalSector		dw	0						;current logical sector
   496                                  wwReadCountCommand	equ	$						;read count and command
   497 000001F6 00                      wbReadCount		db	0						;sectors to read
   498 000001F7 02                      cbReadCommand		db	2						;BIOS read disk fn code
   499                                  wwDriveHead		equ	$						;drive, head (word)
   500 000001F8 00                      wbDrive			db	0						;drive
   501 000001F9 00                      wbHead			db	0						;head
   502                                  wwSectorTrack		equ	$						;sector, track (word)
   503 000001FA 00                      			db	0						;sector
   504 000001FB 00                      wbTrack			db	0						;track
   505 000001FC 00<rept>                			times	510-($-$$) db 0h				;zero fill to end of sector
   506 000001FE 55AA                    			db	055h,0AAh					;end of sector signature
   507                                  %endif
   508                                  %ifdef BUILDPREP
   509                                  ;=======================================================================================================================
   510                                  ;
   511                                  ;	Diskette Preparation Code
   512                                  ;
   513                                  ;	This routine writes the OS boot sector code to a formatted floppy diskette. The diskette parameter table,
   514                                  ;	which is located in the first 30 bytes of the boot sector is first read from the diskette and overlayed onto
   515                                  ;	the OS bootstrap code so that the diskette format parameters are preserved.
   516                                  ;
   517                                  ;=======================================================================================================================
   518                                  ;
   519                                  ;	Query the user to insert a flopppy diskette and press enter or cancel.
   520                                  ;
   521 00000200 BE[CA02]                Prep			mov	si,czPrepMsg10					;starting message address
   522 00000203 E8A4FF                  			call	BootPrint					;display message
   523                                  ;
   524                                  ;	Exit if the Escape key is pressed or loop until Enter is pressed.
   525                                  ;
   526 00000206 B401                    .10			mov	ah,EBIOSFNKEYSTATUS				;BIOS keyboard status function
   527 00000208 CD16                    			int	EBIOSINTKEYBOARD				;get keyboard status
   528 0000020A 7504                    			jnz	.12						;continue if key pressed
   529 0000020C FB                      			sti							;enable interrupts
   530 0000020D F4                      			hlt							;wait for interrupt
   531 0000020E EBF6                    			jmp	.10						;repeat
   532 00000210 3C0D                    .12			cmp	al,EASCIIRETURN					;Enter key pressed?
   533 00000212 7407                    			je	.15						;yes, branch
   534 00000214 3C1B                    			cmp	al,EASCIIESCAPE					;Escape key pressed?
   535 00000216 75EE                    			jne	.10						;no, repeat
   536 00000218 E9A900                  			jmp	.90						;yes, exit program
   537                                  ;
   538                                  ;	Display writing-sector message and patch the JMP instruction.
   539                                  ;
   540 0000021B BE[6E04]                .15			mov	si,czPrepMsg12					;writing-sector message address
   541 0000021E E889FF                  			call	BootPrint					;display message
   542 00000221 BB[0100]                			mov	bx,Boot+1					;address of JMP instruction operand
   543 00000224 B81B00                  			mov	ax,01Bh						;address past disk parameter table
   544 00000227 8907                    			mov	[bx],ax						;update the JMP instruction
   545                                  ;
   546                                  ;	Try to read the boot sector.
   547                                  ;
   548 00000229 B90500                  			mov	cx,EBOOTMAXTRIES				;try up to five times
   549 0000022C 51                      .20			push	cx						;save remaining tries
   550 0000022D BB[760A]                			mov	bx,wcPrepInBuf					;input buffer address
   551 00000230 BA0000                  			mov	dx,0						;head zero, drive zero
   552 00000233 B90100                  			mov	cx,1						;track zero, sector one
   553 00000236 B80102                  			mov	ax,0201h					;read one sector
   554 00000239 CD13                    			int	EBIOSINTDISKETTE				;attempt the read
   555 0000023B 59                      			pop	cx						;restore remaining retries
   556 0000023C 7307                    			jnc	.30						;skip ahead if successful
   557 0000023E E2EC                    			loop	.20						;try again
   558 00000240 BE[9E04]                			mov	si,czPrepMsg20					;read-error message address
   559 00000243 EB2C                    			jmp	.50						;branch to error routine
   560                                  ;
   561                                  ;	Copy diskette parms from input buffer to output buffer.
   562                                  ;
   563 00000245 BE[760A]                .30			mov	si,wcPrepInBuf					;input buffer address
   564 00000248 83C60B                  			add	si,11						;skip over JMP and system ID
   565 0000024B BF[0000]                			mov	di,Boot						;output buffer address
   566 0000024E 83C70B                  			add	di,11						;skip over JMP and system ID
   567 00000251 B91300                  			mov	cx,19						;length of diskette parameters
   568 00000254 FC                      			cld							;forward string copies
   569 00000255 F3A4                    			rep	movsb						;copy diskette parameters
   570                                  ;
   571                                  ;	Try to write boot sector to diskette.
   572                                  ;
   573 00000257 B90500                  			mov	cx,EBOOTMAXTRIES				;try up to five times
   574 0000025A 51                      .40			push	cx						;save remaining tries
   575 0000025B BB[0000]                			mov	bx,Boot						;output buffer address
   576 0000025E BA0000                  			mov	dx,0						;head zero, drive zero
   577 00000261 B90100                  			mov	cx,1						;track zero, sector one
   578 00000264 B80103                  			mov	ax,0301h					;write one sector
   579 00000267 CD13                    			int	EBIOSINTDISKETTE				;attempt the write
   580 00000269 59                      			pop	cx						;restore remaining retries
   581 0000026A 7326                    			jnc	.80						;skip ahead if successful
   582 0000026C E2EC                    			loop	.40						;try again
   583 0000026E BE[EC04]                			mov	si,czPrepMsg30					;write-error message address
   584                                  ;
   585                                  ;	Convert the error code to ASCII and display the error message.
   586                                  ;
   587 00000271 50                      .50			push	ax						;save error code
   588 00000272 88E0                    			mov	al,ah						;copy error code
   589 00000274 B400                    			mov	ah,0						;AX = error code
   590 00000276 B210                    			mov	dl,10h						;hexadecimal divisor
   591 00000278 F6FA                    			idiv	dl						;AL = hi-order, AH = lo-order
   592 0000027A 0D3030                  			or	ax,03030h					;add ASCII zone digits
   593 0000027D 80FC3A                  			cmp	ah,03Ah						;AH ASCII numeral?
   594 00000280 7203                    			jb	.60						;yes, continue
   595 00000282 80C407                  			add	ah,7						;no, make ASCII 'A'-'F'
   596 00000285 3C3A                    .60			cmp	al,03Ah						;al ASCII numeral?
   597 00000287 7202                    			jb	.70						;yes, continue
   598 00000289 0407                    			add	al,7						;no, make ASCII
   599 0000028B 894411                  .70			mov	[si+17],ax					;put ASCII error code in message
   600 0000028E E819FF                  			call	BootPrint					;write error message
   601 00000291 58                      			pop	ax						;restore error code
   602                                  ;
   603                                  ;	Display the completion message.
   604                                  ;
   605 00000292 BE[3805]                .80			mov	si,czPrepMsgOK					;assume successful completion
   606 00000295 88E0                    			mov	al,ah						;BIOS return code
   607 00000297 3C00                    			cmp	al,0						;success?
   608 00000299 7426                    			je	.85						;yes, continue
   609 0000029B BE[D705]                			mov	si,czPrepMsgErr1				;disk parameter error message
   610 0000029E 3C01                    			cmp	al,1						;disk parameter error?
   611 000002A0 741F                    			je	.85						;yes, continue
   612 000002A2 BE[A106]                			mov	si,czPrepMsgErr2				;address mark not found message
   613 000002A5 3C02                    			cmp	al,2						;address mark not found?
   614 000002A7 7418                    			je	.85						;yes, continue
   615 000002A9 BE[2A07]                			mov	si,czPrepMsgErr3				;protected disk message
   616 000002AC 3C03                    			cmp	al,3						;protected disk?
   617 000002AE 7411                    			je	.85						;yes, continue
   618 000002B0 BE[E407]                			mov	si,czPrepMsgErr6				;diskette removed message
   619 000002B3 3C06                    			cmp	al,6						;diskette removed?
   620 000002B5 740A                    			je	.85						;yes, continue
   621 000002B7 BE[1409]                			mov	si,czPrepMsgErr80				;drive timed out message
   622 000002BA 3C80                    			cmp	al,80H						;drive timed out?
   623 000002BC 7403                    			je	.85						;yes, continue
   624 000002BE BE[C509]                			mov	si,czPrepMsgErrXX				;unknown error message
   625 000002C1 E8E6FE                  .85			call	BootPrint					;display result message
   626 000002C4 B8004C                  .90			mov	ax,04C00H					;terminate with zero result code
   627 000002C7 CD21                    			int	021h						;terminate DOS program
   628 000002C9 C3                      			ret							;return (should not execute)
   629                                  ;-----------------------------------------------------------------------------------------------------------------------
   630                                  ;
   631                                  ;	Diskette Preparation Messages
   632                                  ;
   633                                  ;-----------------------------------------------------------------------------------------------------------------------
   634 000002CA 0D0A437573746F6D4F-     czPrepMsg10		db	13,10,"CustomOS Boot-Diskette Preparation Program"
   634 000002D3 5320426F6F742D4469-
   634 000002DC 736B65747465205072-
   634 000002E5 657061726174696F6E-
   634 000002EE 2050726F6772616D   
   635 000002F6 0D0A436F7079726967-     			db	13,10,"Copyright (C) 2010-2017 David J. Walling. All rights reserved."
   635 000002FF 687420284329203230-
   635 00000308 31302D323031372044-
   635 00000311 61766964204A2E2057-
   635 0000031A 616C6C696E672E2041-
   635 00000323 6C6C20726967687473-
   635 0000032C 207265736572766564-
   635 00000335 2E                 
   636 00000336 0D0A                    			db	13,10
   637 00000338 0D0A54686973207072-     			db	13,10,"This program overwrites the boot sector of a diskette with startup code that"
   637 00000341 6F6772616D206F7665-
   637 0000034A 727772697465732074-
   637 00000353 686520626F6F742073-
   637 0000035C 6563746F72206F6620-
   637 00000365 61206469736B657474-
   637 0000036E 652077697468207374-
   637 00000377 617274757020636F64-
   637 00000380 652074686174       
   638 00000386 0D0A77696C6C206C6F-     			db	13,10,"will load the operating system into memory when the computer is restarted."
   638 0000038F 616420746865206F70-
   638 00000398 65726174696E672073-
   638 000003A1 797374656D20696E74-
   638 000003AA 6F206D656D6F727920-
   638 000003B3 7768656E2074686520-
   638 000003BC 636F6D707574657220-
   638 000003C5 697320726573746172-
   638 000003CE 7465642E           
   639 000003D2 0D0A546F2070726F63-     			db	13,10,"To proceed, place a formatted diskette into drive A: and press the Enter key."
   639 000003DB 6565642C20706C6163-
   639 000003E4 65206120666F726D61-
   639 000003ED 74746564206469736B-
   639 000003F6 6574746520696E746F-
   639 000003FF 20647269766520413A-
   639 00000408 20616E642070726573-
   639 00000411 732074686520456E74-
   639 0000041A 6572206B65792E     
   640 00000421 0D0A546F2065786974-     			db	13,10,"To exit this program without preparing a diskette, press the Escape key."
   640 0000042A 20746869732070726F-
   640 00000433 6772616D2077697468-
   640 0000043C 6F7574207072657061-
   640 00000445 72696E672061206469-
   640 0000044E 736B657474652C2070-
   640 00000457 726573732074686520-
   640 00000460 457363617065206B65-
   640 00000469 792E               
   641 0000046B 0D0A00                  			db	13,10,0
   642 0000046E 0D0A57726974696E67-     czPrepMsg12		db	13,10,"Writing the boot sector to the diskette ..."
   642 00000477 2074686520626F6F74-
   642 00000480 20736563746F722074-
   642 00000489 6F2074686520646973-
   642 00000492 6B65747465202E2E2E 
   643 0000049B 0D0A00                  			db	13,10,0
   644 0000049E 0D0A54686520657272-     czPrepMsg20		db	13,10,"The error-code .. was returned from the BIOS while reading from the disk."
   644 000004A7 6F722D636F6465202E-
   644 000004B0 2E2077617320726574-
   644 000004B9 75726E65642066726F-
   644 000004C2 6D207468652042494F-
   644 000004CB 53207768696C652072-
   644 000004D4 656164696E67206672-
   644 000004DD 6F6D20746865206469-
   644 000004E6 736B2E             
   645 000004E9 0D0A00                  			db	13,10,0
   646 000004EC 0D0A54686520657272-     czPrepMsg30		db	13,10,"The error-code .. was returned from the BIOS while writing to the disk."
   646 000004F5 6F722D636F6465202E-
   646 000004FE 2E2077617320726574-
   646 00000507 75726E65642066726F-
   646 00000510 6D207468652042494F-
   646 00000519 53207768696C652077-
   646 00000522 726974696E6720746F-
   646 0000052B 20746865206469736B-
   646 00000534 2E                 
   647 00000535 0D0A00                  			db	13,10,0
   648 00000538 0D0A54686520626F6F-     czPrepMsgOK		db	13,10,"The boot-sector was written to the diskette. Before booting your computer with"
   648 00000541 742D736563746F7220-
   648 0000054A 776173207772697474-
   648 00000553 656E20746F20746865-
   648 0000055C 206469736B65747465-
   648 00000565 2E204265666F726520-
   648 0000056E 626F6F74696E672079-
   648 00000577 6F757220636F6D7075-
   648 00000580 7465722077697468   
   649 00000588 0D0A74686973206469-     			db	13,10,"this diskette, make sure that the file OS.COM is copied onto the diskette."
   649 00000591 736B657474652C206D-
   649 0000059A 616B65207375726520-
   649 000005A3 746861742074686520-
   649 000005AC 66696C65204F532E43-
   649 000005B5 4F4D20697320636F70-
   649 000005BE 696564206F6E746F20-
   649 000005C7 746865206469736B65-
   649 000005D0 7474652E           
   650 000005D4 0D0A00                  			db	13,10,0
   651 000005D7 0D0A2830312920496E-     czPrepMsgErr1		db	13,10,"(01) Invalid Disk Parameter"
   651 000005E0 76616C696420446973-
   651 000005E9 6B20506172616D6574-
   651 000005F2 6572               
   652 000005F4 0D0A54686973206973-     			db	13,10,"This is an internal error caused by an invalid value being passed to a system"
   652 000005FD 20616E20696E746572-
   652 00000606 6E616C206572726F72-
   652 0000060F 206361757365642062-
   652 00000618 7920616E20696E7661-
   652 00000621 6C69642076616C7565-
   652 0000062A 206265696E67207061-
   652 00000633 7373656420746F2061-
   652 0000063C 2073797374656D     
   653 00000643 0D0A66756E6374696F-     			db	13,10,"function. The OSBOOT.COM file may be corrupt. Copy or download the file again"
   653 0000064C 6E2E20546865204F53-
   653 00000655 424F4F542E434F4D20-
   653 0000065E 66696C65206D617920-
   653 00000667 626520636F72727570-
   653 00000670 742E20436F7079206F-
   653 00000679 7220646F776E6C6F61-
   653 00000682 64207468652066696C-
   653 0000068B 6520616761696E     
   654 00000692 0D0A616E6420726574-     			db	13,10,"and retry."
   654 0000069B 72792E             
   655 0000069E 0D0A00                  			db	13,10,0
   656 000006A1 0D0A28303229204164-     czPrepMsgErr2		db	13,10,"(02) Address Mark Not Found"
   656 000006AA 6472657373204D6172-
   656 000006B3 6B204E6F7420466F75-
   656 000006BC 6E64               
   657 000006BE 0D0A54686973206572-     			db	13,10,"This error indicates a physical problem with the floppy diskette. Please retry"
   657 000006C7 726F7220696E646963-
   657 000006D0 617465732061207068-
   657 000006D9 79736963616C207072-
   657 000006E2 6F626C656D20776974-
   657 000006EB 682074686520666C6F-
   657 000006F4 707079206469736B65-
   657 000006FD 7474652E20506C6561-
   657 00000706 7365207265747279   
   658 0000070E 0D0A7573696E672061-     			db	13,10,"using another diskette."
   658 00000717 6E6F74686572206469-
   658 00000720 736B657474652E     
   659 00000727 0D0A00                  			db	13,10,0
   660 0000072A 0D0A28303329205072-     czPrepMsgErr3		db	13,10,"(03) Protected Disk"
   660 00000733 6F7465637465642044-
   660 0000073C 69736B             
   661 0000073F 0D0A54686973206572-     			db	13,10,"This error is usually caused by attempting to write to a write-protected disk."
   661 00000748 726F72206973207573-
   661 00000751 75616C6C7920636175-
   661 0000075A 736564206279206174-
   661 00000763 74656D7074696E6720-
   661 0000076C 746F20777269746520-
   661 00000775 746F20612077726974-
   661 0000077E 652D70726F74656374-
   661 00000787 6564206469736B2E   
   662 0000078F 0D0A436865636B2074-     			db	13,10,"Check the 'write-protect' setting on the disk or retry using using another disk."
   662 00000798 686520277772697465-
   662 000007A1 2D70726F7465637427-
   662 000007AA 2073657474696E6720-
   662 000007B3 6F6E20746865206469-
   662 000007BC 736B206F7220726574-
   662 000007C5 7279207573696E6720-
   662 000007CE 7573696E6720616E6F-
   662 000007D7 74686572206469736B-
   662 000007E0 2E                 
   663 000007E1 0D0A00                  			db	13,10,0
   664 000007E4 0D0A28303629204469-     czPrepMsgErr6		db	13,10,"(06) Diskette Removed"
   664 000007ED 736B65747465205265-
   664 000007F6 6D6F766564         
   665 000007FB 0D0A54686973206572-     			db	13,10,"This error may indicate that the floppy diskette has been removed from the"
   665 00000804 726F72206D61792069-
   665 0000080D 6E6469636174652074-
   665 00000816 686174207468652066-
   665 0000081F 6C6F70707920646973-
   665 00000828 6B6574746520686173-
   665 00000831 206265656E2072656D-
   665 0000083A 6F7665642066726F6D-
   665 00000843 20746865           
   666 00000847 0D0A6469736B657474-     			db	13,10,"diskette drive. On some systems, this code may also occur if the diskette is"
   666 00000850 652064726976652E20-
   666 00000859 4F6E20736F6D652073-
   666 00000862 797374656D732C2074-
   666 0000086B 68697320636F646520-
   666 00000874 6D617920616C736F20-
   666 0000087D 6F6363757220696620-
   666 00000886 746865206469736B65-
   666 0000088F 747465206973       
   667 00000895 0D0A27777269746520-     			db	13,10,"'write protected.' Please verify that the diskette is not write-protected and"
   667 0000089E 70726F746563746564-
   667 000008A7 2E2720506C65617365-
   667 000008B0 207665726966792074-
   667 000008B9 686174207468652064-
   667 000008C2 69736B657474652069-
   667 000008CB 73206E6F7420777269-
   667 000008D4 74652D70726F746563-
   667 000008DD 74656420616E64     
   668 000008E4 0D0A69732070726F70-     			db	13,10,"is properly inserted in the diskette drive."
   668 000008ED 65726C7920696E7365-
   668 000008F6 7274656420696E2074-
   668 000008FF 6865206469736B6574-
   668 00000908 74652064726976652E 
   669 00000911 0D0A00                  			db	13,10,0
   670 00000914 0D0A28383029204472-     czPrepMsgErr80		db	13,10,"(80) Drive Timed Out"
   670 0000091D 6976652054696D6564-
   670 00000926 204F7574           
   671 0000092A 0D0A54686973206572-     			db	13,10,"This error usually indicates that no diskette is in the diskette drive. Please"
   671 00000933 726F7220757375616C-
   671 0000093C 6C7920696E64696361-
   671 00000945 746573207468617420-
   671 0000094E 6E6F206469736B6574-
   671 00000957 746520697320696E20-
   671 00000960 746865206469736B65-
   671 00000969 747465206472697665-
   671 00000972 2E20506C65617365   
   672 0000097A 0D0A6D616B65207375-     			db	13,10,"make sure that the diskette is properly seated in the drive and retry."
   672 00000983 726520746861742074-
   672 0000098C 6865206469736B6574-
   672 00000995 74652069732070726F-
   672 0000099E 7065726C7920736561-
   672 000009A7 74656420696E207468-
   672 000009B0 652064726976652061-
   672 000009B9 6E642072657472792E 
   673 000009C2 0D0A00                  			db	13,10,0
   674 000009C5 0D0A283F3F2920556E-     czPrepMsgErrXX		db	13,10,"(??) Unknown Error"
   674 000009CE 6B6E6F776E20457272-
   674 000009D7 6F72               
   675 000009D9 0D0A54686520657272-     			db	13,10,"The error-code returned by the BIOS is not a recognized error. Please consult"
   675 000009E2 6F722D636F64652072-
   675 000009EB 657475726E65642062-
   675 000009F4 79207468652042494F-
   675 000009FD 53206973206E6F7420-
   675 00000A06 61207265636F676E69-
   675 00000A0F 7A6564206572726F72-
   675 00000A18 2E20506C6561736520-
   675 00000A21 636F6E73756C74     
   676 00000A28 0D0A796F757220636F-     			db	13,10,"your computer's technical reference for a description of this error code."
   676 00000A31 6D7075746572277320-
   676 00000A3A 746563686E6963616C-
   676 00000A43 207265666572656E63-
   676 00000A4C 6520666F7220612064-
   676 00000A55 65736372697074696F-
   676 00000A5E 6E206F662074686973-
   676 00000A67 206572726F7220636F-
   676 00000A70 64652E             
   677 00000A73 0D0A00                  			db	13,10,0
   678                                  wcPrepInBuf		equ	$
   679                                  %endif
   680                                  %ifdef BUILDDISK
   681                                  ;=======================================================================================================================
   682                                  ;
   683                                  ;	File Allocation Tables
   684                                  ;
   685                                  ;	The disk contains two copies of the File Allocation Table (FAT). On our disk, each FAT copy is 1200h bytes in
   686                                  ;	length. Each FAT entry contains the logical number of the next cluster. The first two entries are reserved. Our
   687                                  ;	OS.COM file here is 200h bytes in length. These 200h bytes contain familiar code that displays a message to the
   688                                  ;	screen. Our disk parameter table defines a cluster as containing one sector and each sector having 200h bytes.
   689                                  ;	Therefore, our FAT table must reserve only one cluster for OS.COM. The cluster used by OS.COM, then, will be
   690                                  ;	cluster 2. The entry value for this cluster is set to "0fffh" to indicate that it is the last cluster in the
   691                                  ;	chain.
   692                                  ;
   693                                  ;	Every three bytes encode two FAT entries as follows:
   694                                  ;
   695                                  ;	db	0abh,0cdh,0efh	;even cluster: 0dabh, odd cluster: 0efch
   696                                  ;
   697                                  ;=======================================================================================================================
   698                                  ;-----------------------------------------------------------------------------------------------------------------------
   699                                  ;
   700                                  ;	FAT copy 1								@disk: 000200	@mem: n/a
   701                                  ;
   702                                  ;-----------------------------------------------------------------------------------------------------------------------
   703                                  section			fat1							;first copy of FAT
   704                                  			db	0F0h,0FFh,0FFh,	0FFh,00Fh,000h
   705                                  			times	(9*512)-($-$$) db 0				;zero fill to end of section
   706                                  ;-----------------------------------------------------------------------------------------------------------------------
   707                                  ;
   708                                  ;	FAT copy 2								@disk: 001400	@mem: n/a
   709                                  ;
   710                                  ;-----------------------------------------------------------------------------------------------------------------------
   711                                  section			fat2							;second copy of FAT
   712                                  			db	0F0h,0FFh,0FFh,	0FFh,00Fh,000h
   713                                  			times	(9*512)-($-$$) db 0				;zero fill to end of section
   714                                  ;-----------------------------------------------------------------------------------------------------------------------
   715                                  ;
   716                                  ;	Diskette Directory							@disk: 002600	@mem: n/a
   717                                  ;
   718                                  ;	The disk contains one copy of the diskette directory. Each directory entry is 32 bytes long. Our directory
   719                                  ;	contains only one entry. Unused entries are set to all nulls. The directory immediately follows the second FAT
   720                                  ;	copy.
   721                                  ;
   722                                  ;-----------------------------------------------------------------------------------------------------------------------
   723                                  section			dir							;diskette directory
   724                                  			db	"OS      COM"					;file name (must contain spaces)
   725                                  			db	020h						;attribute (archive bit set)
   726                                  			times	10 db 0						;unused
   727                                  			dw	0h						;time
   728                                  			db	01000001b					;mmm = 10 MOD 8 = 2; ddddd = 1
   729                                  			db	01001001b					;yyyyyyy = 2016-1980 = 36 = 24h; m/8 = 1
   730                                  			dw	2						;first cluster
   731                                  			dd	200h						;file size
   732                                  			times	(224*32)-($-$$) db 0h				;zero fill to end of section
   733                                  %endif
   734                                  %ifdef BUILDCOM
   735                                  ;=======================================================================================================================
   736                                  ;
   737                                  ;	OS.COM
   738                                  ;
   739                                  ;	The operating system file is assembled at the start of the data area of the floppy disk image, which
   740                                  ;	immediately follows the directory. This corresponds to logical cluster 2, even though the physical address of
   741                                  ;	this sector on the disk varies depending on the disk type. The os.com file consists of two parts, the OS loader
   742                                  ;	and the OS kernel. The Loader is 16-bit code that receives control directly from the boot sector code after the
   743                                  ;	OS.COM file is loaded into memory. The kernel is 32-bit code that receives control after the Loader has
   744                                  ;	initialized protected-mode tables and 32-bit interrupt handlers and switched the CPU into protected mode.
   745                                  ;
   746                                  ;	Our loader addressability is set up according to the following diagram.
   747                                  ;
   748                                  ;	SS -----------> 007b00	+-----------------------------------------------+ SS:0000
   749                                  ;				|  Boot Stack & Boot PSP (Unused)		|
   750                                  ;				|  256 = 100h bytes				|
   751                                  ;	SS:SP -------->	007c00	+-----------------------------------------------+ SS:0100  07b0:0100
   752                                  ;				|  Boot Sector (vstart=0100h)			|
   753                                  ;				|  1 sector = 512 = 200h bytes			|
   754                                  ;			007e00	+-----------------------------------------------+
   755                                  ;				|  File Allocation Table (FAT) I/O Buffer	|
   756                                  ;				|  9 x 512-byte sectors = 4,608 = 1200h bytes	|
   757                                  ;				|						|
   758                                  ;	CS,DS,ES ----->	008f00	|  Loader PSP (Unused)				| DS:0000
   759                                  ;				|						|
   760                                  ;	CS:IP -------->	009000	+-----------------------------------------------+ DS:0100  08f0:0100
   761                                  ;				|  Loader Code					|
   762                                  ;				|  1 sector = 512 = 200h bytes			|
   763                                  ;			009200	+-----------------------------------------------+ DS:0300
   764                                  ;
   765                                  ;=======================================================================================================================
   766                                  ;-----------------------------------------------------------------------------------------------------------------------
   767                                  ;
   768                                  ;	OS Loader								@disk: 004200	@mem: 009000
   769                                  ;
   770                                  ;	This code is the operating system loader. It resides on the boot disk at the start of the data area, following
   771                                  ;	the directory. The loader occupies several clusters that are mapped in the file allocation tables above.
   772                                  ;	The loader executes 16-bit instructions in real mode. It performs several initialization functions such as
   773                                  ;	determining whether the CPU and other resources are sufficient to run the operating system. If all minimum
   774                                  ;	resources are present, the loader initializes protected mode tables, places the CPU into protected mode and
   775                                  ;	starts the console task. Since the loader was called either from the bootstrap or as a .com file on the boot
   776                                  ;	disk, we can assume that the initial ip is 0x100 and not perform any absolute address fix-ups on our segment
   777                                  ;	registers.
   778                                  ;
   779                                  ;-----------------------------------------------------------------------------------------------------------------------
   780                                  			cpu	8086						;assume minimal CPU
   781                                  section			loader	vstart=0100h					;use .COM compatible addressing
   782                                  			bits	16						;this is 16-bit code
   783                                  Loader			push	cs						;use the code segment
   784                                  			pop	ds						;...as our data segment
   785                                  			push	cs						;use the code segment
   786                                  			pop	es						;...as our extra segment
   787                                  ;
   788                                  ;	Write a message to the console so we know we have our addressability established.
   789                                  ;
   790                                  			mov	si,czStartingMsg				;starting message
   791                                  			call	PutTTYString					;display loader message
   792                                  ;
   793                                  ;	Now we want to wait for a keypress. We can use a keyboard interrupt function for this (INT 16h, AH=0).
   794                                  ;	However, some hypervisor BIOS implementations have been seen to implement the "wait" as simply a fast
   795                                  ;	iteration of the keyboard status function call (INT 16h, AH=1), causing a CPU race condition. So, instead
   796                                  ;	we will use the keyboard status call and iterate over a halt (HLT) instruction until a key is pressed.
   797                                  ;	By convention, we enable maskable interrupts with STI before issuing HLT, so as not to catch fire.
   798                                  ;
   799                                  .30			mov	ah,EBIOSFNKEYSTATUS				;keyboard status function
   800                                  			int	EBIOSINTKEYBOARD				;call BIOS keyboard interrupt
   801                                  			jnz	.40						;exit if key pressed
   802                                  			sti							;enable maskable interrupts
   803                                  			hlt							;wait for interrupt
   804                                  			jmp	.30						;repeat until keypress
   805                                  ;
   806                                  ;	Now that a key has been pressed, we signal the system to restart by driving the B0 line on the 8042
   807                                  ;	keyboard controller low (OUT 64h,0feh). The restart may take some microseconds to kick in, so we issue
   808                                  ;	HLT until the system resets.
   809                                  ;
   810                                  .40			mov	al,EKEYBCMDRESET				;8042 pulse output port pin
   811                                  			out	EKEYBPORTSTAT,al				;drive B0 low to restart
   812                                  .50			sti							;enable maskable interrupts
   813                                  			hlt							;stop until reset, int, nmi
   814                                  			jmp	.50						;loop until restart kicks in
   815                                  ;-----------------------------------------------------------------------------------------------------------------------
   816                                  ;
   817                                  ;	Routine:	PutTTYString
   818                                  ;
   819                                  ;	Description:	This routine sends a NUL-terminated string of characters to the TTY output device. We use the
   820                                  ;			TTY output function of the BIOS video interrupt, passing the address of the string in DS:SI
   821                                  ;			and the BIOS teletype function code in AH. After a return from the BIOS interrupt, we repeat
   822                                  ;			for the next string character until a NUL is found. Note that we clear the direction flag (DF)
   823                                  ;			with CLD before each LODSB. This is just in case the direction flag is ever returned as set
   824                                  ;			by the video interrupt. This is a precaution since a well-written BIOS should preserve all
   825                                  ;			registers and flags unless used to indicate return status.
   826                                  ;
   827                                  ;	In:		DS:SI	address of string
   828                                  ;
   829                                  ;-----------------------------------------------------------------------------------------------------------------------
   830                                  PutTTYString		cld							;forward strings
   831                                  			lodsb							;load next byte at DS:SI in AL
   832                                  			test	al,al						;end of string?
   833                                  			jz	.10						;... yes, exit our loop
   834                                  			mov	ah,EBIOSFNTTYOUTPUT				;BIOS teletype function
   835                                  			int	EBIOSINTVIDEO					;call BIOS display interrupt
   836                                  			jmp	PutTTYString					;repeat until done
   837                                  .10			ret							;return
   838                                  ;-----------------------------------------------------------------------------------------------------------------------
   839                                  ;
   840                                  ;	Loader Data
   841                                  ;
   842                                  ;	Our only "data" is the string displayed when system starts. It ends with ASCII carriage-return (13) and line-
   843                                  ;	feed (10) values. The remainder of the boot sector is filled with NUL. The boot sector finally ends with the
   844                                  ;	required two-byte signature checked by the BIOS. Note that recent versions of NASM will issue a warning if
   845                                  ;	the calculated address for the end-of-sector signature produces a negative value for "510-($-$$)". This will
   846                                  ;	indicate if we have added too much data and exceeded the length of the sector.
   847                                  ;
   848                                  ;-----------------------------------------------------------------------------------------------------------------------
   849                                  czStartingMsg		db	"Starting OS",13,10,0				;starting message
   850                                  			times	510-($-$$) db 0h				;zero fill to end of sector
   851                                  			db	055h,0AAh					;end of sector signature
   852                                  %endif
   853                                  %ifdef BUILDDISK
   854                                  ;-----------------------------------------------------------------------------------------------------------------------
   855                                  ;
   856                                  ;	Free Disk Space								@disk: 004400	@mem:  n/a
   857                                  ;
   858                                  ;	Following the convention introduced by DOS, we use the value 'F6' to indicate unused floppy disk storage.
   859                                  ;
   860                                  ;-----------------------------------------------------------------------------------------------------------------------
   861                                  section			unused							;unused disk space
   862                                  			times 	EBOOTDISKBYTES-04400h db 0F6h			;fill to end of disk image
   863                                  %endif
   864                                  ;=======================================================================================================================
   865                                  ;
   866                                  ;	End of Program Code
   867                                  ;
   868                                  ;=======================================================================================================================
