     1                                  ;=======================================================================================================================
     2                                  ;
     3                                  ;       File:           os.asm
     4                                  ;
     5                                  ;       Project:        os.003
     6                                  ;
     7                                  ;       Description:    This sample program adds code to create osprep.com, a program to update the boot sector on a
     8                                  ;                       floppy disk. This utility can be useful in creating floppy boot diskettes from native DOS or
     9                                  ;                       within a DOS VM.
    10                                  ;
    11                                  ;       Revised:        January 1, 2019
    12                                  ;
    13                                  ;       Assembly:       nasm os.asm -f bin -o os.dat     -l os.dat.lst     -DBUILDBOOT
    14                                  ;                       nasm os.asm -f bin -o os.dsk     -l os.dsk.lst     -DBUILDDISK
    15                                  ;                       nasm os.asm -f bin -o os.com     -l os.com.lst     -DBUILDCOM
    16                                  ;                       nasm os.asm -f bin -o osprep.com -l osprep.com.lst -DBUILDPREP
    17                                  ;
    18                                  ;       Assembler:      Netwide Assembler (NASM) 2.13.03, Feb 7 2018
    19                                  ;
    20                                  ;       Notice:         Copyright (C) 2010-2019 David J. Walling. All Rights Reserved.
    21                                  ;
    22                                  ;=======================================================================================================================
    23                                  ;-----------------------------------------------------------------------------------------------------------------------
    24                                  ;
    25                                  ;       Assembly Directives
    26                                  ;
    27                                  ;       Use one of the following as an assembly directive (-D) with NASM.
    28                                  ;
    29                                  ;       BUILDBOOT       Creates os.dat, a 512-byte boot sector as a standalone file.
    30                                  ;       BUILDDISK       Creates os.dsk, a 1.44MB (3.5") floppy disk image file.
    31                                  ;       BUILDCOM        Creates os.com, the OS loader and kernel as a standalone DOS program.
    32                                  ;       BUILDPREP       Creates osprep.com, a DOS program that prepares a floppy disk to boot the OS
    33                                  ;
    34                                  ;-----------------------------------------------------------------------------------------------------------------------
    35                                  %ifdef BUILDDISK                                                                ;if we are building a disk image ...
    36                                  %define BUILDBOOT                                                               ;... build the boot sector
    37                                  %define BUILDCOM                                                                ;... and the OS kernel
    38                                  %endif
    39                                  %ifdef BUILDPREP                                                                ;if creating the disk prep program ...
    40                                  %define BUILDBOOT                                                               ;... also build the boot sector
    41                                  %endif
    42                                  ;-----------------------------------------------------------------------------------------------------------------------
    43                                  ;
    44                                  ;       Conventions
    45                                  ;
    46                                  ;       Alignment:      In this document, columns are numbered beginning with 1.
    47                                  ;                       Logical tabs are set after each eight columns.
    48                                  ;                       Tabs are simulated using SPACE characters.
    49                                  ;                       For comments that span an entire line, comment text begins in column 9.
    50                                  ;                       Assembly instructions (mnemonics) begin in column 25.
    51                                  ;                       Assembly operands begin in column 33.
    52                                  ;                       Inline comments begin in column 81.
    53                                  ;                       Lines should not extend beyond column 120.
    54                                  ;
    55                                  ;       Arguments:      Arguments are passed as registers and generally follow this order: EAX, ECX, EDX, EBX.
    56                                  ;                       However, ECX may be used as the sole parameter if a test for zero is required. EBX and EBP
    57                                  ;                       may be used as parameters if the routine is considered a "method" of an "object". In this
    58                                  ;                       case, EBX or EBP will address the object storage. If the routine is general-purpose string
    59                                  ;                       or character-array manipulator, ESI and EDI may be used as parameters to address input and/or
    60                                  ;                       ouput buffers, respectively.
    61                                  ;
    62                                  ;       Code Order:     Routines should appear in the order of their first likely use.
    63                                  ;                       Negative relative call or jump addresses usually, therefore, indicate reuse.
    64                                  ;
    65                                  ;       Comments:       A comment that spans the entire line begins with a semicolon in column 1.
    66                                  ;                       A comment that accompanies code on a line begins with a semicolon in column 81.
    67                                  ;                       Register names in comments are in upper case (EAX, EDI).
    68                                  ;                       Hexadecimal values in comments are in lower case (01fh, 0dah).
    69                                  ;                       Routines are preceded with a comment box that includes the routine name, description, and
    70                                  ;                       register contents on entry and exit.
    71                                  ;
    72                                  ;       Constants:      Symbolic constants (equates) are named in all-caps beginning with 'E' (EDATAPORT).
    73                                  ;                       Constant stored values are named in camel case, starting with 'c' (cbMaxLines).
    74                                  ;                       The 2nd letter of the constant label indicates the storage type.
    75                                  ;
    76                                  ;                       cq......        constant quad-word (dq)
    77                                  ;                       cd......        constant double-word (dd)
    78                                  ;                       cw......        constant word (dw)
    79                                  ;                       cb......        constant byte (db)
    80                                  ;                       cz......        constant ASCIIZ (null-terminated) string
    81                                  ;
    82                                  ;       Instructions:   32-bit instructions are generally favored.
    83                                  ;                       8-bit instructions and data are preferred for flags and status fields, etc.
    84                                  ;                       16-bit instructions are avoided wherever possible to avoid prefix bytes.
    85                                  ;
    86                                  ;       Labels:         Labels within a routine are numeric and begin with a period (.10, .20).
    87                                  ;                       Labels within a routine begin at ".10" and increment by 10.
    88                                  ;
    89                                  ;       Literals:       Literal values defined by external standards should be defined as symbolic constants (equates).
    90                                  ;                       Hexadecimal literals in code are in upper case with a leading '0' and trailing 'h' (01Fh).
    91                                  ;                       Binary literal values in source code are encoded with a final 'b' (1010b).
    92                                  ;                       Decimal literal values in source code are strictly numerals (2048).
    93                                  ;                       Octal literal values are avoided.
    94                                  ;                       String literals are enclosed in double quotes, e.g. "Loading OS".
    95                                  ;                       Single character literals are enclosed in single quotes, e.g. 'A'.
    96                                  ;
    97                                  ;       Macros:         Macro names are in camel case, beginning with a lower-case letter (getDateString).
    98                                  ;                       Macro names describe an action and so DO begin with a verb.
    99                                  ;
   100                                  ;       Memory Use:     Operating system memory allocation is minimized.
   101                                  ;                       Buffers are kept to as small a size as practicable.
   102                                  ;                       Data and code intermingling is avoided wherever possible.
   103                                  ;
   104                                  ;       Registers:      Register names in comments are in upper case (EAX, EDX).
   105                                  ;                       Register names in source code are in lower case (eax, edx).
   106                                  ;
   107                                  ;       Return Values:  Routines return result values in EAX or ECX or both. Routines should indicate failure by
   108                                  ;                       setting the carry flag to 1. Routines may prefer the use of ECX as a return value if the
   109                                  ;                       value is to be tested for null upon return (using the jecxz instruction).
   110                                  ;
   111                                  ;       Routines:       Routine names are in mixed case and capitalized (GetYear, ReadRealTimeClock).
   112                                  ;                       Routine names begin with a verb (Get, Read, Load).
   113                                  ;                       Routines should have a single entry address and a single exit instruction (ret, iretd, etc.).
   114                                  ;                       Routines that serve as wrappers for library functions carry the same name as the library
   115                                  ;                       function but begin with a leading underscore (_) character.
   116                                  ;
   117                                  ;       Structures:     Structure names are in all-caps (DATETIME).
   118                                  ;                       Structure names describe a "thing" and so do NOT begin with a verb.
   119                                  ;
   120                                  ;       Usage:          Registers EBX, ECX, EBP, SS, CS, DS and ES are preserved by routines.
   121                                  ;                       Registers ESI and EDI are preserved unless they are input parameters.
   122                                  ;                       Registers EAX and ECX are preferred for returning response/result values.
   123                                  ;                       Registers EBX and EBP are preferred for context (structure) address parameters.
   124                                  ;                       Registers EAX, ECX, EDX and EBX are preferred for integral parameters.
   125                                  ;
   126                                  ;       Variables:      Variables are named in camel case, starting with 'w'.
   127                                  ;                       The 2nd letter of the variable label indicates the storage type.
   128                                  ;
   129                                  ;                       wq......        variable quad-word (resq)
   130                                  ;                       wd......        variable double-word (resd)
   131                                  ;                       ww......        variable word (resw)
   132                                  ;                       wb......        variable byte (resb)
   133                                  ;                       ws......        writable structure
   134                                  ;
   135                                  ;-----------------------------------------------------------------------------------------------------------------------
   136                                  ;=======================================================================================================================
   137                                  ;
   138                                  ;       Equates
   139                                  ;
   140                                  ;       The equate (equ) statement defines a symbolic name for a fixed value so that such a value can be defined and
   141                                  ;       verified once and then used throughout the code. Using symbolic names simplifies searching for where logical
   142                                  ;       values are used. Equate names are in all-caps and begin with the letter 'E'. Equates are grouped into related
   143                                  ;       sets. Equates here are defined in the following groupings:
   144                                  ;
   145                                  ;       Hardware-Defined Values
   146                                  ;
   147                                  ;       EKEYB...        8042 or "PS/2 Controller" (Keyboard Controller) values
   148                                  ;
   149                                  ;       Firmware-Defined Values
   150                                  ;
   151                                  ;       EBIOS...        Basic Input/Output System (BIOS) values
   152                                  ;
   153                                  ;       Standards-Based Values
   154                                  ;
   155                                  ;       EASCII...       American Standard Code for Information Interchange (ASCII) values
   156                                  ;
   157                                  ;       Operating System Values
   158                                  ;
   159                                  ;       EBOOT...        Boot sector and loader values
   160                                  ;
   161                                  ;=======================================================================================================================
   162                                  ;-----------------------------------------------------------------------------------------------------------------------
   163                                  ;
   164                                  ;       Hardware-Defined Values
   165                                  ;
   166                                  ;-----------------------------------------------------------------------------------------------------------------------
   167                                  ;-----------------------------------------------------------------------------------------------------------------------
   168                                  ;
   169                                  ;       8042 Keyboard Controller                                                EKEYB...
   170                                  ;
   171                                  ;       The 8042 Keyboard Controller (8042) is a programmable controller that accepts input signals from the keyboard
   172                                  ;       device. It also signals a hardware interrupt to the CPU when the low-order bit of I/O port 64h is set to zero.
   173                                  ;
   174                                  ;-----------------------------------------------------------------------------------------------------------------------
   175                                  EKEYBPORTSTAT           equ     064h                                            ;status port
   176                                  EKEYBCMDRESET           equ     0FEh                                            ;reset bit 0 to restart system
   177                                  ;-----------------------------------------------------------------------------------------------------------------------
   178                                  ;
   179                                  ;       Firmware-Defined Values
   180                                  ;
   181                                  ;-----------------------------------------------------------------------------------------------------------------------
   182                                  ;-----------------------------------------------------------------------------------------------------------------------
   183                                  ;
   184                                  ;       BIOS Interrupts and Functions                                           EBIOS...
   185                                  ;
   186                                  ;       Basic Input/Output System (BIOS) functions are grouped and accessed by issuing an interrupt call. Each
   187                                  ;       BIOS interrupt supports several functions. The function code is typically passed in the AH register.
   188                                  ;
   189                                  ;-----------------------------------------------------------------------------------------------------------------------
   190                                  EBIOSINTVIDEO           equ     010h                                            ;video services interrupt
   191                                  EBIOSFNSETVMODE         equ     000h                                            ;video set mode function
   192                                  EBIOSMODETEXT80         equ     003h                                            ;video mode 80x25 text
   193                                  EBIOSFNTTYOUTPUT        equ     00Eh                                            ;video TTY output function
   194                                  EBIOSINTDISKETTE        equ     013h                                            ;diskette services interrupt
   195                                  EBIOSFNREADSECTOR       equ     002h                                            ;diskette read sector function
   196                                  EBIOSFNWRITESECTOR      equ     003h                                            ;diskette write sector function
   197                                  EBIOSINTKEYBOARD        equ     016h                                            ;keyboard services interrupt
   198                                  EBIOSFNKEYSTATUS        equ     001h                                            ;keyboard status function
   199                                  ;-----------------------------------------------------------------------------------------------------------------------
   200                                  ;
   201                                  ;       Standards-Based Values
   202                                  ;
   203                                  ;-----------------------------------------------------------------------------------------------------------------------
   204                                  ;-----------------------------------------------------------------------------------------------------------------------
   205                                  ;
   206                                  ;       ASCII                                                                   EASCII...
   207                                  ;
   208                                  ;-----------------------------------------------------------------------------------------------------------------------
   209                                  EASCIIRETURN            equ     00Dh                                            ;carriage return
   210                                  EASCIIESCAPE            equ     01Bh                                            ;escape
   211                                  ;-----------------------------------------------------------------------------------------------------------------------
   212                                  ;
   213                                  ;       Operating System Values
   214                                  ;
   215                                  ;-----------------------------------------------------------------------------------------------------------------------
   216                                  ;-----------------------------------------------------------------------------------------------------------------------
   217                                  ;
   218                                  ;       Boot Sector and Loader Constants                                        EBOOT...
   219                                  ;
   220                                  ;       Equates in this section support the boot sector and the 16-bit operating system loader, which will be
   221                                  ;       responsible for placing the CPU into protected mode and calling the initial operating system task.
   222                                  ;
   223                                  ;-----------------------------------------------------------------------------------------------------------------------
   224                                  EBOOTSTACKTOP           equ     0100h                                           ;boot sector stack top relative to DS
   225                                  EBOOTSECTORBYTES        equ     512                                             ;bytes per sector
   226                                  EBOOTDIRENTRIES         equ     224                                             ;directory entries
   227                                  EBOOTDISKSECTORS        equ     2880                                            ;sectors per disk
   228                                  EBOOTDISKBYTES          equ     (EBOOTSECTORBYTES*EBOOTDISKSECTORS)             ;bytes per disk
   229                                  EBOOTFATBASE            equ     (EBOOTSTACKTOP+EBOOTSECTORBYTES)                ;offset of FAT I/O buffer rel to DS
   230                                  EBOOTMAXTRIES           equ     5                                               ;max read retries
   231                                  %ifdef BUILDBOOT
   232                                  ;=======================================================================================================================
   233                                  ;
   234                                  ;       Boot Sector                                                             @disk: 000000   @mem: 007c00
   235                                  ;
   236                                  ;       The first sector of the disk is the boot sector. The BIOS will load the boot sector into memory and pass
   237                                  ;       control to the code at the start of the sector. The boot sector code is responsible for loading the operating
   238                                  ;       system into memory. The boot sector contains a disk parameter table describing the geometry and allocation
   239                                  ;       of the disk. Following the disk parameter table is code to load the operating system kernel into memory.
   240                                  ;
   241                                  ;       The "cpu" directive limits emitted code to those instructions supported by the most primitive processor
   242                                  ;       we expect to ever execute our code. The "vstart" parameter indicates addressability of symbols so as to
   243                                  ;       emulate the DOS .COM program model. Although the BIOS is expected to load the boot sector at address 7c00,
   244                                  ;       we do not make that assumption. The CPU starts in 16-bit addressing mode. A three-byte jump instruction is
   245                                  ;       immediately followed by a disk parameter table.
   246                                  ;
   247                                  ;=======================================================================================================================
   248                                                          cpu     8086                                            ;assume minimal CPU
   249                                  section                 boot    vstart=0100h                                    ;emulate .COM (CS,DS,ES=PSP) addressing
   250                                                          bits    16                                              ;16-bit code at power-up
   251                                  %ifdef BUILDPREP
   252 00000000 E9FD01                  Boot                    jmp     word Prep                                       ;jump to preparation code
   253                                  %else
   254                                  Boot                    jmp     word Boot.10                                    ;jump over parameter table
   255                                  %endif
   256                                  ;-----------------------------------------------------------------------------------------------------------------------
   257                                  ;
   258                                  ;       Disk Parameter Table
   259                                  ;
   260                                  ;       The disk parameter table informs the BIOS of the floppy disk architecture. Here, we use parameters for the
   261                                  ;       3.5" 1.44MB floppy disk since this format is widely supported by virtual machine hypervisors.
   262                                  ;
   263                                  ;-----------------------------------------------------------------------------------------------------------------------
   264 00000003 437573746F6D4F53                                db      "CustomOS"                                      ;eight-byte label
   265 0000000B 0002                    cwSectorBytes           dw      EBOOTSECTORBYTES                                ;bytes per sector
   266 0000000D 01                      cbClusterSectors        db      1                                               ;sectors per cluster
   267 0000000E 0100                    cwReservedSectors       dw      1                                               ;reserved sectors
   268 00000010 02                      cbFatCount              db      2                                               ;file allocation table copies
   269 00000011 E000                    cwDirEntries            dw      EBOOTDIRENTRIES                                 ;max directory entries
   270 00000013 400B                    cwDiskSectors           dw      EBOOTDISKSECTORS                                ;sectors per disk
   271 00000015 F0                      cbDiskType              db      0F0h                                            ;1.44MB
   272 00000016 0900                    cwFatSectors            dw      9                                               ;sectors per FAT copy
   273                                  cbTrackSectors          equ     $                                               ;sectors per track (as byte)
   274 00000018 1200                    cwTrackSectors          dw      18                                              ;sectors per track (as word)
   275 0000001A 0200                    cwDiskSides             dw      2                                               ;sides per disk
   276 0000001C 0000                    cwSpecialSectors        dw      0                                               ;special sectors
   277                                  ;
   278                                  ;       BIOS typically loads the boot sector at absolute address 7c00 and sets the stack pointer at 512 bytes past the
   279                                  ;       end of the boot sector. But, since BIOS code varies, we don't make any assumptions as to where our boot sector
   280                                  ;       is loaded. For example, the initial CS:IP could be 0:7c00, 700:c00, 7c0:0, etc. So, to avoid assumptions, we
   281                                  ;       first normalize CS:IP to get the absolute segment address in BX. The comments below show the effect of this code
   282                                  ;       given several possible starting values for CS:IP.
   283                                  ;
   284                                                                                                                  ;CS:IP   0:7c00 700:c00 7c0:0
   285 0000001E E80000                  Boot.10                 call    word .20                                        ;[ESP] =   7c21     c21    21
   286                                  .@20                    equ     $-$$                                            ;.@20 = 021h
   287 00000021 58                      .20                     pop     ax                                              ;AX =      7c21     c21    21
   288 00000022 83E821                                          sub     ax,.@20                                         ;AX =      7c00     c00     0
   289 00000025 B104                                            mov     cl,4                                            ;shift count
   290 00000027 D3E8                                            shr     ax,cl                                           ;AX =       7c0      c0     0
   291 00000029 8CCB                                            mov     bx,cs                                           ;BX =         0     700   7c0
   292 0000002B 01C3                                            add     bx,ax                                           ;BX =       7c0     7c0   7c0
   293                                  ;
   294                                  ;       Now, since we are assembling our boot code to emulate the addressing of a .COM file, we want the DS and ES
   295                                  ;       registers to be set to where a Program Segment Prefix (PSP) would be, exactly 100h (256) bytes prior to
   296                                  ;       the start of our code. This will correspond to our assembled data address offsets. Note that we instructed
   297                                  ;       the assembler to produce addresses for our symbols that are offset from our code by 100h. See the "vstart"
   298                                  ;       parameter for the "section" directive above. We also set SS to the PSP and SP to the address of our i/o
   299                                  ;       buffer. This leaves 256 bytes of usable stack from 7b0:0 to 7b0:100.
   300                                  ;
   301 0000002D 83EB10                                          sub     bx,16                                           ;BX = 07b0
   302 00000030 8EDB                                            mov     ds,bx                                           ;DS = 07b0 = psp
   303 00000032 8EC3                                            mov     es,bx                                           ;ES = 07b0 = psp
   304 00000034 8ED3                                            mov     ss,bx                                           ;SS = 07b0 = psp (ints disabled)
   305 00000036 BC0001                                          mov     sp,EBOOTSTACKTOP                                ;SP = 0100       (ints enabled)
   306                                  ;
   307                                  ;       Our boot addressability is now set up according to the following diagram.
   308                                  ;
   309                                  ;       DS,ES,SS -----> 007b00  +-----------------------------------------------+ DS:0000
   310                                  ;                               |  Boot Stack & Boot PSP (Unused)               |
   311                                  ;                               |  256 = 100h bytes                             |
   312                                  ;       SS:SP --------> 007c00  +-----------------------------------------------+ DS:0100  07b0:0100
   313                                  ;                               |  Boot Sector (vstart=0100h)                   |
   314                                  ;                               |  1 sector = 512 = 200h bytes                  |
   315                                  ;                       007e00  +-----------------------------------------------+ DS:0300
   316                                  ;                               |  File Allocation Table (FAT) I/O Buffer       |
   317                                  ;                               |  9x512-byte sectors = 4,608 = 1200h bytes     |
   318                                  ;                       009000  +-----------------------------------------------+ DS:1500  08f0:0100
   319                                  ;                               |  Directory Sector Buffer & Kernel Load Area   |
   320                                  ;                               |  2 sectors = 1024 = 400h bytes
   321                                  ;                       009400  +-----------------------------------------------+ DS:1900
   322                                  ;
   323                                  ;       On entry, DL indicates the drive being booted from.
   324                                  ;
   325 00000039 8816[F801]                                      mov     [wbDrive],dl                                    ;[wbDrive] = drive being booted from
   326                                  ;
   327                                  ;       Compute directory i/o buffer address.
   328                                  ;
   329 0000003D A1[1600]                                        mov     ax,[cwFatSectors]                               ;AX = 0009 = FAT sectors
   330 00000040 F726[0B00]                                      mul     word [cwSectorBytes]                            ;DX:AX = 0000:1200 = FAT bytes
   331 00000044 050003                                          add     ax,EBOOTFATBASE                                 ;AX = 1500 = end of FAT buffer
   332 00000047 A3[EC01]                                        mov     [wwDirBuffer],ax                                ;[wwDirBuffer] = 1500
   333                                  ;
   334                                  ;       Compute segment where os.com will be loaded.
   335                                  ;
   336 0000004A D3E8                                            shr     ax,cl                                           ;AX = 0150
   337 0000004C 01D8                                            add     ax,bx                                           ;AX = 0150 + 07b0 = 0900
   338 0000004E 83E810                                          sub     ax,16                                           ;AX = 08f0
   339 00000051 A3[3F01]                                        mov     [wwLoadSegment],ax                              ;[wwLoadSegment] = 08f0
   340                                  ;
   341                                  ;       Set the video mode to 80 column, 25 row, text.
   342                                  ;
   343 00000054 B80300                                          mov     ax,EBIOSFNSETVMODE<<8|EBIOSMODETEXT80           ;set mode function, 80x25 text mode
   344 00000057 CD10                                            int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
   345                                  ;
   346                                  ;       Write a message to the console so we know we have our addressability established.
   347                                  ;
   348 00000059 BE[C501]                                        mov     si,czLoadMsg                                    ;loading message
   349 0000005C E84B01                                          call    BootPrint                                       ;display loader message
   350                                  ;
   351                                  ;       Initialize the number of directory sectors to search.
   352                                  ;
   353 0000005F A1[1100]                                        mov     ax,[cwDirEntries]                               ;AX = 224 = max dir entries
   354 00000062 A3[EE01]                                        mov     [wwEntriesLeft],ax                              ;[wwEntriesLeft] = 224
   355                                  ;
   356                                  ;       Compute number of directory sectors and initialize overhead count.
   357                                  ;
   358 00000065 89C1                                            mov     cx,ax                                           ;CX = 00e0 = 224 entries
   359 00000067 F726[B801]                                      mul     word [cwEntryLen]                               ;DX:AX = 224 * 32 = 7168
   360 0000006B F736[0B00]                                      div     word [cwSectorBytes]                            ;AX = 7168 / 512 = 14 = dir sectors
   361 0000006F A3[F001]                                        mov     [wwOverhead],ax                                 ;[wwOverhead] = 000e
   362                                  ;
   363                                  ;       Compute directory entries per sector.
   364                                  ;
   365 00000072 91                                              xchg    ax,cx                                           ;DX:AX = 0:00e0, CX = 0000e
   366 00000073 F7F1                                            div     cx                                              ;AX = 0010 = entries per dir sector
   367 00000075 A3[F201]                                        mov     [wwSectorEntries],ax                            ;[wwSectorEntries] = 0010
   368                                  ;
   369                                  ;       Compute first logical directory sector and update overhead count.
   370                                  ;
   371 00000078 A1[1600]                                        mov     ax,[cwFatSectors]                               ;AX = 0009 = FAT sectors per copy
   372 0000007B F626[1000]                                      mul     byte [cbFatCount]                               ;AX = 0012 = FAT sectors
   373 0000007F 0306[0E00]                                      add     ax,[cwReservedSectors]                          ;AX = 0013 = FAT plus reserved
   374 00000083 0306[1C00]                                      add     ax,[cwSpecialSectors]                           ;AX = 0013 = FAT + reserved + special
   375 00000087 A3[F401]                                        mov     [wwLogicalSector],ax                            ;[wwLogicalSector] = 0013
   376 0000008A 0106[F001]                                      add     [wwOverhead],ax                                 ;[wwOverhead] = 0021 = res+spec+FAT+dir
   377                                  ;
   378                                  ;       Read directory sector.
   379                                  ;
   380 0000008E B001                    .30                     mov     al,1                                            ;sector count
   381 00000090 A2[F601]                                        mov     [wbReadCount],al                                ;[wbReadCount] = 01
   382 00000093 8B1E[EC01]                                      mov     bx,[wwDirBuffer]                                ;BX = 1500
   383 00000097 E8A700                                          call    ReadSector                                      ;read sector into es:bx
   384                                  ;
   385                                  ;       Setup variables to search this directory sector.
   386                                  ;
   387 0000009A A1[EE01]                                        mov     ax,[wwEntriesLeft]                              ;directory entries to search
   388 0000009D 3B06[F201]                                      cmp     ax,[wwSectorEntries]                            ;need to search more sectors?
   389 000000A1 7603                                            jna     .40                                             ;no, continue
   390 000000A3 A1[F201]                                        mov     ax,[wwSectorEntries]                            ;yes, limit search to sector
   391 000000A6 2906[EE01]              .40                     sub     [wwEntriesLeft],ax                              ;update entries left to searh
   392 000000AA BE[BA01]                                        mov     si,cbKernelProgram                              ;program name
   393 000000AD 8B3E[EC01]                                      mov     di,[wwDirBuffer]                                ;DI = 1500
   394                                  ;
   395                                  ;       Loop through directory sectors searching for kernel program.
   396                                  ;
   397 000000B1 56                      .50                     push    si                                              ;save kernel name address
   398 000000B2 57                                              push    di                                              ;save dir i/o buffer address
   399 000000B3 B90B00                                          mov     cx,11                                           ;length of 8+3 name
   400 000000B6 FC                                              cld                                                     ;forward strings
   401 000000B7 F3A6                                            repe    cmpsb                                           ;compare entry name
   402 000000B9 5F                                              pop     di                                              ;restore dir i/o buffer address
   403 000000BA 5E                                              pop     si                                              ;restore kernel name address
   404 000000BB 7418                                            je      .60                                             ;exit loop if found
   405 000000BD 033E[B801]                                      add     di,[cwEntryLen]                                 ;point to next dir entry
   406 000000C1 48                                              dec     ax                                              ;decrement remaining entries
   407 000000C2 75ED                                            jnz     .50                                             ;next entry
   408                                  ;
   409                                  ;       Repeat search if we are not at the end of the directory.
   410                                  ;
   411 000000C4 FF06[F401]                                      inc     word [wwLogicalSector]                          ;increment logical sector
   412 000000C8 833E[EE01]00                                    cmp     word [wwEntriesLeft],0                          ;done with directory?
   413 000000CD 75BF                                            jne     .30                                             ;no, get next sector
   414 000000CF BE[E001]                                        mov     si,czNoKernel                                   ;missing kernel message
   415 000000D2 E9C000                                          jmp     BootExit                                        ;display message and exit
   416                                  ;
   417                                  ;       If we find the kernel program in the directory, read the FAT.
   418                                  ;
   419 000000D5 A1[0E00]                .60                     mov     ax,[cwReservedSectors]                          ;AX = 0001
   420 000000D8 A3[F401]                                        mov     [wwLogicalSector],ax                            ;start past boot sector
   421 000000DB A1[1600]                                        mov     ax,[cwFatSectors]                               ;AX = 0009
   422 000000DE A2[F601]                                        mov     [wbReadCount],al                                ;[wbReadCount] = 09
   423 000000E1 BB0003                                          mov     bx,EBOOTFATBASE                                 ;BX = 0300
   424 000000E4 E85A00                                          call    ReadSector                                      ;read FAT into buffer
   425                                  ;
   426                                  ;       Get the starting cluster of the kernel program and target address.
   427                                  ;
   428 000000E7 8B451A                                          mov     ax,[di+26]                                      ;AX = starting cluster of file
   429 000000EA C41E[3D01]                                      les     bx,[wwLoadOffset]                               ;ES:BX = kernel load add (08f0:0100)
   430                                  ;
   431                                  ;       Read each program cluster into RAM.
   432                                  ;
   433 000000EE 50                      .70                     push    ax                                              ;save cluster nbr
   434 000000EF 83E802                                          sub     ax,2                                            ;AX = cluster nbr base 0
   435 000000F2 8A0E[0D00]                                      mov     cl,[cbClusterSectors]                           ;CL = sectors per cluster
   436 000000F6 880E[F601]                                      mov     [wbReadCount],cl                                ;save sectors to read
   437 000000FA 30ED                                            xor     ch,ch                                           ;CX = sectors per cluster
   438 000000FC F7E1                                            mul     cx                                              ;DX:AX = logical cluster sector
   439 000000FE 0306[F001]                                      add     ax,[wwOverhead]                                 ;AX = kernel sector nbr
   440 00000102 A3[F401]                                        mov     [wwLogicalSector],ax                            ;save logical sector nbr
   441 00000105 E83900                                          call    ReadSector                                      ;read sectors into ES:BX
   442                                  ;
   443                                  ;       Update buffer pointer for next cluster.
   444                                  ;
   445 00000108 A0[0D00]                                        mov     al,[cbClusterSectors]                           ;AL = sectors per cluster
   446 0000010B 30E4                                            xor     ah,ah                                           ;AX = sectors per cluster
   447 0000010D F726[0B00]                                      mul     word [cwSectorBytes]                            ;DX:AX = cluster bytes
   448 00000111 01C3                                            add     bx,ax                                           ;BX = next cluster target address
   449 00000113 58                                              pop     ax                                              ;AX = restore cluster nbr
   450                                  ;
   451                                  ;       Compute next cluster number.
   452                                  ;
   453 00000114 89C1                                            mov     cx,ax                                           ;CX = cluster nbr
   454 00000116 89C7                                            mov     di,ax                                           ;DI = cluster nbr
   455 00000118 D1E8                                            shr     ax,1                                            ;AX = cluster/2
   456 0000011A 89C2                                            mov     dx,ax                                           ;DX = cluster/2
   457 0000011C 01D0                                            add     ax,dx                                           ;AX = 2*(cluster/2)
   458 0000011E 01D0                                            add     ax,dx                                           ;AX = 3*(cluster/2)
   459 00000120 83E701                                          and     di,1                                            ;get low bit
   460 00000123 01C7                                            add     di,ax                                           ;add one if cluster is odd
   461 00000125 81C70003                                        add     di,EBOOTFATBASE                                 ;add FAT buffer address
   462 00000129 8B05                                            mov     ax,[di]                                         ;get cluster bytes
   463                                  ;
   464                                  ;       Adjust cluster nbr by 4 bits if cluster is odd; test for end of chain.
   465                                  ;
   466 0000012B F6C101                                          test    cl,1                                            ;is cluster odd?
   467 0000012E 7404                                            jz      .80                                             ;no, skip ahead
   468 00000130 B104                                            mov     cl,4                                            ;shift count
   469 00000132 D3E8                                            shr     ax,cl                                           ;shift nybble low
   470 00000134 25FF0F                  .80                     and     ax,0FFFh                                        ;mask for 24 bits; next cluster nbr
   471 00000137 3DFF0F                                          cmp     ax,0FFFh                                        ;end of chain?
   472 0000013A 75B2                                            jne     .70                                             ;no, continue
   473                                  ;
   474                                  ;       Transfer control to the operating system program.
   475                                  ;
   476 0000013C EA                                              db      0EAh                                            ;jmp seg:offset
   477 0000013D 0001                    wwLoadOffset            dw      0100h                                           ;kernel entry offset
   478 0000013F F008                    wwLoadSegment           dw      08F0h                                           ;kernel entry segment (computed)
   479                                  ;
   480                                  ;       Read [wbReadCount] disk sectors from [wwLogicalSector] into ES:BX.
   481                                  ;
   482 00000141 A1[1800]                ReadSector              mov     ax,[cwTrackSectors]                             ;AX = sectors per track
   483 00000144 F726[1A00]                                      mul     word [cwDiskSides]                              ;DX:AX = sectors per cylinder
   484 00000148 89C1                                            mov     cx,ax                                           ;CX = sectors per cylinder
   485 0000014A A1[F401]                                        mov     ax,[wwLogicalSector]                            ;DX:AX = logical sector
   486 0000014D F7F1                                            div     cx                                              ;AX = cylinder; DX = cyl sector
   487 0000014F A2[FB01]                                        mov     [wbTrack],al                                    ;[wbTrack] = cylinder
   488 00000152 89D0                                            mov     ax,dx                                           ;AX = cyl sector
   489 00000154 F636[1800]                                      div     byte [cbTrackSectors]                           ;AH = sector, AL = head
   490 00000158 FEC4                                            inc     ah                                              ;AH = sector (1,2,3,...)
   491 0000015A A3[F901]                                        mov     [wbHead],ax                                     ;[wbHead]= head, [wwSectorTrack]= sector
   492                                  ;
   493                                  ;       Try maxtries times to read sector.
   494                                  ;
   495 0000015D B90500                                          mov     cx,EBOOTMAXTRIES                                ;CX = 0005
   496 00000160 53                      .10                     push    bx                                              ;save buffer address
   497 00000161 51                                              push    cx                                              ;save retry count
   498 00000162 8B16[F801]                                      mov     dx,[wwDriveHead]                                ;DH = head, DL = drive
   499 00000166 8B0E[FA01]                                      mov     cx,[wwSectorTrack]                              ;CH = track, CL = sector
   500 0000016A A1[F601]                                        mov     ax,[wwReadCountCommand]                         ;AH = fn., AL = sector count
   501 0000016D CD13                                            int     EBIOSINTDISKETTE                                ;read sector
   502 0000016F 59                                              pop     cx                                              ;restore retry count
   503 00000170 5B                                              pop     bx                                              ;restore buffer address
   504 00000171 7343                                            jnc     BootReturn                                      ;skip ahead if done
   505 00000173 E2EB                                            loop    .10                                             ;retry
   506                                  ;
   507                                  ;       Handle disk error: convert to ASCII and store in error string.
   508                                  ;
   509 00000175 88E0                                            mov     al,ah                                           ;AL = bios error code
   510 00000177 30E4                                            xor     ah,ah                                           ;AX = bios error code
   511 00000179 B210                                            mov     dl,16                                           ;divisor for base 16
   512 0000017B F6F2                                            div     dl                                              ;AL = hi order, AH = lo order
   513 0000017D 0D3030                                          or      ax,03030h                                       ;apply ASCII zone bits
   514 00000180 80FC3A                                          cmp     ah,03Ah                                         ;range test ASCII numeral
   515 00000183 7203                                            jb      .20                                             ;continue if numeral
   516 00000185 80C407                                          add     ah,7                                            ;adjust for ASCII 'A'-'F'
   517 00000188 3C3A                    .20                     cmp     al,03Ah                                         ;range test ASCII numeral
   518 0000018A 7203                                            jb      .30                                             ;continue if numeral
   519 0000018C 80C407                                          add     ah,7                                            ;adjust for ASCII 'A'-'F'
   520 0000018F A3[DD01]                .30                     mov     [wzErrorCode],ax                                ;store ASCII error code
   521 00000192 BE[D201]                                        mov     si,czErrorMsg                                   ;error message address
   522 00000195 E81200                  BootExit                call    BootPrint                                       ;display messge to console
   523                                  ;
   524                                  ;       Wait for a key press.
   525                                  ;
   526 00000198 B401                    .10                     mov     ah,EBIOSFNKEYSTATUS                             ;BIOS keyboard status function
   527 0000019A CD16                                            int     EBIOSINTKEYBOARD                                ;get keyboard status
   528 0000019C 7504                                            jnz     .20                                             ;continue if key pressed
   529 0000019E FB                                              sti                                                     ;enable maskable interrupts
   530 0000019F F4                                              hlt                                                     ;wait for interrupt
   531 000001A0 EBF6                                            jmp     .10                                             ;repeat
   532                                  ;
   533                                  ;       Reset the system.
   534                                  ;
   535 000001A2 B0FE                    .20                     mov     al,EKEYBCMDRESET                                ;8042 pulse output port pin
   536 000001A4 E664                                            out     EKEYBPORTSTAT,al                                ;drive B0 low to restart
   537 000001A6 FB                      .30                     sti                                                     ;enable maskable interrupts
   538 000001A7 F4                                              hlt                                                     ;stop until reset, int, nmi
   539 000001A8 EBFC                                            jmp     .30                                             ;loop until restart kicks in
   540                                  ;
   541                                  ;       Display text message.
   542                                  ;
   543 000001AA FC                      BootPrint               cld                                                     ;forward strings
   544 000001AB AC                      .10                     lodsb                                                   ;load next byte at DS:SI in AL
   545 000001AC 84C0                                            test    al,al                                           ;end of string?
   546 000001AE 7406                                            jz      BootReturn                                      ;... yes, exit our loop
   547 000001B0 B40E                                            mov     ah,EBIOSFNTTYOUTPUT                             ;BIOS teletype function
   548 000001B2 CD10                                            int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
   549 000001B4 EBF5                                            jmp     .10                                             ;repeat until done
   550 000001B6 C3                      BootReturn              ret                                                     ;return
   551                                  ;-----------------------------------------------------------------------------------------------------------------------
   552                                  ;
   553                                  ;       Constants
   554                                  ;
   555                                  ;-----------------------------------------------------------------------------------------------------------------------
   556 000001B7 90                                              align   2
   557 000001B8 2000                    cwEntryLen              dw      32                                              ;length of directory entry
   558 000001BA 4F5320202020202043-     cbKernelProgram         db      "OS      COM"                                   ;kernel program name
   558 000001C3 4F4D               
   559 000001C5 4C6F6164696E67204F-     czLoadMsg               db      "Loading OS",13,10,0                            ;loading message
   559 000001CE 530D0A00           
   560 000001D2 4469736B206572726F-     czErrorMsg              db      "Disk error "                                   ;error message
   560 000001DB 7220               
   561 000001DD 202000                  wzErrorCode             db      020h,020h,0                                     ;error code and null terminator
   562 000001E0 4F53206D697373696E-     czNoKernel              db      "OS missing",0                                  ;missing kernel message
   562 000001E9 6700               
   563                                  ;-----------------------------------------------------------------------------------------------------------------------
   564                                  ;
   565                                  ;       Work Areas
   566                                  ;
   567                                  ;-----------------------------------------------------------------------------------------------------------------------
   568 000001EB 90                                              align   2
   569 000001EC 0000                    wwDirBuffer             dw      0                                               ;directory i/o buffer address
   570 000001EE 0000                    wwEntriesLeft           dw      0                                               ;directory entries to search
   571 000001F0 0000                    wwOverhead              dw      0                                               ;overhead sectors
   572 000001F2 0000                    wwSectorEntries         dw      0                                               ;directory entries per sector
   573 000001F4 0000                    wwLogicalSector         dw      0                                               ;current logical sector
   574                                  wwReadCountCommand      equ     $                                               ;read count and command
   575 000001F6 00                      wbReadCount             db      0                                               ;sectors to read
   576 000001F7 02                      cbReadCommand           db      EBIOSFNREADSECTOR                               ;BIOS read disk fn code
   577                                  wwDriveHead             equ     $                                               ;drive, head (word)
   578 000001F8 00                      wbDrive                 db      0                                               ;drive
   579 000001F9 00                      wbHead                  db      0                                               ;head
   580                                  wwSectorTrack           equ     $                                               ;sector, track (word)
   581 000001FA 00                                              db      0                                               ;sector
   582 000001FB 00                      wbTrack                 db      0                                               ;track
   583 000001FC 00<rept>                                        times   510-($-$$) db 0h                                ;zero fill to end of sector
   584 000001FE 55AA                                            db      055h,0AAh                                       ;end of sector signature
   585                                  %endif
   586                                  %ifdef BUILDPREP
   587                                  ;=======================================================================================================================
   588                                  ;
   589                                  ;       Diskette Preparation Code
   590                                  ;
   591                                  ;       This routine writes the OS boot sector code to a formatted floppy diskette. The diskette parameter table,
   592                                  ;       which is located in the first 30 bytes of the boot sector is first read from the diskette and overlayed onto
   593                                  ;       the OS bootstrap code so that the diskette format parameters are preserved.
   594                                  ;
   595                                  ;=======================================================================================================================
   596                                  ;
   597                                  ;       Query the user to insert a flopppy diskette and press enter or cancel.
   598                                  ;
   599 00000200 BE[CC02]                Prep                    mov     si,czPrepMsg10                                  ;starting message address
   600 00000203 E8A4FF                                          call    BootPrint                                       ;display message
   601                                  ;
   602                                  ;       Exit if the Escape key is pressed or loop until Enter is pressed.
   603                                  ;
   604 00000206 B401                    .10                     mov     ah,EBIOSFNKEYSTATUS                             ;BIOS keyboard status function
   605 00000208 CD16                                            int     EBIOSINTKEYBOARD                                ;get keyboard status
   606 0000020A 7504                                            jnz     .20                                             ;continue if key pressed
   607 0000020C FB                                              sti                                                     ;enable interrupts
   608 0000020D F4                                              hlt                                                     ;wait for interrupt
   609 0000020E EBF6                                            jmp     .10                                             ;repeat
   610 00000210 3C0D                    .20                     cmp     al,EASCIIRETURN                                 ;Enter key pressed?
   611 00000212 7407                                            je      .30                                             ;yes, branch
   612 00000214 3C1B                                            cmp     al,EASCIIESCAPE                                 ;Escape key pressed?
   613 00000216 75EE                                            jne     .10                                             ;no, repeat
   614 00000218 E9AB00                                          jmp     .120                                            ;yes, exit program
   615                                  ;
   616                                  ;       Display writing-sector message and patch the JMP instruction.
   617                                  ;
   618 0000021B BE[7004]                .30                     mov     si,czPrepMsg12                                  ;writing-sector message address
   619 0000021E E889FF                                          call    BootPrint                                       ;display message
   620 00000221 BB[0100]                                        mov     bx,Boot+1                                       ;address of JMP instruction operand
   621 00000224 B81B00                                          mov     ax,01Bh                                         ;address past disk parameter table
   622 00000227 8907                                            mov     [bx],ax                                         ;update the JMP instruction
   623                                  ;
   624                                  ;       Try to read the boot sector.
   625                                  ;
   626 00000229 B90500                                          mov     cx,EBOOTMAXTRIES                                ;try up to five times
   627 0000022C 51                      .40                     push    cx                                              ;save remaining tries
   628 0000022D BB[780A]                                        mov     bx,wcPrepInBuf                                  ;input buffer address
   629 00000230 BA0000                                          mov     dx,0                                            ;head zero, drive zero
   630 00000233 B90100                                          mov     cx,1                                            ;track zero, sector one
   631 00000236 B001                                            mov     al,1                                            ;one sector
   632 00000238 B402                                            mov     ah,EBIOSFNREADSECTOR                            ;read function
   633 0000023A CD13                                            int     EBIOSINTDISKETTE                                ;attempt the read
   634 0000023C 59                                              pop     cx                                              ;restore remaining retries
   635 0000023D 7307                                            jnc     .50                                             ;skip ahead if successful
   636 0000023F E2EB                                            loop    .40                                             ;try again
   637 00000241 BE[A004]                                        mov     si,czPrepMsg20                                  ;read-error message address
   638 00000244 EB2D                                            jmp     .70                                             ;branch to error routine
   639                                  ;
   640                                  ;       Copy diskette parms from input buffer to output buffer.
   641                                  ;
   642 00000246 BE[780A]                .50                     mov     si,wcPrepInBuf                                  ;input buffer address
   643 00000249 83C60B                                          add     si,11                                           ;skip over JMP and system ID
   644 0000024C BF[0000]                                        mov     di,Boot                                         ;output buffer address
   645 0000024F 83C70B                                          add     di,11                                           ;skip over JMP and system ID
   646 00000252 B91300                                          mov     cx,19                                           ;length of diskette parameters
   647 00000255 FC                                              cld                                                     ;forward string copies
   648 00000256 F3A4                                            rep     movsb                                           ;copy diskette parameters
   649                                  ;
   650                                  ;       Try to write boot sector to diskette.
   651                                  ;
   652 00000258 B90500                                          mov     cx,EBOOTMAXTRIES                                ;try up to five times
   653 0000025B 51                      .60                     push    cx                                              ;save remaining tries
   654 0000025C BB[0000]                                        mov     bx,Boot                                         ;output buffer address
   655 0000025F BA0000                                          mov     dx,0                                            ;head zero, drive zero
   656 00000262 B90100                                          mov     cx,1                                            ;track zero, sector one
   657 00000265 B001                                            mov     al,1                                            ;one sector
   658 00000267 B403                                            mov     ah,EBIOSFNWRITESECTOR                           ;write function
   659 00000269 CD13                                            int     EBIOSINTDISKETTE                                ;attempt the write
   660 0000026B 59                                              pop     cx                                              ;restore remaining retries
   661 0000026C 7326                                            jnc     .100                                            ;skip ahead if successful
   662 0000026E E2EB                                            loop    .60                                             ;try again
   663 00000270 BE[EE04]                                        mov     si,czPrepMsg30                                  ;write-error message address
   664                                  ;
   665                                  ;       Convert the error code to ASCII and display the error message.
   666                                  ;
   667 00000273 50                      .70                     push    ax                                              ;save error code
   668 00000274 88E0                                            mov     al,ah                                           ;copy error code
   669 00000276 B400                                            mov     ah,0                                            ;AX = error code
   670 00000278 B210                                            mov     dl,10h                                          ;hexadecimal divisor
   671 0000027A F6FA                                            idiv    dl                                              ;AL = hi-order, AH = lo-order
   672 0000027C 0D3030                                          or      ax,03030h                                       ;add ASCII zone digits
   673 0000027F 80FC3A                                          cmp     ah,03Ah                                         ;AH ASCII numeral?
   674 00000282 7203                                            jb      .80                                             ;yes, continue
   675 00000284 80C407                                          add     ah,7                                            ;no, make ASCII 'A'-'F'
   676 00000287 3C3A                    .80                     cmp     al,03Ah                                         ;ASCII numeral?
   677 00000289 7202                                            jb      .90                                             ;yes, continue
   678 0000028B 0407                                            add     al,7                                            ;no, make ASCII
   679 0000028D 894411                  .90                     mov     [si+17],ax                                      ;put ASCII error code in message
   680 00000290 E817FF                                          call    BootPrint                                       ;write error message
   681 00000293 58                                              pop     ax                                              ;restore error code
   682                                  ;
   683                                  ;       Display the completion message.
   684                                  ;
   685 00000294 BE[3A05]                .100                    mov     si,czPrepMsgOK                                  ;assume successful completion
   686 00000297 88E0                                            mov     al,ah                                           ;BIOS return code
   687 00000299 3C00                                            cmp     al,0                                            ;success?
   688 0000029B 7426                                            je      .110                                            ;yes, continue
   689 0000029D BE[D905]                                        mov     si,czPrepMsgErr1                                ;disk parameter error message
   690 000002A0 3C01                                            cmp     al,1                                            ;disk parameter error?
   691 000002A2 741F                                            je      .110                                            ;yes, continue
   692 000002A4 BE[A306]                                        mov     si,czPrepMsgErr2                                ;address mark not found message
   693 000002A7 3C02                                            cmp     al,2                                            ;address mark not found?
   694 000002A9 7418                                            je      .110                                            ;yes, continue
   695 000002AB BE[2C07]                                        mov     si,czPrepMsgErr3                                ;protected disk message
   696 000002AE 3C03                                            cmp     al,3                                            ;protected disk?
   697 000002B0 7411                                            je      .110                                            ;yes, continue
   698 000002B2 BE[E607]                                        mov     si,czPrepMsgErr6                                ;diskette removed message
   699 000002B5 3C06                                            cmp     al,6                                            ;diskette removed?
   700 000002B7 740A                                            je      .110                                            ;yes, continue
   701 000002B9 BE[1609]                                        mov     si,czPrepMsgErr80                               ;drive timed out message
   702 000002BC 3C80                                            cmp     al,80H                                          ;drive timed out?
   703 000002BE 7403                                            je      .110                                            ;yes, continue
   704 000002C0 BE[C709]                                        mov     si,czPrepMsgErrXX                               ;unknown error message
   705 000002C3 E8E4FE                  .110                    call    BootPrint                                       ;display result message
   706 000002C6 B8004C                  .120                    mov     ax,04C00H                                       ;terminate with zero result code
   707 000002C9 CD21                                            int     021h                                            ;terminate DOS program
   708 000002CB C3                                              ret                                                     ;return (should not execute)
   709                                  ;-----------------------------------------------------------------------------------------------------------------------
   710                                  ;
   711                                  ;       Diskette Preparation Messages
   712                                  ;
   713                                  ;-----------------------------------------------------------------------------------------------------------------------
   714 000002CC 0D0A437573746F6D4F-     czPrepMsg10             db      13,10,"CustomOS Boot-Diskette Preparation Program"
   714 000002D5 5320426F6F742D4469-
   714 000002DE 736B65747465205072-
   714 000002E7 657061726174696F6E-
   714 000002F0 2050726F6772616D   
   715 000002F8 0D0A436F7079726967-                             db      13,10,"Copyright (C) 2010-2019 David J. Walling. All rights reserved."
   715 00000301 687420284329203230-
   715 0000030A 31302D323031392044-
   715 00000313 61766964204A2E2057-
   715 0000031C 616C6C696E672E2041-
   715 00000325 6C6C20726967687473-
   715 0000032E 207265736572766564-
   715 00000337 2E                 
   716 00000338 0D0A                                            db      13,10
   717 0000033A 0D0A54686973207072-                             db      13,10,"This program overwrites the boot sector of a diskette with startup code that"
   717 00000343 6F6772616D206F7665-
   717 0000034C 727772697465732074-
   717 00000355 686520626F6F742073-
   717 0000035E 6563746F72206F6620-
   717 00000367 61206469736B657474-
   717 00000370 652077697468207374-
   717 00000379 617274757020636F64-
   717 00000382 652074686174       
   718 00000388 0D0A77696C6C206C6F-                             db      13,10,"will load the operating system into memory when the computer is restarted."
   718 00000391 616420746865206F70-
   718 0000039A 65726174696E672073-
   718 000003A3 797374656D20696E74-
   718 000003AC 6F206D656D6F727920-
   718 000003B5 7768656E2074686520-
   718 000003BE 636F6D707574657220-
   718 000003C7 697320726573746172-
   718 000003D0 7465642E           
   719 000003D4 0D0A546F2070726F63-                             db      13,10,"To proceed, place a formatted diskette into drive A: and press the Enter key."
   719 000003DD 6565642C20706C6163-
   719 000003E6 65206120666F726D61-
   719 000003EF 74746564206469736B-
   719 000003F8 6574746520696E746F-
   719 00000401 20647269766520413A-
   719 0000040A 20616E642070726573-
   719 00000413 732074686520456E74-
   719 0000041C 6572206B65792E     
   720 00000423 0D0A546F2065786974-                             db      13,10,"To exit this program without preparing a diskette, press the Escape key."
   720 0000042C 20746869732070726F-
   720 00000435 6772616D2077697468-
   720 0000043E 6F7574207072657061-
   720 00000447 72696E672061206469-
   720 00000450 736B657474652C2070-
   720 00000459 726573732074686520-
   720 00000462 457363617065206B65-
   720 0000046B 792E               
   721 0000046D 0D0A00                                          db      13,10,0
   722 00000470 0D0A57726974696E67-     czPrepMsg12             db      13,10,"Writing the boot sector to the diskette ..."
   722 00000479 2074686520626F6F74-
   722 00000482 20736563746F722074-
   722 0000048B 6F2074686520646973-
   722 00000494 6B65747465202E2E2E 
   723 0000049D 0D0A00                                          db      13,10,0
   724 000004A0 0D0A54686520657272-     czPrepMsg20             db      13,10,"The error-code .. was returned from the BIOS while reading from the disk."
   724 000004A9 6F722D636F6465202E-
   724 000004B2 2E2077617320726574-
   724 000004BB 75726E65642066726F-
   724 000004C4 6D207468652042494F-
   724 000004CD 53207768696C652072-
   724 000004D6 656164696E67206672-
   724 000004DF 6F6D20746865206469-
   724 000004E8 736B2E             
   725 000004EB 0D0A00                                          db      13,10,0
   726 000004EE 0D0A54686520657272-     czPrepMsg30             db      13,10,"The error-code .. was returned from the BIOS while writing to the disk."
   726 000004F7 6F722D636F6465202E-
   726 00000500 2E2077617320726574-
   726 00000509 75726E65642066726F-
   726 00000512 6D207468652042494F-
   726 0000051B 53207768696C652077-
   726 00000524 726974696E6720746F-
   726 0000052D 20746865206469736B-
   726 00000536 2E                 
   727 00000537 0D0A00                                          db      13,10,0
   728 0000053A 0D0A54686520626F6F-     czPrepMsgOK             db      13,10,"The boot-sector was written to the diskette. Before booting your computer with"
   728 00000543 742D736563746F7220-
   728 0000054C 776173207772697474-
   728 00000555 656E20746F20746865-
   728 0000055E 206469736B65747465-
   728 00000567 2E204265666F726520-
   728 00000570 626F6F74696E672079-
   728 00000579 6F757220636F6D7075-
   728 00000582 7465722077697468   
   729 0000058A 0D0A74686973206469-                             db      13,10,"this diskette, make sure that the file OS.COM is copied onto the diskette."
   729 00000593 736B657474652C206D-
   729 0000059C 616B65207375726520-
   729 000005A5 746861742074686520-
   729 000005AE 66696C65204F532E43-
   729 000005B7 4F4D20697320636F70-
   729 000005C0 696564206F6E746F20-
   729 000005C9 746865206469736B65-
   729 000005D2 7474652E           
   730 000005D6 0D0A00                                          db      13,10,0
   731 000005D9 0D0A2830312920496E-     czPrepMsgErr1           db      13,10,"(01) Invalid Disk Parameter"
   731 000005E2 76616C696420446973-
   731 000005EB 6B20506172616D6574-
   731 000005F4 6572               
   732 000005F6 0D0A54686973206973-                             db      13,10,"This is an internal error caused by an invalid value being passed to a system"
   732 000005FF 20616E20696E746572-
   732 00000608 6E616C206572726F72-
   732 00000611 206361757365642062-
   732 0000061A 7920616E20696E7661-
   732 00000623 6C69642076616C7565-
   732 0000062C 206265696E67207061-
   732 00000635 7373656420746F2061-
   732 0000063E 2073797374656D     
   733 00000645 0D0A66756E6374696F-                             db      13,10,"function. The OSBOOT.COM file may be corrupt. Copy or download the file again"
   733 0000064E 6E2E20546865204F53-
   733 00000657 424F4F542E434F4D20-
   733 00000660 66696C65206D617920-
   733 00000669 626520636F72727570-
   733 00000672 742E20436F7079206F-
   733 0000067B 7220646F776E6C6F61-
   733 00000684 64207468652066696C-
   733 0000068D 6520616761696E     
   734 00000694 0D0A616E6420726574-                             db      13,10,"and retry."
   734 0000069D 72792E             
   735 000006A0 0D0A00                                          db      13,10,0
   736 000006A3 0D0A28303229204164-     czPrepMsgErr2           db      13,10,"(02) Address Mark Not Found"
   736 000006AC 6472657373204D6172-
   736 000006B5 6B204E6F7420466F75-
   736 000006BE 6E64               
   737 000006C0 0D0A54686973206572-                             db      13,10,"This error indicates a physical problem with the floppy diskette. Please retry"
   737 000006C9 726F7220696E646963-
   737 000006D2 617465732061207068-
   737 000006DB 79736963616C207072-
   737 000006E4 6F626C656D20776974-
   737 000006ED 682074686520666C6F-
   737 000006F6 707079206469736B65-
   737 000006FF 7474652E20506C6561-
   737 00000708 7365207265747279   
   738 00000710 0D0A7573696E672061-                             db      13,10,"using another diskette."
   738 00000719 6E6F74686572206469-
   738 00000722 736B657474652E     
   739 00000729 0D0A00                                          db      13,10,0
   740 0000072C 0D0A28303329205072-     czPrepMsgErr3           db      13,10,"(03) Protected Disk"
   740 00000735 6F7465637465642044-
   740 0000073E 69736B             
   741 00000741 0D0A54686973206572-                             db      13,10,"This error is usually caused by attempting to write to a write-protected disk."
   741 0000074A 726F72206973207573-
   741 00000753 75616C6C7920636175-
   741 0000075C 736564206279206174-
   741 00000765 74656D7074696E6720-
   741 0000076E 746F20777269746520-
   741 00000777 746F20612077726974-
   741 00000780 652D70726F74656374-
   741 00000789 6564206469736B2E   
   742 00000791 0D0A436865636B2074-                             db      13,10,"Check the 'write-protect' setting on the disk or retry using using another disk."
   742 0000079A 686520277772697465-
   742 000007A3 2D70726F7465637427-
   742 000007AC 2073657474696E6720-
   742 000007B5 6F6E20746865206469-
   742 000007BE 736B206F7220726574-
   742 000007C7 7279207573696E6720-
   742 000007D0 7573696E6720616E6F-
   742 000007D9 74686572206469736B-
   742 000007E2 2E                 
   743 000007E3 0D0A00                                          db      13,10,0
   744 000007E6 0D0A28303629204469-     czPrepMsgErr6           db      13,10,"(06) Diskette Removed"
   744 000007EF 736B65747465205265-
   744 000007F8 6D6F766564         
   745 000007FD 0D0A54686973206572-                             db      13,10,"This error may indicate that the floppy diskette has been removed from the"
   745 00000806 726F72206D61792069-
   745 0000080F 6E6469636174652074-
   745 00000818 686174207468652066-
   745 00000821 6C6F70707920646973-
   745 0000082A 6B6574746520686173-
   745 00000833 206265656E2072656D-
   745 0000083C 6F7665642066726F6D-
   745 00000845 20746865           
   746 00000849 0D0A6469736B657474-                             db      13,10,"diskette drive. On some systems, this code may also occur if the diskette is"
   746 00000852 652064726976652E20-
   746 0000085B 4F6E20736F6D652073-
   746 00000864 797374656D732C2074-
   746 0000086D 68697320636F646520-
   746 00000876 6D617920616C736F20-
   746 0000087F 6F6363757220696620-
   746 00000888 746865206469736B65-
   746 00000891 747465206973       
   747 00000897 0D0A27777269746520-                             db      13,10,"'write protected.' Please verify that the diskette is not write-protected and"
   747 000008A0 70726F746563746564-
   747 000008A9 2E2720506C65617365-
   747 000008B2 207665726966792074-
   747 000008BB 686174207468652064-
   747 000008C4 69736B657474652069-
   747 000008CD 73206E6F7420777269-
   747 000008D6 74652D70726F746563-
   747 000008DF 74656420616E64     
   748 000008E6 0D0A69732070726F70-                             db      13,10,"is properly inserted in the diskette drive."
   748 000008EF 65726C7920696E7365-
   748 000008F8 7274656420696E2074-
   748 00000901 6865206469736B6574-
   748 0000090A 74652064726976652E 
   749 00000913 0D0A00                                          db      13,10,0
   750 00000916 0D0A28383029204472-     czPrepMsgErr80          db      13,10,"(80) Drive Timed Out"
   750 0000091F 6976652054696D6564-
   750 00000928 204F7574           
   751 0000092C 0D0A54686973206572-                             db      13,10,"This error usually indicates that no diskette is in the diskette drive. Please"
   751 00000935 726F7220757375616C-
   751 0000093E 6C7920696E64696361-
   751 00000947 746573207468617420-
   751 00000950 6E6F206469736B6574-
   751 00000959 746520697320696E20-
   751 00000962 746865206469736B65-
   751 0000096B 747465206472697665-
   751 00000974 2E20506C65617365   
   752 0000097C 0D0A6D616B65207375-                             db      13,10,"make sure that the diskette is properly seated in the drive and retry."
   752 00000985 726520746861742074-
   752 0000098E 6865206469736B6574-
   752 00000997 74652069732070726F-
   752 000009A0 7065726C7920736561-
   752 000009A9 74656420696E207468-
   752 000009B2 652064726976652061-
   752 000009BB 6E642072657472792E 
   753 000009C4 0D0A00                                          db      13,10,0
   754 000009C7 0D0A283F3F2920556E-     czPrepMsgErrXX          db      13,10,"(??) Unknown Error"
   754 000009D0 6B6E6F776E20457272-
   754 000009D9 6F72               
   755 000009DB 0D0A54686520657272-                             db      13,10,"The error-code returned by the BIOS is not a recognized error. Please consult"
   755 000009E4 6F722D636F64652072-
   755 000009ED 657475726E65642062-
   755 000009F6 79207468652042494F-
   755 000009FF 53206973206E6F7420-
   755 00000A08 61207265636F676E69-
   755 00000A11 7A6564206572726F72-
   755 00000A1A 2E20506C6561736520-
   755 00000A23 636F6E73756C74     
   756 00000A2A 0D0A796F757220636F-                             db      13,10,"your computer's technical reference for a description of this error code."
   756 00000A33 6D7075746572277320-
   756 00000A3C 746563686E6963616C-
   756 00000A45 207265666572656E63-
   756 00000A4E 6520666F7220612064-
   756 00000A57 65736372697074696F-
   756 00000A60 6E206F662074686973-
   756 00000A69 206572726F7220636F-
   756 00000A72 64652E             
   757 00000A75 0D0A00                                          db      13,10,0
   758                                  wcPrepInBuf             equ     $
   759                                  %endif
   760                                  %ifdef BUILDDISK
   761                                  ;=======================================================================================================================
   762                                  ;
   763                                  ;       File Allocation Tables
   764                                  ;
   765                                  ;       The disk contains two copies of the File Allocation Table (FAT). On our disk, each FAT copy is 1200h bytes in
   766                                  ;       length. Each FAT entry contains the logical number of the next cluster. The first two entries are reserved. Our
   767                                  ;       OS.COM file here is 400h bytes in length. These 400h bytes contain familiar code that displays a message to the
   768                                  ;       screen. Our disk parameter table defines a cluster as containing one sector and each sector having 200h bytes.
   769                                  ;       Therefore, our FAT table must reserve only two clusters for OS.COM. The clusters used by OS.COM, then, will be
   770                                  ;       clusters 2 and 3. The entry value for cluster 3 is set to "0fffh" to indicate that it is the last cluster in the
   771                                  ;       chain.
   772                                  ;
   773                                  ;       Every three bytes encode two FAT entries as follows:
   774                                  ;
   775                                  ;       db      0abh,0cdh,0efh  ;even cluster: 0dabh, odd cluster: 0efch
   776                                  ;
   777                                  ;=======================================================================================================================
   778                                  ;-----------------------------------------------------------------------------------------------------------------------
   779                                  ;
   780                                  ;       FAT copy 1                                                              @disk: 000200   @mem: n/a
   781                                  ;
   782                                  ;-----------------------------------------------------------------------------------------------------------------------
   783                                  section                 fat1                                                    ;first copy of FAT
   784                                                          db      0F0h,0FFh,0FFh, 003h,0F0h,0FFh
   785                                                          times   (9*512)-($-$$) db 0                             ;zero fill to end of section
   786                                  ;-----------------------------------------------------------------------------------------------------------------------
   787                                  ;
   788                                  ;       FAT copy 2                                                              @disk: 001400   @mem: n/a
   789                                  ;
   790                                  ;-----------------------------------------------------------------------------------------------------------------------
   791                                  section                 fat2                                                    ;second copy of FAT
   792                                                          db      0F0h,0FFh,0FFh, 003h,0F0h,0FFh
   793                                                          times   (9*512)-($-$$) db 0                             ;zero fill to end of section
   794                                  ;-----------------------------------------------------------------------------------------------------------------------
   795                                  ;
   796                                  ;       Diskette Directory                                                      @disk: 002600   @mem: n/a
   797                                  ;
   798                                  ;       The disk contains one copy of the diskette directory. Each directory entry is 32 bytes long. Our directory
   799                                  ;       contains only one entry. Unused entries are set to all nulls. The directory immediately follows the second FAT
   800                                  ;       copy.
   801                                  ;
   802                                  ;-----------------------------------------------------------------------------------------------------------------------
   803                                  section                 dir                                                     ;diskette directory
   804                                                          db      "OS      COM"                                   ;file name (must contain spaces)
   805                                                          db      020h                                            ;attribute (archive bit set)
   806                                                          times   10 db 0                                         ;unused
   807                                                          dw      0h                                              ;time
   808                                                          db      01000001b                                       ;mmm = 10 MOD 8 = 2; ddddd = 1
   809                                                          db      01001001b                                       ;yyyyyyy = 2016-1980 = 36 = 24h; m/8 = 1
   810                                                          dw      2                                               ;first cluster
   811                                                          dd      400h                                            ;file size
   812                                                          times   (EBOOTDIRENTRIES*32)-($-$$) db 0h               ;zero fill to end of section
   813                                  %endif
   814                                  %ifdef BUILDCOM
   815                                  ;=======================================================================================================================
   816                                  ;
   817                                  ;       OS.COM
   818                                  ;
   819                                  ;       The operating system file is assembled at the start of the data area of the floppy disk image, which
   820                                  ;       immediately follows the directory. This corresponds to logical cluster 2, even though the physical address of
   821                                  ;       this sector on the disk varies depending on the disk type. The os.com file consists of two parts, the OS loader
   822                                  ;       and the OS kernel. The Loader is 16-bit code that receives control directly from the boot sector code after the
   823                                  ;       OS.COM file is loaded into memory. The kernel is 32-bit code that receives control after the Loader has
   824                                  ;       initialized protected-mode tables and 32-bit interrupt handlers and switched the CPU into protected mode.
   825                                  ;
   826                                  ;       Our loader addressability is set up according to the following diagram.
   827                                  ;
   828                                  ;       SS -----------> 007b00  +-----------------------------------------------+ SS:0000
   829                                  ;                               |  Boot Stack & Boot PSP (Unused)               |
   830                                  ;                               |  256 = 100h bytes                             |
   831                                  ;       SS:SP --------> 007c00  +-----------------------------------------------+ SS:0100  07b0:0100
   832                                  ;                               |  Boot Sector (vstart=0100h)                   |
   833                                  ;                               |  1 sector = 512 = 200h bytes                  |
   834                                  ;                       007e00  +-----------------------------------------------+
   835                                  ;                               |  File Allocation Table (FAT) I/O Buffer       |
   836                                  ;                               |  9 x 512-byte sectors = 4,608 = 1200h bytes   |
   837                                  ;                               |                                               |
   838                                  ;       CS,DS,ES -----> 008f00  |  Loader PSP (Unused)                          | DS:0000
   839                                  ;                               |                                               |
   840                                  ;       CS:IP --------> 009000  +-----------------------------------------------+ DS:0100  08f0:0100
   841                                  ;                               |  Loader Code                                  |
   842                                  ;                               |  2 sectors = 1024 = 400h bytes                |
   843                                  ;                       009400  +-----------------------------------------------+ DS:0500
   844                                  ;
   845                                  ;=======================================================================================================================
   846                                  ;-----------------------------------------------------------------------------------------------------------------------
   847                                  ;
   848                                  ;       OS Loader                                                               @disk: 004200   @mem: 009000
   849                                  ;
   850                                  ;       This code is the operating system loader. It resides on the boot disk at the start of the data area, following
   851                                  ;       the directory. The loader occupies several clusters that are mapped in the file allocation tables above.
   852                                  ;       The loader executes 16-bit instructions in real mode. It performs several initialization functions such as
   853                                  ;       determining whether the CPU and other resources are sufficient to run the operating system. If all minimum
   854                                  ;       resources are present, the loader initializes protected mode tables, places the CPU into protected mode and
   855                                  ;       starts the console task. Since the loader was called either from the bootstrap or as a .com file on the boot
   856                                  ;       disk, we can assume that the initial IP is 0x100 and not perform any absolute address fix-ups on our segment
   857                                  ;       registers.
   858                                  ;
   859                                  ;-----------------------------------------------------------------------------------------------------------------------
   860                                                          cpu     8086                                            ;assume minimal CPU
   861                                  section                 loader  vstart=0100h                                    ;use .COM compatible addressing
   862                                                          bits    16                                              ;this is 16-bit code
   863                                  Loader                  push    cs                                              ;use the code segment
   864                                                          pop     ds                                              ;...as our data segment
   865                                                          push    cs                                              ;use the code segment
   866                                                          pop     es                                              ;...as our extra segment
   867                                  ;
   868                                  ;       Write a message to the console so we know we have our addressability established.
   869                                  ;
   870                                                          mov     si,czStartingMsg                                ;starting message
   871                                                          call    PutTTYString                                    ;display loader message
   872                                  ;
   873                                  ;       Now we want to wait for a keypress. We can use a keyboard interrupt function for this (INT 16h, AH=0).
   874                                  ;       However, some hypervisor BIOS implementations have been seen to implement the "wait" as simply a fast
   875                                  ;       iteration of the keyboard status function call (INT 16h, AH=1), causing a max CPU condition. So, instead,
   876                                  ;       we will use the keyboard status call and iterate over a halt (HLT) instruction until a key is pressed.
   877                                  ;       By convention, we enable maskable interrupts with STI before issuing HLT, so as not to catch fire.
   878                                  ;
   879                                  .30                     mov     ah,EBIOSFNKEYSTATUS                             ;keyboard status function
   880                                                          int     EBIOSINTKEYBOARD                                ;call BIOS keyboard interrupt
   881                                                          jnz     .40                                             ;exit if key pressed
   882                                                          sti                                                     ;enable maskable interrupts
   883                                                          hlt                                                     ;wait for interrupt
   884                                                          jmp     .30                                             ;repeat until keypress
   885                                  ;
   886                                  ;       Now that a key has been pressed, we signal the system to restart by driving the B0 line on the 8042
   887                                  ;       keyboard controller low (OUT 64h,0feh). The restart may take some microseconds to kick in, so we issue
   888                                  ;       HLT until the system resets.
   889                                  ;
   890                                  .40                     mov     al,EKEYBCMDRESET                                ;8042 pulse output port pin
   891                                                          out     EKEYBPORTSTAT,al                                ;drive B0 low to restart
   892                                  .50                     sti                                                     ;enable maskable interrupts
   893                                                          hlt                                                     ;stop until reset, int, nmi
   894                                                          jmp     .50                                             ;loop until restart kicks in
   895                                  ;-----------------------------------------------------------------------------------------------------------------------
   896                                  ;
   897                                  ;       Routine:        PutTTYString
   898                                  ;
   899                                  ;       Description:    This routine sends a NUL-terminated string of characters to the TTY output device. We use the
   900                                  ;                       TTY output function of the BIOS video interrupt, passing the address of the string in DS:SI
   901                                  ;                       and the BIOS teletype function code in AH. After a return from the BIOS interrupt, we repeat
   902                                  ;                       for the next string character until a NUL is found. Note that we clear the direction flag (DF)
   903                                  ;                       with CLD before the first LODSB. The direction flag is not guaranteed to be preseved between
   904                                  ;                       calls within the OS. However, the "int" instruction does store the EFLAGS register on the
   905                                  ;                       stack and restores it on return. Therefore, clearing the direction flag before subsequent calls
   906                                  ;                       to LODSB is not needed.
   907                                  ;
   908                                  ;       In:             DS:SI   address of string
   909                                  ;
   910                                  ;       Out:            DF      0
   911                                  ;                       ZF      1
   912                                  ;                       AL      0
   913                                  ;
   914                                  ;-----------------------------------------------------------------------------------------------------------------------
   915                                  PutTTYString            cld                                                     ;forward strings
   916                                  .10                     lodsb                                                   ;load next byte at DS:SI in AL
   917                                                          test    al,al                                           ;end of string?
   918                                                          jz      .20                                             ;... yes, exit our loop
   919                                                          mov     ah,EBIOSFNTTYOUTPUT                             ;BIOS teletype function
   920                                                          int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
   921                                                          jmp     .10                                             ;repeat until done
   922                                  .20                     ret                                                     ;return
   923                                  ;-----------------------------------------------------------------------------------------------------------------------
   924                                  ;
   925                                  ;       Loader Data
   926                                  ;
   927                                  ;       Our only "data" is the string displayed when system starts. It ends with ASCII carriage-return (13) and line-
   928                                  ;       feed (10) values. The remainder of the boot sector is filled with NUL. The boot sector finally ends with the
   929                                  ;       required two-byte signature checked by the BIOS. Note that recent versions of NASM will issue a warning if
   930                                  ;       the calculated address for the end-of-sector signature produces a negative value for "1024-($-$$)". This will
   931                                  ;       indicate if we have added too much data and exceeded the length of the sector. Note also that since we are at
   932                                  ;       the end of a "file" (os.com) and not the boot sector, there is no end-of-sector marker (0x55 0xaa) here.
   933                                  ;
   934                                  ;-----------------------------------------------------------------------------------------------------------------------
   935                                  czStartingMsg           db      "Starting OS",13,10,0                           ;starting message
   936                                                          times   1024-($-$$) db 0h                               ;zero fill to end of sector
   937                                  %endif
   938                                  %ifdef BUILDDISK
   939                                  ;-----------------------------------------------------------------------------------------------------------------------
   940                                  ;
   941                                  ;       Free Disk Space                                                         @disk: 004600   @mem:  n/a
   942                                  ;
   943                                  ;       Following the convention introduced by DOS, we use the value 'F6' to indicate unused floppy disk storage.
   944                                  ;
   945                                  ;-----------------------------------------------------------------------------------------------------------------------
   946                                  section                 unused                                                  ;unused disk space
   947                                                          times   EBOOTDISKBYTES-04600h db 0F6h                   ;fill to end of disk image
   948                                  %endif
   949                                  ;=======================================================================================================================
   950                                  ;
   951                                  ;       End of Program Code
   952                                  ;
   953                                  ;=======================================================================================================================
