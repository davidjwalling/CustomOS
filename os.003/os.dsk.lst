     1                                  ;=======================================================================================================================
     2                                  ;
     3                                  ;       File:           os.asm
     4                                  ;
     5                                  ;       Project:        os.003
     6                                  ;
     7                                  ;       Description:    This sample program adds code to create osprep.com, a program to update the boot sector on a
     8                                  ;                       floppy disk. This utility can be useful in creating floppy boot diskettes from native DOS or
     9                                  ;                       within a DOS VM.
    10                                  ;
    11                                  ;       Revised:        17 June 2019
    12                                  ;
    13                                  ;       Assembly:       nasm os.asm -f bin -o os.dat     -l os.dat.lst     -DBUILDBOOT
    14                                  ;                       nasm os.asm -f bin -o os.dsk     -l os.dsk.lst     -DBUILDDISK
    15                                  ;                       nasm os.asm -f bin -o os.com     -l os.com.lst     -DBUILDCOM
    16                                  ;                       nasm os.asm -f bin -o osprep.com -l osprep.com.lst -DBUILDPREP
    17                                  ;
    18                                  ;       Assembler:      Netwide Assembler (NASM) 2.13.03, 7 Feb 2018
    19                                  ;
    20                                  ;       Notice:         Copyright (C) 2010-2019 David J. Walling
    21                                  ;
    22                                  ;=======================================================================================================================
    23                                  ;-----------------------------------------------------------------------------------------------------------------------
    24                                  ;
    25                                  ;       Assembly Directives
    26                                  ;
    27                                  ;       Use one of the following as an assembly directive (-D) with NASM.
    28                                  ;
    29                                  ;       BUILDBOOT       Creates os.dat, a 512-byte boot sector as a standalone file.
    30                                  ;       BUILDDISK       Creates os.dsk, a 1.44MB (3.5") floppy disk image file.
    31                                  ;       BUILDCOM        Creates os.com, the OS loader and kernel as a standalone DOS program.
    32                                  ;       BUILDPREP       Creates osprep.com, a DOS program that prepares a floppy disk to boot the OS
    33                                  ;
    34                                  ;-----------------------------------------------------------------------------------------------------------------------
    35                                  %ifdef BUILDDISK                                                                ;if we are building a disk image ...
    36                                  %define BUILDBOOT                                                               ;... also build the boot sector
    37                                  %define BUILDCOM                                                                ;... and the OS kernel
    38                                  %endif
    39                                  %ifdef BUILDPREP                                                                ;if creating the disk prep program ...
    40                                  %define BUILDBOOT                                                               ;... also build the boot sector
    41                                  %endif
    42                                  ;-----------------------------------------------------------------------------------------------------------------------
    43                                  ;
    44                                  ;       Conventions
    45                                  ;
    46                                  ;       Alignment:      In this document, columns are numbered beginning with 1. Logical tabs are set after every
    47                                  ;                       eight columns. Tabs are simulated using SPACE characters. Comments that span an entire line
    48                                  ;                       have a semicolon in line 1 and text begins in column 9. Assembly instructions (mnemonics)
    49                                  ;                       begin in column 25. Assembly operands begin in column 33. Inline comments begin in column 81.
    50                                  ;                       Lines should not extend beyond column 120.
    51                                  ;
    52                                  ;       Arguments:      Arguments are passed as registers and generally follow this order: EAX, ECX, EDX, EBX. ECX
    53                                  ;                       may be used as the sole parameter if a test for zero is required. EBX and EBP may be used as
    54                                  ;                       parameters if the routine is considered a "method" of an "object". In this case, EBX or EBP
    55                                  ;                       will address the object storage. If the routine is general-purpose string or character-array
    56                                  ;                       manipulator, ESI and EDI may be used as parameters to address input and/or ouput buffers.
    57                                  ;
    58                                  ;       Code Order:     Routines should appear in the order of their first likely use. Negative relative call or jump
    59                                  ;                       addresses usually, therefore, indicate reuse.
    60                                  ;
    61                                  ;       Comments:       A comment that spans the entire line begins with a semicolon in column 1. A comment that
    62                                  ;                       accompanies code on a line begins with a semicolon in column 81. Register names in comments
    63                                  ;                       are in upper case (EAX, EDI). Hexadecimal values in comments are in lower case (01fh, 0dah).
    64                                  ;                       Routines are preceded with a comment box that includes the routine name, description, and
    65                                  ;                       register contents on entry and exit, if applicable.
    66                                  ;
    67                                  ;       Constants:      Symbolic constants (equates) are named in all-caps beginning with 'E' (EDATAPORT). Constant
    68                                  ;                       stored values are named in camel case, starting with 'c' (cbMaxLines). The 2nd letter of the
    69                                  ;                       constant label indicates the storage type.
    70                                  ;
    71                                  ;                       cq......        constant quad-word (dq)
    72                                  ;                       cd......        constant double-word (dd)
    73                                  ;                       cw......        constant word (dw)
    74                                  ;                       cb......        constant byte (db)
    75                                  ;                       cz......        constant ASCIIZ (null-terminated) string
    76                                  ;                       cs......        constant non-terminated string (sequence of characters)
    77                                  ;
    78                                  ;       Instructions:   32-bit instructions are generally favored. 8-bit instructions and data are preferred for
    79                                  ;                       flags and status fields, etc. 16-bit instructions are avoided wherever possible to limit
    80                                  ;                       the generation of prefix bytes.
    81                                  ;
    82                                  ;       Labels:         Labels within a routine are numeric and begin with a period (.10, .20). Labels within a
    83                                  ;                       routine begin at ".10" and increment by 10.
    84                                  ;
    85                                  ;       Literals:       Literal values defined by external standards should be defined as symbolic constants
    86                                  ;                       (equates). Hexadecimal literals in code are in upper case with a leading '0' and trailing
    87                                  ;                       'h' (01Fh). Binary literal values in source code are encoded with a final 'b' (1010b).
    88                                  ;                       Decimal literal values in source code are strictly numerals (2048). Octal literal values
    89                                  ;                       are avoided. String literals are enclosed in double quotes, e.g. "Loading OS". Single
    90                                  ;                       character literals are enclosed in single quotes, e.g. 'A'.
    91                                  ;
    92                                  ;       Macros:         Macro names are in camel case, beginning with a lower-case letter (getDateString). Macro
    93                                  ;                       names describe an action and begin with a verb.
    94                                  ;
    95                                  ;       Memory Use:     Operating system memory allocation is avoided. Buffers are kept to as small a size as
    96                                  ;                       practicable. Data and code intermingling is avoided.
    97                                  ;
    98                                  ;       Registers:      Register names in comments are in upper case (EAX, EDX). Register names in source code are
    99                                  ;                       in lower case (eax, edx).
   100                                  ;
   101                                  ;       Return Values:  Routines return result values in EAX or ECX or both. Routines should indicate failure by
   102                                  ;                       setting the carry flag to 1. Routines may prefer the use of ECX as a return value if the
   103                                  ;                       value is to be tested for null upon return (using the jecxz instruction).
   104                                  ;
   105                                  ;       Routines:       Routine names are in mixed case and capitalized (GetYear, ReadRealTimeClock). Routine names
   106                                  ;                       begin with a verb (Get, Read, Load). Routines should have a single entry address and a single
   107                                  ;                       exit instruction (ret, iretd, etc.). Routines that serve as wrappers for library functions
   108                                  ;                       carry the same name as the library function but begin with a leading underscore (_) character.
   109                                  ;
   110                                  ;       Structures:     Structure names are in all-caps (DATETIME). Structure names describe a "thing" and so do NOT
   111                                  ;                       begin with a verb.
   112                                  ;
   113                                  ;       Usage:          Registers EBX, ECX, EBP, SS, CS, DS and ES are preserved by routines. Registers ESI and EDI
   114                                  ;                       are preserved unless they are input parameters. Registers EAX and ECX are preferred for
   115                                  ;                       returning response/result values. Registers EBX and EBP are preferred for context (structure)
   116                                  ;                       address parameters. Registers EAX, ECX, EDX and EBX are preferred for integral parameters.
   117                                  ;
   118                                  ;       Variables:      Variables are named in camel case, starting with 'w'. The 2nd letter of the variable label
   119                                  ;                       indicates the storage type.
   120                                  ;
   121                                  ;                       wq......        variable quad-word (resq)
   122                                  ;                       wd......        variable double-word (resd)
   123                                  ;                       ww......        variable word (resw)
   124                                  ;                       wb......        variable byte (resb)
   125                                  ;                       ws......        writable structure
   126                                  ;
   127                                  ;-----------------------------------------------------------------------------------------------------------------------
   128                                  ;=======================================================================================================================
   129                                  ;
   130                                  ;       Equates
   131                                  ;
   132                                  ;       The equate (equ) statement defines a symbolic name for a fixed value so that such a value can be defined and
   133                                  ;       verified once and then used throughout the code. Using symbolic names simplifies searching for where logical
   134                                  ;       values are used. Equate names are in all-caps and begin with the letter 'E'. Equates are grouped into related
   135                                  ;       sets. Equates in this sample program are defined in the following groupings:
   136                                  ;
   137                                  ;       Hardware-Defined Values
   138                                  ;
   139                                  ;       EKEYB...        8042 or "PS/2 Controller" (Keyboard Controller) values
   140                                  ;
   141                                  ;       Firmware-Defined Values
   142                                  ;
   143                                  ;       EBIOS...        Basic Input/Output System (BIOS) values
   144                                  ;
   145                                  ;       Standards-Based Values
   146                                  ;
   147                                  ;       EASCII...       American Standard Code for Information Interchange (ASCII) values
   148                                  ;
   149                                  ;       Operating System Values
   150                                  ;
   151                                  ;       EBOOT...        Boot sector and loader values
   152                                  ;
   153                                  ;=======================================================================================================================
   154                                  ;-----------------------------------------------------------------------------------------------------------------------
   155                                  ;
   156                                  ;       Hardware-Defined Values
   157                                  ;
   158                                  ;-----------------------------------------------------------------------------------------------------------------------
   159                                  ;-----------------------------------------------------------------------------------------------------------------------
   160                                  ;
   161                                  ;       8042 Keyboard Controller                                                EKEYB...
   162                                  ;
   163                                  ;       The 8042 Keyboard Controller (8042) is a programmable controller that accepts input signals from the keyboard
   164                                  ;       device. It also signals a hardware interrupt to the CPU when the low-order bit of I/O port 64h is set to zero.
   165                                  ;
   166                                  ;-----------------------------------------------------------------------------------------------------------------------
   167                                  EKEYBPORTSTAT           equ     064h                                            ;status port
   168                                  EKEYBCMDRESET           equ     0FEh                                            ;reset bit 0 to restart system
   169                                  ;-----------------------------------------------------------------------------------------------------------------------
   170                                  ;
   171                                  ;       Firmware-Defined Values
   172                                  ;
   173                                  ;-----------------------------------------------------------------------------------------------------------------------
   174                                  ;-----------------------------------------------------------------------------------------------------------------------
   175                                  ;
   176                                  ;       BIOS Interrupts and Functions                                           EBIOS...
   177                                  ;
   178                                  ;       Basic Input/Output System (BIOS) functions are grouped and accessed by issuing an interrupt call. Each
   179                                  ;       BIOS interrupt supports several functions. The function code is typically passed in the AH register.
   180                                  ;
   181                                  ;-----------------------------------------------------------------------------------------------------------------------
   182                                  EBIOSINTVIDEO           equ     010h                                            ;video services interrupt
   183                                  EBIOSFNSETVMODE         equ     000h                                            ;video set mode function
   184                                  EBIOSMODETEXT80         equ     003h                                            ;video mode 80x25 text
   185                                  EBIOSFNTTYOUTPUT        equ     00Eh                                            ;video TTY output function
   186                                  EBIOSINTDISKETTE        equ     013h                                            ;diskette services interrupt
   187                                  EBIOSFNREADSECTOR       equ     002h                                            ;diskette read sector function
   188                                  EBIOSFNWRITESECTOR      equ     003h                                            ;diskette write sector function
   189                                  EBIOSINTKEYBOARD        equ     016h                                            ;keyboard services interrupt
   190                                  EBIOSFNKEYSTATUS        equ     001h                                            ;keyboard status function
   191                                  ;-----------------------------------------------------------------------------------------------------------------------
   192                                  ;
   193                                  ;       Standards-Based Values
   194                                  ;
   195                                  ;-----------------------------------------------------------------------------------------------------------------------
   196                                  ;-----------------------------------------------------------------------------------------------------------------------
   197                                  ;
   198                                  ;       ASCII                                                                   EASCII...
   199                                  ;
   200                                  ;-----------------------------------------------------------------------------------------------------------------------
   201                                  EASCIIRETURN            equ     00Dh                                            ;carriage return
   202                                  EASCIIESCAPE            equ     01Bh                                            ;escape
   203                                  ;-----------------------------------------------------------------------------------------------------------------------
   204                                  ;
   205                                  ;       Operating System Values
   206                                  ;
   207                                  ;-----------------------------------------------------------------------------------------------------------------------
   208                                  ;-----------------------------------------------------------------------------------------------------------------------
   209                                  ;
   210                                  ;       Boot Sector and Loader Constants                                        EBOOT...
   211                                  ;
   212                                  ;       Equates in this section support the boot sector and the 16-bit operating system loader, which will be
   213                                  ;       responsible for placing the CPU into protected mode and calling the initial operating system task.
   214                                  ;
   215                                  ;-----------------------------------------------------------------------------------------------------------------------
   216                                  EBOOTSTACKTOP           equ     0100h                                           ;boot sector stack top relative to DS
   217                                  EBOOTSECTORBYTES        equ     512                                             ;bytes per sector
   218                                  EBOOTDIRENTRIES         equ     224                                             ;directory entries (1.44MB 3.5" FD)
   219                                  EBOOTDISKSECTORS        equ     2880                                            ;sectors per disk (1.44MB 3.5" FD)
   220                                  EBOOTDISKBYTES          equ     (EBOOTSECTORBYTES*EBOOTDISKSECTORS)             ;bytes per disk
   221                                  EBOOTFATBASE            equ     (EBOOTSTACKTOP+EBOOTSECTORBYTES)                ;offset of FAT I/O buffer rel to DS
   222                                  EBOOTMAXTRIES           equ     5                                               ;max read retries
   223                                  %ifdef BUILDBOOT
   224                                  ;=======================================================================================================================
   225                                  ;
   226                                  ;       Boot Sector                                                             @disk: 000000   @mem: 007c00
   227                                  ;
   228                                  ;       The first sector of the diskette is the boot sector. The BIOS will load the boot sector into memory and pass
   229                                  ;       control to the code at the start of the sector. The boot sector code is responsible for loading the operating
   230                                  ;       system into memory. The boot sector contains a disk parameter table describing the geometry and allocation
   231                                  ;       of the diskette. Following the disk parameter table is code to load the operating system kernel into memory.
   232                                  ;
   233                                  ;       The "cpu" directive limits emitted code to those instructions supported by the most primitive processor
   234                                  ;       we expect to ever execute our code. The "vstart" parameter indicates addressability of symbols so as to
   235                                  ;       emulate the DOS .COM program model. Although the BIOS is expected to load the boot sector at address 7c00,
   236                                  ;       we do not make that assumption. The CPU starts in 16-bit addressing mode. A three-byte jump instruction is
   237                                  ;       immediately followed by the disk parameter table.
   238                                  ;
   239                                  ;=======================================================================================================================
   240                                                          cpu     8086                                            ;assume minimal CPU
   241                                  section                 boot    vstart=0100h                                    ;emulate .COM (CS,DS,ES=PSP) addressing
   242                                                          bits    16                                              ;16-bit code at power-up
   243                                  %ifdef BUILDPREP
   244                                  Boot                    jmp     word Prep                                       ;jump to preparation code
   245                                  %else
   246 00000000 E91B00                  Boot                    jmp     word Boot.10                                    ;jump over parameter table
   247                                  %endif
   248                                  ;-----------------------------------------------------------------------------------------------------------------------
   249                                  ;
   250                                  ;       Disk Parameter Table
   251                                  ;
   252                                  ;       The disk parameter table informs the BIOS of the floppy disk architecture. Here, we use parameters for the
   253                                  ;       3.5" 1.44MB floppy disk since this format is widely supported by virtual machine hypervisors.
   254                                  ;
   255                                  ;-----------------------------------------------------------------------------------------------------------------------
   256 00000003 4F53202020202020                                db      "OS      "                                      ;eight-byte label
   257 0000000B 0002                    cwSectorBytes           dw      EBOOTSECTORBYTES                                ;bytes per sector
   258 0000000D 01                      cbClusterSectors        db      1                                               ;sectors per cluster
   259 0000000E 0100                    cwReservedSectors       dw      1                                               ;reserved sectors
   260 00000010 02                      cbFatCount              db      2                                               ;file allocation table copies
   261 00000011 E000                    cwDirEntries            dw      EBOOTDIRENTRIES                                 ;max directory entries
   262 00000013 400B                    cwDiskSectors           dw      EBOOTDISKSECTORS                                ;sectors per disk
   263 00000015 F0                      cbDiskType              db      0F0h                                            ;1.44MB
   264 00000016 0900                    cwFatSectors            dw      9                                               ;sectors per FAT copy
   265                                  cbTrackSectors          equ     $                                               ;sectors per track (as byte)
   266 00000018 1200                    cwTrackSectors          dw      18                                              ;sectors per track (as word)
   267 0000001A 0200                    cwDiskSides             dw      2                                               ;sides per disk
   268 0000001C 0000                    cwSpecialSectors        dw      0                                               ;special sectors
   269                                  ;
   270                                  ;       BIOS typically loads the boot sector at absolute address 7c00 and sets the stack pointer at 512 bytes past
   271                                  ;       the end of the boot sector. But, since BIOS code varies, we don't make any assumptions as to where our boot
   272                                  ;       sector is loaded. For example, the initial CS:IP could be 0:7c00, 700:c00, 7c0:0, etc. To avoid assumptions,
   273                                  ;       we first normalize CS:IP to get the absolute segment address in BX. The comments below show the effect of this
   274                                  ;       code given several possible starting values for CS:IP.
   275                                  ;
   276                                                                                                                  ;CS:IP   0:7c00 700:c00 7c0:0
   277 0000001E E80000                  Boot.10                 call    word .20                                        ;[ESP] =   7c21     c21    21
   278                                  .@20                    equ     $-$$                                            ;.@20 = 021h
   279 00000021 58                      .20                     pop     ax                                              ;AX =      7c21     c21    21
   280 00000022 83E821                                          sub     ax,.@20                                         ;AX =      7c00     c00     0
   281 00000025 B104                                            mov     cl,4                                            ;shift count
   282 00000027 D3E8                                            shr     ax,cl                                           ;AX =       7c0      c0     0
   283 00000029 8CCB                                            mov     bx,cs                                           ;BX =         0     700   7c0
   284 0000002B 01C3                                            add     bx,ax                                           ;BX =       7c0     7c0   7c0
   285                                  ;
   286                                  ;       Now, since we are assembling our boot code to emulate the addressing of a .COM file, we want the DS and ES
   287                                  ;       registers to be set to where a Program Segment Prefix (PSP) would be, exactly 100h (256) bytes prior to
   288                                  ;       the start of our code. This will correspond to our assembled data address offsets. Note that we instructed
   289                                  ;       the assembler to produce addresses for our symbols that are offset from our code by 100h. See the "vstart"
   290                                  ;       parameter for the "section" directive above. We also set SS to the PSP and SP to the address of our i/o
   291                                  ;       buffer. This leaves 256 bytes of usable stack from 7b0:0 to 7b0:100.
   292                                  ;
   293                                  ;       Note that when a value is loaded into the stack segment register (SS) interrupts are disabled until the
   294                                  ;       completion of the following instruction.
   295                                  ;
   296 0000002D 83EB10                                          sub     bx,16                                           ;BX = 07b0
   297 00000030 8EDB                                            mov     ds,bx                                           ;DS = 07b0 = psp
   298 00000032 8EC3                                            mov     es,bx                                           ;ES = 07b0 = psp
   299 00000034 8ED3                                            mov     ss,bx                                           ;SS = 07b0 = psp (ints disabled)
   300 00000036 BC0001                                          mov     sp,EBOOTSTACKTOP                                ;SP = 0100       (ints enabled)
   301                                  ;
   302                                  ;       Our boot addressability is now set up according to the following diagram.
   303                                  ;
   304                                  ;       DS,ES,SS -----> 007b00  +-----------------------------------------------+ DS:0000
   305                                  ;                               |  Boot Stack & Boot PSP (Unused)               |
   306                                  ;                               |  256 = 100h bytes                             |
   307                                  ;       SS:SP --------> 007c00  +-----------------------------------------------+ DS:0100  07b0:0100
   308                                  ;                               |  Boot Sector (vstart=0100h)                   |
   309                                  ;                               |  1 sector = 512 = 200h bytes                  |
   310                                  ;                       007e00  +-----------------------------------------------+ DS:0300
   311                                  ;                               |  File Allocation Table (FAT) I/O Buffer       |
   312                                  ;                               |  9x512-byte sectors = 4,608 = 1200h bytes     |
   313                                  ;                       009000  +-----------------------------------------------+ DS:1500  08f0:0100
   314                                  ;                               |  Directory Sector Buffer & Kernel Load Area   |
   315                                  ;                               |  2 sectors = 1024 = 400h bytes
   316                                  ;                       009400  +-----------------------------------------------+ DS:1900
   317                                  ;
   318                                  ;       On entry, DL indicates the drive being booted from.
   319                                  ;
   320 00000039 8816[F801]                                      mov     [wbDrive],dl                                    ;[wbDrive] = drive being booted from
   321                                  ;
   322                                  ;       Compute directory i/o buffer address.
   323                                  ;
   324 0000003D A1[1600]                                        mov     ax,[cwFatSectors]                               ;AX = 0009 = FAT sectors
   325 00000040 F726[0B00]                                      mul     word [cwSectorBytes]                            ;DX:AX = 0000:1200 = FAT bytes
   326 00000044 050003                                          add     ax,EBOOTFATBASE                                 ;AX = 1500 = end of FAT buffer
   327 00000047 A3[EC01]                                        mov     [wwDirBuffer],ax                                ;[wwDirBuffer] = 1500
   328                                  ;
   329                                  ;       Compute segment where os.com will be loaded.
   330                                  ;
   331 0000004A D3E8                                            shr     ax,cl                                           ;AX = 0150
   332 0000004C 01D8                                            add     ax,bx                                           ;AX = 0150 + 07b0 = 0900
   333 0000004E 83E810                                          sub     ax,16                                           ;AX = 08f0
   334 00000051 A3[3F01]                                        mov     [wwLoadSegment],ax                              ;[wwLoadSegment] = 08f0
   335                                  ;
   336                                  ;       Set the video mode to 80 column, 25 row, text.
   337                                  ;
   338 00000054 B80300                                          mov     ax,EBIOSFNSETVMODE<<8|EBIOSMODETEXT80           ;set mode function, 80x25 text mode
   339 00000057 CD10                                            int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
   340                                  ;
   341                                  ;       Write a message to the console so we know we have our addressability established.
   342                                  ;
   343 00000059 BE[C501]                                        mov     si,czLoadMsg                                    ;loading message
   344 0000005C E84B01                                          call    BootPrint                                       ;display loader message
   345                                  ;
   346                                  ;       Initialize the number of directory sectors to search.
   347                                  ;
   348 0000005F A1[1100]                                        mov     ax,[cwDirEntries]                               ;AX = 224 = max dir entries
   349 00000062 A3[EE01]                                        mov     [wwEntriesLeft],ax                              ;[wwEntriesLeft] = 224
   350                                  ;
   351                                  ;       Compute number of directory sectors and initialize overhead count.
   352                                  ;
   353 00000065 89C1                                            mov     cx,ax                                           ;CX = 00e0 = 224 entries
   354 00000067 F726[B801]                                      mul     word [cwEntryLen]                               ;DX:AX = 224 * 32 = 7168
   355 0000006B F736[0B00]                                      div     word [cwSectorBytes]                            ;AX = 7168 / 512 = 14 = dir sectors
   356 0000006F A3[F001]                                        mov     [wwOverhead],ax                                 ;[wwOverhead] = 000e
   357                                  ;
   358                                  ;       Compute directory entries per sector.
   359                                  ;
   360 00000072 91                                              xchg    ax,cx                                           ;DX:AX = 0:00e0, CX = 0000e
   361 00000073 F7F1                                            div     cx                                              ;AX = 0010 = entries per dir sector
   362 00000075 A3[F201]                                        mov     [wwSectorEntries],ax                            ;[wwSectorEntries] = 0010
   363                                  ;
   364                                  ;       Compute first logical directory sector and update overhead count.
   365                                  ;
   366 00000078 A1[1600]                                        mov     ax,[cwFatSectors]                               ;AX = 0009 = FAT sectors per copy
   367 0000007B F626[1000]                                      mul     byte [cbFatCount]                               ;AX = 0012 = FAT sectors
   368 0000007F 0306[0E00]                                      add     ax,[cwReservedSectors]                          ;AX = 0013 = FAT plus reserved
   369 00000083 0306[1C00]                                      add     ax,[cwSpecialSectors]                           ;AX = 0013 = FAT + reserved + special
   370 00000087 A3[F401]                                        mov     [wwLogicalSector],ax                            ;[wwLogicalSector] = 0013
   371 0000008A 0106[F001]                                      add     [wwOverhead],ax                                 ;[wwOverhead] = 0021 = res+spec+FAT+dir
   372                                  ;
   373                                  ;       Read directory sector.
   374                                  ;
   375 0000008E B001                    .30                     mov     al,1                                            ;sector count
   376 00000090 A2[F601]                                        mov     [wbReadCount],al                                ;[wbReadCount] = 01
   377 00000093 8B1E[EC01]                                      mov     bx,[wwDirBuffer]                                ;BX = 1500
   378 00000097 E8A700                                          call    ReadSector                                      ;read sector into es:bx
   379                                  ;
   380                                  ;       Setup variables to search this directory sector.
   381                                  ;
   382 0000009A A1[EE01]                                        mov     ax,[wwEntriesLeft]                              ;directory entries to search
   383 0000009D 3B06[F201]                                      cmp     ax,[wwSectorEntries]                            ;need to search more sectors?
   384 000000A1 7603                                            jna     .40                                             ;no, continue
   385 000000A3 A1[F201]                                        mov     ax,[wwSectorEntries]                            ;yes, limit search to sector
   386 000000A6 2906[EE01]              .40                     sub     [wwEntriesLeft],ax                              ;update entries left to searh
   387 000000AA BE[BA01]                                        mov     si,cbKernelProgram                              ;program name
   388 000000AD 8B3E[EC01]                                      mov     di,[wwDirBuffer]                                ;DI = 1500
   389                                  ;
   390                                  ;       Loop through directory sectors searching for kernel program.
   391                                  ;
   392 000000B1 56                      .50                     push    si                                              ;save kernel name address
   393 000000B2 57                                              push    di                                              ;save dir i/o buffer address
   394 000000B3 B90B00                                          mov     cx,11                                           ;length of 8+3 name
   395 000000B6 FC                                              cld                                                     ;forward strings
   396 000000B7 F3A6                                            repe    cmpsb                                           ;compare entry name
   397 000000B9 5F                                              pop     di                                              ;restore dir i/o buffer address
   398 000000BA 5E                                              pop     si                                              ;restore kernel name address
   399 000000BB 7418                                            je      .60                                             ;exit loop if found
   400 000000BD 033E[B801]                                      add     di,[cwEntryLen]                                 ;point to next dir entry
   401 000000C1 48                                              dec     ax                                              ;decrement remaining entries
   402 000000C2 75ED                                            jnz     .50                                             ;next entry
   403                                  ;
   404                                  ;       Repeat search if we are not at the end of the directory.
   405                                  ;
   406 000000C4 FF06[F401]                                      inc     word [wwLogicalSector]                          ;increment logical sector
   407 000000C8 833E[EE01]00                                    cmp     word [wwEntriesLeft],0                          ;done with directory?
   408 000000CD 75BF                                            jne     .30                                             ;no, get next sector
   409 000000CF BE[E001]                                        mov     si,czNoKernel                                   ;missing kernel message
   410 000000D2 E9C000                                          jmp     BootExit                                        ;display message and exit
   411                                  ;
   412                                  ;       If we find the kernel program in the directory, read the FAT.
   413                                  ;
   414 000000D5 A1[0E00]                .60                     mov     ax,[cwReservedSectors]                          ;AX = 0001
   415 000000D8 A3[F401]                                        mov     [wwLogicalSector],ax                            ;start past boot sector
   416 000000DB A1[1600]                                        mov     ax,[cwFatSectors]                               ;AX = 0009
   417 000000DE A2[F601]                                        mov     [wbReadCount],al                                ;[wbReadCount] = 09
   418 000000E1 BB0003                                          mov     bx,EBOOTFATBASE                                 ;BX = 0300
   419 000000E4 E85A00                                          call    ReadSector                                      ;read FAT into buffer
   420                                  ;
   421                                  ;       Get the starting cluster of the kernel program and target address.
   422                                  ;
   423 000000E7 8B451A                                          mov     ax,[di+26]                                      ;AX = starting cluster of file
   424 000000EA C41E[3D01]                                      les     bx,[wwLoadOffset]                               ;ES:BX = kernel load add (08f0:0100)
   425                                  ;
   426                                  ;       Read each program cluster into RAM.
   427                                  ;
   428 000000EE 50                      .70                     push    ax                                              ;save cluster nbr
   429 000000EF 83E802                                          sub     ax,2                                            ;AX = cluster nbr base 0
   430 000000F2 8A0E[0D00]                                      mov     cl,[cbClusterSectors]                           ;CL = sectors per cluster
   431 000000F6 880E[F601]                                      mov     [wbReadCount],cl                                ;save sectors to read
   432 000000FA 30ED                                            xor     ch,ch                                           ;CX = sectors per cluster
   433 000000FC F7E1                                            mul     cx                                              ;DX:AX = logical cluster sector
   434 000000FE 0306[F001]                                      add     ax,[wwOverhead]                                 ;AX = kernel sector nbr
   435 00000102 A3[F401]                                        mov     [wwLogicalSector],ax                            ;save logical sector nbr
   436 00000105 E83900                                          call    ReadSector                                      ;read sectors into ES:BX
   437                                  ;
   438                                  ;       Update buffer pointer for next cluster.
   439                                  ;
   440 00000108 A0[0D00]                                        mov     al,[cbClusterSectors]                           ;AL = sectors per cluster
   441 0000010B 30E4                                            xor     ah,ah                                           ;AX = sectors per cluster
   442 0000010D F726[0B00]                                      mul     word [cwSectorBytes]                            ;DX:AX = cluster bytes
   443 00000111 01C3                                            add     bx,ax                                           ;BX = next cluster target address
   444 00000113 58                                              pop     ax                                              ;AX = restore cluster nbr
   445                                  ;
   446                                  ;       Compute next cluster number.
   447                                  ;
   448 00000114 89C1                                            mov     cx,ax                                           ;CX = cluster nbr
   449 00000116 89C7                                            mov     di,ax                                           ;DI = cluster nbr
   450 00000118 D1E8                                            shr     ax,1                                            ;AX = cluster/2
   451 0000011A 89C2                                            mov     dx,ax                                           ;DX = cluster/2
   452 0000011C 01D0                                            add     ax,dx                                           ;AX = 2*(cluster/2)
   453 0000011E 01D0                                            add     ax,dx                                           ;AX = 3*(cluster/2)
   454 00000120 83E701                                          and     di,1                                            ;get low bit
   455 00000123 01C7                                            add     di,ax                                           ;add one if cluster is odd
   456 00000125 81C70003                                        add     di,EBOOTFATBASE                                 ;add FAT buffer address
   457 00000129 8B05                                            mov     ax,[di]                                         ;get cluster bytes
   458                                  ;
   459                                  ;       Adjust cluster nbr by 4 bits if cluster is odd; test for end of chain.
   460                                  ;
   461 0000012B F6C101                                          test    cl,1                                            ;is cluster odd?
   462 0000012E 7404                                            jz      .80                                             ;no, skip ahead
   463 00000130 B104                                            mov     cl,4                                            ;shift count
   464 00000132 D3E8                                            shr     ax,cl                                           ;shift nybble low
   465 00000134 25FF0F                  .80                     and     ax,0FFFh                                        ;mask for 24 bits; next cluster nbr
   466 00000137 3DFF0F                                          cmp     ax,0FFFh                                        ;end of chain?
   467 0000013A 75B2                                            jne     .70                                             ;no, continue
   468                                  ;
   469                                  ;       Transfer control to the operating system program.
   470                                  ;
   471 0000013C EA                                              db      0EAh                                            ;jmp seg:offset
   472 0000013D 0001                    wwLoadOffset            dw      0100h                                           ;kernel entry offset
   473 0000013F F008                    wwLoadSegment           dw      08F0h                                           ;kernel entry segment (computed)
   474                                  ;
   475                                  ;       Read [wbReadCount] disk sectors from [wwLogicalSector] into ES:BX.
   476                                  ;
   477 00000141 A1[1800]                ReadSector              mov     ax,[cwTrackSectors]                             ;AX = sectors per track
   478 00000144 F726[1A00]                                      mul     word [cwDiskSides]                              ;DX:AX = sectors per cylinder
   479 00000148 89C1                                            mov     cx,ax                                           ;CX = sectors per cylinder
   480 0000014A A1[F401]                                        mov     ax,[wwLogicalSector]                            ;DX:AX = logical sector
   481 0000014D F7F1                                            div     cx                                              ;AX = cylinder; DX = cyl sector
   482 0000014F A2[FB01]                                        mov     [wbTrack],al                                    ;[wbTrack] = cylinder
   483 00000152 89D0                                            mov     ax,dx                                           ;AX = cyl sector
   484 00000154 F636[1800]                                      div     byte [cbTrackSectors]                           ;AH = sector, AL = head
   485 00000158 FEC4                                            inc     ah                                              ;AH = sector (1,2,3,...)
   486 0000015A A3[F901]                                        mov     [wbHead],ax                                     ;[wbHead]= head, [wwSectorTrack]= sector
   487                                  ;
   488                                  ;       Try maxtries times to read sector.
   489                                  ;
   490 0000015D B90500                                          mov     cx,EBOOTMAXTRIES                                ;CX = 0005
   491 00000160 53                      .10                     push    bx                                              ;save buffer address
   492 00000161 51                                              push    cx                                              ;save retry count
   493 00000162 8B16[F801]                                      mov     dx,[wwDriveHead]                                ;DH = head, DL = drive
   494 00000166 8B0E[FA01]                                      mov     cx,[wwSectorTrack]                              ;CH = track, CL = sector
   495 0000016A A1[F601]                                        mov     ax,[wwReadCountCommand]                         ;AH = fn., AL = sector count
   496 0000016D CD13                                            int     EBIOSINTDISKETTE                                ;read sector
   497 0000016F 59                                              pop     cx                                              ;restore retry count
   498 00000170 5B                                              pop     bx                                              ;restore buffer address
   499 00000171 7343                                            jnc     BootReturn                                      ;skip ahead if done
   500 00000173 E2EB                                            loop    .10                                             ;retry
   501                                  ;
   502                                  ;       Handle disk error: convert to ASCII and store in error string.
   503                                  ;
   504 00000175 88E0                                            mov     al,ah                                           ;AL = bios error code
   505 00000177 30E4                                            xor     ah,ah                                           ;AX = bios error code
   506 00000179 B210                                            mov     dl,16                                           ;divisor for base 16
   507 0000017B F6F2                                            div     dl                                              ;AL = hi order, AH = lo order
   508 0000017D 0D3030                                          or      ax,03030h                                       ;apply ASCII zone bits
   509 00000180 80FC3A                                          cmp     ah,03Ah                                         ;range test ASCII numeral
   510 00000183 7203                                            jb      .20                                             ;continue if numeral
   511 00000185 80C407                                          add     ah,7                                            ;adjust for ASCII 'A'-'F'
   512 00000188 3C3A                    .20                     cmp     al,03Ah                                         ;range test ASCII numeral
   513 0000018A 7203                                            jb      .30                                             ;continue if numeral
   514 0000018C 80C407                                          add     ah,7                                            ;adjust for ASCII 'A'-'F'
   515 0000018F A3[DD01]                .30                     mov     [wzErrorCode],ax                                ;store ASCII error code
   516 00000192 BE[D201]                                        mov     si,czErrorMsg                                   ;error message address
   517 00000195 E81200                  BootExit                call    BootPrint                                       ;display messge to console
   518                                  ;
   519                                  ;       Wait for a key press.
   520                                  ;
   521 00000198 B401                    .10                     mov     ah,EBIOSFNKEYSTATUS                             ;BIOS keyboard status function
   522 0000019A CD16                                            int     EBIOSINTKEYBOARD                                ;get keyboard status
   523 0000019C 7504                                            jnz     .20                                             ;continue if key pressed
   524 0000019E FB                                              sti                                                     ;enable maskable interrupts
   525 0000019F F4                                              hlt                                                     ;wait for interrupt
   526 000001A0 EBF6                                            jmp     .10                                             ;repeat
   527                                  ;
   528                                  ;       Reset the system.
   529                                  ;
   530 000001A2 B0FE                    .20                     mov     al,EKEYBCMDRESET                                ;8042 pulse output port pin
   531 000001A4 E664                                            out     EKEYBPORTSTAT,al                                ;drive B0 low to restart
   532 000001A6 FB                      .30                     sti                                                     ;enable maskable interrupts
   533 000001A7 F4                                              hlt                                                     ;stop until reset, int, nmi
   534 000001A8 EBFC                                            jmp     .30                                             ;loop until restart kicks in
   535                                  ;
   536                                  ;       Display text message.
   537                                  ;
   538 000001AA FC                      BootPrint               cld                                                     ;forward strings
   539 000001AB AC                      .10                     lodsb                                                   ;load next byte at DS:SI in AL
   540 000001AC 84C0                                            test    al,al                                           ;end of string?
   541 000001AE 7406                                            jz      BootReturn                                      ;... yes, exit our loop
   542 000001B0 B40E                                            mov     ah,EBIOSFNTTYOUTPUT                             ;BIOS teletype function
   543 000001B2 CD10                                            int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
   544 000001B4 EBF5                                            jmp     .10                                             ;repeat until done
   545 000001B6 C3                      BootReturn              ret                                                     ;return
   546                                  ;-----------------------------------------------------------------------------------------------------------------------
   547                                  ;
   548                                  ;       Constants
   549                                  ;
   550                                  ;-----------------------------------------------------------------------------------------------------------------------
   551 000001B7 90                                              align   2
   552 000001B8 2000                    cwEntryLen              dw      32                                              ;length of directory entry
   553 000001BA 4F5320202020202043-     cbKernelProgram         db      "OS      COM"                                   ;kernel program name
   553 000001C3 4F4D               
   554 000001C5 4C6F6164696E67204F-     czLoadMsg               db      "Loading OS",13,10,0                            ;loading message
   554 000001CE 530D0A00           
   555 000001D2 4469736B206572726F-     czErrorMsg              db      "Disk error "                                   ;error message
   555 000001DB 7220               
   556 000001DD 202000                  wzErrorCode             db      020h,020h,0                                     ;error code and null terminator
   557 000001E0 4F53206D697373696E-     czNoKernel              db      "OS missing",0                                  ;missing kernel message
   557 000001E9 6700               
   558                                  ;-----------------------------------------------------------------------------------------------------------------------
   559                                  ;
   560                                  ;       Work Areas
   561                                  ;
   562                                  ;-----------------------------------------------------------------------------------------------------------------------
   563 000001EB 90                                              align   2
   564 000001EC 0000                    wwDirBuffer             dw      0                                               ;directory i/o buffer address
   565 000001EE 0000                    wwEntriesLeft           dw      0                                               ;directory entries to search
   566 000001F0 0000                    wwOverhead              dw      0                                               ;overhead sectors
   567 000001F2 0000                    wwSectorEntries         dw      0                                               ;directory entries per sector
   568 000001F4 0000                    wwLogicalSector         dw      0                                               ;current logical sector
   569                                  wwReadCountCommand      equ     $                                               ;read count and command
   570 000001F6 00                      wbReadCount             db      0                                               ;sectors to read
   571 000001F7 02                      cbReadCommand           db      EBIOSFNREADSECTOR                               ;BIOS read disk fn code
   572                                  wwDriveHead             equ     $                                               ;drive, head (word)
   573 000001F8 00                      wbDrive                 db      0                                               ;drive
   574 000001F9 00                      wbHead                  db      0                                               ;head
   575                                  wwSectorTrack           equ     $                                               ;sector, track (word)
   576 000001FA 00                                              db      0                                               ;sector
   577 000001FB 00                      wbTrack                 db      0                                               ;track
   578 000001FC 00<rept>                                        times   510-($-$$) db 0h                                ;zero fill to end of sector
   579 000001FE 55AA                                            db      055h,0AAh                                       ;end of sector signature
   580                                  %endif
   581                                  %ifdef BUILDPREP
   582                                  ;=======================================================================================================================
   583                                  ;
   584                                  ;       Diskette Preparation Code
   585                                  ;
   586                                  ;       This routine writes the OS boot sector code to a formatted floppy diskette. The diskette parameter table,
   587                                  ;       which is located in the first 30 bytes of the boot sector is first read from the diskette and overlayed onto
   588                                  ;       the OS bootstrap code so that the diskette format parameters are preserved.
   589                                  ;
   590                                  ;=======================================================================================================================
   591                                  ;
   592                                  ;       Query the user to insert a flopppy diskette and press enter or cancel.
   593                                  ;
   594                                  Prep                    mov     si,czPrepMsg10                                  ;starting message address
   595                                                          call    BootPrint                                       ;display message
   596                                  ;
   597                                  ;       Exit if the Escape key is pressed or loop until Enter is pressed.
   598                                  ;
   599                                  .10                     mov     ah,EBIOSFNKEYSTATUS                             ;BIOS keyboard status function
   600                                                          int     EBIOSINTKEYBOARD                                ;get keyboard status
   601                                                          jnz     .20                                             ;continue if key pressed
   602                                                          sti                                                     ;enable interrupts
   603                                                          hlt                                                     ;wait for interrupt
   604                                                          jmp     .10                                             ;repeat
   605                                  .20                     cmp     al,EASCIIRETURN                                 ;Enter key pressed?
   606                                                          je      .30                                             ;yes, branch
   607                                                          cmp     al,EASCIIESCAPE                                 ;Escape key pressed?
   608                                                          jne     .10                                             ;no, repeat
   609                                                          jmp     .120                                            ;yes, exit program
   610                                  ;
   611                                  ;       Display writing-sector message and patch the JMP instruction.
   612                                  ;
   613                                  .30                     mov     si,czPrepMsg12                                  ;writing-sector message address
   614                                                          call    BootPrint                                       ;display message
   615                                                          mov     bx,Boot+1                                       ;address of JMP instruction operand
   616                                                          mov     ax,01Bh                                         ;address past disk parameter table
   617                                                          mov     [bx],ax                                         ;update the JMP instruction
   618                                  ;
   619                                  ;       Try to read the boot sector.
   620                                  ;
   621                                                          mov     cx,EBOOTMAXTRIES                                ;try up to five times
   622                                  .40                     push    cx                                              ;save remaining tries
   623                                                          mov     bx,wcPrepInBuf                                  ;input buffer address
   624                                                          mov     dx,0                                            ;head zero, drive zero
   625                                                          mov     cx,1                                            ;track zero, sector one
   626                                                          mov     al,1                                            ;one sector
   627                                                          mov     ah,EBIOSFNREADSECTOR                            ;read function
   628                                                          int     EBIOSINTDISKETTE                                ;attempt the read
   629                                                          pop     cx                                              ;restore remaining retries
   630                                                          jnc     .50                                             ;skip ahead if successful
   631                                                          loop    .40                                             ;try again
   632                                                          mov     si,czPrepMsg20                                  ;read-error message address
   633                                                          jmp     .70                                             ;branch to error routine
   634                                  ;
   635                                  ;       Copy diskette parms from input buffer to output buffer.
   636                                  ;
   637                                  .50                     mov     si,wcPrepInBuf                                  ;input buffer address
   638                                                          add     si,11                                           ;skip over JMP and system ID
   639                                                          mov     di,Boot                                         ;output buffer address
   640                                                          add     di,11                                           ;skip over JMP and system ID
   641                                                          mov     cx,19                                           ;length of diskette parameters
   642                                                          cld                                                     ;forward string copies
   643                                                          rep     movsb                                           ;copy diskette parameters
   644                                  ;
   645                                  ;       Try to write boot sector to diskette.
   646                                  ;
   647                                                          mov     cx,EBOOTMAXTRIES                                ;try up to five times
   648                                  .60                     push    cx                                              ;save remaining tries
   649                                                          mov     bx,Boot                                         ;output buffer address
   650                                                          mov     dx,0                                            ;head zero, drive zero
   651                                                          mov     cx,1                                            ;track zero, sector one
   652                                                          mov     al,1                                            ;one sector
   653                                                          mov     ah,EBIOSFNWRITESECTOR                           ;write function
   654                                                          int     EBIOSINTDISKETTE                                ;attempt the write
   655                                                          pop     cx                                              ;restore remaining retries
   656                                                          jnc     .100                                            ;skip ahead if successful
   657                                                          loop    .60                                             ;try again
   658                                                          mov     si,czPrepMsg30                                  ;write-error message address
   659                                  ;
   660                                  ;       Convert the error code to ASCII and display the error message.
   661                                  ;
   662                                  .70                     push    ax                                              ;save error code
   663                                                          mov     al,ah                                           ;copy error code
   664                                                          mov     ah,0                                            ;AX = error code
   665                                                          mov     dl,10h                                          ;hexadecimal divisor
   666                                                          idiv    dl                                              ;AL = hi-order, AH = lo-order
   667                                                          or      ax,03030h                                       ;add ASCII zone digits
   668                                                          cmp     ah,03Ah                                         ;AH ASCII numeral?
   669                                                          jb      .80                                             ;yes, continue
   670                                                          add     ah,7                                            ;no, make ASCII 'A'-'F'
   671                                  .80                     cmp     al,03Ah                                         ;ASCII numeral?
   672                                                          jb      .90                                             ;yes, continue
   673                                                          add     al,7                                            ;no, make ASCII
   674                                  .90                     mov     [si+17],ax                                      ;put ASCII error code in message
   675                                                          call    BootPrint                                       ;write error message
   676                                                          pop     ax                                              ;restore error code
   677                                  ;
   678                                  ;       Display the completion message.
   679                                  ;
   680                                  .100                    mov     si,czPrepMsgOK                                  ;assume successful completion
   681                                                          mov     al,ah                                           ;BIOS return code
   682                                                          cmp     al,0                                            ;success?
   683                                                          je      .110                                            ;yes, continue
   684                                                          mov     si,czPrepMsgErr1                                ;disk parameter error message
   685                                                          cmp     al,1                                            ;disk parameter error?
   686                                                          je      .110                                            ;yes, continue
   687                                                          mov     si,czPrepMsgErr2                                ;address mark not found message
   688                                                          cmp     al,2                                            ;address mark not found?
   689                                                          je      .110                                            ;yes, continue
   690                                                          mov     si,czPrepMsgErr3                                ;protected disk message
   691                                                          cmp     al,3                                            ;protected disk?
   692                                                          je      .110                                            ;yes, continue
   693                                                          mov     si,czPrepMsgErr6                                ;diskette removed message
   694                                                          cmp     al,6                                            ;diskette removed?
   695                                                          je      .110                                            ;yes, continue
   696                                                          mov     si,czPrepMsgErr80                               ;drive timed out message
   697                                                          cmp     al,80H                                          ;drive timed out?
   698                                                          je      .110                                            ;yes, continue
   699                                                          mov     si,czPrepMsgErrXX                               ;unknown error message
   700                                  .110                    call    BootPrint                                       ;display result message
   701                                  .120                    mov     ax,04C00H                                       ;terminate with zero result code
   702                                                          int     021h                                            ;terminate DOS program
   703                                                          ret                                                     ;return (should not execute)
   704                                  ;-----------------------------------------------------------------------------------------------------------------------
   705                                  ;
   706                                  ;       Diskette Preparation Messages
   707                                  ;
   708                                  ;-----------------------------------------------------------------------------------------------------------------------
   709                                  czPrepMsg10             db      13,10,"CustomOS Boot-Diskette Preparation Program"
   710                                                          db      13,10,"Copyright (C) 2010-2019 David J. Walling. All rights reserved."
   711                                                          db      13,10
   712                                                          db      13,10,"This program overwrites the boot sector of a diskette with startup code that"
   713                                                          db      13,10,"will load the operating system into memory when the computer is restarted."
   714                                                          db      13,10,"To proceed, place a formatted diskette into drive A: and press the Enter key."
   715                                                          db      13,10,"To exit this program without preparing a diskette, press the Escape key."
   716                                                          db      13,10,0
   717                                  czPrepMsg12             db      13,10,"Writing the boot sector to the diskette ..."
   718                                                          db      13,10,0
   719                                  czPrepMsg20             db      13,10,"The error-code .. was returned from the BIOS while reading from the disk."
   720                                                          db      13,10,0
   721                                  czPrepMsg30             db      13,10,"The error-code .. was returned from the BIOS while writing to the disk."
   722                                                          db      13,10,0
   723                                  czPrepMsgOK             db      13,10,"The boot-sector was written to the diskette. Before booting your computer with"
   724                                                          db      13,10,"this diskette, make sure that the file OS.COM is copied onto the diskette."
   725                                                          db      13,10,0
   726                                  czPrepMsgErr1           db      13,10,"(01) Invalid Disk Parameter"
   727                                                          db      13,10,"This is an internal error caused by an invalid value being passed to a system"
   728                                                          db      13,10,"function. The OSBOOT.COM file may be corrupt. Copy or download the file again"
   729                                                          db      13,10,"and retry."
   730                                                          db      13,10,0
   731                                  czPrepMsgErr2           db      13,10,"(02) Address Mark Not Found"
   732                                                          db      13,10,"This error indicates a physical problem with the floppy diskette. Please retry"
   733                                                          db      13,10,"using another diskette."
   734                                                          db      13,10,0
   735                                  czPrepMsgErr3           db      13,10,"(03) Protected Disk"
   736                                                          db      13,10,"This error is usually caused by attempting to write to a write-protected disk."
   737                                                          db      13,10,"Check the 'write-protect' setting on the disk or retry using using another disk."
   738                                                          db      13,10,0
   739                                  czPrepMsgErr6           db      13,10,"(06) Diskette Removed"
   740                                                          db      13,10,"This error may indicate that the floppy diskette has been removed from the"
   741                                                          db      13,10,"diskette drive. On some systems, this code may also occur if the diskette is"
   742                                                          db      13,10,"'write protected.' Please verify that the diskette is not write-protected and"
   743                                                          db      13,10,"is properly inserted in the diskette drive."
   744                                                          db      13,10,0
   745                                  czPrepMsgErr80          db      13,10,"(80) Drive Timed Out"
   746                                                          db      13,10,"This error usually indicates that no diskette is in the diskette drive. Please"
   747                                                          db      13,10,"make sure that the diskette is properly seated in the drive and retry."
   748                                                          db      13,10,0
   749                                  czPrepMsgErrXX          db      13,10,"(??) Unknown Error"
   750                                                          db      13,10,"The error-code returned by the BIOS is not a recognized error. Please consult"
   751                                                          db      13,10,"your computer's technical reference for a description of this error code."
   752                                                          db      13,10,0
   753                                  wcPrepInBuf             equ     $
   754                                  %endif
   755                                  %ifdef BUILDDISK
   756                                  ;=======================================================================================================================
   757                                  ;
   758                                  ;       File Allocation Tables
   759                                  ;
   760                                  ;       The disk contains two copies of the File Allocation Table (FAT). On our disk, each FAT copy is 1200h bytes in
   761                                  ;       length. Each FAT entry contains the logical number of the next cluster. The first two entries are reserved. Our
   762                                  ;       OS.COM file here is 400h bytes in length. These 400h bytes contain familiar code that displays a message to the
   763                                  ;       screen. Our disk parameter table defines a cluster as containing one sector and each sector having 200h bytes.
   764                                  ;       Therefore, our FAT table must reserve only two clusters for OS.COM. The clusters used by OS.COM, then, will be
   765                                  ;       clusters 2 and 3. The entry value for cluster 3 is set to "0fffh" to indicate that it is the last cluster in the
   766                                  ;       chain.
   767                                  ;
   768                                  ;       Every three bytes encode two FAT entries as follows:
   769                                  ;
   770                                  ;       db      0abh,0cdh,0efh  ;even cluster: 0dabh, odd cluster: 0efch
   771                                  ;
   772                                  ;=======================================================================================================================
   773                                  ;-----------------------------------------------------------------------------------------------------------------------
   774                                  ;
   775                                  ;       FAT copy 1                                                              @disk: 000200   @mem: n/a
   776                                  ;
   777                                  ;-----------------------------------------------------------------------------------------------------------------------
   778                                  section                 fat1                                                    ;first copy of FAT
   779 00000000 F0FFFF03F0FF                                    db      0F0h,0FFh,0FFh, 003h,0F0h,0FFh
   780 00000006 00<rept>                                        times   (9*512)-($-$$) db 0                             ;zero fill to end of section
   781                                  ;-----------------------------------------------------------------------------------------------------------------------
   782                                  ;
   783                                  ;       FAT copy 2                                                              @disk: 001400   @mem: n/a
   784                                  ;
   785                                  ;-----------------------------------------------------------------------------------------------------------------------
   786                                  section                 fat2                                                    ;second copy of FAT
   787 00000000 F0FFFF03F0FF                                    db      0F0h,0FFh,0FFh, 003h,0F0h,0FFh
   788 00000006 00<rept>                                        times   (9*512)-($-$$) db 0                             ;zero fill to end of section
   789                                  ;-----------------------------------------------------------------------------------------------------------------------
   790                                  ;
   791                                  ;       Diskette Directory                                                      @disk: 002600   @mem: n/a
   792                                  ;
   793                                  ;       The disk contains one copy of the diskette directory. Each directory entry is 32 bytes long. Our directory
   794                                  ;       contains only one entry. Unused entries are set to all nulls. The directory immediately follows the second FAT
   795                                  ;       copy.
   796                                  ;
   797                                  ;-----------------------------------------------------------------------------------------------------------------------
   798                                  section                 dir                                                     ;diskette directory
   799 00000000 4F5320202020202043-                             db      "OS      COM"                                   ;file name (must contain spaces)
   799 00000009 4F4D               
   800 0000000B 20                                              db      020h                                            ;attribute (archive bit set)
   801 0000000C 00<rept>                                        times   10 db 0                                         ;unused
   802 00000016 0000                                            dw      0h                                              ;time
   803 00000018 41                                              db      01000001b                                       ;mmm = 10 MOD 8 = 2; ddddd = 1
   804 00000019 49                                              db      01001001b                                       ;yyyyyyy = 2016-1980 = 36 = 24h; m/8 = 1
   805 0000001A 0200                                            dw      2                                               ;first cluster
   806 0000001C 00040000                                        dd      400h                                            ;file size
   807 00000020 00<rept>                                        times   (EBOOTDIRENTRIES*32)-($-$$) db 0h               ;zero fill to end of section
   808                                  %endif
   809                                  %ifdef BUILDCOM
   810                                  ;=======================================================================================================================
   811                                  ;
   812                                  ;       OS.COM
   813                                  ;
   814                                  ;       The operating system file is assembled at the start of the data area of the floppy disk image, which
   815                                  ;       immediately follows the directory. This corresponds to logical cluster 2, even though the physical address of
   816                                  ;       this sector on the disk varies depending on the disk type. The os.com file consists of two parts, the OS loader
   817                                  ;       and the OS kernel. The Loader is 16-bit code that receives control directly from the boot sector code after the
   818                                  ;       OS.COM file is loaded into memory. The kernel is 32-bit code that receives control after the Loader has
   819                                  ;       initialized protected-mode tables and 32-bit interrupt handlers and switched the CPU into protected mode.
   820                                  ;
   821                                  ;       Our loader addressability is set up according to the following diagram.
   822                                  ;
   823                                  ;       SS -----------> 007b00  +-----------------------------------------------+ SS:0000
   824                                  ;                               |  Boot Stack & Boot PSP (Unused)               |
   825                                  ;                               |  256 = 100h bytes                             |
   826                                  ;       SS:SP --------> 007c00  +-----------------------------------------------+ SS:0100  07b0:0100
   827                                  ;                               |  Boot Sector (vstart=0100h)                   |
   828                                  ;                               |  1 sector = 512 = 200h bytes                  |
   829                                  ;                       007e00  +-----------------------------------------------+
   830                                  ;                               |  File Allocation Table (FAT) I/O Buffer       |
   831                                  ;                               |  9 x 512-byte sectors = 4,608 = 1200h bytes   |
   832                                  ;                               |                                               |
   833                                  ;       CS,DS,ES -----> 008f00  |  Loader PSP (Unused)                          | DS:0000
   834                                  ;                               |                                               |
   835                                  ;       CS:IP --------> 009000  +-----------------------------------------------+ DS:0100  08f0:0100
   836                                  ;                               |  Loader Code                                  |
   837                                  ;                               |  2 sectors = 1024 = 400h bytes                |
   838                                  ;                       009400  +-----------------------------------------------+ DS:0500
   839                                  ;
   840                                  ;=======================================================================================================================
   841                                  ;-----------------------------------------------------------------------------------------------------------------------
   842                                  ;
   843                                  ;       OS Loader                                                               @disk: 004200   @mem: 009000
   844                                  ;
   845                                  ;       This code is the operating system loader. It resides on the boot disk at the start of the data area, following
   846                                  ;       the directory. The loader occupies several clusters that are mapped in the file allocation tables above.
   847                                  ;       The loader executes 16-bit instructions in real mode. It performs several initialization functions such as
   848                                  ;       determining whether the CPU and other resources are sufficient to run the operating system. If all minimum
   849                                  ;       resources are present, the loader initializes protected mode tables, places the CPU into protected mode and
   850                                  ;       starts the console task. Since the loader was called either from the bootstrap or as a .com file on the boot
   851                                  ;       disk, we can assume that the initial IP is 0x100 and not perform any absolute address fix-ups on our segment
   852                                  ;       registers.
   853                                  ;
   854                                  ;-----------------------------------------------------------------------------------------------------------------------
   855                                                          cpu     8086                                            ;assume minimal CPU
   856                                  section                 loader  vstart=0100h                                    ;use .COM compatible addressing
   857                                                          bits    16                                              ;this is 16-bit code
   858 00000000 0E                      Loader                  push    cs                                              ;use the code segment
   859 00000001 1F                                              pop     ds                                              ;...as our data segment
   860 00000002 0E                                              push    cs                                              ;use the code segment
   861 00000003 07                                              pop     es                                              ;...as our extra segment
   862                                  ;
   863                                  ;       Write a message to the console so we know we have our addressability established.
   864                                  ;
   865 00000004 BE[2900]                                        mov     si,czStartingMsg                                ;starting message
   866 00000007 E81200                                          call    PutTTYString                                    ;display loader message
   867                                  ;
   868                                  ;       Now we want to wait for a keypress. We can use a keyboard interrupt function for this (INT 16h, AH=0).
   869                                  ;       However, some hypervisor BIOS implementations have been seen to implement the "wait" as simply a fast
   870                                  ;       iteration of the keyboard status function call (INT 16h, AH=1), causing a max CPU condition. So, instead,
   871                                  ;       we will use the keyboard status call and iterate over a halt (HLT) instruction until a key is pressed.
   872                                  ;       The STI instruction enables maskable interrupts, including the keyboard. The CPU assures that the
   873                                  ;       instruction immediately following STI will be executed before any interrupt is serviced.
   874                                  ;
   875 0000000A B401                    .30                     mov     ah,EBIOSFNKEYSTATUS                             ;keyboard status function
   876 0000000C CD16                                            int     EBIOSINTKEYBOARD                                ;call BIOS keyboard interrupt
   877 0000000E 7504                                            jnz     .40                                             ;exit if key pressed
   878 00000010 FB                                              sti                                                     ;enable maskable interrupts
   879 00000011 F4                                              hlt                                                     ;wait for interrupt
   880 00000012 EBF6                                            jmp     .30                                             ;repeat until keypress
   881                                  ;
   882                                  ;       Now that a key has been pressed, we signal the system to restart by driving the B0 line on the 8042
   883                                  ;       keyboard controller low (OUT 64h,0feh). The restart may take some microseconds to kick in, so we issue
   884                                  ;       HLT until the system resets.
   885                                  ;
   886 00000014 B0FE                    .40                     mov     al,EKEYBCMDRESET                                ;8042 pulse output port pin
   887 00000016 E664                                            out     EKEYBPORTSTAT,al                                ;drive B0 low to restart
   888 00000018 FB                      .50                     sti                                                     ;enable maskable interrupts
   889 00000019 F4                                              hlt                                                     ;stop until reset, int, nmi
   890 0000001A EBFC                                            jmp     .50                                             ;loop until restart kicks in
   891                                  ;-----------------------------------------------------------------------------------------------------------------------
   892                                  ;
   893                                  ;       Routine:        PutTTYString
   894                                  ;
   895                                  ;       Description:    This routine sends a NUL-terminated string of characters to the TTY output device. We use the
   896                                  ;                       TTY output function of the BIOS video interrupt, passing the address of the string in DS:SI
   897                                  ;                       and the BIOS teletype function code in AH. After a return from the BIOS interrupt, we repeat
   898                                  ;                       for the next string character until a NUL is found. Note that we clear the direction flag (DF)
   899                                  ;                       with CLD before the first LODSB. The direction flag is not guaranteed to be preserved between
   900                                  ;                       calls within the OS. However, the "int" instruction does store the EFLAGS register on the
   901                                  ;                       stack and restores it on return. Therefore, clearing the direction flag before subsequent calls
   902                                  ;                       to LODSB is not needed.
   903                                  ;
   904                                  ;       In:             DS:SI   address of string
   905                                  ;
   906                                  ;       Out:            DF      0
   907                                  ;                       ZF      1
   908                                  ;                       AL      0
   909                                  ;
   910                                  ;-----------------------------------------------------------------------------------------------------------------------
   911 0000001C FC                      PutTTYString            cld                                                     ;forward strings
   912 0000001D AC                      .10                     lodsb                                                   ;load next byte at DS:SI in AL
   913 0000001E 84C0                                            test    al,al                                           ;end of string?
   914 00000020 7406                                            jz      .20                                             ;... yes, exit our loop
   915 00000022 B40E                                            mov     ah,EBIOSFNTTYOUTPUT                             ;BIOS teletype function
   916 00000024 CD10                                            int     EBIOSINTVIDEO                                   ;call BIOS display interrupt
   917 00000026 EBF5                                            jmp     .10                                             ;repeat until done
   918 00000028 C3                      .20                     ret                                                     ;return
   919                                  ;-----------------------------------------------------------------------------------------------------------------------
   920                                  ;
   921                                  ;       Loader Data
   922                                  ;
   923                                  ;       Our only "data" is the string displayed when system starts. It ends with ASCII carriage-return (13) and line-
   924                                  ;       feed (10) values. The remainder of the boot sector is filled with NUL. The boot sector finally ends with the
   925                                  ;       required two-byte signature checked by the BIOS. Note that recent versions of NASM will issue a warning if
   926                                  ;       the calculated address for the end-of-sector signature produces a negative value for "1024-($-$$)". This will
   927                                  ;       indicate if we have added too much data and exceeded the length of the sector. Note also that since we are at
   928                                  ;       the end of a "file" (os.com) and not the boot sector, there is no end-of-sector marker (0x55 0xaa) here.
   929                                  ;
   930                                  ;-----------------------------------------------------------------------------------------------------------------------
   931 00000029 5374617274696E6720-     czStartingMsg           db      "Starting OS",13,10,0                           ;starting message
   931 00000032 4F530D0A00         
   932 00000037 00<rept>                                        times   1024-($-$$) db 0h                               ;zero fill to end of sector
   933                                  %endif
   934                                  %ifdef BUILDDISK
   935                                  ;-----------------------------------------------------------------------------------------------------------------------
   936                                  ;
   937                                  ;       Free Disk Space                                                         @disk: 004600   @mem:  n/a
   938                                  ;
   939                                  ;       Following the convention introduced by DOS, we use the value 'F6' to indicate unused floppy disk storage.
   940                                  ;
   941                                  ;-----------------------------------------------------------------------------------------------------------------------
   942                                  section                 unused                                                  ;unused disk space
   943 00000000 F6<rept>                                        times   EBOOTDISKBYTES-04600h db 0F6h                   ;fill to end of disk image
   944                                  %endif
   945                                  ;=======================================================================================================================
   946                                  ;
   947                                  ;       End of Program Code
   948                                  ;
   949                                  ;=======================================================================================================================
