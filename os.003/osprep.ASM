;-------------------------------------------------------------------------------
;
;	OSBOOT.ASM
;
;	THIS FILE CONTAINS THE SOURCE CODE FOR THE UTILITY THAT WRITES THE
;	OPERATING SYSTEM BOOT SECTOR TO A FLOPPY DISK.
;
;-------------------------------------------------------------------------------
TITLE		OSBOOT.ASM
CODE		SEGMENT PUBLIC USE16 'CODE'
		ASSUME	CS:CODE,DS:CODE
		ASSUME	ES:CODE,SS:CODE
		ORG	0100H
;-------------------------------------------------------------------------------
;
;	EQUATES
;
;-------------------------------------------------------------------------------
BPTR		EQU	<BYTE PTR>
WPTR		EQU	<WORD PTR>
MAXTRIES	EQU	5			;DISK ACCESS ATTEMPT COUNT
READDISK	EQU	2			;BIOS DISK READ FUNCTION
WRITEDISK	EQU	3			;BIOS DISK WRITE FUNCTION
DIRBUFFER	EQU	400H			;DIRECTORY I/O ADDRESS
;-------------------------------------------------------------------------------
;
;	PROGRAM ENTRY
;
;	THE OSBOOT LABEL IS BOTH THE ENTRY POINT OF THE OSBOOT PROGRAM AND
;	THE BEGINNING OF THE OS BOOT SECTOR THAT IS WRITTEN TO THE FLOPPY
;	DISK. THE INITIAL JMP INSTRUCTION TO OSPREP BRANCHES TO LOGIC THAT
;	PROMPTS THE USER TO ENTER A FORMATTED DISK IN DRIVE A: AND PROCEEDS
;	TO WRITE THE OS BOOT SECTOR TO THE DISK. BEFORE WRITING THE BOOT
;	SECTOR, THE JMP INSTRUCTION IS MODIFIED TO JUMP TO OSBOOT10 SO THAT
;	THE BOOT SECTOR, WHEN EXECUTED, WILL EXECUTE THE OS BOOT CODE,
;	WHICH SEARCHES FOR OS.COM, LOADS AND RUNS THAT PROGRAM.
;
;-------------------------------------------------------------------------------
OSBOOT:		JMP	OSPREP			;PREPARE BOOT DISKETTE
;-------------------------------------------------------------------------------
;
;	DEFAULT DISK PARAMETER TABLE
;
;-------------------------------------------------------------------------------
		DB	'MERCURY '		;SYSTEM IDENTIFIER (8 BYTES)
SECTORBYTES	DW	512			;512 BYTES PER SECTOR
CLUSTERSECTORS	DB	1			;1 SECTOR PER CLUSTER
RESERVEDSECTORS	DW	1			;1 RESERVED SECTOR
FATCOUNT	DB	2			;2 FAT COPIES
DIRENTRIES	DW	224			;224 ROOT DIRECTORY ENTRIES
DISKSECTORS	DW	2880			;2880 SECTORS PER DISK
DISKTYPE	DB	0F0H			;0F0H DISKETTE TYPE
FATSECTORS	DW	9			;9 SECTORS PER FAT
BTRACKSECTORS	LABEL	BYTE			;SECTORS PER TRACK (BYTE)
WTRACKSECTORS	DW	18			;18 SECTORS PER TRACK (WORD)
BDISKSIDES	LABEL	BYTE			;SIDES PER DISK (BYTE)
WDISKSIDES	DW	2			;2 SIDES PER DISK (WORD)
SPECIALSECTORS	DW	0			;0 SPECIAL RESERVED SECTORS
;-------------------------------------------------------------------------------
;
;	BOOT-SECTOR CODE			CS:IP = 0700:0C00
;
;	THIS CODE SEARCHES THE FLOPPY DISK DIRECTORY FOR THE FILE OS.COM,
;	LOADS THE FILE INTO MEMORY IF FOUND AND TRANSFERS CONTROL TO THE
;	OS.COM PROGRAM. IF THIS PROGRAM WAS LOADED FROM A FLOPPY DISK AT
;	BOOT TIME, THIS PROGRAM WILL RESIDE AT ADDRESS 0700:0C00.
;
;-------------------------------------------------------------------------------
;
;	SETUP DS,ES TO POINT TO THE PSP SEGEMENT (07B0) TO ADDRESS DATA
;
OSBOOT10:	CALL	OSBOOT20		;[ESP] = 0C21 AFTER CALL
@OSBOOT20	EQU	$-OSBOOT		;
OSBOOT20:	POP	AX			;AX = 0C21
		SUB	AX,@OSBOOT20		;AX = 0C00
		MOV	CL,4			;CL = SHIFT COUNT
		SHR	AX,CL			;AX = 00C0
		MOV	BX,CS			;BX = 0700
		ADD	BX,AX			;BX = 07C0
		SUB	BX,10H			;BX = 07B0
		MOV	DS,BX			;DS = 07B0
		MOV	ES,BX			;ES = 07B0
;
;	DISPLAY COPYRIGHT
;
		LEA	SI,CLOADMSG		;COPYRIGHT MESSAGE ADDRESS
		CALL	TTYOUT			;DISPLAY MESSAGE
;
;	ALL DISK I/O IS TO DRIVE A:
;
		XOR	AL,AL			;AL = 0
		MOV	DRIVE,AL		;[DRIVE] = 0
;
;	COMPUTE OFFSET ADDRESS WHERE FILE-ALLOCATION TABLE (FAT) WILL BE LOADED
;
		MOV	AX,SECTORBYTES		;AX = 0200
		ADD	AX,DIRBUFFER		;AX = 0600
		MOV	FATBUFFER,AX		;[FATBUFFER] = 0600
;
;	COMPUTE SEGMENT ADDRESS WHERE OS.COM WILL BE LOADED
;
		MOV	AX,FATSECTORS		;AX = 0009
		MUL	WPTR SECTORBYTES	;AX = 1200
		ADD	AX,FATBUFFER		;AX = 1800
		SHR	AX,CL			;AX = 0180
		ADD	AX,BX			;AX = 0930
		SUB	BX,10H			;AX = 0920
		MOV	LOADSEGMENT,AX		;[LOADSEGMENT] = 0920
;
;	INITIALIZE THE REMAINING NUMBER OF DIRECTORY SECTORS TO SEARCH
;
		MOV	AX,DIRENTRIES		;AX = 00E0
		MOV	ENTRIESLEFT,AX		;[ENTRIESLEFT] = 00E0
;
;	COMPUTE NUMBER OF DIRECTORY SECTORS
;	INITIALIZE OVERHEAD SECTOR COUNT
;
		MOV	CX,AX			;CX = 00E0
		MUL	WPTR ENTRYLEN		;AX = 1C00
		DIV	WPTR SECTORBYTES	;AX = 000E	
		MOV	DIRSECTORS,AX		;[DIRSECTORS] = 000E
		MOV	OVERHEAD,AX		;[OVERHEAD] = 000E
;
;	COMPUTE DIRECTORY ENTRIES PER SECTOR
;
		XCHG	AX,CX			;AX = 00E0, CX = 000E
		DIV	CX			;AX = 0010
		MOV	SECTORENTRIES,AX	;[SECTORENTRIES] = 0010
;
;	COMPUTE FIRST LOGICAL DIRECTORY SECTOR
;	UPDATE OVERHEAD SECTOR COUNT
;
		MOV	AX,FATSECTORS		;AX = 0009
		MUL	BPTR FATCOUNT		;AX = 0012
		ADD	AX,RESERVEDSECTORS	;AX = 0013
		ADD	AX,SPECIALSECTORS	;AX = 0013
		MOV	LOGICALSECTOR,AX	;[LOGICALSECTOR] = 0013
		ADD	WPTR OVERHEAD,AX	;[OVERHEAD] = 0021
;
;	READ DIRECTORY SECTOR
;
OSBOOT30:	MOV	AL,1			;SECTOR COUNT
		MOV	READCOUNT,AL		;[READCOUNT] = 01
		MOV	BX,DIRBUFFER		;WORK AREA ADDRESS
		CALL	OSBOOT100		;READ SECTOR INTO ES:BX
;
;	SETUP VARIABLES TO SEARCH THIS DIRECTORY SECTOR
;
		MOV	CX,ENTRIESLEFT		;ENTRIES LEFT TO SEARCH
		CMP	CX,SECTORENTRIES	;MORE THAN SECTOR HOLDS?
		JNA	OSBOOT40		;NO, CONTINUE
		MOV	CX,SECTORENTRIES	;YES, LIMIT SEARCH TO SECTOR
OSBOOT40:	SUB	ENTRIESLEFT,CX		;UPDATE ENTRIES LEFT TO SEARCH
		LEA	SI,KERNELPROGRAM	;THE KERNEL PROGRAM NAME
		MOV	DI,DIRBUFFER		;DIRECTORY BUFFER ADDRESS
		CLD				;FORWARD STRINGS
;
;	LOOP THROUGH DIRECTORY SECTOR
;	BRANCH AHEAD IF ENTRY FOUND, ELSE SEARCH NEXT DIRECTORY ENTRY
;
OSBOOT50:	PUSH	CX			;SAVE ENTRY COUNT
		PUSH	SI			;SAVE KERNEL NAME ADDRESS
		PUSH	DI			;SAVE DIR BUFFER ADDRESS
		MOV	CX,11			;LENGTH OF 8.3 NAME
		REPE	CMPSB			;COMPARE ENTRY NAME
		POP	DI			;RESTORE DIR BUFFER ADDR
		POP	SI			;RESTORE KERNEL NAME ADDR
		POP	CX			;RESTORE ENTRY COUNT
		JE	OSBOOT60		;SKIP AHEAD IF FOUND
		ADD	DI,ENTRYLEN		;POINT TO NEXT ENTRY
		LOOP	OSBOOT50		;CONTINUE UNTIL SECTOR DONE
;
;	REPEAT SEARCH IF NOT AT END OF DIRECTORY
;	DISPLAY ERROR MESSAGE IF LOADER COULD NOT BE FOUND
;
		INC	WPTR LOGICALSECTOR	;INCREMENT SECTOR NBR
		CMP	WPTR ENTRIESLEFT,0	;ALL DONE WITH DIRECTORY?
		JNE	OSBOOT30		;NO, GET NEXT SECTOR
		LEA	SI,CMISSINGMSG		;KERNEL NOT FOUND MESSAGE
		JMP	OSBOOT140		;DISPLAY MESSAGE AND EXIT
;
;	READ THE FILE-ALLOCATION TABLE (FAT) INTO MEMORY
;
OSBOOT60:	MOV	AX,RESERVEDSECTORS	;BOOT SECTOR
		MOV	LOGICALSECTOR,AX	;START PAST BOOT SECTOR
		MOV	AX,FATSECTORS		;SECTORS PER FAT COPY
		MOV	READCOUNT,AL		;SECTORS TO READ
		MOV	BX,FATBUFFER		;FAT BUFFER ADDRESS
		CALL	OSBOOT100		;READ FAT COPY INTO BUFFER
;
;	GET THE STARTING CLUSTER OF THE KERNEL PROGRAM AND TARGET ADDRESS
;
		MOV	AX,[DI+26]		;STARTING CLUSTER OF KERNEL
		LES	BX,LOADADDRESS		;ES:BX KERNAL LOAD ADDR
;
;	READ EACH KERNEL CLUSTER INTO RAM
;
OSBOOT70:	PUSH	AX			;SAVE CLUSTER NBR
		SUB	AX,2			;ABSOLUTE CLUSTER NBR
		MOV	CL,CLUSTERSECTORS	;SECTORS PER CLUSTER
		XOR	CH,CH			;ZERO HIGH MULTIPLICAND
		MUL	CX			;LOGICAL SECTOR
		ADD	AX,OVERHEAD		;ADD OVERHEAD SECTORS
		MOV	LOGICALSECTOR,AX	;SAVE LOGICAL SECTOR NBR
		MOV	AL,CLUSTERSECTORS	;SECTORS PER CLUSTER
		MOV	READCOUNT,AL		;SETUP READ COUNT
		CALL	OSBOOT100		;READ CLUSTER
;
;	UPDATE BUFFER POINTER POINTER FOR NEXT CLUSTER
;
		MOV	AL,CLUSTERSECTORS
 		XOR	AH,AH
		MUL	WPTR SECTORBYTES
		ADD	BX,AX

;		MOV	CL,CLUSTERSECTORS	;SECTORS PER CLUSTER
;		XOR	CH,CH			;SECTORS PER CLUSTER
;OSBOOT80:	ADD	BX,SECTORBYTES		;BUMP TARGET ADDRESS
;		LOOP	OSBOOT80		;FOR EACH CLUSTER SECTOR

		POP	AX			;RESTORE CLUSTER NBR
;
;	COMPUTE NEXT CLUSTER NUMBER
;
		MOV	CX,AX			;COPY OF CLUSTER NBR
		MOV	DI,AX			;COPY OF CLUSTER NBR
		SHR	AX,1			;CLUSTER/2
		MOV	DX,AX			;CLUSTER/2
		ADD	AX,DX			;2*(CLUSTER/2)
		ADD	AX,DX			;3*(CLUSTER/2)
		AND	DI,1			;GET LOW BIT
		ADD	DI,AX			;ADD ONE IF ODD CLUSTER
		ADD	DI,FATBUFFER		;ADD BUFFER OFFSET
		MOV	AX,[DI]			;GET CLUSTER BYTES
;
;	ADJUST CLUSTER NUMBER BY 4 BITS IF CLUSTER IS ODD
;	MASK OUT HIGH 4 BITS AND TEST FOR END OF CLUSTER CHAIN
;
		TEST	CL,1			;IS CLUSTER ODD?
		JZ	OSBOOT90		;NO, SKIP AHEAD
		MOV	CL,4			;BITS TO SHIFT
		SHR	AX,CL			;SHIFT NYBBLE LOW
OSBOOT90:	AND	AX,0FFFH		;MASK FOR 24 BITS
		CMP	AX,0FFFH		;END-OF-CHAIN?
		JNE	OSBOOT70		;NO, CONTINUE
;
;	TRANSFER CONTROL TO OS.COM
;
		DB	0EAH			;JMP SEG:OFS
LOADADDRESS	LABEL	DWORD
		DW	0100H			;OS ENTRY OFFSET
LOADSEGMENT	DW	0900H			;OS ENTRY SEGMENT
;-------------------------------------------------------------------------------
;
;	READ DISK SECTOR
;
;	INPUT:	LOGICALSECTOR	= LOGICAL SECTOR (0,1,2,...)
;		READCOUNT	= SECTORS TO READ
;		ES:BX		= BUFFER ADDRESS
;
;-------------------------------------------------------------------------------
;
;	CONVERT LOGICAL SECTOR TO PHYSICAL TRACK, HEAD AND SECTOR
;	
OSBOOT100:	MOV	AX,WTRACKSECTORS	;AX = SECTORS PER TRACK
		MUL	WPTR WDISKSIDES		;AX = SECTORS PER CYL, DX = 0
		MOV	CX,AX			;CX = SECTORS PER CYL
		MOV	AX,LOGICALSECTOR	;AX = LOGICAL SECTOR NBR
		DIV	CX			;AX = CYLINDER, DX = CYL SECTOR
		MOV	TRACK,AL		;[TRACK] = CYLINDER
		MOV	AX,DX			;AX = CYL SECTOR
		DIV	BPTR BTRACKSECTORS	;AH = SECTOR, AL = HEAD
		INC	AH			;AH = SECTOR (1,2,3,...)
		MOV	HEADSECTOR,AX		;[HEADSECTOR] HEAD, SECTOR
;
;	TRY MAXTRIES TIMES TO READ SECTOR
;
		MOV	CX,MAXTRIES		;CX = MAX RETRY COUNT
OSBOOT110:	PUSH	BX			;SAVE BUFFER ADDRESS
		PUSH	CX			;SAVE RETRY COUNT
		MOV	DX,DRIVEHEAD		;DH = HEAD, DL = DRIVE
		MOV	CX,SECTORTRACK		;CH = TRACK, CL = SECTOR
		MOV	AH,READDISK		;AH = 2
		MOV	AL,READCOUNT		;AL = SECTOR COUNT
		INT	13H			;READ SECTOR
		POP	CX			;RESTORE RETRY COUNT
		POP	BX			;RESTORE BUFFER ADDRESS
		JNC	OSBOOT160		;SKIP AHEAD IF DONE
		LOOP	OSBOOT110		;RETRY
;
;	HANDLE DISK ERROR: CONVERT ERROR CODE TO ASCII AND STORE IN ERROR STRING
;
		MOV	AL,AH			;AL = BIOS ERROR CODE
		XOR	AH,AH			;AX = BIOS ERROR CODE
		MOV	DL,10H			;DIVISOR FOR BASE 16
		DIV	DL			;AL = HI ORDER, AH = LO ORDER
		OR	AX,3030H		;ADD ASCII ZONE
		CMP	AH,3AH			;AH ASCII NUMERAL?
		JB	OSBOOT120		;YES, CONTINUE
		ADD	AH,7			;NO, MAKE ASCII 'A-F'
OSBOOT120:	CMP	AL,3AH			;AL ASCII NUMERAL?
		JB	OSBOOT130		;YES, CONTINUE
		ADD	AL,7			;NO, MAKE ASCII 'A-F'
OSBOOT130:	MOV	ERRORCODE,AX		;STORE ASCII ERROR CODE
		LEA	SI,CERRORMSG		;ERROR MESSAGE ADDR
;
;	DISPLAY ERROR MESSAGE, WAIT FOR KEYPRESS, REBOOT
;
OSBOOT140:	CALL	TTYOUT			;DISPLAY MESSAGE
		MOV	AH,0			;BIOS WAIT FOR KEYPRESS
		INT	16H			;WAIT FOR KEYPRESS
		MOV 	AL,0FEH			;8042 PULSE OUTPUT PORT PIN
		OUT 	64H,AL			;DRIVE B0 LOW TO RESTART
OSBOOT150:	HLT				;STOP UNTIL RESET, INT OR NMI
		JMP	OSBOOT150		;LOOP UNTIL RESET
OSBOOT160:	RET				;RETURN TO CALLER
;-------------------------------------------------------------------------------
;
;	DISPLAY TEXT MESSAGE
;
;-------------------------------------------------------------------------------
TTYOUT:		MOV	AH,14			;BIOS TTY OUTPUT FN
TTYOUT10:	LODSB				;MESSAGE BYTE
		OR	AL,AL			;END OF MESSAGE?
		JZ	TTYOUT20		;YES, EXIT LOOP
		INT	10H			;WRITE BYTE TO CONSOLE
		JMP	SHORT TTYOUT10		;CONTINUE
TTYOUT20:	RET				;RETURN TO CALLER
;-------------------------------------------------------------------------------
;
;	CONSTANTS
;
;-------------------------------------------------------------------------------
ENTRYLEN	DW	32			;FLOPPY DIRECTORY ENTRY LENGTH
KERNELPROGRAM	DB	'OS      COM'		;OS KERNEL PROGRAM NAME
CLOADMSG	DB	'Starting Sparrow ... '	;LOADING MESSAGE
		DB	13,10,0
CERRORMSG	DB	'Error ('		;ERROR MESSAGE TEMPLATE
ERRORCODE	DW	2020H			;ERROR CODE
		DB	')',0
CMISSINGMSG	DB	'OS.COM Missing',0
;-------------------------------------------------------------------------------
;
;	PAD BOOT-SECTOR WITH FILLER DATA AND END-OF-MODULE MARKER
;
;-------------------------------------------------------------------------------
		DB	64 DUP (0)
		ORG	02FEH
		DB	055H,0AAH
;-------------------------------------------------------------------------------
;
;	WORK AREAS
;
;-------------------------------------------------------------------------------
FATBUFFER	DW	?			;FAT I/O ADDRESS
ENTRIESLEFT	DW	?			;DIRECTORY ENTRIES TO SEARCH
DIRSECTORS	DW	?			;DIRECTORY SECTORS
SECTORENTRIES	DW	?			;DIRECTORY ENTRIES PER SECTOR
OVERHEAD	DW	?			;TOTAL OVERHEAD SECTORS
LOGICALSECTOR	DW	?			;LOGICAL SECTOR TO READ
READCOUNT	DB	?			;SECTORS TO READ
DRIVEHEAD	LABEL	WORD			;PHYSICAL DRIVE AND HEAD
DRIVE		DB	?			;DRIVE
HEADSECTOR	LABEL	WORD			;PHYSICAL HEAD AND SECTOR
HEAD		DB	?			;HEAD
SECTORTRACK	LABEL	WORD			;PHYSICAL SECTOR AND TRACK
SECTOR		DB	?			;SECTOR
TRACK		DB	?			;TRACK
;-------------------------------------------------------------------------------
;
;	OSPREP
;
;	THIS ROUTINE WRITES THE OS BOOT SECTOR CODE TO A FORMATTED FLOPPY
;	DISKETTE. THE DISKETTE PARAMETER TABLE, WHICH IS LOCATED IN THE FIRST
;	30 BYTES OF THE BOOT-STRAP SECTOR IS FIRST READ FROM THE DISKETTE AND
;	OVERLAYED ONTO THE OS BOOT-STRAP CODE, SO THAT THE DISKETTE FORMAT
;	PARAMETERS ARE PRESERVED.
;
;-------------------------------------------------------------------------------
;
;	QUERY THE USER TO INSERT A FLOPPY DISKETTE AND PRESS ENTER OR CANCEL
;
OSPREP:		LEA	SI,OSPREPMSG10		;STARTUP MESSAGE ADDRESS
		CALL	TTYOUT			;DISPLAY MESSAGE
;
;	EXIT IF ESCAPE IS PRESSED OR LOOP UNTIL ENTER IS PRESSED
;
OSPREP10:	MOV	AH,0			;WAIT FOR KEYPRESS FN
		INT	16H			;WAIT FOR KEYPRESS
		CMP	AL,13			;IS KEYPRESS ENTER?
		JE	OSPREP15		;YES, SKIP AHEAD
		CMP	AL,27			;IS KEYPRESS ESCAPE?
		JNE	OSPREP10		;NO, GET ANOTHER KEY
		JMP	OSPREP90		;EXIT IF ESCAPE PRESSED
;
;	DISPLAY WRITING-SECTOR MESSAGE AND PATCH JMP INSTRUCTION
;
OSPREP15:	LEA	SI,OSPREPMSG12		;WRITING-SECTOR MESSAGE ADDR
		CALL	TTYOUT			;DISPLAY MESSAGE
		LEA	BX,OSBOOT+1		;JMP INSTRUCTION OPERAND ADDR
		MOV	AX,001BH		;NEW JUMP PAST DISK PARMS
		MOV	[BX],AX			;STORE NEW JMP OPERAND
;
;	TRY TO READ BOOT SECTOR TO GET ACTUAL DISKETTE PARAMETERS
;
		MOV	CX,MAXTRIES		;TRY UP TO FIVE TIMES
OSPREP20:	PUSH	CX			;SAVE REMAINING TRIES
		LEA	BX,OSPREPINBUF		;INBUT BUFFER ADDRESS
		MOV	DX,0			;HEAD ZERO, DRIVE ZERO
		MOV	CX,1			;TRACK ZERO, SECTOR ONE
		MOV	AX,0201H		;READ ONE SECTOR
		INT	13H			;ATTEMPT READ
		POP	CX			;RESTORE RETRY COUNT
		JNC	OSPREP30		;SKIP AHEAD IF SUCCESSFUL
		LOOP	OSPREP20		;TRY AGAIN
		LEA	SI,OSPREPMSG20		;ERROR MESSAGE
		JMP	OSPREP50		;BRANCH TO ERROR ROUTINE
;
;	COPY DISKETTE PARMS FROM INPUT BUFFER TO OUTPUT BUFFER
;
OSPREP30:	LEA	SI,OSPREPINBUF		;INPUT BUFFER ADDRESS
		ADD	SI,11			;SKIP OVER JMP AND SYSTEM-ID
		LEA	DI,OSBOOT		;OUTPUT BUFFER ADDRESS
		ADD	DI,11			;SKIP OVER JMP AND SYSTEM-ID
		MOV	CX,19			;LENGTH OF DISKETTE PARAMETERS
		CLD				;FORWARD STRING COPIES
		REP	MOVSB			;COPY DISKETTE PARAMETERS
;
;	TRY TO WRITE BOOT SECTOR TO DISKETTE
;
		MOV	CX,MAXTRIES		;TRY UP TO FIVE TIMES
OSPREP40:	PUSH	CX			;SAVE REMAINING TRIES
		LEA	BX,OSBOOT		;OUTPUT BUFFER ADDRESS
		MOV	DX,0			;HEAD ZERO, DRIVE ZERO
		MOV	CX,1			;TRACK ZERO, SECTOR ONE
		MOV	AX,0301H		;WRITE ONE SECTOR
		INT	13H			;ATTEMPT WRITE
		POP	CX			;RESTORE RETRY COUNT
		JNC	OSPREP80		;SKIP AHEAD IF SUCCESSFUL
		LOOP	OSPREP40		;TRY AGAIN
		LEA	SI,OSPREPMSG30		;WRITE-ERROR MESSAGE
;
;	CONVERT THE ERROR CODE TO ASCII AND DISPLAY THE ERROR MESSAGE
;
OSPREP50:	PUSH	AX			;SAVE ERROR CODE
		MOV	AL,AH			;COPY ERROR CODE
		MOV	AH,0			;AX = ERROR CODE
		MOV	DL,10H			;HEXADECIMAL DIVISOR
		IDIV	DL			;AL = HI-ORDER, AH = LO-ORDER
		OR	AX,3030H		;ADD ASCII ZONE DIGITS
		CMP	AH,3AH			;AH ASCII NUMERAL?
		JB	OSPREP60		;YES, CONTINUE
		ADD	AH,7			;NO, MAKE ASCII 'A-F'
OSPREP60:	CMP	AL,3AH			;AL ASCII NUMERAL?
		JB	OSPREP70		;YES, CONTINUE
		ADD	AL,7			;NO, MAKE ASCII
OSPREP70:	MOV	[SI+17],AX		;PUT ASCII ERROR CODE IN MESSAGE
		CALL	TTYOUT			;WRITE ERROR MESSAGE
		POP	AX			;RESTORE ERROR CODE
;
;	DISPLAY THE COMPLETION MESSAGE
;
OSPREP80:	LEA	SI,OSPREPOK		;ASSUME SUCCESSFUL COMPLETION
		MOV	AL,AH			;BIOS RETURN CODE
		CMP	AL,0			;SUCCESS?
		JE	OSPREP85		;YES, CONTINUE
		LEA	SI,OSPREPERR1		;DISK PARAMETER ERROR MESSAGE
		CMP	AL,1			;DISK PARAMETER ERROR?
		JE	OSPREP85		;YES, CONTINUE
		LEA	SI,OSPREPERR2		;ADDRESS MARK NOT FOUND MESSAGE
		CMP	AL,2			;ADDRESS MARK NOT FOUND?
		JE	OSPREP85		;YES, CONTINUE
		LEA	SI,OSPREPERR3		;PROTECTED DISK MESSAGE
		CMP	AL,3			;PROTECTED DISK?
		JE	OSPREP85		;YES, CONTINUE
		LEA	SI,OSPREPERR6		;DISKETTE REMOVED MESSAGE
		CMP	AL,6			;DISKETTE REMOVED?
		JE	OSPREP85		;YES, CONTINUE
		LEA	SI,OSPREPERR80		;DRIVE TIMED OUT MESSAGE
		CMP	AL,80H			;DRIVE TIMED OUT?
		JE	OSPREP85		;YES, CONTINUE
		LEA	SI,OSPREPERRXX		;UNKNOWN ERROR MESSAGE
OSPREP85:	CALL	TTYOUT			;DISPLAY RESULT MESSAGE
OSPREP90:	MOV	AX,4C00H		;TERMINATE WITH ZERO RESULT CODE
		INT	21H			;TERMINATE PROGRAM
		RET
;-------------------------------------------------------------------------------
;
;	MESSAGES
;
;-------------------------------------------------------------------------------
OSPREPMSG10	DB	13,10,'Sparrow OS Boot-Diskette Preparation Program Version 0.0.1'
		DB	13,10,'(C) Copyright 2010 Sevyn Systems, LLC.'
		DB	13,10
		DB	13,10,'This program overwrites the boot sector of a diskette with startup code that'
		DB	13,10,'will load the operating system into memory when the computer is restarted.'
		DB	13,10,'To proceed, place a formatted diskette into drive A: and press the Enter key.'
		DB	13,10,'To exit this program without preparing a diskette, press the Escape key.'
		DB	13,10,0
OSPREPMSG12	DB	13,10,'Writing the boot sector to the diskette ...'
		DB	13,10,0
OSPREPMSG20	DB	13,10,'The error-code .. was returned from the BIOS while reading from the disk.'
		DB	13,10,0
OSPREPMSG30	DB	13,10,'The error-code .. was returned from the BIOS while writing to the disk.'
		DB	13,10,0
OSPREPOK	DB	13,10,'The boot-sector was written to the diskette. Before booting your computer with'
		DB	13,10,'this diskette, make sure that the file OS.COM is copied onto the diskette.'
		DB	13,10,0
OSPREPERR1	DB	13,10,'(01) Invalid Disk Parameter'
		DB	13,10,'This is an internal error caused by an invalid value being passed to a system'
		DB	13,10,'function. The OSBOOT.COM file may be corrupt. Copy or download the file again'
		DB	13,10,'and retry.'
		DB	13,10,0
OSPREPERR2	DB	13,10,'(02) Address Mark Not Found'
		DB	13,10,'This error indicates a physical problem with the floppy diskette. Please retry'
		DB	13,10,'using another diskette.'
		DB	13,10,0
OSPREPERR3	DB	13,10,'(03) Protected Disk'
		DB	13,10,'This error is usually caused by attempting to write to a write-protected disk.'
		DB	13,10,'Check the "write-protect" setting on the disk or retry using using another disk.'
		DB	13,10,0
OSPREPERR6	DB	13,10,'(06) Diskette Removed'
		DB	13,10,'This error may indicate that the floppy diskette has been removed from the'
		DB	13,10,'diskette drive. On some systems, this code may also occur if the diskette is'
		DB	13,10,'"write protected." Please verify that the diskette is not write-protected and'
		DB	13,10,'is properly inserted in the diskette drive.'
		DB	13,10,0
OSPREPERR80	DB	13,10,'(80) Drive Timed Out'
		DB	13,10,'This error usually indicates that no diskette is in the diskette drive. Please'
		DB	13,10,'make sure that the diskette is properly seated in the drive and retry.'
		DB	13,10,0
OSPREPERRXX	DB	13,10,'(??) Unknown Error'
		DB	13,10,'The error-code returned by the BIOS is not a recognized error. Please consult'
		DB	13,10,'your computer''s technical reference for a description of this error code.'
		DB	13,10,0
;-------------------------------------------------------------------------------
;
;	WORK AREA
;
;-------------------------------------------------------------------------------
OSPREPINBUF	EQU	$
CODE		ENDS
		END	_OSBOOT
