     1                                  ;-----------------------------------------------------------------------------------------------------------------------
     2                                  ;
     3                                  ;	File:		os.asm
     4                                  ;
     5                                  ;	Project:	os.003
     6                                  ;
     7                                  ;	Description:	This sample program adds code to create osprep.com, a program to update the boot sector on a
     8                                  ;			floppy disk.
     9                                  ;
    10                                  ;	Revised:	January 1, 2017
    11                                  ;
    12                                  ;	Assembly:	nasm os.asm -f bin -o os.dat     -l os.dat.lst     -DBUILDBOOT
    13                                  ;			nasm os.asm -f bin -o os.dsk     -l os.dsk.lst     -DBUILDDISK
    14                                  ;			nasm os.asm -f bin -o os.com     -l os.com.lst     -DBUILDCOM
    15                                  ;			nasm os.asm -f bin -o osprep.com -l osprep.com.lst -DBUILDPREP
    16                                  ;
    17                                  ;	Assembler:	Netwide Assembler (NASM) 2.13.01
    18                                  ;
    19                                  ;			Copyright (C) 2010-2017 by David J. Walling. All Rights Reserved.
    20                                  ;
    21                                  ;-----------------------------------------------------------------------------------------------------------------------
    22                                  ;-----------------------------------------------------------------------------------------------------------------------
    23                                  ;
    24                                  ;	Assembly Directives
    25                                  ;
    26                                  ;	Use one of the following as an assembly directive (-D) with NASM.
    27                                  ;
    28                                  ;	BUILDBOOT	Creates os.dat, a 512-byte boot sector as a standalone file.
    29                                  ;	BUILDDISK	Creates os.dsk, a 1.44MB (3.5") floppy disk image file.
    30                                  ;	BUILDCOM	Creates os.com, the OS loader and kernel as a standalone DOS program.
    31                                  ;	BUILDPREP	Creates osprep.com, a DOS program that prepares a floppy disk to boot the OS
    32                                  ;
    33                                  ;-----------------------------------------------------------------------------------------------------------------------
    34                                  %ifdef BUILDDISK
    35                                  %define BUILDBOOT
    36                                  %define BUILDCOM
    37                                  %endif
    38                                  %ifdef BUILDPREP
    39                                  %define BUILDBOOT
    40                                  %endif
    41                                  ;-----------------------------------------------------------------------------------------------------------------------
    42                                  ;
    43                                  ;	Conventions
    44                                  ;
    45                                  ;	Labels:		Labels within a routine are numeric and begin with a period (.10, .20).
    46                                  ;			Labels within a routine begin at ".10" and increment by 10.
    47                                  ;
    48                                  ;	Comments:	A comment that spans the entire line begins with a semicolon in column 1.
    49                                  ;			A comment that accompanies code on a line begins with a semicolon in column 81.
    50                                  ;
    51                                  ;	Alignment:	Assembly instructions (mnemonics) begin in column 25.
    52                                  ;			Assembly operands begin in column 33.
    53                                  ;			Lines should not extend beyond column 120.
    54                                  ;
    55                                  ;	Routines:	Routine names are in mixed case (GetYear, ReadRealTimeClock)
    56                                  ;			Routine names begin with a verb (Get, Read, etc.)
    57                                  ;
    58                                  ;	Constants:	Symbolic constants (equates) are named in all-caps beginning with 'E' (EDATAPORT).
    59                                  ;			Constant stored values are named in camel case, starting with 'c'.
    60                                  ;			The 2nd letter of the constant label indicates the storage type.
    61                                  ;
    62                                  ;			cq......	constant quad-word (dq)
    63                                  ;			cd......	constant double-word (dd)
    64                                  ;			cw......	constant word (dw)
    65                                  ;			cb......	constant byte (db)
    66                                  ;			cz......	constant ASCIIZ (null-terminated) string
    67                                  ;
    68                                  ;	Variables:	Variables are named in camel case, starting with 'w'.
    69                                  ;			The 2nd letter of the variable label indicates the storage type.
    70                                  ;
    71                                  ;			wq......	variable quad-word (resq)
    72                                  ;			wd......	variable double-word (resd)
    73                                  ;			ww......	variable word (resw)
    74                                  ;			wb......	variable byte (resb)
    75                                  ;
    76                                  ;	Structures:	Structure names are in all-caps (DATETIME).
    77                                  ;			Structure names do not begin with a verb.
    78                                  ;
    79                                  ;	Macros:		Macro names are in camel case (getDateString).
    80                                  ;			Macro names do begin with a verb.
    81                                  ;
    82                                  ;	Registers:	Registers EBX, ESI, EDI, EBP, SS, CS, DS and ES are preserved by all OS routines.
    83                                  ;			Register EAX is preferred for returning a response/result value.
    84                                  ;			Register EBX is preferred for passing a context (structure) address parameter.
    85                                  ;			Registers EAX, EDX and ECX are preferred for passing integral parameters.
    86                                  ;
    87                                  ;-----------------------------------------------------------------------------------------------------------------------
    88                                  ;-----------------------------------------------------------------------------------------------------------------------
    89                                  ;
    90                                  ;	Equates
    91                                  ;
    92                                  ;	The equate (equ) statements define symbolic names for fixed values so that these values can be defined and
    93                                  ;	verified once and then used throughout the code. Using symbolic names simplifies searching for where logical
    94                                  ;	values are used. Equate names are in all-caps and are the only symbolic names that begin with the letter 'E'.
    95                                  ;	Equates are grouped into related sets. Hardware-based values are listed first, followed by BIOS and protocol
    96                                  ;	values and, lastly, application values.
    97                                  ;
    98                                  ;-----------------------------------------------------------------------------------------------------------------------
    99                                  ;-----------------------------------------------------------------------------------------------------------------------
   100                                  ;
   101                                  ;	8042 Keyboard Controller						EKEY...
   102                                  ;
   103                                  ;	The 8042 Keyboard Controller (8042) is a programmable controller that accepts input signals from the keyboard
   104                                  ;	device. It also signals a hardware interrupt to the CPU when the low-order bit of I/O port 0x64 is set to zero.
   105                                  ;
   106                                  ;-----------------------------------------------------------------------------------------------------------------------
   107                                  EKEYPORTSTAT		equ	064h						;8042 status port
   108                                  EKEYCMDRESET		equ	0FEh						;8042 drive B0 low to restart
   109                                  ;-----------------------------------------------------------------------------------------------------------------------
   110                                  ;
   111                                  ;	BIOS Interrupts and Functions						EBIOS...
   112                                  ;
   113                                  ;	Basic Input/Output System (BIOS) functions are grouped and accessed by issuing an interrupt call. Each
   114                                  ;	BIOS interrupt supports several funtions. The function code is typically passed in the AH register.
   115                                  ;
   116                                  ;-----------------------------------------------------------------------------------------------------------------------
   117                                  EBIOSINTVIDEO		equ	010h						;BIOS video services interrupt
   118                                  EBIOSFNTTYOUTPUT	equ	00Eh						;BIOS video TTY output function
   119                                  EBIOSINTDISKETTE	equ	013h						;BIOS diskette services interrupt
   120                                  EBIOSINTKEYBOARD	equ	016h						;BIOS keyboard services interrupt
   121                                  EBIOSFNKEYSTATUS	equ	001h						;BIOS keyboard status function
   122                                  ;-----------------------------------------------------------------------------------------------------------------------
   123                                  ;
   124                                  ;	ASCII									EASC...
   125                                  ;
   126                                  ;-----------------------------------------------------------------------------------------------------------------------
   127                                  EASCIIRETURN		equ	13						;ASCII carriage return
   128                                  EASCIIESCAPE		equ	27						;ASCII escape
   129                                  ;-----------------------------------------------------------------------------------------------------------------------
   130                                  ;
   131                                  ;	Boot Sector and Loader Constants
   132                                  ;
   133                                  ;	Equates in this section support the boot sector and the 16-bit operating system loader, which will be
   134                                  ;	responsible for placing the CPU into protected mode and calling the initial operating system task.
   135                                  ;
   136                                  ;-----------------------------------------------------------------------------------------------------------------------
   137                                  EBOOTSECTORBYTES	equ	512						;bytes per sector
   138                                  EBOOTDISKSECTORS	equ	2880						;sectors per disk
   139                                  EBOOTDISKBYTES		equ	(EBOOTSECTORBYTES*EBOOTDISKSECTORS)		;bytes per disk
   140                                  EBOOTSTACKTOP		equ	400h						;boot sector stack top relative to DS
   141                                  EMAXTRIES		equ	5						;max read retries
   142                                  %ifdef BUILDBOOT
   143                                  ;-----------------------------------------------------------------------------------------------------------------------
   144                                  ;
   145                                  ;	Boot Sector Code							@disk: 000000	@mem: 007c00
   146                                  ;
   147                                  ;	The first sector of the disk is the boot sector. The BIOS will load the boot sector into memory and pass
   148                                  ;	control to the code at the start of the sector. The boot sector code is responsible for loading the operating
   149                                  ;	system into memory. The boot sector contains a disk parameter table describing the geometry and allocation
   150                                  ;	of the disk. Following the disk parameter table is code to load the operating system kernel into memory.
   151                                  ;
   152                                  ;	The 'cpu' directive limits emitted code to those instructions supported by the most primitive processor
   153                                  ;	we expect to ever execute our code. The 'vstart' parameter indicates addressability of symbols so as to
   154                                  ;	emulating the DOS .COM program model. Although the BIOS is expected to load the boot sector at address 7c00,
   155                                  ;	we do not make that assumption. The CPU starts in 16-bit addressing mode. A three-byte jump instruction is
   156                                  ;	immediately followed by a disk parameter table.
   157                                  ;
   158                                  ;-----------------------------------------------------------------------------------------------------------------------
   159                                  			cpu	8086						;assume minimal CPU
   160                                  section			boot	vstart=0100h					;emulate .COM (CS,DS,ES=PSP) addressing
   161                                  			bits	16						;16-bit code at power-up
   162                                  %ifdef BUILDPREP
   163                                  Boot			jmp	word Prep					;jump to preparation code
   164                                  %else
   165                                  Boot			jmp	word Boot.10					;jump over parameter table
   166                                  %endif
   167                                  ;-----------------------------------------------------------------------------------------------------------------------
   168                                  ;
   169                                  ;	Disk Parameter Table
   170                                  ;
   171                                  ;	The disk parameter table informs the BIOS of the floppy disk architecture. Here, we use parameters for the
   172                                  ;	3.5" 1.44MB floppy disk since this format is widely supported by virtual machine hypervisors.
   173                                  ;
   174                                  ;-----------------------------------------------------------------------------------------------------------------------
   175                                  			db	"CustomOS"					;eight-byte label
   176                                  cwSectorBytes		dw	EBOOTSECTORBYTES				;bytes per sector
   177                                  cbClusterSectors	db	1						;sectors per cluster
   178                                  cwReservedSectors	dw	1						;reserved sectors
   179                                  cbFatCount		db	2						;file allocation table copies
   180                                  cwDirEntries		dw	224						;max directory entries
   181                                  cwDiskSectors		dw	EBOOTDISKSECTORS				;sectors per disk
   182                                  cbDiskType		db	0F0h						;1.44MB
   183                                  cwFatSectors		dw	9						;sectors per FAT copy
   184                                  cbTrackSectors		equ	$						;sectors per track (as byte)
   185                                  cwTrackSectors		dw	18						;sectors per track (as word)
   186                                  cwDiskSides		dw	2						;sides per disk
   187                                  cwSpecialSectors	dw	0						;special sectors
   188                                  ;
   189                                  ;	BIOS typically loads the boot sector at absolute address 7c00 and sets the stack pointer at 512 bytes past the
   190                                  ;	end of the boot sector. But, since BIOS code varies, we don't make any assumptions as to where our boot sector
   191                                  ;	is loaded. For example, the initial CS:IP could be 0:7c00, 700:c00, 7c0:0, etc. So, to avoid assumptions, we
   192                                  ;	first normalize CS:IP to get the absolute segment address in BX. The comments below show the effect of this code
   193                                  ;	given several possible starting values for CS:IP.
   194                                  ;
   195                                  										;CS:IP	 0:7c00 700:c00 7c0:0
   196                                  Boot.10			call	word .20					;[ESP] =   7c21     c21    21
   197                                  .@20			equ	$-$$						;.@20 = 021h
   198                                  .20			pop	ax						;AX =	   7c21     c21    21
   199                                  			sub	ax,.@20						;BX =	   7c00     c00     0
   200                                  			mov	cl,4						;shift count
   201                                  			shr	ax,cl						;AX =	    7c0      c0     0
   202                                  			mov	bx,cs						;BX =	      0     700   7c0
   203                                  			add	bx,ax						;BX =	    7c0     7c0   7c0
   204                                  ;
   205                                  ;	Now, since we are assembling our boot code to emulate the addressing of a .COM file, we need DS and ES
   206                                  ;	registers to be set to where a Program Segment Prefix (PSP) would be, exactly 100h (256) bytes prior to
   207                                  ;	the start of our code. This will correspond to our assembled data address offsets. Note that we instructed
   208                                  ;	the assembler to produce addresses for our symbols that are offset from our code by 100h. See the "vstart"
   209                                  ;	parameter for the "section" directive above. We also set SS to the PSP and SP to the address of our i/o
   210                                  ;	buffer. This leaves 256 bytes of usable stack from 7b0:300 to 7b0:400.
   211                                  ;
   212                                  			sub	bx,16						;BX = 07b0
   213                                  			mov	ds,bx						;DS = 07b0 = psp
   214                                  			mov	es,bx						;ES = 07b0 = psp
   215                                  			mov	ss,bx						;SS = 07b0 = psp
   216                                  			mov	sp,EBOOTSTACKTOP				;SP = 0400
   217                                  ;
   218                                  ;	Our boot addressability is now set up according to the following diagram.
   219                                  ;
   220                                  ;	DS,ES,SS ----->	007b00	+-----------------------------------------------+ DS:0000
   221                                  ;				|  Unused (DOS Program Segment Prefix)		|
   222                                  ;			007c00	+-----------------------------------------------+ DS:0100
   223                                  ;				|  Boot Sector Code (vstart=100h)		|
   224                                  ;				|						|
   225                                  ;			007e00	+-----------------------------------------------+ DS:0300
   226                                  ;				|  Boot Stack					|
   227                                  ;	SS:SP --------> 007f00	+-----------------------------------------------+ DS:0400
   228                                  ;				|  File Allocation Table (FAT) I/O Buffer	|
   229                                  ;				|  9x512-byte sectors = 4,608 = 1200h bytes	|
   230                                  ;				|						|
   231                                  ;			009100	+-----------------------------------------------+ DS:1600
   232                                  ;				|  Directory Sector Buffer & Kernel Load Area	|
   233                                  ;				|						|
   234                                  ;			009300	+-----------------------------------------------+ DS:1800
   235                                  ;
   236                                  ;	On entry, DL indicates the drive being booted from.
   237                                  ;
   238                                  			mov	[wbDrive],dl					;[drive] = drive being booted from
   239                                  ;
   240                                  ;	Compute directory i/o buffer address.
   241                                  ;
   242                                  			mov	ax,[cwFatSectors]				;AX = 0009 = FAT sectors
   243                                  			mul	word [cwSectorBytes]				;DX:AX = 0000:1200 = FAT bytes
   244                                  			add	ax,EBOOTSTACKTOP				;AX = 1600 = end of FAT buffer
   245                                  			mov	[wwDirBuffer],ax				;[dirbuffer] = 1600
   246                                  ;
   247                                  ;	Compute segment where os.com will be loaded.
   248                                  ;
   249                                  			shr	ax,cl						;AX = 0160
   250                                  			add	ax,bx						;AX = 0160 + 07b0 = 0910
   251                                  			sub	ax,16						;AX = 0900
   252                                  			mov	[wwLoadSegment],ax				;[loadsegment] = 0900
   253                                  ;
   254                                  ;	Write a message to the console so we know we have our addressability established.
   255                                  ;
   256                                  			mov	si,czLoadMsg					;loading message
   257                                  			call	BootPrint					;display loader message
   258                                  ;
   259                                  ;	Initialize the number of directory sectors to search.
   260                                  ;
   261                                  			mov	ax,[cwDirEntries]				;AX = 224 = max dir entries
   262                                  			mov	[wwEntriesLeft],ax				;[entriesleft] = 224
   263                                  ;
   264                                  ;	Compute number of directory sectors and initialize overhead count.
   265                                  ;
   266                                  			mov	cx,ax						;CX = 00e0 = 224 entries
   267                                  			mul	word [cwEntryLen]				;DX:AX = 224 * 32 = 7168
   268                                  			div	word [cwSectorBytes]				;AX = 7168 / 512 = 14 = dir sectors
   269                                  			mov	[wwOverhead],ax					;[overhead] = 000e
   270                                  ;
   271                                  ;	Compute directory entries per sector.
   272                                  ;
   273                                  			xchg	ax,cx						;DX:AX = 0:00e0, DX = 0000e
   274                                  			div	cx						;AX = 0010 = entries per dir sector
   275                                  			mov	[wwSectorEntries],ax				;[sectorentries] = 0010
   276                                  ;
   277                                  ;	Compute first logical directory sector and update overhead count.
   278                                  ;
   279                                  			mov	ax,[cwFatSectors]				;AX = 0009 = FAT sectors per copy
   280                                  			mul	byte [cbFatCount]				;AX = 0012 = FAT sectors
   281                                  			add	ax,[cwReservedSectors]				;AX = 0013 = FAT plus reserved
   282                                  			add	ax,[cwSpecialSectors]				;AX = 0013 = FAT + reserved + special
   283                                  			mov	[wwLogicalSector],ax				;[logicalsector] = 0013
   284                                  			add	[wwOverhead],ax					;[overhead] = 0021 = res+spec+FAT+dir
   285                                  ;
   286                                  ;	Read directory sector.
   287                                  ;
   288                                  .30			mov	al,1						;sector count
   289                                  			mov	[wbReadCount],al				;[readcount] = 01
   290                                  			mov	bx,[wwDirBuffer]				;BX = 1600
   291                                  			call	ReadSector					;read sector into es:bx
   292                                  ;
   293                                  ;	Setup variables to search this directory sector.
   294                                  ;
   295                                  			mov	ax,[wwEntriesLeft]				;directory entries to search
   296                                  			cmp	ax,[wwSectorEntries]				;need to search more sectors?
   297                                  			jna	.40						;no, continue
   298                                  			mov	ax,[wwSectorEntries]				;yes, limit search to sector
   299                                  .40			sub	[wwEntriesLeft],ax				;update entries left to searh
   300                                  			mov	si,cbKernelProgram				;program name
   301                                  			mov	di,[wwDirBuffer]				;DI = 1600
   302                                  ;
   303                                  ;	Loop through directory sectors searching for kernel program.
   304                                  ;
   305                                  .50			push	si						;save kernel name address
   306                                  			push	di						;save dir i/o buffer address
   307                                  			mov	cx,11						;length of 8+3 name
   308                                  			cld							;forward strings
   309                                  			repe	cmpsb						;compare entry name
   310                                  			pop	di						;restore dir i/o buffer address
   311                                  			pop	si						;restore kernel name address
   312                                  			je	.60						;exit loop if found
   313                                  			add	di,[cwEntryLen]					;point to next dir entry
   314                                  			dec	ax						;decrement remaining entries
   315                                  			jnz	.50						;next entry
   316                                  ;
   317                                  ;	Repeat search if we are not at the end of the directory.
   318                                  ;
   319                                  			inc	word [wwLogicalSector]				;increment logical sector
   320                                  			cmp	word [wwEntriesLeft],0				;done with directory?
   321                                  			jne	.30						;no, get next sector
   322                                  			mov	si,czNoKernel					;missing kernel message
   323                                  			jmp	BootExit					;display message and exit
   324                                  ;
   325                                  ;	If we find the kernel program in the directory, read the FAT.
   326                                  ;
   327                                  .60			mov	ax,[cwReservedSectors]				;AX = 0001
   328                                  			mov	[wwLogicalSector],ax				;start past boot sector
   329                                  			mov	ax,[cwFatSectors]				;AX = 0009
   330                                  			mov	[wbReadCount],al				;[readcount] = 09
   331                                  			mov	bx,EBOOTSTACKTOP				;BX = 0500
   332                                  			call	ReadSector					;read FAT into buffer
   333                                  ;
   334                                  ;	Get the starting cluster of the kernel program and target address.
   335                                  ;
   336                                  			mov	ax,[di+26]					;AX = starting cluster of file
   337                                  			les	bx,[wwLoadOffset]				;ES:BX = kernel load address
   338                                  ;
   339                                  ;	Read each program cluster into RAM.
   340                                  ;
   341                                  .70			push	ax						;save cluster nbr
   342                                  			sub	ax,2						;AX = cluster nbr base 0
   343                                  			mov	cl,[cbClusterSectors]				;CL = sectors per cluster
   344                                  			mov	[wbReadCount],cl				;save sectors to read
   345                                  			xor	ch,ch						;CX = sectors per cluster
   346                                  			mul	cx						;DX:AX = logical cluster sector
   347                                  			add	ax,[wwOverhead]					;AX = kernel sector nbr
   348                                  			mov	[wwLogicalSector],ax				;save logical sector nbr
   349                                  			call	ReadSector					;read sectors into es:bx
   350                                  ;
   351                                  ;	Update buffer pointer for next cluster.
   352                                  ;
   353                                  			mov	al,[cbClusterSectors]				;AL = sectors per cluster
   354                                  			xor	ah,ah						;AX = sectors per cluster
   355                                  			mul	word [cwSectorBytes]				;DX:AX = cluster bytes
   356                                  			add	bx,ax						;BX = next cluster target address
   357                                  			pop	ax						;AX = restore cluster nbr
   358                                  ;
   359                                  ;	Compute next cluster number.
   360                                  ;
   361                                  			mov	cx,ax						;CX = cluster nbr
   362                                  			mov	di,ax						;DI = cluster nbr
   363                                  			shr	ax,1						;AX = cluster/2
   364                                  			mov	dx,ax						;DX = cluster/2
   365                                  			add	ax,dx						;AX = 2*(cluster/2)
   366                                  			add	ax,dx						;AX = 3*(cluster/2)
   367                                  			and	di,1						;get low bit
   368                                  			add	di,ax						;add one if cluster is odd
   369                                  			add	di,EBOOTSTACKTOP				;add FAT buffer address
   370                                  			mov	ax,[di]						;get cluster bytes
   371                                  ;
   372                                  ;	Adjust cluster nbr by 4 bits if cluster is odd; test for end of chain.
   373                                  ;
   374                                  			test	cl,1						;is cluster odd?
   375                                  			jz	.80						;no, skip ahead
   376                                  			mov	cl,4						;shift count
   377                                  			shr	ax,cl						;shift nybble low
   378                                  .80			and	ax,0FFFh					;mask for 24 bits; next cluster nbr
   379                                  			cmp	ax,0FFFh					;end of chain?
   380                                  			jne	.70						;no, continue
   381                                  ;
   382                                  ;	Transfer control to the operating system program.
   383                                  ;
   384                                  			db	0EAh						;jmp seg:offset
   385                                  wwLoadOffset		dw	0100h						;kernel entry offset
   386                                  wwLoadSegment		dw	0900h						;kernel entry segment (computed)
   387                                  ;
   388                                  ;	Read [readcount] disk sectors from [logicalsector] into ES:BX.
   389                                  ;
   390                                  ReadSector		mov	ax,[cwTrackSectors]				;AX = sectors per track
   391                                  			mul	word [cwDiskSides]				;DX:AX = sectors per cylinder
   392                                  			mov	cx,ax						;CX = sectors per cylinder
   393                                  			mov	ax,[wwLogicalSector]				;DX:AX = logical sector
   394                                  			div	cx						;AX = cylinder; DX = cyl sector
   395                                  			mov	[wbTrack],al					;[track] = cylinder
   396                                  			mov	ax,dx						;AX = cyl sector
   397                                  			div	byte [cbTrackSectors]				;AH = sector, AL = head
   398                                  			inc	ah						;AH = sector (1,2,3,...)
   399                                  			mov	[wbHead],ax					;[head]= head, [sector]= sector
   400                                  ;
   401                                  ;	Try maxtries times to read sector.
   402                                  ;
   403                                  			mov	cx,EMAXTRIES					;CX = 0005
   404                                  .10			push	bx						;save buffer address
   405                                  			push	cx						;save retry count
   406                                  			mov	dx,[wwDriveHead]				;DH = head, DL = drive
   407                                  			mov	cx,[wwSectorTrack]				;CH = track, CL = sector
   408                                  			mov	ax,[wwReadCountCommand]				;AH = fn., AL = sector count
   409                                  			int	EBIOSINTDISKETTE				;read sector
   410                                  			pop	cx						;restore retry count
   411                                  			pop	bx						;restore buffer address
   412                                  			jnc	BootReturn					;skip ahead if done
   413                                  			loop	.10						;retry
   414                                  ;
   415                                  ;	Handle disk error: convert to ASCII and store in error string.
   416                                  ;
   417                                  			mov	al,ah						;AL = bios error code
   418                                  			xor	ah,ah						;AX = bios error code
   419                                  			mov	dl,16						;divisor for base 16
   420                                  			div	dl						;AL = hi order, AH = lo order
   421                                  			or	ax,3030h					;apply ASCII zone bits
   422                                  			cmp	ah,3Ah						;range test ASCII numeral
   423                                  			jb	.20						;continue if numeral
   424                                  			add	ah,7						;adjust for ASCII 'A'-'F'
   425                                  .20			cmp	al,3Ah						;range test ASCII numeral
   426                                  			jb	.30						;continue if numeral
   427                                  			add	ah,7						;adjust for ASCII 'A'-'F'
   428                                  .30			mov	[wzErrorCode],ax				;store ASCII error code
   429                                  			mov	si,czErrorMsg					;error message address
   430                                  BootExit		call	BootPrint					;display messge to console
   431                                  .10			mov	ah,EBIOSFNKEYSTATUS				;bios keyboard status function
   432                                  			int	EBIOSINTKEYBOARD				;get keyboard status
   433                                  			jnz	.20						;continue if key pressed
   434                                  			sti							;enable interrupts
   435                                  			hlt							;wait for interrupt
   436                                  			jmp	.10						;repeat
   437                                  .20			mov	al,EKEYCMDRESET					;8042 pulse output port pin
   438                                  			out	EKEYPORTSTAT,al					;drive B0 low to restart
   439                                  .30			sti							;enable interrupts
   440                                  			hlt							;stop until reset, int, nmi
   441                                  			jmp	.30						;loop until restart kicks in
   442                                  ;
   443                                  ;	Display text message.
   444                                  ;
   445                                  BootPrint		cld							;forward strings
   446                                  			lodsb							;load next byte at DS:SI in AL
   447                                  			test	al,al						;end of string?
   448                                  			jz	BootReturn					;... yes, exit our loop
   449                                  			mov	ah,EBIOSFNTTYOUTPUT				;BIOS teletype function
   450                                  			int	EBIOSINTVIDEO					;call BIOS display interrupt
   451                                  			jmp	BootPrint					;repeat until done
   452                                  BootReturn		ret							;return to caller
   453                                  ;-----------------------------------------------------------------------------------------------------------------------
   454                                  ;
   455                                  ;	Constants
   456                                  ;
   457                                  ;-----------------------------------------------------------------------------------------------------------------------
   458                                  			align	2
   459                                  cwEntryLen		dw	32						;length of directory entry
   460                                  cbKernelProgram		db	"OS      COM"					;kernel program name
   461                                  czLoadMsg		db	"Loading ...",13,10,0				;loading message
   462                                  czErrorMsg		db	"Disk error "					;error message
   463                                  wzErrorCode		db	20h,20h,0					;error code and null terminator
   464                                  czNoKernel		db	"OS.COM missing",0				;missing kernel message
   465                                  ;-----------------------------------------------------------------------------------------------------------------------
   466                                  ;
   467                                  ;	Work Areas
   468                                  ;
   469                                  ;-----------------------------------------------------------------------------------------------------------------------
   470                                  			align	2
   471                                  wwDirBuffer		dw	0						;directory i/o buffer address
   472                                  wwEntriesLeft		dw	0						;directory entries to search
   473                                  wwOverhead		dw	0						;overhead sectors
   474                                  wwSectorEntries		dw	0						;directory entries per sector
   475                                  wwLogicalSector		dw	0						;current logical sector
   476                                  wwReadCountCommand	equ	$						;read count and command
   477                                  wbReadCount		db	0						;sectors to read
   478                                  cbReadCommand		db	2						;BIOS read disk fn code
   479                                  wwDriveHead		equ	$						;drive, head (word)
   480                                  wbDrive			db	0						;drive
   481                                  wbHead			db	0						;head
   482                                  wwSectorTrack		equ	$						;sector, track (word)
   483                                  			db	0						;sector
   484                                  wbTrack			db	0						;track
   485                                  			times	510-($-$$) db 0h				;zero fill to end of sector
   486                                  			db	055h,0AAh					;end of sector signature
   487                                  %endif
   488                                  %ifdef BUILDPREP
   489                                  ;-----------------------------------------------------------------------------------------------------------------------
   490                                  ;
   491                                  ;	Diskette Preparation Code
   492                                  ;
   493                                  ;	This routine writes the OS boot sector code to a formatted floppy diskette. The diskette parameter table,
   494                                  ;	which is located in the first 30 bytes of the boot sector is first read from the diskette and overlayed onto
   495                                  ;	the OS bootstrap code so that the diskette format parameters are preserved.
   496                                  ;
   497                                  ;-----------------------------------------------------------------------------------------------------------------------
   498                                  ;
   499                                  ;	Query the user to insert a flopppy diskette and press enter or cancel.
   500                                  ;
   501                                  Prep			mov	si,czPrepMsg10					;starting message address
   502                                  			call	BootPrint					;display message
   503                                  ;
   504                                  ;	Exit if the Escape key is pressed or loop until Enter is pressed.
   505                                  ;
   506                                  .10			mov	ah,EBIOSFNKEYSTATUS				;BIOS keyboard status function
   507                                  			int	EBIOSINTKEYBOARD				;get keyboard status
   508                                  			jnz	.12						;continue if key pressed
   509                                  			sti							;enable interrupts
   510                                  			hlt							;wait for interrupt
   511                                  			jmp	.10						;repeat
   512                                  .12			cmp	al,EASCIIRETURN					;Enter key pressed?
   513                                  			je	.15						;yes, branch
   514                                  			cmp	al,EASCIIESCAPE					;Escape key pressed?
   515                                  			jne	.10						;no, repeat
   516                                  			jmp	.90						;yes, exit program
   517                                  ;
   518                                  ;	Display writing-sector message and patch the JMP instruction.
   519                                  ;
   520                                  .15			mov	si,czPrepMsg12					;writing-sector message address
   521                                  			call	BootPrint					;display message
   522                                  			mov	bx,Boot+1					;address of JMP instruction operand
   523                                  			mov	ax,01Bh						;address past disk parameter table
   524                                  			mov	[bx],ax						;update the JMP instruction
   525                                  ;
   526                                  ;	Try to read the boot sector.
   527                                  ;
   528                                  			mov	cx,EMAXTRIES					;try up to five times
   529                                  .20			push	cx						;save remaining tries
   530                                  			mov	bx,wcPrepInBuf					;input buffer address
   531                                  			mov	dx,0						;head zero, drive zero
   532                                  			mov	cx,1						;track zero, sector one
   533                                  			mov	ax,0201h					;read one sector
   534                                  			int	EBIOSINTDISKETTE				;attempt the read
   535                                  			pop	cx						;restore remaining retries
   536                                  			jnc	.30						;skip ahead if successful
   537                                  			loop	.20						;try again
   538                                  			mov	si,czPrepMsg20					;read-error message address
   539                                  			jmp	.50						;branch to error routine
   540                                  ;
   541                                  ;	Copy diskette parms from input buffer to output buffer.
   542                                  ;
   543                                  .30			mov	si,wcPrepInBuf					;input buffer address
   544                                  			add	si,11						;skip over JMP and system ID
   545                                  			mov	di,Boot						;output buffer address
   546                                  			add	di,11						;skip over JMP and system ID
   547                                  			mov	cx,19						;length of diskette parameters
   548                                  			cld							;forward string copies
   549                                  			rep	movsb						;copy diskette parameters
   550                                  ;
   551                                  ;	Try to write boot sector to diskette.
   552                                  ;
   553                                  			mov	cx,EMAXTRIES					;try up to five times
   554                                  .40			push	cx						;save remaining tries
   555                                  			mov	bx,Boot						;output buffer address
   556                                  			mov	dx,0						;head zero, drive zero
   557                                  			mov	cx,1						;track zero, sector one
   558                                  			mov	ax,0301h					;write one sector
   559                                  			int	EBIOSINTDISKETTE				;attempt the write
   560                                  			pop	cx						;restore remaining retries
   561                                  			jnc	.80						;skip ahead if successful
   562                                  			loop	.40						;try again
   563                                  			mov	si,czPrepMsg30					;write-error message address
   564                                  ;
   565                                  ;	Convert the error code to ASCII and display the error message.
   566                                  ;
   567                                  .50			push	ax						;save error code
   568                                  			mov	al,ah						;copy error code
   569                                  			mov	ah,0						;AX = error code
   570                                  			mov	dl,10h						;hexadecimal divisor
   571                                  			idiv	dl						;AL = hi-order, AH = lo-order
   572                                  			or	ax,3030h					;add ASCII zone digits
   573                                  			cmp	ah,3Ah						;AH ASCII numeral?
   574                                  			jb	.60						;yes, continue
   575                                  			add	ah,7						;no, make ASCII 'A'-'F'
   576                                  .60			cmp	al,3Ah						;al ASCII numeral?
   577                                  			jb	.70						;yes, continue
   578                                  			add	al,7						;no, make ASCII
   579                                  .70			mov	[si+17],ax					;put ASCII error code in message
   580                                  			call	BootPrint					;write error message
   581                                  			pop	ax						;restore error code
   582                                  ;
   583                                  ;	Display the completion message.
   584                                  ;
   585                                  .80			mov	si,czPrepMsgOK					;assume successful completion
   586                                  			mov	al,ah						;BIOS return code
   587                                  			cmp	al,0						;success?
   588                                  			je	.85						;yes, continue
   589                                  			mov	si,czPrepMsgErr1				;disk parameter error message
   590                                  			cmp	al,1						;disk parameter error?
   591                                  			je	.85						;yes, continue
   592                                  			mov	si,czPrepMsgErr2				;address mark not found message
   593                                  			cmp	al,2						;address mark not found?
   594                                  			je	.85						;yes, continue
   595                                  			mov	si,czPrepMsgErr3				;protected disk message
   596                                  			cmp	al,3						;protected disk?
   597                                  			je	.85						;yes, continue
   598                                  			mov	si,czPrepMsgErr6				;diskette removed message
   599                                  			cmp	al,6						;diskette removed?
   600                                  			je	.85						;yes, continue
   601                                  			mov	si,czPrepMsgErr80				;drive timed out message
   602                                  			cmp	al,80H						;drive timed out?
   603                                  			je	.85						;yes, continue
   604                                  			mov	si,czPrepMsgErrXX				;unknown error message
   605                                  .85			call	BootPrint					;display result message
   606                                  .90			mov	ax,4C00H					;terminate with zero result code
   607                                  			int	21h						;terminate DOS program
   608                                  			ret							;return (should not execute)
   609                                  ;-----------------------------------------------------------------------------------------------------------------------
   610                                  ;
   611                                  ;	Diskette Preparation Messages
   612                                  ;
   613                                  ;-----------------------------------------------------------------------------------------------------------------------
   614                                  czPrepMsg10		db	13,10,"CustomOS Boot-Diskette Preparation Program"
   615                                  			db	13,10,"Copyright (C) 2010-2017 David J. Walling. All rights reserved."
   616                                  			db	13,10
   617                                  			db	13,10,"This program overwrites the boot sector of a diskette with startup code that"
   618                                  			db	13,10,"will load the operating system into memory when the computer is restarted."
   619                                  			db	13,10,"To proceed, place a formatted diskette into drive A: and press the Enter key."
   620                                  			db	13,10,"To exit this program without preparing a diskette, press the Escape key."
   621                                  			db	13,10,0
   622                                  czPrepMsg12		db	13,10,"Writing the boot sector to the diskette ..."
   623                                  			db	13,10,0
   624                                  czPrepMsg20		db	13,10,"The error-code .. was returned from the BIOS while reading from the disk."
   625                                  			db	13,10,0
   626                                  czPrepMsg30		db	13,10,"The error-code .. was returned from the BIOS while writing to the disk."
   627                                  			db	13,10,0
   628                                  czPrepMsgOK		db	13,10,"The boot-sector was written to the diskette. Before booting your computer with"
   629                                  			db	13,10,"this diskette, make sure that the file OS.COM is copied onto the diskette."
   630                                  			db	13,10,0
   631                                  czPrepMsgErr1		db	13,10,"(01) Invalid Disk Parameter"
   632                                  			db	13,10,"This is an internal error caused by an invalid value being passed to a system"
   633                                  			db	13,10,"function. The OSBOOT.COM file may be corrupt. Copy or download the file again"
   634                                  			db	13,10,"and retry."
   635                                  			db	13,10,0
   636                                  czPrepMsgErr2		db	13,10,"(02) Address Mark Not Found"
   637                                  			db	13,10,"This error indicates a physical problem with the floppy diskette. Please retry"
   638                                  			db	13,10,"using another diskette."
   639                                  			db	13,10,0
   640                                  czPrepMsgErr3		db	13,10,"(03) Protected Disk"
   641                                  			db	13,10,"This error is usually caused by attempting to write to a write-protected disk."
   642                                  			db	13,10,"Check the 'write-protect' setting on the disk or retry using using another disk."
   643                                  			db	13,10,0
   644                                  czPrepMsgErr6		db	13,10,"(06) Diskette Removed"
   645                                  			db	13,10,"This error may indicate that the floppy diskette has been removed from the"
   646                                  			db	13,10,"diskette drive. On some systems, this code may also occur if the diskette is"
   647                                  			db	13,10,"'write protected.' Please verify that the diskette is not write-protected and"
   648                                  			db	13,10,"is properly inserted in the diskette drive."
   649                                  			db	13,10,0
   650                                  czPrepMsgErr80		db	13,10,"(80) Drive Timed Out"
   651                                  			db	13,10,"This error usually indicates that no diskette is in the diskette drive. Please"
   652                                  			db	13,10,"make sure that the diskette is properly seated in the drive and retry."
   653                                  			db	13,10,0
   654                                  czPrepMsgErrXX		db	13,10,"(??) Unknown Error"
   655                                  			db	13,10,"The error-code returned by the BIOS is not a recognized error. Please consult"
   656                                  			db	13,10,"your computer's technical reference for a description of this error code."
   657                                  			db	13,10,0
   658                                  wcPrepInBuf		equ	$
   659                                  %endif
   660                                  %ifdef BUILDDISK
   661                                  ;-----------------------------------------------------------------------------------------------------------------------
   662                                  ;
   663                                  ;	File Allocation Tables
   664                                  ;
   665                                  ;	The disk contains two copies of the File Allocation Table (FAT). On our disk, each FAT copy is 1200h bytes in
   666                                  ;	length. Each FAT entry contains the logical number of the next cluster. The first two entries are reserved. Our
   667                                  ;	OS.COM file here is 200h bytes in length. These 200h bytes contain familiar code that displays a message to the
   668                                  ;	screen. Our disk parameter table defines a cluster as containing one sector and each sector having 200h bytes.
   669                                  ;	Therefore, our FAT table must reserve only one cluster for OS.COM. The cluster used by OS.COM, then, will be
   670                                  ;	cluster 2. The entry value for this cluster is set to "0fffh" to indicate that it is the last cluster in the
   671                                  ;	chain.
   672                                  ;
   673                                  ;	Every three bytes encode two FAT entries as follows:
   674                                  ;
   675                                  ;	db	0abh,0cdh,0efh	;even cluster: 0dabh, odd cluster: 0efch
   676                                  ;
   677                                  ;-----------------------------------------------------------------------------------------------------------------------
   678                                  ;-----------------------------------------------------------------------------------------------------------------------
   679                                  ;
   680                                  ;	FAT copy 1								@disk: 000200	@mem: n/a
   681                                  ;
   682                                  ;-----------------------------------------------------------------------------------------------------------------------
   683                                  section			fat1							;first copy of FAT
   684                                  			db	0F0h,0FFh,0FFh,	0FFh,00Fh,000h
   685                                  			times	(9*512)-($-$$) db 0				;zero fill to end of section
   686                                  ;-----------------------------------------------------------------------------------------------------------------------
   687                                  ;
   688                                  ;	FAT copy 2								@disk: 001400	@mem: n/a
   689                                  ;
   690                                  ;-----------------------------------------------------------------------------------------------------------------------
   691                                  section			fat2							;second copy of FAT
   692                                  			db	0F0h,0FFh,0FFh,	0FFh,00Fh,000h
   693                                  			times	(9*512)-($-$$) db 0				;zero fill to end of section
   694                                  ;-----------------------------------------------------------------------------------------------------------------------
   695                                  ;
   696                                  ;	Diskette Directory							@disk: 002600	@mem: n/a
   697                                  ;
   698                                  ;	The disk contains one copy of the diskette directory. Each directory entry is 32 bytes long. Our directory
   699                                  ;	contains only one entry. Unused entries are set to all nulls. The directory immediately follows the second FAT
   700                                  ;	copy.
   701                                  ;
   702                                  ;-----------------------------------------------------------------------------------------------------------------------
   703                                  section			dir							;diskette directory
   704                                  			db	"OS      COM"					;file name (must contain spaces)
   705                                  			db	20h						;attribute (archive bit set)
   706                                  			times	10 db 0;					;unused
   707                                  			dw	0h						;time
   708                                  			db	01000001b					;mmm = 10 MOD 8 = 2; ddddd = 1
   709                                  			db	01001001b					;yyyyyyy = 2016-1980 = 36 = 24h; m/8 = 1
   710                                  			dw	2						;first cluster
   711                                  			dd	200h						;file size
   712                                  			times	(224*32)-($-$$) db 0h				;zero fill to end of section
   713                                  %endif
   714                                  %ifdef BUILDCOM
   715                                  ;-----------------------------------------------------------------------------------------------------------------------
   716                                  ;
   717                                  ;	OS.COM
   718                                  ;
   719                                  ;	The operating system file is assembled at the start of the data area of the floppy disk image, which
   720                                  ;	immediately follows the directory. This corresponds to logical cluster 2, even though the physical address of
   721                                  ;	this sector on the disk varies depending on the disk type. The os.com file consists of two parts, the OS loader
   722                                  ;	and the OS kernel. The Loader is 16-bit code that receives control directly from the boot sector code after the
   723                                  ;	OS.COM file is loaded into memory. The kernel is 32-bit code that receives control after the Loader has
   724                                  ;	initialized protected-mode tables and 32-bit interrupt handlers and switched the CPU into protected mode.
   725                                  ;
   726                                  ;	Our loader addressability is set up according to the following diagram.
   727                                  ;
   728                                  ;	SS -----------> 007b00	+-----------------------------------------------+ SS:0000
   729                                  ;				|  Boot Sector & Loader Stack Area		|
   730                                  ;				|						|
   731                                  ;	SS:SP -------->	007f00	+-----------------------------------------------+ SS:0400
   732                                  ;
   733                                  ;
   734                                  ;	CS,DS,ES ----->	009000	+-----------------------------------------------+ CS:0000
   735                                  ;				|  Unused (DOS Program Segment Prefix)		|
   736                                  ;	CS:IP -------->	009100	+-----------------------------------------------+ CS:0100
   737                                  ;				|  Loader Code					|
   738                                  ;				|						|
   739                                  ;			009300	+-----------------------------------------------+ CS:0200
   740                                  ;
   741                                  ;-----------------------------------------------------------------------------------------------------------------------
   742                                  ;-----------------------------------------------------------------------------------------------------------------------
   743                                  ;
   744                                  ;	OS Loader								@disk: 004200	@mem: 009100
   745                                  ;
   746                                  ;	This code is the operating system loader. It resides on the boot disk at the start of the data area, following
   747                                  ;	the directory. The loader occupies several clusters that are mapped in the file allocation tables above. The
   748                                  ;	size of the loader is limited to 65,280 bytes since the bootstrap will copy the loader into memory at 0:9100.
   749                                  ;	The loader executes 16-bit instructions in real mode. It performs several initialization functions such as
   750                                  ;	determining whether the CPU and other resources are sufficient to run the operating system. If all minimum
   751                                  ;	resources are present, the loader initializes protected mode tables, places the CPU into protected mode and
   752                                  ;	starts the kernel task. Since the loader was called either from the bootstrap or as a .com file on the boot
   753                                  ;	disk, we can assume that the initial ip is 0x100 and not perform any absolute address fix-ups on our segment
   754                                  ;	registers.
   755                                  ;
   756                                  ;-----------------------------------------------------------------------------------------------------------------------
   757                                  			cpu	8086						;assume minimal CPU
   758                                  section			loader	vstart=100h					;use .COM compatible addressing
   759                                  			bits	16						;this is 16-bit code
   760 00000000 0E                      Loader			push	cs						;use the code segment
   761 00000001 1F                      			pop	ds						;...as our data segment
   762 00000002 0E                      			push	cs						;use the code segment
   763 00000003 07                      			pop	es						;...as our extra segment
   764                                  ;
   765                                  ;	Write a message to the console so we know we have our addressability established.
   766                                  ;
   767 00000004 BE[2900]                			mov	si,czStartingMsg				;starting message
   768 00000007 E81200                  			call	PutTTYString					;display loader message
   769                                  ;
   770                                  ;	Now we want to wait for a keypress. We can use a keyboard interrupt function for this (INT 16h, AH=0).
   771                                  ;	However, some hypervisor BIOS implementations have been seen to implement the "wait" as simply a fast
   772                                  ;	iteration of the keyboard status function call (INT 16h, AH=1), causing a CPU race condition. So, instead
   773                                  ;	we will use the keyboard status call and iterate over a halt (HLT) instruction until a key is pressed.
   774                                  ;	By convention, we enable maskable interrupts with STI before issuing HLT, so as not to catch fire.
   775                                  ;
   776 0000000A B401                    .30			mov	ah,EBIOSFNKEYSTATUS				;keyboard status function
   777 0000000C CD16                    			int	EBIOSINTKEYBOARD				;call BIOS keyboard interrupt
   778 0000000E 7504                    			jnz	.40						;exit if key pressed
   779 00000010 FB                      			sti							;enable maskable interrupts
   780 00000011 F4                      			hlt							;wait for interrupt
   781 00000012 EBF6                    			jmp	.30						;repeat until keypress
   782                                  ;
   783                                  ;	Now that a key has been pressed, we signal the system to restart by driving the B0 line on the 8042
   784                                  ;	keyboard controller low (OUT 64h,0feh). The restart may take some microseconds to kick in, so we issue
   785                                  ;	HLT until the system resets.
   786                                  ;
   787 00000014 B0FE                    .40			mov	al,EKEYCMDRESET					;8042 pulse output port pin
   788 00000016 E664                    			out	EKEYPORTSTAT,al					;drive B0 low to restart
   789 00000018 FB                      .50			sti							;enable maskable interrupts
   790 00000019 F4                      			hlt							;stop until reset, int, nmi
   791 0000001A EBFC                    			jmp	.50						;loop until restart kicks in
   792                                  ;-----------------------------------------------------------------------------------------------------------------------
   793                                  ;
   794                                  ;	Routine:	PutTTYString
   795                                  ;
   796                                  ;	Description:	This routine sends a NUL-terminated string of characters to the TTY output device. We use the
   797                                  ;			TTY output function of the BIOS video interrupt, passing the address of the string in DS:SI
   798                                  ;			and the BIOS teletype function code in AH. After a return from the BIOS interrupt, we repeat
   799                                  ;			for the next string character until a NUL is found. Note that we clear the direction flag (DF)
   800                                  ;			with CLD before each LODSB. This is just in case the direction flag is ever returned as set
   801                                  ;			by the video interrupt. This is a precaution since a well-written BIOS should preserve all
   802                                  ;			registers and flags unless used to indicate return status.
   803                                  ;
   804                                  ;	In:		DS:SI	address of string
   805                                  ;
   806                                  ;-----------------------------------------------------------------------------------------------------------------------
   807 0000001C FC                      PutTTYString		cld							;forward strings
   808 0000001D AC                      			lodsb							;load next byte at DS:SI in AL
   809 0000001E 84C0                    			test	al,al						;end of string?
   810 00000020 7406                    			jz	.10						;... yes, exit our loop
   811 00000022 B40E                    			mov	ah,EBIOSFNTTYOUTPUT				;BIOS teletype function
   812 00000024 CD10                    			int	EBIOSINTVIDEO					;call BIOS display interrupt
   813 00000026 EBF4                    			jmp	PutTTYString					;repeat until done
   814 00000028 C3                      .10			ret							;return to caller
   815                                  ;-----------------------------------------------------------------------------------------------------------------------
   816                                  ;
   817                                  ;	Loader Data
   818                                  ;
   819                                  ;	Our only "data" is the string displayed when system starts. It ends with ASCII carriage-return (13) and line-
   820                                  ;	feed (10) values. The remainder of the boot sector is filled with NUL. The boot sector finally ends with the
   821                                  ;	required two-byte signature checked by the BIOS. Note that recent versions of NASM will issue a warning if
   822                                  ;	the calculated address for the end-of-sector signature produces a negative value for "510-($-$$)". This will
   823                                  ;	indicate if we have added too much data and exceeded the length of the sector.
   824                                  ;
   825                                  ;-----------------------------------------------------------------------------------------------------------------------
   826 00000029 5374617274696E6720-     czStartingMsg		db	"Starting ...",13,10,0				;loader message
   826 00000032 2E2E2E0D0A00       
   827 00000038 00<rept>                			times	510-($-$$) db 0h				;zero fill to end of sector
   828 000001FE 55AA                    			db	055h,0AAh					;end of sector signature
   829                                  %endif
   830                                  %ifdef BUILDDISK
   831                                  ;-----------------------------------------------------------------------------------------------------------------------
   832                                  ;
   833                                  ;	Free Disk Space								@disk: 004400	@mem:  n/a
   834                                  ;
   835                                  ;	Following the convention introduced by DOS, we use the value 'F6' to indicate unused floppy disk storage.
   836                                  ;
   837                                  ;-----------------------------------------------------------------------------------------------------------------------
   838                                  section			unused							;unused disk space
   839                                  			times 	EBOOTDISKBYTES-04400h db 0F6h			;fill to end of disk image
   840                                  %endif
