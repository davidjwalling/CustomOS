     1                                  ;-----------------------------------------------------------------------------------------------------------------------
     2                                  ;
     3                                  ;	File:		os.asm
     4                                  ;
     5                                  ;	Project:	os.001
     6                                  ;
     7                                  ;	Description:	This sample program defines a valid boot sector that displays a message and waits for a key
     8                                  ;			to be pressed to restart the system. Using assembly directives, either a simple boot sector
     9                                  ;			or an entire floppy disk image is generated. Real mode BIOS interrupts are used to display
    10                                  ;			the message and poll for a keypress.
    11                                  ;
    12                                  ;	Revised:	January 1, 2017
    13                                  ;
    14                                  ;	Assembly:	nasm os.asm -f bin -o os.dat -l os.dat.lst -DBUILDBOOT
    15                                  ;			nasm os.asm -f bin -o os.dsk -l os.dsk.lst -DBUILDDISK
    16                                  ;
    17                                  ;	Assembler:	Netwide Assembler (NASM) 2.13.01
    18                                  ;
    19                                  ;			Copyright (C) 2010-2017 by David J. Walling. All Rights Reserved.
    20                                  ;
    21                                  ;-----------------------------------------------------------------------------------------------------------------------
    22                                  ;-----------------------------------------------------------------------------------------------------------------------
    23                                  ;
    24                                  ;	Assembly Directives
    25                                  ;
    26                                  ;	Use one of the following as an assembly directive (-D) with NASM.
    27                                  ;
    28                                  ;	BUILDBOOT	Creates os.dat, a 512-byte boot sector as a standalone file.
    29                                  ;	BUILDDISK	Creates os.dsk, a 1.44MB (3.5") floppy disk image file.
    30                                  ;
    31                                  ;-----------------------------------------------------------------------------------------------------------------------
    32                                  %ifdef BUILDDISK
    33                                  %define BUILDBOOT
    34                                  %endif
    35                                  ;-----------------------------------------------------------------------------------------------------------------------
    36                                  ;
    37                                  ;	Equates
    38                                  ;
    39                                  ;	The equate (equ) statements define symbolic names for fixed values so that these values can be defined and
    40                                  ;	verified once and then used throughout the code. Using symbolic names simplifies searching for where logical
    41                                  ;	values are used. Equate names are in all-caps and are the only symbolic names that begin with the letter 'E'.
    42                                  ;	Equates are grouped into related sets. Hardware-based values are listed first, followed by BIOS and protocol
    43                                  ;	values and, lastly, application values.
    44                                  ;
    45                                  ;-----------------------------------------------------------------------------------------------------------------------
    46                                  ;-----------------------------------------------------------------------------------------------------------------------
    47                                  ;
    48                                  ;	8042 Keyboard Controller						EKEY...
    49                                  ;
    50                                  ;	The 8042 Keyboard Controller (8042) is a programmable controller that accepts input signals from the keyboard
    51                                  ;	device. It also signals a hardware interrupt to the CPU when the low-order bit of I/O port 0x64 is set to zero.
    52                                  ;
    53                                  ;-----------------------------------------------------------------------------------------------------------------------
    54                                  EKEYPORTSTAT		equ	064h						;8042 status port
    55                                  EKEYCMDRESET		equ	0FEh						;8042 drive B0 low to restart
    56                                  ;-----------------------------------------------------------------------------------------------------------------------
    57                                  ;
    58                                  ;	BIOS Interrupts and Functions						EBIOS...
    59                                  ;
    60                                  ;	Basic Input/Output System (BIOS) functions are grouped and accessed by issuing an interrupt call. Each
    61                                  ;	BIOS interrupt supports several funtions. The function code is typically passed in the AH register.
    62                                  ;
    63                                  ;-----------------------------------------------------------------------------------------------------------------------
    64                                  EBIOSINTVIDEO		equ	010h						;BIOS video services interrupt
    65                                  EBIOSFNTTYOUTPUT	equ	00Eh						;BIOS video TTY output function
    66                                  EBIOSINTKEYBOARD	equ	016h						;BIOS keyboard services interrupt
    67                                  EBIOSFNKEYSTATUS	equ	001h						;BIOS keyboard status function
    68                                  ;-----------------------------------------------------------------------------------------------------------------------
    69                                  ;
    70                                  ;	Boot Sector and Loader Constants
    71                                  ;
    72                                  ;	Equates in this section support the boot sector and the 16-bit operating system loader, which will be
    73                                  ;	responsible for placing the CPU into protected mode and calling the initial operating system task.
    74                                  ;
    75                                  ;-----------------------------------------------------------------------------------------------------------------------
    76                                  EBOOTSECTORBYTES	equ	512						;bytes per floppy disk sector
    77                                  EBOOTDISKSECTORS	equ	2880						;sectors on a 1.44MB 3.5" floppy disk
    78                                  EBOOTDISKBYTES		equ	(EBOOTSECTORBYTES*EBOOTDISKSECTORS)		;calculated total bytes on disk
    79                                  EBOOTSTACKTOP		equ	400h						;boot sector stack top relative to DS
    80                                  %ifdef BUILDBOOT
    81                                  ;-----------------------------------------------------------------------------------------------------------------------
    82                                  ;
    83                                  ;	Boot Sector Code							@disk: 000000	@mem: 007c00
    84                                  ;
    85                                  ;	The first sector of the disk is the boot sector. The BIOS will load the boot sector into memory and pass
    86                                  ;	control to the code at the start of the sector. The boot sector code is responsible for loading the operating
    87                                  ;	system into memory. The boot sector contains a disk parameter table describing the geometry and allocation
    88                                  ;	of the disk. Following the disk parameter table is code to load the operating system kernel into memory.
    89                                  ;
    90                                  ;	The 'cpu' directive limits emitted code to those instructions supported by the most primitive processor
    91                                  ;	we expect to ever execute our code. The 'vstart' parameter indicates addressability of symbols so as to
    92                                  ;	emulating the DOS .COM program model. Although the BIOS is expected to load the boot sector at address 7c00,
    93                                  ;	we do not make that assumption. The CPU starts in 16-bit addressing mode. A three-byte jump instruction is
    94                                  ;	immediately followed by a disk parameter table.
    95                                  ;
    96                                  ;-----------------------------------------------------------------------------------------------------------------------
    97                                  			cpu	8086						;assume minimal CPU
    98                                  section			boot	vstart=0100h					;emulate .COM (CS,DS,ES=PSP) addressing
    99                                  			bits	16						;16-bit code at power-up
   100 00000000 E91B00                  Boot			jmp	word Boot.10					;jump over parameter table
   101                                  ;-----------------------------------------------------------------------------------------------------------------------
   102                                  ;
   103                                  ;	Disk Parameter Table
   104                                  ;
   105                                  ;	The disk parameter table informs the BIOS of the floppy disk architecture. Here, we use parameters for the
   106                                  ;	3.5" 1.44MB floppy disk since this format is widely supported by virtual machine hypervisors.
   107                                  ;
   108                                  ;-----------------------------------------------------------------------------------------------------------------------
   109 00000003 437573746F6D4F53        			db	"CustomOS"					;eight-byte label
   110 0000000B 0002                    			dw	EBOOTSECTORBYTES				;bytes per sector
   111 0000000D 01                      			db	1						;sectors per cluster
   112 0000000E 0100                    			dw	1						;reserved sectors
   113 00000010 02                      			db	2						;file allocation table copies
   114 00000011 E000                    			dw	224						;max directory entries
   115 00000013 400B                    			dw	EBOOTDISKSECTORS				;sectors per disk
   116 00000015 F0                      			db	0F0h						;1.44MB
   117 00000016 0900                    			dw	9						;sectors per FAT copy
   118 00000018 1200                    			dw	18						;sectors per track
   119 0000001A 0200                    			dw	2						;sides per disk
   120 0000001C 0000                    			dw	0						;special sectors
   121                                  ;
   122                                  ;	BIOS typically loads the boot sector at absolute address 7c00 and sets the stack pointer at 512 bytes past the
   123                                  ;	end of the boot sector. But, since BIOS code varies, we don't make any assumptions as to where our boot sector
   124                                  ;	is loaded. For example, the initial CS:IP could be 0:7c00, 700:c00, 7c0:0, etc. So, to avoid assumptions, we
   125                                  ;	first normalize CS:IP to get the absolute segment address in BX. The comments below show the effect of this code
   126                                  ;	given several possible starting values for CS:IP.
   127                                  ;
   128                                  										;CS:IP	 0:7c00 700:c00 7c0:0
   129 0000001E E80000                  Boot.10			call	word .20					;[ESP] =   7c21     c21    21
   130                                  .@20			equ	$-$$						;.@20 = 021h
   131 00000021 58                      .20			pop	ax						;AX =	   7c21     c21    21
   132 00000022 83E821                  			sub	ax,byte .@20					;BX =	   7c00     c00     0
   133 00000025 B104                    			mov	cl,4						;shift count
   134 00000027 D3E8                    			shr	ax,cl						;AX =	    7c0      c0     0
   135 00000029 8CCB                    			mov	bx,cs						;BX =	      0     700   7c0
   136 0000002B 01C3                    			add	bx,ax						;BX =	    7c0     7c0   7c0
   137                                  ;
   138                                  ;	Now, since we are assembling our boot code to emulate the addressing of a .COM file, we need DS and ES
   139                                  ;	registers to be set to where a Program Segment Prefix (PSP) would be, exactly 100h (256) bytes prior to
   140                                  ;	the start of our code. This will correspond to our assembled data address offsets. Note that we instructed
   141                                  ;	the assembler to produce addresses for our symbols that are offset from our code by 100h. See the "vstart"
   142                                  ;	parameter for the "section" directive above. We also set SS to the PSP and SP to the address of our i/o
   143                                  ;	buffer. This leaves 256 bytes of usable stack from 7b0:300 to 7b0:400.
   144                                  ;
   145 0000002D 83EB10                  			sub	bx,byte 16					;BX = 07b0
   146 00000030 8EDB                    			mov	ds,bx						;DS = 07b0 = psp
   147 00000032 8EC3                    			mov	es,bx						;ES = 07b0 = psp
   148 00000034 8ED3                    			mov	ss,bx						;SS = 07b0 = psp
   149 00000036 BC0004                  			mov	sp,EBOOTSTACKTOP				;SP = 0400
   150                                  ;
   151                                  ;	Our boot addressability is now set up according to the following diagram.
   152                                  ;
   153                                  ;	DS,ES,SS ----->	007b00	+-----------------------------------------------+ DS:0000
   154                                  ;				|  Unused (DOS Program Segment Prefix)		|
   155                                  ;			007c00	+-----------------------------------------------+ DS:0100
   156                                  ;				|  Boot Sector Code (vstart=100h)		|
   157                                  ;				|						|
   158                                  ;			007e00	+-----------------------------------------------+ DS:0300
   159                                  ;				|  Boot Stack					|
   160                                  ;	SS:SP --------> 007f00	+-----------------------------------------------+ DS:0400
   161                                  ;
   162                                  ;	Write a message to the console so we know we have our addressability established.
   163                                  ;
   164 00000039 BE[5E00]                			mov	si,czStartingMsg				;starting message
   165 0000003C E81200                  			call	PutTTYString					;display loader message
   166                                  ;
   167                                  ;	Now we want to wait for a keypress. We can use a keyboard interrupt function for this (INT 16h, AH=0).
   168                                  ;	However, some hypervisor BIOS implementations have been seen to implement the "wait" as simply a fast
   169                                  ;	iteration of the keyboard status function call (INT 16h, AH=1), causing a CPU race condition. So, instead
   170                                  ;	we will use the keyboard status call and iterate over a halt (HLT) instruction until a key is pressed.
   171                                  ;	By convention, we enable maskable interrupts with STI before issuing HLT, so as not to catch fire.
   172                                  ;
   173 0000003F B401                    .30			mov	ah,EBIOSFNKEYSTATUS				;keyboard status function
   174 00000041 CD16                    			int	EBIOSINTKEYBOARD				;call BIOS keyboard interrupt
   175 00000043 7504                    			jnz	.40						;exit if key pressed
   176 00000045 FB                      			sti							;enable maskable interrupts
   177 00000046 F4                      			hlt							;wait for interrupt
   178 00000047 EBF6                    			jmp	short .30					;repeat until keypress
   179                                  ;
   180                                  ;	Now that a key has been pressed, we signal the system to restart by driving the B0 line on the 8042
   181                                  ;	keyboard controller low (OUT 64h,0feh). The restart may take some microseconds to kick in, so we issue
   182                                  ;	HLT until the system resets.
   183                                  ;
   184 00000049 B0FE                    .40			mov	al,EKEYCMDRESET					;8042 pulse output port pin
   185 0000004B E664                    			out	EKEYPORTSTAT,al					;drive B0 low to restart
   186 0000004D FB                      .50			sti							;enable maskable interrupts
   187 0000004E F4                      			hlt							;stop until reset, int, nmi
   188 0000004F EBFC                    			jmp	short .50					;loop until restart kicks in
   189                                  ;-----------------------------------------------------------------------------------------------------------------------
   190                                  ;
   191                                  ;	Routine:	PutTTYString
   192                                  ;
   193                                  ;	Description:	This routine sends a NUL-terminated string of characters to the TTY output device. We use the
   194                                  ;			TTY output function of the BIOS video interrupt, passing the address of the string in DS:SI
   195                                  ;			and the BIOS teletype function code in AH. After a return from the BIOS interrupt, we repeat
   196                                  ;			for the next string character until a NUL is found. Note that we clear the direction flag (DF)
   197                                  ;			with CLD before each LODSB. This is just in case the direction flag is ever returned as set
   198                                  ;			by the video interrupt. This is a precaution since a well-written BIOS should preserve all
   199                                  ;			registers and flags unless used to indicate return status.
   200                                  ;
   201                                  ;	In:		DS:SI	address of string
   202                                  ;
   203                                  ;-----------------------------------------------------------------------------------------------------------------------
   204 00000051 FC                      PutTTYString		cld							;forward strings
   205 00000052 AC                      			lodsb							;load next byte at DS:SI in AL
   206 00000053 84C0                    			test	al,al						;end of string?
   207 00000055 7406                    			jz	.10						;... yes, exit our loop
   208 00000057 B40E                    			mov	ah,EBIOSFNTTYOUTPUT				;BIOS teletype function
   209 00000059 CD10                    			int	EBIOSINTVIDEO					;call BIOS display interrupt
   210 0000005B EBF4                    			jmp	short PutTTYString				;repeat until done
   211 0000005D C3                      .10			ret							;return to caller
   212                                  ;-----------------------------------------------------------------------------------------------------------------------
   213                                  ;
   214                                  ;	Loader Data
   215                                  ;
   216                                  ;	Our only "data" is the string displayed when system starts. It ends with ASCII carriage-return (13) and line-
   217                                  ;	feed (10) values. The remainder of the boot sector is filled with NUL. The boot sector finally ends with the
   218                                  ;	required two-byte signature checked by the BIOS. Note that recent versions of NASM will issue a warning if
   219                                  ;	the calculated address for the end-of-sector signature produces a negative value for "510-($-$$)". This will
   220                                  ;	indicate if we have added too much data and exceeded the length of the sector.
   221                                  ;
   222                                  ;-----------------------------------------------------------------------------------------------------------------------
   223 0000005E 5374617274696E6720-     czStartingMsg		db	"Starting ...",13,10,0				;loader message
   223 00000067 2E2E2E0D0A00       
   224 0000006D 00<rept>                			times	510-($-$$) db 0h				;zero fill to end of sector
   225 000001FE 55AA                    			db	055h,0AAh					;end of sector signature
   226                                  %endif
   227                                  %ifdef BUILDDISK
   228                                  ;-----------------------------------------------------------------------------------------------------------------------
   229                                  ;
   230                                  ;	Free Disk Space								@disk: 000200	@mem:  n/a
   231                                  ;
   232                                  ;	Following the convention introduced by DOS, we use the value 'F6' to indicate unused floppy disk storage.
   233                                  ;
   234                                  ;-----------------------------------------------------------------------------------------------------------------------
   235                                  section			unused							;unused disk space
   236                                  			times 	EBOOTDISKBYTES-($-$$)-512 db 0F6h		;fill to end of disk image
   237                                  %endif
