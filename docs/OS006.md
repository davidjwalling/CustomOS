### Project os.006
Source: [os.006/os.asm](../os.006/os.asm)

### Features and Topics
- Keyboard Controller I/O
- Keyboard Scan Code to ASCII translation

### [Virtual](VIRTUAL.md) Machine Operation
- Update the Virtual Machine configuration to use os.006/os.dsk as the diskette image.
- Start the Virtual Machine.

<img src="../images/os006_VirtualBox_001.PNG" width="640"/>

### [Physical](PHYSICAL.md) Machine Operation
- Overwrite os.com on the OS boot diskette with os.006/os.com.
- Insert the OS boot diskette into the physical system's floppy disk drive A:.
- Start the system.

<img src="../images/os006_Boot_001.jpg"/>

### Notes

This project adds code for the Keyboard Interrupt handler (IRQ1). The interrupt handler reads scan codes from the 8042 keyboard controller and updates shift and key lock states. If the scan code translates into an printable ASCII scan code this is represented in the Operator Information Area (OIA).

In our Equates section, we add a new section for keyboard flags EKEYF...
```
;
;       Operating System Values
;
;       EBOOT...        Boot sector and loader values
;       ECON...         Console values (dimensions and attributes)
;       EGDT...         Global Descriptor Table (GDT) selector values
;       EKEYF...        Keyboard status flags
;       EKRN...         Kernel values (fixed locations and sizes)
;
```
The existing section for keyboard codes is expanded to define specific keyboard scan codes used in the keyboard interrupt.
```
;-----------------------------------------------------------------------------------------------------------------------
;
;       8042 Keyboard Controller                                                EKEYB...
;
;       The 8042 Keyboard Controller (8042) is a programmable controller that accepts input signals from the keyboard
;       device. It also signals a hardware interrupt to the CPU when the low-order bit of I/O port 64h is set to zero.
;
;-----------------------------------------------------------------------------------------------------------------------
EKEYBPORTDATA           equ     060h                                            ;data port
EKEYBPORTSTAT           equ     064h                                            ;status port
EKEYBCMDRESET           equ     0FEh                                            ;reset bit 0 to restart system
EKEYBBITOUT             equ     001h                                            ;output buffer status bit
EKEYBBITIN              equ     002h                                            ;input buffer status bit
EKEYBCMDLAMPS           equ     0EDh                                            ;set/reset lamps command
EKEYBWAITLOOP           equ     010000h                                         ;wait loop
                                                                                ;---------------------------------------
                                                                                ;       Keyboard Scan Codes
                                                                                ;---------------------------------------
EKEYBCTRLLDOWN          equ     01Dh                                            ;control down
EKEYBSHIFTLDOWN         equ     02Ah                                            ;left shift down
EKEYBSHIFTRDOWN         equ     036h                                            ;right shift down
EKEYBALTLDOWN           equ     038h                                            ;alt down
EKEYBCAPSDOWN           equ     03Ah                                            ;caps-lock down
EKEYBNUMDOWN            equ     045h                                            ;num-lock down
EKEYBSCROLLDOWN         equ     046h                                            ;scroll-lock down
EKEYBPAD7DOWN           equ     047h                                            ;keypad-7 down
EKEYBPADINSERTDOWN      equ     052h                                            ;keypad-insert down
EKEYBPADDELETEDOWN      equ     053h                                            ;keypad-delete down
EKEYBWINLDOWN           equ     05Bh                                            ;left windows (R) down
EKEYBWINRDOWN           equ     05Ch                                            ;right windows (R) down
EKEYBINSERTDOWN         equ     072h                                            ;insert down (e0 52)
EKEYBDELETEDOWN         equ     073h                                            ;delete down (e0 53)
EKEYBPADSLASHDOWN       equ     075h                                            ;keypad slash down
EKEYBALTRDOWN           equ     078h                                            ;right-alt down
EKEYBCTRLRDOWN          equ     07Dh                                            ;right-control key down
EKEYBMAKECODEMASK       equ     07Fh                                            ;make code mask
EKEYBUP                 equ     080h                                            ;up
EKEYBCTRLLUP            equ     09Dh                                            ;control key up
EKEYBSHIFTLUP           equ     0AAh                                            ;left shift key up
EKEYBSHIFTRUP           equ     0B6h                                            ;right shift key up
EKEYBPADASTERISKUP      equ     0B7h                                            ;keypad asterisk up
EKEYBALTLUP             equ     0B8h                                            ;left alt key up
EKEYBWINLUP             equ     0DBh                                            ;left windows (R) up
EKEYBWINRUP             equ     0DCh                                            ;right windows (R) up
EKEYBCODEEXT0           equ     0E0h                                            ;extended scan code 0
EKEYBCODEEXT1           equ     0E1h                                            ;extended scan code 1
EKEYBALTRUP             equ     0F8h                                            ;right-alt up
EKEYBCTRLRUP            equ     0FDh                                            ;left-control up
```
The ASCII codes section is expanded to add additional ASCII codes checked in the keyboard interrupt.
```
;-----------------------------------------------------------------------------------------------------------------------
;
;       ASCII                                                                   EASCII...
;
;-----------------------------------------------------------------------------------------------------------------------
EASCIIRETURN            equ     00Dh                                            ;carriage return
EASCIIESCAPE            equ     01Bh                                            ;escape
EASCIISPACE             equ     020h                                            ;space
EASCIISLASH             equ     02Fh                                            ;slash
EASCIIZERO              equ     030h                                            ;zero
EASCIININE              equ     039h                                            ;nine
EASCIIUPPERA            equ     041h                                            ;'A'
EASCIIUPPERZ            equ     05Ah                                            ;'Z'
EASCIICARET             equ     05Eh                                            ;'^'
EASCIILOWERA            equ     061h                                            ;'a'
EASCIILOWERZ            equ     07Ah                                            ;'z'
EASCIITILDE             equ     07Eh                                            ;'~'
EASCIIDELETE            equ     07Fh                                            ;del
```
The OS tracks the state of shift and lock keys using flags in a console task storage word.
```
;-----------------------------------------------------------------------------------------------------------------------
;       Keyboard Flags                                                          EKEYF...
;-----------------------------------------------------------------------------------------------------------------------
EKEYFCTRLLEFT           equ     00000001b                                       ;left control
EKEYFSHIFTLEFT          equ     00000010b                                       ;left shift
EKEYFALTLEFT            equ     00000100b                                       ;left alt
EKEYFCTRLRIGHT          equ     00001000b                                       ;right control
EKEYFSHIFTRIGHT         equ     00010000b                                       ;right shift
EKEYFSHIFT              equ     00010010b                                       ;left or right shift
EKEYFALTRIGHT           equ     00100000b                                       ;right alt
EKEYFWINLEFT            equ     01000000b                                       ;left windows(R)
EKEYFWINRIGHT           equ     10000000b                                       ;right windows (R)
EKEYFLOCKSCROLL         equ     00000001b                                       ;scroll-lock flag
EKEYFLOCKNUM            equ     00000010b                                       ;num-lock flag
EKEYFLOCKCAPS           equ     00000100b                                       ;cap-lock flag
EKEYFLOCKINSERT         equ     00001000b                                       ;insert-lock flag
EKEYFTIMEOUT            equ     10000000b                                       ;controller timeout
```
We define a KEYBDATA structure to group together the set of storage areas used to maintain the state of the keyboard.
```
;-----------------------------------------------------------------------------------------------------------------------
;
;       KEYBDATA
;
;       The KEYBDATA structure holds variables used to handle keyboard events.
;
;-----------------------------------------------------------------------------------------------------------------------
struc                   KEYBDATA
.scan0                  resb    1                                               ;1st scan code
.scan1                  resb    1                                               ;2nd scan code
.scan2                  resb    1                                               ;3rd scan code
.scan3                  resb    1                                               ;4th scan code
.scan                   resb    1                                               ;active scan code
.char                   resb    1                                               ;ASCII character
.last                   resb    1                                               ;previous scan code
.shift                  resb    1                                               ;shift flags (shift, ctrl, alt, win)
.lock                   resb    1                                               ;lock flags (caps, num, scroll, insert)
.status                 resb    1                                               ;status (timeout)
EKEYBDATAL              equ     ($-.scan0)                                      ;structure length
endstruc
```
In our kernel data area we define an instance of the KEYBDATA structure, called wsKeybData.
```
                                                                                ;---------------------------------------
                                                                                ;  set by keyboard interrupt
                                                                                ;---------------------------------------
wsKeybData              resb    EKEYBDATAL                                      ;keyboard data
```
The keyboard interrupt starts by sending the end-of-interrupt signal to the PIC, resetting working areas, reading the first scan code. If the "e1" extended code is arrived, we want to take two additional scan codes for evaluation.
```
                        menter  keyboard                                        ;keyboard interrrupt
                        push    eax                                             ;save non-volatile regs
                        push    ebx                                             ;
                        push    ecx                                             ;
                        push    edx                                             ;
                        push    esi                                             ;
                        push    ds                                              ;
;
;       End the interrupt.
;
                        call    PutPrimaryEndOfInt                              ;send EOI to primary PIC
;
;       Reset codes and flags.
;
                        push    EGDTOSDATA                                      ;load OS data selector ...
                        pop     ds                                              ;... into data segment register
                        mov     esi,wsKeybData                                  ;keyboard data addr
                        mov     al,[esi+KEYBDATA.scan]                          ;load previous scan code
                        mov     [esi+KEYBDATA.last],al                          ;... into previous scan code field
                        xor     al,al                                           ;zero reg
                        mov     [esi+KEYBDATA.char],al                          ;zero ASCII char code
                        mov     [esi+KEYBDATA.scan],al                          ;zero ASCII scan code
                        mov     [esi+KEYBDATA.scan0],al                         ;zero scan code buffer 0
                        mov     [esi+KEYBDATA.scan1],al                         ;zero scan code buffer 1
                        mov     [esi+KEYBDATA.scan2],al                         ;zero scan code buffer 2
                        mov     [esi+KEYBDATA.scan3],al                         ;zero scan code buffer 3
                        mov     al,EKEYFTIMEOUT                                 ;timeout indicator
                        not     al                                              ;status flag mask
                        and     byte [esi+KEYBDATA.status],al                   ;clear timeout indicator
;
;       Hold shift and lock settings. Get first scan code. Ignore ACK and NAK from the controller.
;
                        mov     bl,[esi+KEYBDATA.shift]                         ;shift flags
                        mov     bh,[esi+KEYBDATA.lock]                          ;locl flags
                        call    WaitForKeyOutBuffer                             ;controller timeout?
                        jz      irq1.timeout                                    ;yes, skip ahead
                        in      al,EKEYBPORTDATA                                ;read scan code
                        cmp     al,0FAh                                         ;keyboard ACK?
                        je      irq1.exit                                       ;yes, branch
                        cmp     al,0FCh                                         ;keyboard NAK?
                        je      irq1.exit                                       ;yes, branch
                        mov     [esi+KEYBDATA.scan0],al                         ;save scan code 0
;
;       If the 1st scan code is e1, take the 2nd and 3rd scan code. Use the 3rd scan code.
;
                        cmp     al,EKEYBCODEEXT1                                ;extended scan code 1? (e1)
                        jne     irq1.notext1                                    ;no, branch
                        call    WaitForKeyOutBuffer                             ;controller timeout?
                        jz      irq1.timeout                                    ;yes, skip ahead
                        in      al,EKEYBPORTDATA                                ;read scan code
                        mov     [esi+KEYBDATA.scan1],al                         ;save scan code 1 (1d)
                        call    WaitForKeyOutBuffer                             ;controller timeout?
                        jz      irq1.timeout                                    ;yes, skip ahead
                        in      al,EKEYBPORTDATA                                ;read scan code
                        mov     [esi+KEYBDATA.scan2],al                         ;save scan code 2 (45/c5)
                        movzx   eax,al                                          ;expand scan code to index
                        mov     al,[cs:tscan2ext+eax]                           ;translate scan code
                        mov     [esi+KEYBDATA.scan],al                          ;save final scan code
                        jmp     irq1.putoia                                     ;continue
```
A keyboard read timeout should not normally occur, but we'll set a status bit if it does happen. The "e0" extended code requires we take one additional scan code. The Print Screen keyboard sends both the make and break code sequences immediately.
```
;
;       Handle keyboard read timeout. This should not occur under normal circumstances. Its occurrence suggests an error
;       in the keyboard scan code handling. An error indicator will be shown in the OIA.
;
irq1.timeout            mov     al,EKEYFTIMEOUT                                 ;keyboard controller timeout flag
                        or      [esi+KEYBDATA.status],al                        ;set controller status
                        jmp     irq1.putoia                                     ;continue
;
;       If the 1st scan code is e0, take the 2nd scan code. If the 2nd scan code is b7 get the 2nd pair.
;
irq1.notext1            cmp     al,EKEYBCODEEXT0                                ;extended scan code 0?
                        jne     irq1.notext0                                    ;no, branch
                        call    WaitForKeyOutBuffer                             ;controller timeout?
                        jz      irq1.timeout                                    ;yes, skip ahead
                        in      al,EKEYBPORTDATA                                ;read scan code
                        mov     [esi+KEYBDATA.scan1],al                         ;save scan code 1
                        cmp     al,EKEYBPADASTERISKUP                           ;print-screen (b7)?
                        jne     irq1.notprntscrn                                ;no, branch.
;
;       Get the second pair of scan-codes. Only the Print Screen key should generate a second pair.
;
                        call    WaitForKeyOutBuffer                             ;controller timeout?
                        jz      irq1.timeout                                    ;yes, skip ahead
                        in      al,EKEYBPORTDATA                                ;read scan code 2
                        mov     [esi+KEYBDATA.scan2],al                         ;save scan code 2
                        call    WaitForKeyOutBuffer                             ;controller timeout?
                        jz      irq1.timeout                                    ;yes, skip ahead
                        in      al,EKEYBPORTDATA                                ;read scan code 3
                        mov     [esi+KEYBDATA.scan3],al                         ;save scan code 3
                        mov     al,0F7h                                         ;print-screen up
                        mov     [esi+KEYBDATA.scan],al                          ;save final scan code
                        jmp     irq1.putoia                                     ;continue
;
;       Where needed, use the last scan code and resume above.
;
irq1.uselastscan        mov     al,[esi+KEYBDATA.last]                          ;previous scan code
                        or      al,EKEYBUP                                      ;set break bit
                        mov     [esi+KEYBDATA.scan],al                          ;save as final scan code
                        jmp     irq1.checkchar                                  ;continue
;
;       Some num-lock + extended key combinations return a shift or num-lock make code. Here we need to rely on the
;       previous scan code to determine what key is in break mode.
;
irq1.notprntscrn        cmp     al,EKEYBSHIFTLDOWN                              ;left-shift down (2a)? left-shift
                        je      irq1.uselastscan                                ;yes, use last scan
                        cmp     al,EKEYBSHIFTLUP                                ;left-shift up (aa)? num-lock
                        je      irq1.uselastscan                                ;yes, use last scan
                        cmp     al,EKEYBSHIFTRDOWN                              ;right-shift down (36)? right-shift
                        je      irq1.uselastscan
```
We use an OS-specific extended scan code table so that we return ONE scan code for key press or release. Some codes here will affect shift or lock key status flags.
```
;
;       All remaining extended codes can be translated. Additionally, some extended scan codes set or reset shift flags
;       or toggle locks.
;
                        movzx   eax,al                                          ;extend scan code to table index
                        mov     al,[cs:tscan2ext+eax]                           ;translate to alternate scan code
                        mov     [esi+KEYBDATA.scan],al                          ;save final scan code
                        mov     ah,EKEYFCTRLRIGHT                               ;right control flag
                        cmp     al,EKEYBCTRLRUP                                 ;right control up?
                        je      irq1.shiftclear                                 ;yes, reset flag
                        cmp     al,EKEYBCTRLRDOWN                               ;right control down?
                        je      irq1.shiftset                                   ;yes, set flag
                        mov     ah,EKEYFALTRIGHT                                ;right alt flag
                        cmp     al,EKEYBALTRUP                                  ;alt key up code?
                        je      irq1.shiftclear                                 ;yes, reset flag
                        cmp     al,EKEYBALTRDOWN                                ;alt key down code?
                        je      irq1.shiftset                                   ;yes, set flag
                        mov     ah,EKEYFWINLEFT                                 ;left win flag
                        cmp     al,EKEYBWINLUP                                  ;left win up?
                        je      irq1.shiftclear                                 ;yes, reset flag
                        cmp     al,EKEYBWINLDOWN                                ;left win down?
                        je      irq1.shiftset                                   ;yes, set flag
                        mov     ah,EKEYFWINRIGHT                                ;right win flag
                        cmp     al,EKEYBWINRUP                                  ;right win up?
                        je      irq1.shiftclear                                 ;yes, reset flag
                        cmp     al,EKEYBWINRDOWN                                ;right win down?
                        je      irq1.shiftset                                   ;yes, set flag
                        mov     ah,EKEYFLOCKINSERT                              ;insert flag
                        cmp     al,EKEYBINSERTDOWN                              ;translated insert scan code?
                        je      irq1.locktoggle                                 ;yes, branch
;
;       Extended scan codes for Delete and num-pad slash generate ASCII character codes.
;
irq1.checkchar          and     al,EKEYBMAKECODEMASK                            ;mask out break bit
                        mov     dl,EASCIIDELETE                                 ;ASCII delete
                        cmp     al,EKEYBDELETEDOWN                              ;delete down?
                        je      irq1.savechar                                   ;yes, branch
                        mov     dl,EASCIISLASH                                  ;ASCII slash
                        cmp     al,EKEYBPADSLASHDOWN                            ;keypad-slash down?
                        jne     irq1.putoia                                     ;continue
irq1.savechar           mov     [esi+KEYBDATA.char],dl                          ;store ASCII code
                        jmp     irq1.putoia                                     ;continue
;
;       Flip lock toggles if a toggle key (caps-lock, num-lock, scroll-lock, insert)
;
irq1.locktoggle         xor     bh,ah                                           ;toggle lock flag
                        mov     [esi+KEYBDATA.lock],bh                          ;save lock flags
                        call    SetKeyboardLamps                                ;update keyboard lamps
                        jmp     irq1.putoia                                     ;update OIA
;
;       Set/reset shift flags if a shift key (shift, alt, ctrl, windows)
;
irq1.shiftset           or      bl,ah                                           ;set shift flag
                        jmp     short irq1.shift                                ;skip ahead
irq1.shiftclear         not     ah                                              ;convert flag to mask
                        and     bl,ah                                           ;reset shift flag
irq1.shift              mov     [esi+KEYBDATA.shift],bl                         ;save shift flags
                        jmp     irq1.putoia                                     ;update OIA
```
Single-byte scan codes may also update shift or lock flags. The remaining used to look-up corresponding ASCII base or shifted values.
```
;
;       Check for shift and lock keys first. Note: When num-lock is set, holding shift while pressing a num-pad causes
;       a shift break (aa/b6) to be sent ahead of the num-pad key make code.
;
irq1.notext0            mov     [esi+KEYBDATA.scan],al                          ;save final scan code
                        mov     ah,EKEYFSHIFTLEFT                               ;left shift flag
                        cmp     al,EKEYBSHIFTLUP                                ;left shift key up code?
                        je      irq1.shiftclear                                 ;yes, reset flag
                        cmp     al,EKEYBSHIFTLDOWN                              ;left shift key down code?
                        je      irq1.shiftset                                   ;yes, set flag
                        mov     ah,EKEYFSHIFTRIGHT                              ;right shift flag
                        cmp     al,EKEYBSHIFTRUP                                ;right shift key up code?
                        je      irq1.shiftclear                                 ;yes, reset flag
                        cmp     al,EKEYBSHIFTRDOWN                              ;right shift key down code?
                        je      irq1.shiftset                                   ;yes, set flag
                        mov     ah,EKEYFCTRLLEFT                                ;left control flag
                        cmp     al,EKEYBCTRLLUP                                 ;control key up code?
                        je      irq1.shiftclear                                 ;yes, reset flag
                        cmp     al,EKEYBCTRLLDOWN                               ;control key down code?
                        je      irq1.shiftset                                   ;yes, set flag
                        mov     ah,EKEYFALTLEFT                                 ;left alt flag
                        cmp     al,EKEYBALTLUP                                  ;alt key up code?
                        je      irq1.shiftclear                                 ;yes, reset flag
                        cmp     al,EKEYBALTLDOWN                                ;alt key down code?
                        je      irq1.shiftset                                   ;yes, set flag
;
;       Handle lock keys.
;
                        mov     ah,EKEYFLOCKCAPS                                ;caps-lock flag
                        cmp     al,EKEYBCAPSDOWN                                ;caps-lock key down code?
                        je      irq1.locktoggle                                 ;yes, toggle lamps and flags
                        mov     ah,EKEYFLOCKNUM                                 ;num-lock flag
                        cmp     al,EKEYBNUMDOWN                                 ;num-lock key down code?
                        je      irq1.locktoggle                                 ;yes, toggle lamps and flags
                        mov     ah,EKEYFLOCKSCROLL                              ;scroll-lock flag
                        cmp     al,EKEYBSCROLLDOWN                              ;scroll-lock key down code?
                        je      irq1.locktoggle                                 ;yes, toggle lamps and flags
                        test    byte [esi+KEYBDATA.lock],EKEYFLOCKNUM           ;num-lock?
                        jnz     irq1.translate                                  ;yes, branch
                        mov     ah,EKEYFLOCKINSERT                              ;insert lock flag
                        cmp     al,EKEYBPADINSERTDOWN                           ;keypad-insert down?
                        je      irq1.locktoggle                                 ;yes, toggle lamps and flags
;
;       Get base or shifted ASCII char.
;
irq1.translate          and     al,EKEYBMAKECODEMASK                            ;make code
                        movzx   eax,al                                          ;table index
                        mov     edx,tscan2ascii                                 ;base table
                        test    byte [esi+KEYBDATA.shift],EKEYFSHIFT            ;left or right shift?
                        jz      irq1.getchar                                    ;no, branch
                        mov     edx,tscan2shift                                 ;shift rable
irq1.getchar            mov     al,[cs:edx+eax]                                 ;ASCII code
```
The case of the ASCII code may be affected by the state of the caps-lock and shift keys. Also, if NUM-LOCK is on, if may affect the codes returned by keys in the numeric key-pad. Once the final scan code and ASCII character, if any, is determined, we update the Operator Information Area (OIA). In a later project we will pass these codes to the active task using a message queue.
```
;
;       Check if caps-lock and alphabetic.
;
                        test    byte [esi+KEYBDATA.lock],EKEYFLOCKCAPS          ;caps-lock?
                        jz      irq1.checknum                                   ;no, branch
                        cmp     al,EASCIIUPPERA                                 ;caps range (low)
                        jb      irq1.checknum                                   ;branch if non-alpha
                        cmp     al,EASCIIUPPERZ                                 ;caps range (high)
                        jbe     irq1.swapcase                                   ;branch if alpha
                        cmp     al,EASCIILOWERA                                 ;base range (low)
                        jb      irq1.checknum                                   ;branch if non-alpha
                        cmp     al,EASCIILOWERZ                                 ;base range (high)
                        ja      irq1.checknum                                   ;branch if alpha
;
;       If caps-lock is enabled and the ASCII char is alphabetic, swap the ASCII case bit.
;
irq1.swapcase           xor     al,020h                                         ;swap case bit
                        mov     [esi+KEYBDATA.char],al                          ;save ASCII char code
                        jmp     irq1.putoia                                     ;continue
;
;       Check if num-lock and keypad numeral.
;
irq1.checknum           test    byte [esi+KEYBDATA.lock],EKEYFLOCKNUM           ;num-lock?
                        jz      irq1.notnum                                     ;no, branch
                        mov     dl,[esi+KEYBDATA.scan]                          ;scan code
                        and     dl,EKEYBMAKECODEMASK                            ;make code
                        cmp     dl,EKEYBPAD7DOWN                                ;keypad numeral range (low)
                        jb      irq1.notnum                                     ;branch if non-numeral
                        cmp     dl,EKEYBPADDELETEDOWN                           ;keypad numeral range (high)
                        ja      irq1.notnum                                     ;branch if non-numeral
                        sub     dl,EKEYBPAD7DOWN                                ;lookup table index
                        movzx   edx,dl                                          ;extend to register
                        mov     al,[cs:tscankeypad+edx]                         ;translate to numeral equivalent
irq1.notnum             mov     [esi+KEYBDATA.char],al                          ;save ASCII character code
;
;       Update operator information area. Enable maskable ints.
;
irq1.putoia             call    PutConsoleOIA                                   ;OIA shift indicators
irq1.exit               sti                                                     ;enable maskable interrupts
;
;       Restore and return.
;
                        pop     ds                                              ;restore non-volatile regs
                        pop     esi                                             ;
                        pop     edx                                             ;
                        pop     ecx                                             ;
                        pop     ebx                                             ;
                        pop     eax                                             ;
                        iretd                                                   ;return
```
The translation tables used by they keyboard interrupt follow. These handle numeric key-pad, scan code to extended scan code, scan to ASCII base and scan to ASCII shifted.
```
;-----------------------------------------------------------------------------------------------------------------------
;       Scan-Code to ASCII Translation Tables
;-----------------------------------------------------------------------------------------------------------------------
;
;       Keypad directional to numeral
;
tscankeypad             db      037h,038h,039h,02Dh,034h,035h,036h,02Bh         ;47-4e  789-456+
                        db      031h,032h,033h,030h,02Eh                        ;4f-53  1230.
;
;       Scan Code to Extended Scan Code
;
tscan2ext               db      000h,000h,000h,000h,000h,000h,000h,000h         ;00-07
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;08-0f
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;10-17
                        db      000h,000h,000h,000h,07Ch,07Dh,000h,000h         ;18-1f  1c->7c,1d->7d
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;20-27
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;28-2f
                        db      000h,000h,000h,000h,000h,075h,000h,077h         ;30-37  35->75,37->77
                        db      078h,000h,000h,000h,000h,000h,000h,000h         ;38-3f  38->78
                        db      000h,000h,000h,000h,000h,065h,066h,067h         ;40-47  45->65,46-66,47->67
                        db      068h,069h,04Ah,06Bh,04Ch,06Dh,04Eh,06Fh         ;48-4f  48->68,49->69,4b->6b,4d->6d,4f->6f
                        db      070h,071h,072h,073h,000h,000h,000h,000h         ;50-57  50->70,51->71,52->72,53->73
                        db      000h,000h,000h,05Bh,05Ch,05Dh,000h,000h         ;58-5f  5b->5b,5c->5c,5d->5d
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;60-67
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;68-6f
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;70-77
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;78-7f
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;80-87
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;88-8f
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;90-97
                        db      000h,000h,000h,000h,0FCh,0FDh,000h,000h         ;98-9f  9c->fc,9d->fd
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;a0-a7
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;a8-af
                        db      000h,000h,000h,000h,000h,0F5h,000h,0F7h         ;b0-b7  b5->f5,b7->f7
                        db      0F8h,000h,000h,000h,000h,000h,000h,000h         ;b8-bf  b8->f8
                        db      000h,000h,000h,000h,000h,0E5h,0E6h,0E7h         ;c0-c7  c5->e5,c6->e6,c7->e7
                        db      0E8h,0E9h,0CAh,0EBh,0CCh,0EDh,0CEh,0EFh         ;c8-cf  c8->e8,c9->e9,cb->eb,cd->ed,cf->ef
                        db      0F0h,0F1h,0F2h,0F3h,000h,000h,000h,000h         ;d0-d7  d0->f0,d1->f1,d2->f2,d3->f3
                        db      000h,000h,000h,0DBh,0DCh,0DDh,0DEh,000h         ;d8-df  db->db,dc->dc,de->de
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;e0-e7
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;e8-ef
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;f0-f7
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;f8-ff
;
;       Scan Code to Base ASCII
;
tscan2ascii             db      000h,01Bh,031h,032h,033h,034h,035h,036h         ;00-07
                        db      037h,038h,039h,030h,02Dh,03Dh,008h,009h         ;08-0f
                        db      071h,077h,065h,072h,074h,079h,075h,069h         ;10-17
                        db      06Fh,070h,05Bh,05Dh,000h,000h,061h,073h         ;18-1f
                        db      064h,066h,067h,068h,06Ah,06Bh,06Ch,03Bh         ;20-27
                        db      027h,060h,000h,05Ch,07Ah,078h,063h,076h         ;28-2f
                        db      062h,06Eh,06Dh,02Ch,02Eh,02Fh,000h,02Ah         ;30-37
                        db      000h,020h,000h,000h,000h,000h,000h,000h         ;38-3f
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;40-47
                        db      000h,000h,02Dh,000h,000h,000h,02Bh,000h         ;48-4f
                        db      000h,000h,000h,07Fh,000h,000h,000h,000h         ;50-57
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;58-5f
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;60-67
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;68-6f
                        db      000h,000h,000h,07Fh,000h,02Fh,000h,000h         ;70-77
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;78-7f
;
;       Scan Code to Shifted ASCII
;
tscan2shift             db      000h,01Bh,021h,040h,023h,024h,025h,05Eh         ;80-87
                        db      026h,02Ah,028h,029h,05Fh,02Bh,008h,009h         ;88-8f
                        db      051h,057h,045h,052h,054h,059h,055h,049h         ;90-97
                        db      04Fh,050h,07Bh,07Dh,000h,000h,041h,053h         ;98-9f
                        db      044h,046h,047h,048h,04Ah,04Bh,04Ch,03Ah         ;a0-a7
                        db      022h,07Eh,000h,07Ch,05Ah,058h,043h,056h         ;a8-af
                        db      042h,04Eh,04Dh,03Ch,03Eh,03Fh,000h,02Ah         ;b0-b7
                        db      000h,020h,000h,000h,000h,000h,000h,000h         ;b8-bf
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;c0-c7
                        db      000h,000h,02Dh,000h,000h,000h,02Bh,000h         ;c8-cf
                        db      000h,000h,000h,07Fh,000h,000h,000h,000h         ;d0-d7
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;d8-df
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;e0-e7
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;e8-ef
                        db      000h,000h,000h,07Fh,000h,02Fh,000h,000h         ;f0-f7
                        db      000h,000h,000h,000h,000h,000h,000h,000h         ;f8-ff
```
In this project, we add three new kernel routines accessed through the interrupt 30h service handler. PutConsoleOIA writes updated status indicators to the screen. SetKeyboardLamps turns on or off the keyboard light-emiting diodes (LED) that indicate caps-lock, num-lock and scroll-lock. The Yield routine issues a HLT to allow another task to run if needed.
```
%macro                  putConsoleOIA 0
                        mov     al,ePutConsoleOIA                               ;function code
                        int     _svc                                            ;invoke OS service
%endmacro
%macro                  setKeyboardLamps 0
                        mov     al,eSetKeyboardLamps                            ;function code
                        int     _svc                                            ;invoke OS service
%endmacro
%macro                  yield 0
                        mov     al,eYield                                       ;function code
                        int     _svc                                            ;invoke OS service
%endmacro
```
In the kernel routine library, the above-mentioned three routines along with several other helper routines are added. The first, PutConsoleHexByte writes a given ASCII character to the screen at the given coordinates.
```
;=======================================================================================================================
;
;       Console Helper Routines
;
;       PutConsoleHexByte
;       PutConsoleOIA
;       Yield
;
;=======================================================================================================================
;-----------------------------------------------------------------------------------------------------------------------
;
;       Routine:        PutConsoleHexByte
;
;       Description:    This routine writes two ASCII characters to the console representing a byte value.
;
;       In:             AL      byte value
;                       CL      column
;                       CH      row
;                       DS      OS data selector
;                       ES      CGA selector
;
;-----------------------------------------------------------------------------------------------------------------------
PutConsoleHexByte       push    eax                                             ;save non-volatile regs
                        shr     al,4                                            ;hi-order nybble
                        call    .10                                             ;make ASCII and store
                        pop     eax                                             ;byte value
                        and     al,0Fh                                          ;lo-order nybble
.10                     or      al,EASCIIZERO                                   ;apply ASCII zone
                        cmp     al,EASCIININE                                   ;numeric?
                        jbe     .20                                             ;yes, skip ahead
                        add     al,7                                            ;add ASCII offset for alpha
.20                     call    SetConsoleChar                                  ;display ASCII character
                        ret                                                     ;return
```
The PutConsoleOIA routine draws indicators, characters and numbers, to the CGA screen on the OIA row to indicate the status of shift and lock keys, the scan codes read from the 8042 keyboard controller, and the final extended scan code and corresponding ASCII code. Also shown, if applicable, is any printable ASCII character corresponding to the ASCII code.
```
;-----------------------------------------------------------------------------------------------------------------------
;
;       Routine:        PutConsoleOIA
;
;       Description:    This routine updates the Operator Information Area (OIA).
;
;       In:             DS      OS data selector
;
;       0         1         2         3         4         5         6         7
;       01234567890123456789012345678901234567890123456789012345678901234567890123456789
;       00112233  WSCA  XXAA                    C                         ASCW    ^CNS !
;
;-----------------------------------------------------------------------------------------------------------------------
PutConsoleOIA           push    ebx                                             ;save non-volatile regs
                        push    ecx                                             ;
                        push    esi                                             ;
                        push    es                                              ;
;
;       Address OS data and video memory
;
                        push    EGDTCGA                                         ;load CGA selector ...
                        pop     es                                              ;... into extra segment register
;
;       Display up to six keyboard scan codes
;
                        mov     esi,wsKeybData                                  ;keyboard data addr
                        lea     esi,[esi+KEYBDATA.scan0]                        ;scan code 0
                        xor     ebx,ebx                                         ;zero register
                        mov     bh,ECONOIAROW                                   ;OIA row
                        xor     ecx,ecx                                         ;zero register
                        mov     cl,4                                            ;maximum scan code count
.10                     push    ecx                                             ;save remaining count
                        mov     ecx,ebx                                         ;row, column
                        lodsb                                                   ;read scan code
                        test    al,al                                           ;scan code present?
                        jz      .20                                             ;no, skip ahead
                        call    PutConsoleHexByte                               ;display scan code
                        jmp     .30                                             ;continue
.20                     mov     al,' '                                          ;ASCII space
                        call    SetConsoleChar                                  ;display space
                        mov     al,' '                                          ;ASCII space
                        call    SetConsoleChar                                  ;display space
.30                     add     bl,2                                            ;next column (+2)
                        pop     ecx                                             ;restore remaining
                        loop    .10                                             ;next code
;
;       Display left shift, control, alt indicators
;
                        mov     esi,wsKeybData                                  ;keyboard data
                        mov     ch,ECONOIAROW                                   ;OIA row
                        mov     al,EASCIISPACE                                  ;ASCII space
                        test    byte [esi+KEYBDATA.shift],EKEYFWINLEFT          ;left-windows?
                        jz      .35                                             ;no, branch
                        mov     al,'W'                                          ;yes, indicate with 'W'
.35                     mov     cl,10                                           ;indicator column
                        call    SetConsoleChar                                  ;display ASCII indicator
                        mov     al,EASCIISPACE                                  ;space is default character
                        test    byte [esi+KEYBDATA.shift],EKEYFSHIFTLEFT        ;left-shift?
                        jz      .40                                             ;no, skip ahead
                        mov     al,'S'                                          ;yes, indicate with 'S'
.40                     mov     cl,11                                           ;indicator column
                        call    SetConsoleChar                                  ;display ASCII character
                        mov     al,EASCIISPACE                                  ;ASCII space
                        test    byte [esi+KEYBDATA.shift],EKEYFCTRLLEFT         ;left-ctrl?
                        jz      .50                                             ;no, skip ahead
                        mov     al,'C'                                          ;yes, indicate with 'C'
.50                     mov     cl,12                                           ;indicator column
                        call    SetConsoleChar                                  ;display ASCII character
                        mov     al,EASCIISPACE                                  ;ASCII space
                        test    byte [esi+KEYBDATA.shift],EKEYFALTLEFT          ;left-alt?
                        jz      .60                                             ;no, skip ahead
                        mov     al,'A'                                          ;yes, indicate with 'A'
.60                     mov     cl,13                                           ;indicator column
                        call    SetConsoleChar                                  ;display ASCII character
;
;       We do not display left or right shift make or break codes even if they are stored as the final
;       scan code because these are immediately sent after num-pad digits if both num-lock and scroll
;       are enabled. We don not display the scan code and char code if the scan code is null.
;
                        mov     al,[esi+KEYBDATA.scan]                          ;final scan code
                        test    al,al                                           ;null?
                        jz      .65                                             ;yes, branch
                        cmp     al,EKEYBSHIFTLDOWN                              ;left shift make?
                        je      .65                                             ;yes, branch
                        cmp     al,EKEYBSHIFTLUP                                ;left shift break?
                        je      .65                                             ;yes, branch
                        cmp     al,EKEYBSHIFTRDOWN                              ;right shift make?
                        je      .65                                             ;yes, branch
                        cmp     al,EKEYBSHIFTRUP                                ;right shift break?
                        je      .65                                             ;yes, branch
;
;       Display scan code returned in messages.
;
                        mov     cl,16                                           ;column
                        call    PutConsoleHexByte                               ;store hex byte
                        mov     al,[esi+KEYBDATA.char]                          ;ASCII char
                        mov     cl,18                                           ;column
                        call    PutConsoleHexByte                               ;store hex byte
;
;       Display ASCII character.
;
.65                     mov     al,[esi+KEYBDATA.char]                          ;ASCII char
                        cmp     al,EASCIISPACE                                  ;printable? (lower-bounds)
                        jb      .70                                             ;no, skip ahead
                        cmp     al,EASCIITILDE                                  ;printable? (upper-bounds)
                        jbe     .80                                             ;yes, branch
.70                     mov     al,EASCIISPACE                                  ;use space for non-printables
.80                     mov     ch,bh                                           ;OIA row
                        mov     cl,40                                           ;character display column
                        call    SetConsoleChar                                  ;display ASCII character
;
;       Display right alt, control, shift indicators
;
                        mov     al,EASCIISPACE                                  ;ASCII space
                        test    byte [esi+KEYBDATA.shift],EKEYFALTRIGHT         ;right-alt?
                        jz      .90                                             ;no, skip ahead
                        mov     al,'A'                                          ;yes, indicate with 'A'
.90                     mov     cl,66                                           ;indicator column
                        call    SetConsoleChar                                  ;display ASCII character
                        mov     al,EASCIISPACE                                  ;ASCII space
                        test    byte [esi+KEYBDATA.shift],EKEYFCTRLRIGHT        ;right-ctrl?
                        jz      .100                                            ;no, skip ahead
                        mov     al,'C'                                          ;yes, indicate with 'C'
.100                    mov     cl,67                                           ;indicator column
                        call    SetConsoleChar                                  ;display ASCII character
                        mov     al,EASCIISPACE                                  ;ASCII space
                        test    byte [esi+KEYBDATA.shift],EKEYFSHIFTRIGHT       ;right-shift
                        jz      .110                                            ;no, skip ahead
                        mov     al,'S'                                          ;yes, indicate with 'S'
.110                    mov     cl,68                                           ;indicator column
                        call    SetConsoleChar                                  ;display ASCII character
                        mov     al,EASCIISPACE                                  ;ASCII space
                        test    byte [esi+KEYBDATA.shift],EKEYFWINRIGHT         ;right-windows?
                        jz      .115                                            ;no, branch
                        mov     al,'W'                                          ;yes, indicate wiht 'W'
.115                    mov     cl,69                                           ;indicator column
                        call    SetConsoleChar                                  ;display ASCII character
;
;       Display Insert, Caps, Scroll and Num-Lock indicators.
;
                        mov     al,EASCIISPACE                                  ;ASCII space
                        test    byte [esi+KEYBDATA.lock],EKEYFLOCKINSERT        ;insert mode?
                        jz      .120                                            ;no, branch
                        mov     al,EASCIICARET                                  ;indicate with a caret '^'
.120                    mov     cl,74                                           ;indicoator column
                        call    SetConsoleChar                                  ;display ASCII character
                        mov     al,EASCIISPACE                                  ;ASCII space
                        test    byte [esi+KEYBDATA.lock],EKEYFLOCKSCROLL        ;scroll-lock?
                        jz      .130                                            ;no, skip ahead
                        mov     al,'S'                                          ;yes, indicate with 'S'
.130                    mov     cl,75                                           ;indicator column
                        call    SetConsoleChar                                  ;display ASCII character
                        mov     al,EASCIISPACE                                  ;ASCII space
                        test    byte [esi+KEYBDATA.lock],EKEYFLOCKNUM           ;num-lock?
                        jz      .140                                            ;no, skip ahead
                        mov     al,'N'                                          ;yes, indicate with 'N'
.140                    mov     cl,76                                           ;indicator column
                        call    SetConsoleChar                                  ;display ASCII character
                        mov     al,EASCIISPACE                                  ;ASCII space
                        test    byte [esi+KEYBDATA.lock],EKEYFLOCKCAPS          ;caps-lock?
                        jz      .150                                            ;no, skip ahead
                        mov     al,'C'                                          ;yes, indicate with 'C'
.150                    mov     cl,77                                           ;indicator column
                        call    SetConsoleChar                                  ;display ASCII character
;
;       Display timeout flag.
;
                        mov     al,EASCIISPACE                                  ;ASCII space
                        test    byte [esi+KEYBDATA.status],EKEYFTIMEOUT         ;keyboard timeout?
                        jz      .155                                            ;no, branch
                        mov     al,'!'                                          ;ASCII indicator
.155                    mov     cl,79                                           ;indicator column
                        call    SetConsoleChar                                  ;display ASCII character
;
;       Restore and return.
;
.160                    pop     es                                              ;restore non-volatile regs
                        pop     esi                                             ;
                        pop     ecx                                             ;
                        pop     ebx                                             ;
                        ret                                                     ;return
```
The Yield routine issues a HLT to allow any pending interrupt gain control.
```
;-----------------------------------------------------------------------------------------------------------------------
;
;       Routine:        Yield
;
;       Description:    This routine passes control to the next ready task or enter halt.
;
;-----------------------------------------------------------------------------------------------------------------------
Yield                   sti                                                     ;enable maskagle interrupts
                        hlt                                                     ;halt until external interrupt
                        ret                                                     ;return
```
The SetConsoleChar I/O routine is added to convert a row and column to the CGA video memory offset and write a character at this location.
```
;=======================================================================================================================
;
;       Memory-Mapped Video Routines
;
;       These routines read and/or write directly to CGA video memory (B800:0)
;
;       SetConsoleChar
;
;=======================================================================================================================
;-----------------------------------------------------------------------------------------------------------------------
;
;       Routine:        SetConsoleChar
;
;       Description:    This routine outputs an ASCII character at the given row and column.
;
;       In:             AL      ASCII character
;                       CL      column
;                       CH      row
;                       ES      CGA selector
;
;       Out:            EAX     last target address written (ES:)
;                       CL      column + 1
;
;-----------------------------------------------------------------------------------------------------------------------
SetConsoleChar          mov     dl,al                                           ;ASCII character
                        movzx   eax,ch                                          ;row
                        mov     ah,ECONCOLS                                     ;cols/row
                        mul     ah                                              ;row * cols/row
                        add     al,cl                                           ;add column
                        adc     ah,0                                            ;handle carry
                        shl     eax,1                                           ;screen offset
                        mov     [es:eax],dl                                     ;store character
                        inc     cl                                              ;next column
                        ret                                                     ;return
```
In the I/O Routines section we add three new routintes, SetKeyboardLamps, WaitForKeyInBuffer and WaitForKeyOutBuffer.
```
;=======================================================================================================================
;
;       Input/Output Routines
;
;       These routines read and/or write directly to ports.
;
;       PlaceCursor
;       PutPrimaryEndOfInt
;       PutSecondaryEndOfInt
;       SetKeyboardLamps
;       WaitForKeyInBuffer
;       WaitForKeyOutBuffer
;
;=======================================================================================================================
```
SetKeyboardLamps updates the LEDs for caps, scroll and num-lock. WaitForKeyInBuffer waits for the keyboard input buffer to be available. WaitForKeyOutBuffer waits for keyboard scan code data to be available in the output buffer.
```
;-----------------------------------------------------------------------------------------------------------------------
;
;       Routine:        SetKeyboardLamps
;
;       Description:    This routine sends the set/reset mode indicators command to the keyboard device.
;
;       In:             BH      00000CNS (C:Caps Lock,N:Num Lock,S:Scroll Lock)
;
;-----------------------------------------------------------------------------------------------------------------------
SetKeyboardLamps        push    ebx                                             ;save non-volatile regs
                        push    esi                                             ;
                        mov     esi,wsKeybData                                  ;keyboard data addr
                        mov     bh,[esi+KEYBDATA.lock]                          ;lock flags
                        call    WaitForKeyInBuffer                              ;wait for input buffer ready
                        mov     al,EKEYBCMDLAMPS                                ;set/reset lamps command
                        out     EKEYBPORTDATA,al                                ;send command to 8042
                        call    WaitForKeyOutBuffer                             ;wait for 8042 result
                        in      al,EKEYBPORTDATA                                ;read 8042 'ACK' (0fah)
                        call    WaitForKeyInBuffer                              ;wait for input buffer ready
                        mov     al,bh                                           ;set/reset lamps value
                        and     al,7                                            ;mask for lamp switches
                        out     EKEYBPORTDATA,al                                ;send lamps value
                        call    WaitForKeyOutBuffer                             ;wait for 8042 result
                        in      al,EKEYBPORTDATA                                ;read 8042 'ACK' (0fah)
                        pop     esi                                             ;restore non-volatile regs
                        pop     ebx                                             ;
                        ret                                                     ;return
;-----------------------------------------------------------------------------------------------------------------------
;
;       Routine:        WaitForKeyInBuffer
;
;       Description:    This routine waits for keyboard input buffer to be ready for input.
;
;       Out:            ZF      1 = Input buffer ready
;                               0 = Input buffer not ready after timeout
;
;-----------------------------------------------------------------------------------------------------------------------
WaitForKeyInBuffer      push    ecx                                             ;save non-volatile regs
                        mov     ecx,EKEYBWAITLOOP                               ;keyboard controller timeout
.10                     in      al,EKEYBPORTSTAT                                ;keyboard status byte
                        test    al,EKEYBBITIN                                   ;is input buffer still full?
                        loopnz  .10                                             ;yes, repeat till timeout
                        pop     ecx                                             ;restore non-volatile regs
                        ret                                                     ;return
;-----------------------------------------------------------------------------------------------------------------------
;
;       Routine:        WaitForKeyOutBuffer
;
;       Description:    This routine waits for keyboard output buffer to have data to read.
;
;       Out:            ZF      1 = Output buffer has data from controller
;                               0 = Output buffer empty after timeout
;
;-----------------------------------------------------------------------------------------------------------------------
WaitForKeyOutBuffer     push    ecx                                             ;save non-volatile regs
                        mov     ecx,EKEYBWAITLOOP                               ;keyboard controller timeout
.10                     in      al,EKEYBPORTSTAT                                ;keyboard status byte
                        test    al,EKEYBBITOUT                                  ;output buffer status bit
                        loopz   .10                                             ;loop until output buffer bit
                        pop     ecx                                             ;restore non-volatile regs
                        ret                                                     ;return
```
Finally, in the console task, we add several initialization statements to set the num-lock flag on startup, illuminate the lamps as needed, and draw the initial OIA.
```
;
;       Set num-lock and update lamps
;       Display the initial OIA
;
                        or      byte [wsKeybData+KEYBDATA.lock],EKEYFLOCKNUM    ;BIOS boots with num-lock on
                        setKeyboardLamps
                        putConsoleOIA
```
